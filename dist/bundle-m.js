var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod3) => function __require3() {
  return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __export = (target, all5) => {
  for (var name15 in all5)
    __defProp(target, name15, { get: all5[name15], enumerable: true });
};
var __copyProps = (to, from19, except, desc) => {
  if (from19 && typeof from19 === "object" || typeof from19 === "function") {
    for (let key of __getOwnPropNames(from19))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from19[key], enumerable: !(desc = __getOwnPropDesc(from19, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
  mod3
));

// process-shim.js
var init_process_shim = __esm({
  "process-shim.js"() {
    "use strict";
  }
});

// node_modules/@fleek-platform/sdk/dist/browser/chunk-DNE4QC7K.js
var __create2, __defProp2, __getOwnPropDesc2, __getOwnPropNames2, __getProtoOf2, __hasOwnProp2, __typeError, __defNormalProp, __require2, __esm2, __commonJS2, __export2, __copyProps2, __toESM2, __toCommonJS, __publicField, __accessCheck, __privateGet, __privateAdd, __privateSet;
var init_chunk_DNE4QC7K = __esm({
  "node_modules/@fleek-platform/sdk/dist/browser/chunk-DNE4QC7K.js"() {
    init_process_shim();
    __create2 = Object.create;
    __defProp2 = Object.defineProperty;
    __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    __getOwnPropNames2 = Object.getOwnPropertyNames;
    __getProtoOf2 = Object.getPrototypeOf;
    __hasOwnProp2 = Object.prototype.hasOwnProperty;
    __typeError = (msg) => {
      throw TypeError(msg);
    };
    __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    __require2 = /* @__PURE__ */ ((x) => typeof __require !== "undefined" ? __require : typeof Proxy !== "undefined" ? new Proxy(x, {
      get: (a, b) => (typeof __require !== "undefined" ? __require : a)[b]
    }) : x)(function(x) {
      if (typeof __require !== "undefined") return __require.apply(this, arguments);
      throw Error('Dynamic require of "' + x + '" is not supported');
    });
    __esm2 = (fn, res) => function __init() {
      return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
    };
    __commonJS2 = (cb, mod3) => function __require22() {
      return mod3 || (0, cb[__getOwnPropNames2(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
    };
    __export2 = (target, all5) => {
      for (var name15 in all5)
        __defProp2(target, name15, { get: all5[name15], enumerable: true });
    };
    __copyProps2 = (to, from19, except, desc) => {
      if (from19 && typeof from19 === "object" || typeof from19 === "function") {
        for (let key of __getOwnPropNames2(from19))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from19[key], enumerable: !(desc = __getOwnPropDesc2(from19, key)) || desc.enumerable });
      }
      return to;
    };
    __toESM2 = (mod3, isNodeMode, target) => (target = mod3 != null ? __create2(__getProtoOf2(mod3)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod3 || !mod3.__esModule ? __defProp2(target, "default", { value: mod3, enumerable: true }) : target,
      mod3
    ));
    __toCommonJS = (mod3) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod3);
    __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
    __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
    __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
    __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
  }
});

// node_modules/@fleek-platform/sdk/dist/browser/chunk-UHP4SR3D.js
var empty_exports, empty_default, Readable, init_empty;
var init_chunk_UHP4SR3D = __esm({
  "node_modules/@fleek-platform/sdk/dist/browser/chunk-UHP4SR3D.js"() {
    init_process_shim();
    init_chunk_DNE4QC7K();
    empty_exports = {};
    __export2(empty_exports, {
      Readable: () => Readable,
      default: () => empty_default
    });
    init_empty = __esm2({
      "src/utils/empty.ts"() {
        empty_default = {};
        Readable = {};
      }
    });
  }
});

// node_modules/@fleek-platform/sdk/dist/browser/chunk-77WUQNS7.js
var require_encode, require_decode, require_length, require_varint, require_aspromise, require_base64, require_eventemitter, require_float, require_inquire, require_utf8, require_pool;
var init_chunk_77WUQNS7 = __esm({
  "node_modules/@fleek-platform/sdk/dist/browser/chunk-77WUQNS7.js"() {
    init_process_shim();
    init_chunk_DNE4QC7K();
    require_encode = __commonJS2({
      "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js"(exports2, module2) {
        module2.exports = encode39;
        var MSB6 = 128;
        var REST6 = 127;
        var MSBALL6 = ~REST6;
        var INT6 = Math.pow(2, 31);
        function encode39(num, out, offset3) {
          if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
            encode39.bytes = 0;
            throw new RangeError("Could not encode varint");
          }
          out = out || [];
          offset3 = offset3 || 0;
          var oldOffset = offset3;
          while (num >= INT6) {
            out[offset3++] = num & 255 | MSB6;
            num /= 128;
          }
          while (num & MSBALL6) {
            out[offset3++] = num & 255 | MSB6;
            num >>>= 7;
          }
          out[offset3] = num | 0;
          encode39.bytes = offset3 - oldOffset + 1;
          return out;
        }
      }
    });
    require_decode = __commonJS2({
      "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js"(exports2, module2) {
        module2.exports = read10;
        var MSB6 = 128;
        var REST6 = 127;
        function read10(buf3, offset3) {
          var res = 0, offset3 = offset3 || 0, shift = 0, counter = offset3, b, l2 = buf3.length;
          do {
            if (counter >= l2 || shift > 49) {
              read10.bytes = 0;
              throw new RangeError("Could not decode varint");
            }
            b = buf3[counter++];
            res += shift < 28 ? (b & REST6) << shift : (b & REST6) * Math.pow(2, shift);
            shift += 7;
          } while (b >= MSB6);
          read10.bytes = counter - offset3;
          return res;
        }
      }
    });
    require_length = __commonJS2({
      "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js"(exports2, module2) {
        var N15 = Math.pow(2, 7);
        var N25 = Math.pow(2, 14);
        var N35 = Math.pow(2, 21);
        var N45 = Math.pow(2, 28);
        var N55 = Math.pow(2, 35);
        var N65 = Math.pow(2, 42);
        var N75 = Math.pow(2, 49);
        var N85 = Math.pow(2, 56);
        var N95 = Math.pow(2, 63);
        module2.exports = function(value) {
          return value < N15 ? 1 : value < N25 ? 2 : value < N35 ? 3 : value < N45 ? 4 : value < N55 ? 5 : value < N65 ? 6 : value < N75 ? 7 : value < N85 ? 8 : value < N95 ? 9 : 10;
        };
      }
    });
    require_varint = __commonJS2({
      "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js"(exports2, module2) {
        module2.exports = {
          encode: require_encode(),
          decode: require_decode(),
          encodingLength: require_length()
        };
      }
    });
    require_aspromise = __commonJS2({
      "../../node_modules/.pnpm/@protobufjs+aspromise@1.1.2/node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
        "use strict";
        module2.exports = asPromise;
        function asPromise(fn, ctx) {
          var params = new Array(arguments.length - 1), offset3 = 0, index2 = 2, pending = true;
          while (index2 < arguments.length)
            params[offset3++] = arguments[index2++];
          return new Promise(function executor(resolve2, reject) {
            params[offset3] = function callback(err) {
              if (pending) {
                pending = false;
                if (err)
                  reject(err);
                else {
                  var params2 = new Array(arguments.length - 1), offset22 = 0;
                  while (offset22 < params2.length)
                    params2[offset22++] = arguments[offset22];
                  resolve2.apply(null, params2);
                }
              }
            };
            try {
              fn.apply(ctx || null, params);
            } catch (err) {
              if (pending) {
                pending = false;
                reject(err);
              }
            }
          });
        }
      }
    });
    require_base64 = __commonJS2({
      "../../node_modules/.pnpm/@protobufjs+base64@1.1.2/node_modules/@protobufjs/base64/index.js"(exports2) {
        "use strict";
        var base644 = exports2;
        base644.length = function length5(string4) {
          var p = string4.length;
          if (!p)
            return 0;
          var n2 = 0;
          while (--p % 4 > 1 && string4.charAt(p) === "=")
            ++n2;
          return Math.ceil(string4.length * 3) / 4 - n2;
        };
        var b64 = new Array(64);
        var s64 = new Array(123);
        for (i = 0; i < 64; )
          s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
        var i;
        base644.encode = function encode39(buffer3, start, end) {
          var parts = null, chunk = [];
          var i2 = 0, j = 0, t;
          while (start < end) {
            var b = buffer3[start++];
            switch (j) {
              case 0:
                chunk[i2++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
              case 1:
                chunk[i2++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
              case 2:
                chunk[i2++] = b64[t | b >> 6];
                chunk[i2++] = b64[b & 63];
                j = 0;
                break;
            }
            if (i2 > 8191) {
              (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
              i2 = 0;
            }
          }
          if (j) {
            chunk[i2++] = b64[t];
            chunk[i2++] = 61;
            if (j === 1)
              chunk[i2++] = 61;
          }
          if (parts) {
            if (i2)
              parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
            return parts.join("");
          }
          return String.fromCharCode.apply(String, chunk.slice(0, i2));
        };
        var invalidEncoding = "invalid encoding";
        base644.decode = function decode43(string4, buffer3, offset3) {
          var start = offset3;
          var j = 0, t;
          for (var i2 = 0; i2 < string4.length; ) {
            var c = string4.charCodeAt(i2++);
            if (c === 61 && j > 1)
              break;
            if ((c = s64[c]) === void 0)
              throw Error(invalidEncoding);
            switch (j) {
              case 0:
                t = c;
                j = 1;
                break;
              case 1:
                buffer3[offset3++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
              case 2:
                buffer3[offset3++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
              case 3:
                buffer3[offset3++] = (t & 3) << 6 | c;
                j = 0;
                break;
            }
          }
          if (j === 1)
            throw Error(invalidEncoding);
          return offset3 - start;
        };
        base644.test = function test2(string4) {
          return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string4);
        };
      }
    });
    require_eventemitter = __commonJS2({
      "../../node_modules/.pnpm/@protobufjs+eventemitter@1.1.0/node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
        "use strict";
        module2.exports = EventEmitter2;
        function EventEmitter2() {
          this._listeners = {};
        }
        EventEmitter2.prototype.on = function on(evt, fn, ctx) {
          (this._listeners[evt] || (this._listeners[evt] = [])).push({
            fn,
            ctx: ctx || this
          });
          return this;
        };
        EventEmitter2.prototype.off = function off(evt, fn) {
          if (evt === void 0)
            this._listeners = {};
          else {
            if (fn === void 0)
              this._listeners[evt] = [];
            else {
              var listeners = this._listeners[evt];
              for (var i = 0; i < listeners.length; )
                if (listeners[i].fn === fn)
                  listeners.splice(i, 1);
                else
                  ++i;
            }
          }
          return this;
        };
        EventEmitter2.prototype.emit = function emit(evt) {
          var listeners = this._listeners[evt];
          if (listeners) {
            var args = [], i = 1;
            for (; i < arguments.length; )
              args.push(arguments[i++]);
            for (i = 0; i < listeners.length; )
              listeners[i].fn.apply(listeners[i++].ctx, args);
          }
          return this;
        };
      }
    });
    require_float = __commonJS2({
      "../../node_modules/.pnpm/@protobufjs+float@1.0.2/node_modules/@protobufjs/float/index.js"(exports2, module2) {
        "use strict";
        module2.exports = factory(factory);
        function factory(exports3) {
          if (typeof Float32Array !== "undefined") (function() {
            var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
            function writeFloat_f32_cpy(val, buf3, pos) {
              f32[0] = val;
              buf3[pos] = f8b[0];
              buf3[pos + 1] = f8b[1];
              buf3[pos + 2] = f8b[2];
              buf3[pos + 3] = f8b[3];
            }
            function writeFloat_f32_rev(val, buf3, pos) {
              f32[0] = val;
              buf3[pos] = f8b[3];
              buf3[pos + 1] = f8b[2];
              buf3[pos + 2] = f8b[1];
              buf3[pos + 3] = f8b[0];
            }
            exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
            exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
            function readFloat_f32_cpy(buf3, pos) {
              f8b[0] = buf3[pos];
              f8b[1] = buf3[pos + 1];
              f8b[2] = buf3[pos + 2];
              f8b[3] = buf3[pos + 3];
              return f32[0];
            }
            function readFloat_f32_rev(buf3, pos) {
              f8b[3] = buf3[pos];
              f8b[2] = buf3[pos + 1];
              f8b[1] = buf3[pos + 2];
              f8b[0] = buf3[pos + 3];
              return f32[0];
            }
            exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
            exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
          })();
          else (function() {
            function writeFloat_ieee754(writeUint, val, buf3, pos) {
              var sign3 = val < 0 ? 1 : 0;
              if (sign3)
                val = -val;
              if (val === 0)
                writeUint(1 / val > 0 ? (
                  /* positive */
                  0
                ) : (
                  /* negative 0 */
                  2147483648
                ), buf3, pos);
              else if (isNaN(val))
                writeUint(2143289344, buf3, pos);
              else if (val > 34028234663852886e22)
                writeUint((sign3 << 31 | 2139095040) >>> 0, buf3, pos);
              else if (val < 11754943508222875e-54)
                writeUint((sign3 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf3, pos);
              else {
                var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign3 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf3, pos);
              }
            }
            exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
            exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
            function readFloat_ieee754(readUint, buf3, pos) {
              var uint = readUint(buf3, pos), sign3 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
              return exponent === 255 ? mantissa ? NaN : sign3 * Infinity : exponent === 0 ? sign3 * 1401298464324817e-60 * mantissa : sign3 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
            }
            exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
            exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
          })();
          if (typeof Float64Array !== "undefined") (function() {
            var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
            function writeDouble_f64_cpy(val, buf3, pos) {
              f64[0] = val;
              buf3[pos] = f8b[0];
              buf3[pos + 1] = f8b[1];
              buf3[pos + 2] = f8b[2];
              buf3[pos + 3] = f8b[3];
              buf3[pos + 4] = f8b[4];
              buf3[pos + 5] = f8b[5];
              buf3[pos + 6] = f8b[6];
              buf3[pos + 7] = f8b[7];
            }
            function writeDouble_f64_rev(val, buf3, pos) {
              f64[0] = val;
              buf3[pos] = f8b[7];
              buf3[pos + 1] = f8b[6];
              buf3[pos + 2] = f8b[5];
              buf3[pos + 3] = f8b[4];
              buf3[pos + 4] = f8b[3];
              buf3[pos + 5] = f8b[2];
              buf3[pos + 6] = f8b[1];
              buf3[pos + 7] = f8b[0];
            }
            exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
            exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
            function readDouble_f64_cpy(buf3, pos) {
              f8b[0] = buf3[pos];
              f8b[1] = buf3[pos + 1];
              f8b[2] = buf3[pos + 2];
              f8b[3] = buf3[pos + 3];
              f8b[4] = buf3[pos + 4];
              f8b[5] = buf3[pos + 5];
              f8b[6] = buf3[pos + 6];
              f8b[7] = buf3[pos + 7];
              return f64[0];
            }
            function readDouble_f64_rev(buf3, pos) {
              f8b[7] = buf3[pos];
              f8b[6] = buf3[pos + 1];
              f8b[5] = buf3[pos + 2];
              f8b[4] = buf3[pos + 3];
              f8b[3] = buf3[pos + 4];
              f8b[2] = buf3[pos + 5];
              f8b[1] = buf3[pos + 6];
              f8b[0] = buf3[pos + 7];
              return f64[0];
            }
            exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
            exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
          })();
          else (function() {
            function writeDouble_ieee754(writeUint, off0, off1, val, buf3, pos) {
              var sign3 = val < 0 ? 1 : 0;
              if (sign3)
                val = -val;
              if (val === 0) {
                writeUint(0, buf3, pos + off0);
                writeUint(1 / val > 0 ? (
                  /* positive */
                  0
                ) : (
                  /* negative 0 */
                  2147483648
                ), buf3, pos + off1);
              } else if (isNaN(val)) {
                writeUint(0, buf3, pos + off0);
                writeUint(2146959360, buf3, pos + off1);
              } else if (val > 17976931348623157e292) {
                writeUint(0, buf3, pos + off0);
                writeUint((sign3 << 31 | 2146435072) >>> 0, buf3, pos + off1);
              } else {
                var mantissa;
                if (val < 22250738585072014e-324) {
                  mantissa = val / 5e-324;
                  writeUint(mantissa >>> 0, buf3, pos + off0);
                  writeUint((sign3 << 31 | mantissa / 4294967296) >>> 0, buf3, pos + off1);
                } else {
                  var exponent = Math.floor(Math.log(val) / Math.LN2);
                  if (exponent === 1024)
                    exponent = 1023;
                  mantissa = val * Math.pow(2, -exponent);
                  writeUint(mantissa * 4503599627370496 >>> 0, buf3, pos + off0);
                  writeUint((sign3 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf3, pos + off1);
                }
              }
            }
            exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
            exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
            function readDouble_ieee754(readUint, off0, off1, buf3, pos) {
              var lo = readUint(buf3, pos + off0), hi = readUint(buf3, pos + off1);
              var sign3 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
              return exponent === 2047 ? mantissa ? NaN : sign3 * Infinity : exponent === 0 ? sign3 * 5e-324 * mantissa : sign3 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
            }
            exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
            exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
          })();
          return exports3;
        }
        function writeUintLE(val, buf3, pos) {
          buf3[pos] = val & 255;
          buf3[pos + 1] = val >>> 8 & 255;
          buf3[pos + 2] = val >>> 16 & 255;
          buf3[pos + 3] = val >>> 24;
        }
        function writeUintBE(val, buf3, pos) {
          buf3[pos] = val >>> 24;
          buf3[pos + 1] = val >>> 16 & 255;
          buf3[pos + 2] = val >>> 8 & 255;
          buf3[pos + 3] = val & 255;
        }
        function readUintLE(buf3, pos) {
          return (buf3[pos] | buf3[pos + 1] << 8 | buf3[pos + 2] << 16 | buf3[pos + 3] << 24) >>> 0;
        }
        function readUintBE(buf3, pos) {
          return (buf3[pos] << 24 | buf3[pos + 1] << 16 | buf3[pos + 2] << 8 | buf3[pos + 3]) >>> 0;
        }
      }
    });
    require_inquire = __commonJS2({
      "../../node_modules/.pnpm/@protobufjs+inquire@1.1.0/node_modules/@protobufjs/inquire/index.js"(exports, module) {
        "use strict";
        module.exports = inquire;
        function inquire(moduleName) {
          try {
            var mod = eval("quire".replace(/^/, "re"))(moduleName);
            if (mod && (mod.length || Object.keys(mod).length))
              return mod;
          } catch (e) {
          }
          return null;
        }
      }
    });
    require_utf8 = __commonJS2({
      "../../node_modules/.pnpm/@protobufjs+utf8@1.1.0/node_modules/@protobufjs/utf8/index.js"(exports2) {
        "use strict";
        var utf84 = exports2;
        utf84.length = function utf8_length(string4) {
          var len = 0, c = 0;
          for (var i = 0; i < string4.length; ++i) {
            c = string4.charCodeAt(i);
            if (c < 128)
              len += 1;
            else if (c < 2048)
              len += 2;
            else if ((c & 64512) === 55296 && (string4.charCodeAt(i + 1) & 64512) === 56320) {
              ++i;
              len += 4;
            } else
              len += 3;
          }
          return len;
        };
        utf84.read = function utf8_read(buffer3, start, end) {
          var len = end - start;
          if (len < 1)
            return "";
          var parts = null, chunk = [], i = 0, t;
          while (start < end) {
            t = buffer3[start++];
            if (t < 128)
              chunk[i++] = t;
            else if (t > 191 && t < 224)
              chunk[i++] = (t & 31) << 6 | buffer3[start++] & 63;
            else if (t > 239 && t < 365) {
              t = ((t & 7) << 18 | (buffer3[start++] & 63) << 12 | (buffer3[start++] & 63) << 6 | buffer3[start++] & 63) - 65536;
              chunk[i++] = 55296 + (t >> 10);
              chunk[i++] = 56320 + (t & 1023);
            } else
              chunk[i++] = (t & 15) << 12 | (buffer3[start++] & 63) << 6 | buffer3[start++] & 63;
            if (i > 8191) {
              (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
              i = 0;
            }
          }
          if (parts) {
            if (i)
              parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
            return parts.join("");
          }
          return String.fromCharCode.apply(String, chunk.slice(0, i));
        };
        utf84.write = function utf8_write(string4, buffer3, offset3) {
          var start = offset3, c1, c2;
          for (var i = 0; i < string4.length; ++i) {
            c1 = string4.charCodeAt(i);
            if (c1 < 128) {
              buffer3[offset3++] = c1;
            } else if (c1 < 2048) {
              buffer3[offset3++] = c1 >> 6 | 192;
              buffer3[offset3++] = c1 & 63 | 128;
            } else if ((c1 & 64512) === 55296 && ((c2 = string4.charCodeAt(i + 1)) & 64512) === 56320) {
              c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
              ++i;
              buffer3[offset3++] = c1 >> 18 | 240;
              buffer3[offset3++] = c1 >> 12 & 63 | 128;
              buffer3[offset3++] = c1 >> 6 & 63 | 128;
              buffer3[offset3++] = c1 & 63 | 128;
            } else {
              buffer3[offset3++] = c1 >> 12 | 224;
              buffer3[offset3++] = c1 >> 6 & 63 | 128;
              buffer3[offset3++] = c1 & 63 | 128;
            }
          }
          return offset3 - start;
        };
      }
    });
    require_pool = __commonJS2({
      "../../node_modules/.pnpm/@protobufjs+pool@1.1.0/node_modules/@protobufjs/pool/index.js"(exports2, module2) {
        "use strict";
        module2.exports = pool;
        function pool(alloc4, slice4, size5) {
          var SIZE3 = size5 || 8192;
          var MAX = SIZE3 >>> 1;
          var slab = null;
          var offset3 = SIZE3;
          return function pool_alloc(size22) {
            if (size22 < 1 || size22 > MAX)
              return alloc4(size22);
            if (offset3 + size22 > SIZE3) {
              slab = alloc4(SIZE3);
              offset3 = 0;
            }
            var buf3 = slice4.call(slab, offset3, offset3 += size22);
            if (offset3 & 7)
              offset3 = (offset3 | 7) + 1;
            return buf3;
          };
        }
      }
    });
  }
});

// node_modules/@noble/hashes/esm/_assert.js
function number(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`positive integer expected, not ${n2}`);
}
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var init_assert = __esm({
  "node_modules/@noble/hashes/esm/_assert.js"() {
    init_process_shim();
  }
});

// node_modules/@noble/hashes/esm/utils.js
function byteSwap32(arr) {
  for (let i = 0; i < arr.length; i++) {
    arr[i] = byteSwap(arr[i]);
  }
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  bytes(data);
  return data;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
var u8, u32, createView, rotr, isLE, byteSwap, byteSwapIfBE, Hash, toStr;
var init_utils = __esm({
  "node_modules/@noble/hashes/esm/utils.js"() {
    init_process_shim();
    init_assert();
    u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    rotr = (word, shift) => word << 32 - shift | word >>> shift;
    isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    byteSwapIfBE = isLE ? (n2) => n2 : (n2) => byteSwap(n2);
    Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    toStr = {}.toString;
  }
});

// node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view6, byteOffset, value, isLE2) {
  if (typeof view6.setBigUint64 === "function")
    return view6.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view6.setUint32(byteOffset + h, wh, isLE2);
  view6.setUint32(byteOffset + l2, wl, isLE2);
}
var Chi, Maj, HashMD;
var init_md = __esm({
  "node_modules/@noble/hashes/esm/_md.js"() {
    init_process_shim();
    init_assert();
    init_utils();
    Chi = (a, b, c) => a & b ^ ~a & c;
    Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    HashMD = class extends Hash {
      constructor(blockLen, outputLen, padOffset, isLE2) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE2;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView(this.buffer);
      }
      update(data) {
        exists(this);
        const { view: view6, buffer: buffer3, blockLen } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView3 = createView(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView3, pos);
            continue;
          }
          buffer3.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view6, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        exists(this);
        output(out, this);
        this.finished = true;
        const { buffer: buffer3, view: view6, blockLen, isLE: isLE2 } = this;
        let { pos } = this;
        buffer3[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view6, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer3[i] = 0;
        setBigUint64(view6, blockLen - 8, BigInt(this.length * 8), isLE2);
        this.process(view6, 0);
        const oview = createView(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE2);
      }
      digest() {
        const { buffer: buffer3, outputLen } = this;
        this.digestInto(buffer3);
        const res = buffer3.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer: buffer3, length: length5, finished, destroyed, pos } = this;
        to.length = length5;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length5 % blockLen)
          to.buffer.set(buffer3);
        return to;
      }
    };
  }
});

// node_modules/@noble/hashes/esm/sha256.js
var SHA256_K, SHA256_IV, SHA256_W, SHA256, sha256;
var init_sha256 = __esm({
  "node_modules/@noble/hashes/esm/sha256.js"() {
    init_process_shim();
    init_md();
    init_utils();
    SHA256_K = /* @__PURE__ */ new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    SHA256_IV = /* @__PURE__ */ new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    SHA256_W = /* @__PURE__ */ new Uint32Array(64);
    SHA256 = class extends HashMD {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view6, offset3) {
        for (let i = 0; i < 16; i++, offset3 += 4)
          SHA256_W[i] = view6.getUint32(offset3, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
          const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());
  }
});

// node_modules/@fleek-platform/sdk/dist/browser/chunk-BOSPY7YV.js
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf2 = typeof value;
  if (typeofs.includes(typeOf2)) {
    return typeOf2;
  }
  if (typeOf2 === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer(value)) {
    return "Buffer";
  }
  const objectType = getObjectType(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
function isBuffer2(buf22) {
  return useBuffer && globalThis.Buffer.isBuffer(buf22);
}
function asU8A(buf22) {
  if (!(buf22 instanceof Uint8Array)) {
    return Uint8Array.from(buf22);
  }
  return isBuffer2(buf22) ? new Uint8Array(buf22.buffer, buf22.byteOffset, buf22.byteLength) : buf22;
}
function compare(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes2(str) {
  const out = [];
  let p = 0;
  for (let i = 0; i < str.length; i++) {
    let c = str.charCodeAt(i);
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }
  return out;
}
function utf8Slice(buf22, offset22, end) {
  const res = [];
  while (offset22 < end) {
    const firstByte = buf22[offset22];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset22 + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf22[offset22 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf22[offset22 + 1];
          thirdByte = buf22[offset22 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf22[offset22 + 1];
          thirdByte = buf22[offset22 + 2];
          fourthByte = buf22[offset22 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset22 += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}
function readUint8(data, offset22, options) {
  assertEnoughData(data, offset22, 1);
  const value = data[offset22];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data, offset22, options) {
  assertEnoughData(data, offset22, 2);
  const value = data[offset22] << 8 | data[offset22 + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data, offset22, options) {
  assertEnoughData(data, offset22, 4);
  const value = data[offset22] * 16777216 + (data[offset22 + 1] << 16) + (data[offset22 + 2] << 8) + data[offset22 + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data, offset22, options) {
  assertEnoughData(data, offset22, 8);
  const hi = data[offset22] * 16777216 + (data[offset22 + 1] << 16) + (data[offset22 + 2] << 8) + data[offset22 + 3];
  const lo = data[offset22 + 4] * 16777216 + (data[offset22 + 5] << 16) + (data[offset22 + 6] << 8) + data[offset22 + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf22, token) {
  return encodeUintValue(buf22, 0, token.value);
}
function encodeUintValue(buf22, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf22.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf22.push([major | 24, nuint]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf22.push([major | 25, nuint >>> 8, nuint & 255]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf22.push([major | 26, nuint >>> 24 & 255, nuint >>> 16 & 255, nuint >>> 8 & 255, nuint & 255]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set5 = [major | 27, 0, 0, 0, 0, 0, 0, 0];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set5[8] = lo & 255;
      lo = lo >> 8;
      set5[7] = lo & 255;
      lo = lo >> 8;
      set5[6] = lo & 255;
      lo = lo >> 8;
      set5[5] = lo & 255;
      set5[4] = hi & 255;
      hi = hi >> 8;
      set5[3] = hi & 255;
      hi = hi >> 8;
      set5[2] = hi & 255;
      hi = hi >> 8;
      set5[1] = hi & 255;
      buf22.push(set5);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
function decodeNegint64(data, pos, _minor, options) {
  const int2 = readUint64(data, pos + 1, options);
  if (typeof int2 !== "bigint") {
    const value = -1 - int2;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int2), 9);
}
function encodeNegint(buf22, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf22, token.type.majorEncoded, unsigned);
}
function toToken(data, pos, prefix2, length42) {
  assertEnoughData(data, pos, prefix2 + length42);
  const buf22 = slice(data, pos + prefix2, pos + prefix2 + length42);
  return new Token(Type.bytes, buf22, prefix2 + length42);
}
function decodeBytesCompact(data, pos, minor, _options2) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l2 = readUint64(data, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l2);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf22, token) {
  const bytes22 = tokenBytes(token);
  encodeUintValue(buf22, token.type.majorEncoded, bytes22.length);
  buf22.push(bytes22);
}
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
}
function toToken2(data, pos, prefix2, length42, options) {
  const totLength = prefix2 + length42;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString(data, pos + prefix2, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix2, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options) {
  return toToken2(data, pos, 1, minor, options);
}
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
function decodeString64(data, pos, _minor, options) {
  const l2 = readUint64(data, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l2, options);
}
function toToken3(_data2, _pos, prefix2, length42) {
  return new Token(Type.array, length42, prefix2);
}
function decodeArrayCompact(data, pos, minor, _options2) {
  return toToken3(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l2 = readUint64(data, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l2);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
function encodeArray(buf22, token) {
  encodeUintValue(buf22, Type.array.majorEncoded, token.value);
}
function toToken4(_data2, _pos, prefix2, length42) {
  return new Token(Type.map, length42, prefix2);
}
function decodeMapCompact(data, pos, minor, _options2) {
  return toToken4(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l2 = readUint64(data, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l2);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
function encodeMap(buf22, token) {
  encodeUintValue(buf22, Type.map.majorEncoded, token.value);
}
function decodeTagCompact(_data2, _pos, minor, _options2) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf22, token) {
  encodeUintValue(buf22, Type.tag.majorEncoded, token.value);
}
function decodeUndefined(_data2, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data2, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value, bytes22, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value, bytes22);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf22, token, options) {
  const float2 = token.value;
  if (float2 === false) {
    buf22.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float2 === true) {
    buf22.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float2 === null) {
    buf22.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float2 === void 0) {
    buf22.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float2);
      decoded = readFloat16(ui8a, 1);
      if (float2 === decoded || Number.isNaN(float2)) {
        ui8a[0] = 249;
        buf22.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float2);
        decoded = readFloat32(ui8a, 1);
        if (float2 === decoded) {
          ui8a[0] = 250;
          buf22.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float2);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf22.push(ui8a.slice(0, 9));
    }
  }
}
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | /* sign bit */
        1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a22, pos) {
  if (ui8a22.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a22[pos] << 8) + ui8a22[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a22, pos) {
  if (ui8a22.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset22 = (ui8a22.byteOffset || 0) + pos;
  return new DataView(ui8a22.buffer, offset22, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a22, pos) {
  if (ui8a22.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset22 = (ui8a22.byteOffset || 0) + pos;
  return new DataView(ui8a22.buffer, offset22, 8).getFloat64(0, false);
}
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && /** @type {OptionalTypeEncoder} */
  options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries3, options) {
  if (options.mapSorter) {
    entries3.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf22, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf22, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf22, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder32 = encoders[tokens.type.major];
    if (encoder32.encodedSize) {
      const size5 = encoder32.encodedSize(tokens, options);
      const buf22 = new Bl(size5);
      encoder32(buf22, tokens, options);
      if (buf22.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf22.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
      }
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decodeFirst(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  return [decoded, data.subarray(tokeniser.pos())];
}
function decode(data, options) {
  const [decoded, remainder] = decodeFirst(data, options);
  if (remainder.length > 0) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}
function toHex(d) {
  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
}
function fromHex(hex) {
  const hexes2 = hex.match(/../g);
  return hexes2 != null ? new Uint8Array(hexes2.map((b) => parseInt(b, 16))) : empty3;
}
function equals2(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce2(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function isBinary(o) {
  return o instanceof ArrayBuffer || ArrayBuffer.isView(o);
}
function fromString2(str) {
  return new TextEncoder().encode(str);
}
function toString2(b) {
  return new TextDecoder().decode(b);
}
function base(ALPHABET2, name142) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET2.length; i++) {
    var x = ALPHABET2.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode342(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length42 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size5 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size5);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size5 - 1; (carry !== 0 || i2 < length42) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length42 = i2;
      pbegin++;
    }
    var it2 = size5 - length42;
    while (it2 !== size5 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size5; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length42 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size5 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size5);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size5 - 1; (carry !== 0 || i2 < length42) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length42 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size5 - length42;
    while (it4 !== size5 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size5 - it4));
    var j2 = zeroes;
    while (it4 !== size5) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode412(string32) {
    var buffer22 = decodeUnsafe(string32);
    if (buffer22) {
      return buffer22;
    }
    throw new Error(`Non-${name142} character`);
  }
  return {
    encode: encode342,
    decodeUnsafe,
    decode: decode412
  };
}
function or(left, right) {
  return new ComposedDecoder({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
function from2({ name: name142, prefix: prefix2, encode: encode342, decode: decode412 }) {
  return new Codec(name142, prefix2, encode342, decode412);
}
function baseX({ name: name142, prefix: prefix2, alphabet: alphabet22 }) {
  const { encode: encode342, decode: decode412 } = base_x_default(alphabet22, name142);
  return from2({
    prefix: prefix2,
    name: name142,
    encode: encode342,
    decode: (text2) => coerce2(decode412(text2))
  });
}
function decode2(string32, alphabet22, bitsPerChar, name142) {
  const codes = {};
  for (let i = 0; i < alphabet22.length; ++i) {
    codes[alphabet22[i]] = i;
  }
  let end = string32.length;
  while (string32[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer22 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes[string32[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name142} character`);
    }
    buffer22 = buffer22 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer22 >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer22 << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode2(data, alphabet22, bitsPerChar) {
  const pad2 = alphabet22[alphabet22.length - 1] === "=";
  const mask2 = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer22 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer22 = buffer22 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet22[mask2 & buffer22 >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet22[mask2 & buffer22 << bitsPerChar - bits];
  }
  if (pad2) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc4648({ name: name142, prefix: prefix2, bitsPerChar, alphabet: alphabet22 }) {
  return from2({
    prefix: prefix2,
    name: name142,
    encode(input10) {
      return encode2(input10, alphabet22, bitsPerChar);
    },
    decode(input10) {
      return decode2(input10, alphabet22, bitsPerChar, name142);
    }
  });
}
function encode3(num, out, offset22) {
  out = out || [];
  offset22 = offset22 || 0;
  var oldOffset = offset22;
  while (num >= INT) {
    out[offset22++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset22++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset22] = num | 0;
  encode3.bytes = offset22 - oldOffset + 1;
  return out;
}
function read(buf22, offset22) {
  var res = 0, offset22 = offset22 || 0, shift = 0, counter = offset22, b, l2 = buf22.length;
  do {
    if (counter >= l2) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf22[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset22;
  return res;
}
function decode4(data, offset22 = 0) {
  const code192 = varint_default.decode(data, offset22);
  return [code192, varint_default.decode.bytes];
}
function encodeTo(int2, target, offset22 = 0) {
  varint_default.encode(int2, target, offset22);
  return target;
}
function encodingLength(int2) {
  return varint_default.encodingLength(int2);
}
function create(code192, digest52) {
  const size5 = digest52.byteLength;
  const sizeOffset = encodingLength(code192);
  const digestOffset = sizeOffset + encodingLength(size5);
  const bytes22 = new Uint8Array(digestOffset + size5);
  encodeTo(code192, bytes22, 0);
  encodeTo(size5, bytes22, sizeOffset);
  bytes22.set(digest52, digestOffset);
  return new Digest2(code192, size5, digest52, bytes22);
}
function decode5(multihash) {
  const bytes22 = coerce2(multihash);
  const [code192, sizeOffset] = decode4(bytes22);
  const [size5, digestOffset] = decode4(bytes22.subarray(sizeOffset));
  const digest52 = bytes22.subarray(sizeOffset + digestOffset);
  if (digest52.byteLength !== size5) {
    throw new Error("Incorrect length");
  }
  return new Digest2(code192, size5, digest52, bytes22);
}
function equals3(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals2(a.bytes, data.bytes);
  }
}
function format(link5, base42) {
  const { bytes: bytes22, version: version22 } = link5;
  switch (version22) {
    case 0:
      return toStringV0(bytes22, baseCache(link5), base42 ?? base58btc.encoder);
    default:
      return toStringV1(bytes22, baseCache(link5), base42 ?? base32.encoder);
  }
}
function baseCache(cid) {
  const baseCache4 = cache.get(cid);
  if (baseCache4 == null) {
    const baseCache5 = /* @__PURE__ */ new Map();
    cache.set(cid, baseCache5);
    return baseCache5;
  }
  return baseCache4;
}
function parseCIDtoBytes(source, base42) {
  switch (source[0]) {
    case "Q": {
      const decoder32 = base42 ?? base58btc;
      return [
        base58btc.prefix,
        decoder32.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder32 = base42 ?? base58btc;
      return [base58btc.prefix, decoder32.decode(source)];
    }
    case base32.prefix: {
      const decoder32 = base42 ?? base32;
      return [base32.prefix, decoder32.decode(source)];
    }
    default: {
      if (base42 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base42.decode(source)];
    }
  }
}
function toStringV0(bytes22, cache5, base42) {
  const { prefix: prefix2 } = base42;
  if (prefix2 !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base42.name} encoding`);
  }
  const cid = cache5.get(prefix2);
  if (cid == null) {
    const cid2 = base42.encode(bytes22).slice(1);
    cache5.set(prefix2, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV1(bytes22, cache5, base42) {
  const { prefix: prefix2 } = base42;
  const cid = cache5.get(prefix2);
  if (cid == null) {
    const cid2 = base42.encode(bytes22);
    cache5.set(prefix2, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function encodeCID(version22, code192, multihash) {
  const codeOffset = encodingLength(version22);
  const hashOffset = codeOffset + encodingLength(code192);
  const bytes22 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version22, bytes22, 0);
  encodeTo(code192, bytes22, codeOffset);
  bytes22.set(multihash, hashOffset);
  return bytes22;
}
function toByteView(buf22) {
  if (buf22 instanceof ArrayBuffer) {
    return new Uint8Array(buf22, 0, buf22.byteLength);
  }
  return buf22;
}
function cidEncoder(obj) {
  if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes22 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes22.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes22)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
function cidDecoder(bytes22) {
  if (bytes22[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes22.subarray(1));
}
function encode5(num, out, offset22) {
  out = out || [];
  offset22 = offset22 || 0;
  var oldOffset = offset22;
  while (num >= INT2) {
    out[offset22++] = num & 255 | MSB2;
    num /= 128;
  }
  while (num & MSBALL2) {
    out[offset22++] = num & 255 | MSB2;
    num >>>= 7;
  }
  out[offset22] = num | 0;
  encode5.bytes = offset22 - oldOffset + 1;
  return out;
}
function read2(buf22, offset22) {
  var res = 0, offset22 = offset22 || 0, shift = 0, counter = offset22, b, l2 = buf22.length;
  do {
    if (counter >= l2) {
      read2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf22[counter++];
    res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$12);
  read2.bytes = counter - offset22;
  return res;
}
function base2(ALPHABET2, name142) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET2.length; i++) {
    var x = ALPHABET2.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode342(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length42 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size5 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size5);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size5 - 1; (carry !== 0 || i2 < length42) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length42 = i2;
      pbegin++;
    }
    var it2 = size5 - length42;
    while (it2 !== size5 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size5; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length42 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size5 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size5);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size5 - 1; (carry !== 0 || i2 < length42) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length42 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size5 - length42;
    while (it4 !== size5 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size5 - it4));
    var j2 = zeroes;
    while (it4 !== size5) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode412(string32) {
    var buffer22 = decodeUnsafe(string32);
    if (buffer22) {
      return buffer22;
    }
    throw new Error(`Non-${name142} character`);
  }
  return {
    encode: encode342,
    decodeUnsafe,
    decode: decode412
  };
}
function truncatedHash(payload) {
  const { digest: digest52 } = sha256_exports.digest(payload);
  return truncate(digest52);
}
function truncate(node) {
  node[NODE_SIZE - 1] &= 63;
  return node;
}
function toZeroPaddedSize(payloadSize) {
  const size5 = Math.max(payloadSize, MIN_PAYLOAD_SIZE);
  const highestBit = Math.floor(Math.log2(size5));
  const bound = Math.ceil(FR_RATIO * 2 ** (highestBit + 1));
  return size5 <= bound ? bound : Math.ceil(FR_RATIO * 2 ** (highestBit + 2));
}
function mapSorter2(e1, e2) {
  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {
    throw new Error(`${encodeErrPrefix} complex map keys are not supported`);
  }
  const keyToken1 = e1[0];
  const keyToken2 = e2[0];
  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {
    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`);
  }
  if (keyToken1 < keyToken2) {
    return -1;
  }
  if (keyToken1 > keyToken2) {
    return 1;
  }
  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`);
}
function encode11(data, options) {
  options = Object.assign({}, defaultEncodeOptions2, options);
  return encodeCustom(data, new JSONEncoder(), options);
}
function decode14(data, options) {
  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options);
  return decode(data, options);
}
function from6({ name: name142, code: code192, encode: encode342 }) {
  return new Hasher3(name142, code192, encode342);
}
function toByteView2(buf22) {
  if (buf22 instanceof ArrayBuffer) {
    return new Uint8Array(buf22, 0, buf22.byteLength);
  }
  return buf22;
}
function cidEncoder2(obj) {
  if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const cidString = cid.toString();
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    // key
    new Token(Type.string, cidString, cidString.length),
    // value
    new Token(Type.break, void 0, 1)
  ];
}
function bytesEncoder(bytes22) {
  const bytesString = base642.encode(bytes22).slice(1);
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    // key
    new Token(Type.map, Infinity, 1),
    // value
    new Token(Type.string, "bytes", 5),
    // inner key
    new Token(Type.string, bytesString, bytesString.length),
    // inner value
    new Token(Type.break, void 0, 1),
    new Token(Type.break, void 0, 1)
  ];
}
function taBytesEncoder(obj) {
  return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
}
function abBytesEncoder(ab) {
  return bytesEncoder(new Uint8Array(ab));
}
function undefinedEncoder2() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder2(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
function decodeVarint(bytes22, seeker) {
  if (!bytes22.length) {
    throw new Error("Unexpected end of data");
  }
  const i = import_varint3.default.decode(bytes22);
  seeker.seek(
    /** @type {number} */
    import_varint3.default.decode.bytes
  );
  return i;
}
function decodeV2Header(bytes22) {
  const dv = new DataView(bytes22.buffer, bytes22.byteOffset, bytes22.byteLength);
  let offset22 = 0;
  const header = {
    version: 2,
    /** @type {[bigint, bigint]} */
    characteristics: [
      dv.getBigUint64(offset22, true),
      dv.getBigUint64(offset22 += 8, true)
    ],
    dataOffset: Number(dv.getBigUint64(offset22 += 8, true)),
    dataSize: Number(dv.getBigUint64(offset22 += 8, true)),
    indexOffset: Number(dv.getBigUint64(offset22 += 8, true))
  };
  return header;
}
function getMultihashLength(bytes22) {
  import_varint3.default.decode(bytes22);
  const codeLength = (
    /** @type {number} */
    import_varint3.default.decode.bytes
  );
  const length42 = import_varint3.default.decode(bytes22.subarray(import_varint3.default.decode.bytes));
  const lengthLength = (
    /** @type {number} */
    import_varint3.default.decode.bytes
  );
  const mhLength = codeLength + lengthLength + length42;
  return mhLength;
}
function readHeader(reader, strictVersion) {
  const length42 = decodeVarint(reader.upTo(8), reader);
  if (length42 === 0) {
    throw new Error("Invalid CAR header (zero length)");
  }
  const header = reader.exactly(length42, true);
  const block = decode6(header);
  if (CarV1HeaderOrV2Pragma.toTyped(block) === void 0) {
    throw new Error("Invalid CAR header format");
  }
  if (block.version !== 1 && block.version !== 2 || strictVersion !== void 0 && block.version !== strictVersion) {
    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== void 0 ? ` (expected ${strictVersion})` : ""}`);
  }
  if (block.version === 1) {
    if (!Array.isArray(block.roots)) {
      throw new Error("Invalid CAR header format");
    }
    return block;
  }
  if (block.roots !== void 0) {
    throw new Error("Invalid CAR header format");
  }
  const v2Header = decodeV2Header(reader.exactly(V2_HEADER_LENGTH, true));
  reader.seek(v2Header.dataOffset - reader.pos);
  const v1Header = readHeader(reader, 1);
  return Object.assign(v1Header, v2Header);
}
function readCid(reader) {
  const first = reader.exactly(2, false);
  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {
    const bytes3 = reader.exactly(34, true);
    const multihash2 = decode5(bytes3);
    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash2);
  }
  const version22 = decodeVarint(reader.upTo(8), reader);
  if (version22 !== 1) {
    throw new Error(`Unexpected CID version (${version22})`);
  }
  const codec = decodeVarint(reader.upTo(8), reader);
  const bytes22 = reader.exactly(getMultihashLength(reader.upTo(8)), true);
  const multihash = decode5(bytes22);
  return CID.create(version22, codec, multihash);
}
function readBlockHead(reader) {
  const start = reader.pos;
  let length42 = decodeVarint(reader.upTo(8), reader);
  if (length42 === 0) {
    throw new Error("Invalid CAR section (zero length)");
  }
  length42 += reader.pos - start;
  const cid = readCid(reader);
  const blockLength2 = length42 - Number(reader.pos - start);
  return { cid, length: length42, blockLength: blockLength2 };
}
function fromBytes2(bytes22) {
  let reader = bytesReader(bytes22);
  const header = readHeader(reader);
  if (header.version === 2) {
    const v1length = reader.pos - header.dataOffset;
    reader = limitReader(reader, header.dataSize - v1length);
  }
  const blocks = [];
  while (reader.upTo(8).length > 0) {
    const { cid, blockLength: blockLength2 } = readBlockHead(reader);
    blocks.push({ cid, bytes: reader.exactly(blockLength2, true) });
  }
  return {
    header,
    blocks
  };
}
function bytesReader(bytes22) {
  let pos = 0;
  return {
    upTo(length42) {
      return bytes22.subarray(pos, pos + Math.min(length42, bytes22.length - pos));
    },
    exactly(length42, seek = false) {
      if (length42 > bytes22.length - pos) {
        throw new Error("Unexpected end of data");
      }
      const out = bytes22.subarray(pos, pos + length42);
      if (seek) {
        pos += length42;
      }
      return out;
    },
    seek(length42) {
      pos += length42;
    },
    get pos() {
      return pos;
    }
  };
}
function limitReader(reader, byteLimit) {
  let bytesRead = 0;
  return {
    upTo(length42) {
      let bytes22 = reader.upTo(length42);
      if (bytes22.length + bytesRead > byteLimit) {
        bytes22 = bytes22.subarray(0, byteLimit - bytesRead);
      }
      return bytes22;
    },
    exactly(length42, seek = false) {
      const bytes22 = reader.exactly(length42, seek);
      if (bytes22.length + bytesRead > byteLimit) {
        throw new Error("Unexpected end of data");
      }
      if (seek) {
        bytesRead += length42;
      }
      return bytes22;
    },
    seek(length42) {
      bytesRead += length42;
      reader.seek(length42);
    },
    get pos() {
      return reader.pos;
    }
  };
}
function tokensToLength(tokens, encoders = cborEncoders2, options = defaultEncodeOptions3) {
  if (Array.isArray(tokens)) {
    let len = 0;
    for (const token of tokens) {
      len += tokensToLength(token, encoders, options);
    }
    return len;
  } else {
    const encoder32 = encoders[tokens.type.major];
    if (encoder32.encodedSize === void 0 || typeof encoder32.encodedSize !== "function") {
      throw new Error(`Encoder for ${tokens.type.name} does not have an encodedSize()`);
    }
    return encoder32.encodedSize(tokens, options);
  }
}
function getLinksFromObject(obj) {
  const links3 = [];
  function recurse(obj2) {
    for (const key in obj2) {
      const value = obj2[key];
      if (isLink(value)) {
        links3.push(value);
      } else if (value && typeof value === "object") {
        recurse(value);
      }
    }
  }
  recurse(obj);
  return links3;
}
function equals5(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function equalWith(child, parent) {
  return child.with === parent.with ? ok({}) : fail2(`Can not derive ${child.can} with ${child.with} from ${parent.with}`);
}
function equal(child, parent, constraint) {
  if (parent === void 0 || parent === "*") {
    return ok({});
  } else if (String(child) === String(parent)) {
    return ok({});
  } else {
    return fail2(
      `Constrain violation: ${child} violates imposed ${constraint} constraint ${parent}`
    );
  }
}
async function filecoinOffer2({ issuer, with: resource, proofs: proofs2, audience }, content2, piece, options = {}) {
  const conn = options.connection ?? connection;
  const invocation = filecoinOffer.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? services.STOREFRONT.principal,
    with: resource,
    nb: {
      content: content2,
      piece
    },
    proofs: proofs2,
    expiration: Infinity
  });
  return await invocation.execute(conn);
}
async function filecoinSubmit2({ issuer, with: resource, proofs: proofs2, audience }, content2, piece, options = {}) {
  const conn = options.connection ?? connection;
  const invocation = filecoinSubmit.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? services.STOREFRONT.principal,
    with: resource,
    nb: {
      content: content2,
      piece
    },
    proofs: proofs2,
    expiration: Infinity
  });
  return await invocation.execute(conn);
}
async function filecoinAccept2({ issuer, with: resource, proofs: proofs2, audience }, content2, piece, options = {}) {
  const conn = options.connection ?? connection;
  const invocation = filecoinAccept.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? services.STOREFRONT.principal,
    with: resource,
    nb: {
      content: content2,
      piece
    },
    proofs: proofs2,
    expiration: Infinity
  });
  return await invocation.execute(conn);
}
async function filecoinInfo2({ issuer, with: resource, proofs: proofs2, audience }, piece, options = {}) {
  const conn = options.connection ?? connection;
  const invocation = filecoinInfo.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? services.STOREFRONT.principal,
    with: resource,
    nb: {
      piece
    },
    proofs: proofs2
  });
  return await invocation.execute(conn);
}
function base3(ALPHABET2, name142) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET2.length; i++) {
    var x = ALPHABET2.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode342(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length42 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size5 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size5);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size5 - 1; (carry !== 0 || i2 < length42) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length42 = i2;
      pbegin++;
    }
    var it2 = size5 - length42;
    while (it2 !== size5 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size5; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length42 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size5 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size5);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size5 - 1; (carry !== 0 || i2 < length42) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length42 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size5 - length42;
    while (it4 !== size5 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size5 - it4));
    var j2 = zeroes;
    while (it4 !== size5) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode412(string32) {
    var buffer22 = decodeUnsafe(string32);
    if (buffer22) {
      return buffer22;
    }
    throw new Error(`Non-${name142} character`);
  }
  return {
    encode: encode342,
    decodeUnsafe,
    decode: decode412
  };
}
function encode21(num, out, offset22) {
  out = out || [];
  offset22 = offset22 || 0;
  var oldOffset = offset22;
  while (num >= INT3) {
    out[offset22++] = num & 255 | MSB3;
    num /= 128;
  }
  while (num & MSBALL3) {
    out[offset22++] = num & 255 | MSB3;
    num >>>= 7;
  }
  out[offset22] = num | 0;
  encode21.bytes = offset22 - oldOffset + 1;
  return out;
}
function read7(buf22, offset22) {
  var res = 0, offset22 = offset22 || 0, shift = 0, counter = offset22, b, l2 = buf22.length;
  do {
    if (counter >= l2) {
      read7.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf22[counter++];
    res += shift < 28 ? (b & REST$13) << shift : (b & REST$13) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$13);
  read7.bytes = counter - offset22;
  return res;
}
function equalWith2(child, parent) {
  return child.with === parent.with ? ok({}) : fail2(`Can not derive ${child.can} with ${child.with} from ${parent.with}`);
}
function equal2(child, parent, constraint) {
  if (parent === void 0 || parent === "*") {
    return ok({});
  } else if (String(child) === String(parent)) {
    return ok({});
  } else {
    return fail2(
      `Constrain violation: ${child} violates imposed ${constraint} constraint ${parent}`
    );
  }
}
async function pRetry(input10, options) {
  return new Promise((resolve2, reject) => {
    options = {
      onFailedAttempt() {
      },
      retries: 10,
      ...options
    };
    const operation = import_retry.default.operation(options);
    operation.attempt(async (attemptNumber) => {
      try {
        resolve2(await input10(attemptNumber));
      } catch (error3) {
        if (!(error3 instanceof Error)) {
          reject(new TypeError(`Non-error was thrown: "${error3}". You should only throw errors.`));
          return;
        }
        if (error3 instanceof AbortError) {
          operation.stop();
          reject(error3.originalError);
        } else if (error3 instanceof TypeError && !isNetworkError(error3.message)) {
          operation.stop();
          reject(error3);
        } else {
          decorateErrorWithCounts(error3, attemptNumber, options);
          try {
            await options.onFailedAttempt(error3);
          } catch (error4) {
            reject(error4);
            return;
          }
          if (!operation.retry(error3)) {
            reject(operation.mainError());
          }
        }
      }
    });
    if (options.signal && !options.signal.aborted) {
      options.signal.addEventListener("abort", () => {
        operation.stop();
        const reason = options.signal.reason === void 0 ? getDOMException("The operation was aborted.") : options.signal.reason;
        reject(reason instanceof Error ? reason : getDOMException(reason));
      }, {
        once: true
      });
    }
  });
}
function createUploadProgressHandler(url2, handler) {
  function onUploadProgress({ total, loaded, lengthComputable }) {
    return handler({ total, loaded, lengthComputable, url: url2 });
  }
  return onUploadProgress;
}
async function add2({ issuer, with: resource, proofs: proofs2, audience }, car, options = {}) {
  const bytes22 = car instanceof Uint8Array ? car : new Uint8Array(await car.arrayBuffer());
  const link5 = await car_exports2.codec.link(bytes22);
  const conn = options.connection ?? connection5;
  const result = await pRetry(async () => {
    return await add.invoke({
      issuer,
      /* c8 ignore next */
      audience: audience ?? servicePrincipal,
      with: SpaceDID2.from(resource),
      nb: { link: link5, size: bytes22.length },
      proofs: proofs2,
      nonce: options.nonce
    }).execute(conn);
  }, {
    onFailedAttempt: console.warn,
    retries: options.retries ?? REQUEST_RETRIES
  });
  if (!result.out.ok) {
    throw new Error(`failed ${add.can} invocation`, {
      cause: result.out.error
    });
  }
  if (result.out.ok.status === "done") {
    return link5;
  }
  const responseAddUpload = result.out.ok;
  const fetchWithUploadProgress = options.fetchWithUploadProgress || options.fetch || globalThis.fetch.bind(globalThis);
  let fetchDidCallUploadProgressCb = false;
  const res = await pRetry(async () => {
    try {
      const res2 = await fetchWithUploadProgress(responseAddUpload.url, {
        method: "PUT",
        body: car,
        headers: responseAddUpload.headers,
        signal: options.signal,
        onUploadProgress: (status) => {
          fetchDidCallUploadProgressCb = true;
          if (options.onUploadProgress)
            createUploadProgressHandler(responseAddUpload.url, options.onUploadProgress)(status);
        },
        // @ts-expect-error - this is needed by recent versions of node - see https://github.com/bluesky-social/atproto/pull/470 for more info
        duplex: "half"
      });
      if (res2.status >= 400 && res2.status < 500) {
        throw new AbortError(`upload failed: ${res2.status}`);
      }
      return res2;
    } catch (err) {
      if (options.signal?.aborted === true) {
        throw new AbortError("upload aborted");
      }
      throw err;
    }
  }, {
    retries: options.retries ?? REQUEST_RETRIES
  });
  if (!fetchDidCallUploadProgressCb && options.onUploadProgress) {
    const carBlob = new Blob([car]);
    options.onUploadProgress({
      total: carBlob.size,
      loaded: carBlob.size,
      lengthComputable: false
    });
  }
  if (!res.ok) {
    throw new Error(`upload failed: ${res.status}`);
  }
  return link5;
}
async function get3({ issuer, with: resource, proofs: proofs2, audience }, link5, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await pRetry(async () => {
    return await get2.invoke({
      issuer,
      /* c8 ignore next */
      audience: audience ?? servicePrincipal,
      with: SpaceDID2.from(resource),
      nb: { link: link5 },
      proofs: proofs2,
      nonce: options.nonce
    }).execute(conn);
  }, {
    onFailedAttempt: console.warn,
    retries: options.retries ?? REQUEST_RETRIES
  });
  if (!result.out.ok) {
    throw new Error(`failed ${get2.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out.ok;
}
async function list2({ issuer, with: resource, proofs: proofs2, audience }, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await list.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? servicePrincipal,
    with: SpaceDID2.from(resource),
    proofs: proofs2,
    nb: {
      cursor: options.cursor,
      size: options.size,
      pre: options.pre
    },
    nonce: options.nonce
  }).execute(conn);
  if (!result.out.ok) {
    throw new Error(`failed ${list.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out.ok;
}
async function remove2({ issuer, with: resource, proofs: proofs2, audience }, link5, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await remove.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? servicePrincipal,
    with: SpaceDID2.from(resource),
    nb: { link: link5 },
    proofs: proofs2,
    nonce: options.nonce
  }).execute(conn);
  if (!result.out.ok) {
    throw new Error(`failed ${remove.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out;
}
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function assertExtPoint(other) {
  if (!(other instanceof ExtendedPoint))
    throw new TypeError("ExtendedPoint expected");
}
function assertRstPoint(other) {
  if (!(other instanceof RistrettoPoint))
    throw new TypeError("RistrettoPoint expected");
}
function legacyRist() {
  throw new Error("Legacy method: switch to RistrettoPoint");
}
function concatBytes(...arrays) {
  if (!arrays.every((a) => a instanceof Uint8Array))
    throw new Error("Expected Uint8Array list");
  if (arrays.length === 1)
    return arrays[0];
  const length42 = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length42);
  for (let i = 0, pad2 = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad2);
    pad2 += arr.length;
  }
  return result;
}
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex += hexes[uint8a[i]];
  }
  return hex;
}
function hexToBytes(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array2 = new Uint8Array(hex.length / 2);
  for (let i = 0; i < array2.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array2[i] = byte;
  }
  return array2;
}
function numberTo32BytesBE(num) {
  const length42 = 32;
  const hex = num.toString(16).padStart(length42 * 2, "0");
  return hexToBytes(hex);
}
function numberTo32BytesLE(num) {
  return numberTo32BytesBE(num).reverse();
}
function edIsNegative(num) {
  return (mod2(num) & _1n) === _1n;
}
function bytesToNumberLE(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  return BigInt("0x" + bytesToHex(Uint8Array.from(uint8a).reverse()));
}
function bytes255ToNumberLE(bytes22) {
  return mod2(bytesToNumberLE(bytes22) & MAX_255B);
}
function mod2(a, b = CURVE.P) {
  const res = a % b;
  return res >= _0n ? res : b + res;
}
function invert(number22, modulo = CURVE.P) {
  if (number22 === _0n || modulo <= _0n) {
    throw new Error(`invert: expected positive integers, got n=${number22} mod=${modulo}`);
  }
  let a = mod2(number22, modulo);
  let b = modulo;
  let x = _0n, y = _1n, u = _1n, v = _0n;
  while (a !== _0n) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n2 = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n2;
  }
  const gcd = b;
  if (gcd !== _1n)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (num === _0n)
      return acc;
    tmp[i] = acc;
    return mod2(acc * num, p);
  }, _1n);
  const inverted = invert(lastMultiplied, p);
  nums.reduceRight((acc, num, i) => {
    if (num === _0n)
      return acc;
    tmp[i] = mod2(acc * tmp[i], p);
    return mod2(acc * num, p);
  }, inverted);
  return tmp;
}
function pow2(x, power) {
  const { P } = CURVE;
  let res = x;
  while (power-- > _0n) {
    res *= res;
    res %= P;
  }
  return res;
}
function pow_2_252_3(x) {
  const { P } = CURVE;
  const _5n = BigInt(5);
  const _10n = BigInt(10);
  const _20n = BigInt(20);
  const _40n = BigInt(40);
  const _80n = BigInt(80);
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, _2n) * b2 % P;
  const b5 = pow2(b4, _1n) * x % P;
  const b10 = pow2(b5, _5n) * b5 % P;
  const b20 = pow2(b10, _10n) * b10 % P;
  const b40 = pow2(b20, _20n) * b20 % P;
  const b80 = pow2(b40, _40n) * b40 % P;
  const b160 = pow2(b80, _80n) * b80 % P;
  const b240 = pow2(b160, _80n) * b80 % P;
  const b250 = pow2(b240, _10n) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n) * x % P;
  return { pow_p_5_8, b2 };
}
function uvRatio(u, v) {
  const v3 = mod2(v * v * v);
  const v7 = mod2(v3 * v3 * v);
  const pow = pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod2(u * v3 * pow);
  const vx2 = mod2(v * x * x);
  const root1 = x;
  const root2 = mod2(x * SQRT_M1);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod2(-u);
  const noRoot = vx2 === mod2(-u * SQRT_M1);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (edIsNegative(x))
    x = mod2(-x);
  return { isValid: useRoot1 || useRoot2, value: x };
}
function invertSqrt(number22) {
  return uvRatio(_1n, number22);
}
function modlLE(hash) {
  return mod2(bytesToNumberLE(hash), CURVE.l);
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length) {
    return false;
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] !== b2[i]) {
      return false;
    }
  }
  return true;
}
function ensureBytes(hex, expectedLength) {
  const bytes22 = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
  if (typeof expectedLength === "number" && bytes22.length !== expectedLength)
    throw new Error(`Expected ${expectedLength} bytes`);
  return bytes22;
}
function normalizeScalar(num, max, strict = true) {
  if (!max)
    throw new TypeError("Specify max value");
  if (typeof num === "number" && Number.isSafeInteger(num))
    num = BigInt(num);
  if (typeof num === "bigint" && num < max) {
    if (strict) {
      if (_0n < num)
        return num;
    } else {
      if (_0n <= num)
        return num;
    }
  }
  throw new TypeError("Expected valid scalar: 0 < scalar < max");
}
function adjustBytes25519(bytes22) {
  bytes22[0] &= 248;
  bytes22[31] &= 127;
  bytes22[31] |= 64;
  return bytes22;
}
function checkPrivateKey(key) {
  key = typeof key === "bigint" || typeof key === "number" ? numberTo32BytesBE(normalizeScalar(key, POW_2_256)) : ensureBytes(key);
  if (key.length !== 32)
    throw new Error(`Expected 32 bytes`);
  return key;
}
function getKeyFromHash(hashed) {
  const head = adjustBytes25519(hashed.slice(0, 32));
  const prefix2 = hashed.slice(32, 64);
  const scalar = modlLE(head);
  const point = Point.BASE.multiply(scalar);
  const pointBytes = point.toRawBytes();
  return { head, prefix: prefix2, scalar, point, pointBytes };
}
async function getExtendedPublicKey(key) {
  return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));
}
async function getPublicKey(privateKey) {
  return (await getExtendedPublicKey(privateKey)).pointBytes;
}
async function sign(message2, privateKey) {
  message2 = ensureBytes(message2);
  const { prefix: prefix2, scalar, pointBytes } = await getExtendedPublicKey(privateKey);
  const r = modlLE(await utils.sha512(prefix2, message2));
  const R = Point.BASE.multiply(r);
  const k = modlLE(await utils.sha512(R.toRawBytes(), pointBytes, message2));
  const s2 = mod2(r + k * scalar, CURVE.l);
  return new Signature2(R, s2).toRawBytes();
}
function prepareVerification(sig, message2, publicKey) {
  message2 = ensureBytes(message2);
  if (!(publicKey instanceof Point))
    publicKey = Point.fromHex(publicKey, false);
  const { r, s: s2 } = sig instanceof Signature2 ? sig.assertValidity() : Signature2.fromHex(sig);
  const SB = ExtendedPoint.BASE.multiplyUnsafe(s2);
  return { r, s: s2, SB, pub: publicKey, msg: message2 };
}
function finishVerification(publicKey, r, SB, hashed) {
  const k = modlLE(hashed);
  const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);
  const RkA = ExtendedPoint.fromAffine(r).add(kA);
  return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
}
async function verify(sig, message2, publicKey) {
  const { r, SB, msg, pub } = prepareVerification(sig, message2, publicKey);
  const hashed = await utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);
  return finishVerification(pub, r, SB, hashed);
}
async function poll(taskCid, options = {}) {
  return await pRetry(async () => {
    const res = await get5(taskCid, options);
    if (res.error) {
      if (res.error.name === "ReceiptNotFound") {
        throw res.error;
      } else {
        throw new AbortError(new Error("failed to fetch blob/accept receipt", {
          cause: res.error
        }));
      }
    }
    return res.ok;
  }, {
    onFailedAttempt: console.warn,
    /* c8 ignore next */
    retries: options.retries ?? REQUEST_RETRIES
  });
}
async function get5(taskCid, options = {}) {
  const url2 = new URL(taskCid.toString(), options.receiptsEndpoint ?? receiptsEndpoint);
  const fetchReceipt = options.fetch ?? globalThis.fetch.bind(globalThis);
  const workflowResponse = await fetchReceipt(url2);
  if (workflowResponse.status === 404) {
    return {
      error: new ReceiptNotFound(taskCid)
    };
  }
  const agentMessageBytes = new Uint8Array(await workflowResponse.arrayBuffer());
  const agentMessage = await car_exports2.request.decode({
    body: agentMessageBytes,
    headers: {}
  });
  const receipt = agentMessage.receipts.get(taskCid.toString());
  if (!receipt) {
    return {
      error: new ReceiptMissing(taskCid)
    };
  }
  return {
    ok: receipt
  };
}
function createUploadProgressHandler2(url2, handler) {
  const onUploadProgress = ({ total, loaded, lengthComputable }) => {
    return handler({ total, loaded, lengthComputable, url: url2 });
  };
  return onUploadProgress;
}
function getConcludeReceipt(concludeFx) {
  const receiptBlocks = /* @__PURE__ */ new Map();
  for (const block of concludeFx.iterateIPLDBlocks()) {
    receiptBlocks.set(`${block.cid}`, block);
  }
  return receipt_exports.view({
    // @ts-expect-error object of type unknown
    root: concludeFx.capabilities[0].nb.receipt,
    blocks: receiptBlocks
  });
}
function parseBlobAddReceiptNext(receipt) {
  const forkInvocations = receipt.fx.fork;
  const allocateTask = forkInvocations.find((fork5) => fork5.capabilities[0].can === allocate.can);
  const concludefxs = forkInvocations.filter((fork5) => fork5.capabilities[0].can === conclude.can);
  const putTask = forkInvocations.find((fork5) => fork5.capabilities[0].can === put.can);
  const acceptTask = forkInvocations.find((fork5) => fork5.capabilities[0].can === accept.can);
  if (!allocateTask || !concludefxs.length || !putTask || !acceptTask) {
    throw new Error("mandatory effects not received");
  }
  const nextReceipts = concludefxs.map((fx) => getConcludeReceipt(fx));
  const allocateReceipt = nextReceipts.find((receipt2) => receipt2.ran.link().equals(allocateTask.cid));
  const putReceipt = nextReceipts.find((receipt2) => receipt2.ran.link().equals(putTask.cid));
  const acceptReceipt = nextReceipts.find((receipt2) => receipt2.ran.link().equals(acceptTask.cid));
  if (!allocateReceipt) {
    throw new Error("mandatory effects not received");
  }
  return {
    allocate: {
      task: allocateTask,
      receipt: allocateReceipt
    },
    put: {
      task: putTask,
      receipt: putReceipt
    },
    accept: {
      task: acceptTask,
      receipt: acceptReceipt
    }
  };
}
function createConcludeInvocation(id, serviceDid, receipt) {
  const receiptBlocks = [];
  const receiptCids = [];
  for (const block of receipt.iterateIPLDBlocks()) {
    receiptBlocks.push(block);
    receiptCids.push(block.cid);
  }
  const concludeAllocatefx = conclude.invoke({
    issuer: id,
    audience: serviceDid,
    with: id.toDIDKey(),
    nb: {
      receipt: receipt.link()
    },
    expiration: Infinity,
    facts: [
      {
        ...receiptCids
      }
    ]
  });
  for (const block of receiptBlocks) {
    concludeAllocatefx.attach(block);
  }
  return concludeAllocatefx;
}
async function add4({ issuer, with: resource, proofs: proofs2, audience }, digest52, data, options = {}) {
  const bytes22 = data instanceof Uint8Array ? data : new Uint8Array(await data.arrayBuffer());
  const size5 = bytes22.length;
  const conn = options.connection ?? connection5;
  const result = await pRetry(async () => {
    return await add3.invoke({
      issuer,
      /* c8 ignore next */
      audience: audience ?? servicePrincipal,
      with: SpaceDID2.from(resource),
      nb: input(digest52, size5),
      proofs: proofs2,
      nonce: options.nonce
    }).execute(conn);
  }, {
    onFailedAttempt: console.warn,
    retries: options.retries ?? REQUEST_RETRIES
  });
  if (!result.out.ok) {
    throw new Error(`failed ${add3.can} invocation`, {
      cause: result.out.error
    });
  }
  const nextTasks = parseBlobAddReceiptNext(result);
  const { receipt: allocateReceipt } = nextTasks.allocate;
  if (!allocateReceipt.out.ok) {
    throw new Error(`failed ${add3.can} invocation`, {
      cause: allocateReceipt.out.error
    });
  }
  const { address } = allocateReceipt.out.ok;
  if (address) {
    const fetchWithUploadProgress = options.fetchWithUploadProgress || options.fetch || globalThis.fetch.bind(globalThis);
    let fetchDidCallUploadProgressCb = false;
    const { status } = await pRetry(async () => {
      try {
        const res = await fetchWithUploadProgress(address.url, {
          method: "PUT",
          mode: "cors",
          body: bytes22,
          headers: address.headers,
          signal: options.signal,
          onUploadProgress: (status2) => {
            fetchDidCallUploadProgressCb = true;
            if (options.onUploadProgress)
              createUploadProgressHandler2(address.url, options.onUploadProgress)(status2);
          },
          // @ts-expect-error - this is needed by recent versions of node - see https://github.com/bluesky-social/atproto/pull/470 for more info
          duplex: "half"
        });
        if (res.status >= 400 && res.status < 500) {
          throw new AbortError(`upload failed: ${res.status}`);
        }
        return res;
      } catch (err) {
        if (options.signal?.aborted === true) {
          throw new AbortError("upload aborted");
        }
        throw err;
      }
    }, {
      retries: options.retries ?? REQUEST_RETRIES
    });
    if (status !== 200)
      throw new Error(`upload failed: ${status}`);
    if (!fetchDidCallUploadProgressCb && options.onUploadProgress) {
      const blob3 = new Blob([bytes22]);
      options.onUploadProgress({
        total: blob3.size,
        loaded: blob3.size,
        lengthComputable: false
      });
    }
  }
  let { receipt: httpPutReceipt } = nextTasks.put;
  if (!httpPutReceipt?.out.ok) {
    const derivedSigner = ed25519_exports.from(
      /** @type {import('@ucanto/interface').SignerArchive<import('@ucanto/interface').DID, typeof ed25519.signatureCode>} */
      nextTasks.put.task.facts[0]["keys"]
    );
    httpPutReceipt = await receipt_exports.issue({
      issuer: derivedSigner,
      ran: nextTasks.put.task.cid,
      result: { ok: {} }
    });
    const httpPutConcludeInvocation = createConcludeInvocation(
      issuer,
      /* c8 ignore next */
      audience ?? servicePrincipal,
      httpPutReceipt
    );
    const ucanConclude = await httpPutConcludeInvocation.execute(conn);
    if (!ucanConclude.out.ok) {
      throw new Error(`failed ${add3.can} invocation`, {
        cause: result.out.error
      });
    }
  }
  let { receipt: acceptReceipt } = nextTasks.accept;
  if (!acceptReceipt?.out.ok) {
    acceptReceipt = await poll(nextTasks.accept.task.link(), options);
  }
  const blocks = new Map([...acceptReceipt.iterateIPLDBlocks()].map((block) => [
    `${block.cid}`,
    block
  ]));
  const site = delegation_exports.view({
    root: (
      /** @type {import('@ucanto/interface').UCANLink} */
      acceptReceipt.out.ok?.site
    ),
    blocks
  });
  return { site };
}
async function get6({ issuer, with: resource, proofs: proofs2, audience }, multihash, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await get4.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? servicePrincipal,
    with: SpaceDID2.from(resource),
    nb: input2(multihash),
    proofs: proofs2,
    nonce: options.nonce
  }).execute(conn);
  if (!result.out.ok) {
    throw new Error(`failed ${get4.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out;
}
async function list4({ issuer, with: resource, proofs: proofs2, audience }, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await list3.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? servicePrincipal,
    with: SpaceDID2.from(resource),
    proofs: proofs2,
    nb: input3(options.cursor, options.size),
    nonce: options.nonce
  }).execute(conn);
  if (!result.out.ok) {
    throw new Error(`failed ${list3.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out.ok;
}
async function remove4({ issuer, with: resource, proofs: proofs2, audience }, multihash, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await remove3.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? servicePrincipal,
    with: SpaceDID2.from(resource),
    nb: input4(multihash),
    proofs: proofs2,
    nonce: options.nonce
  }).execute(conn);
  if (!result.out.ok) {
    throw new Error(`failed ${remove3.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out;
}
async function add6({ issuer, with: resource, proofs: proofs2, audience }, index2, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await pRetry(async () => {
    return await add5.invoke({
      issuer,
      /* c8 ignore next */
      audience: audience ?? servicePrincipal,
      with: SpaceDID2.from(resource),
      nb: input5(index2),
      proofs: proofs2
    }).execute(conn);
  }, {
    onFailedAttempt: console.warn,
    retries: options.retries ?? REQUEST_RETRIES
  });
  if (!result.out.ok) {
    throw new Error(`failed ${add5.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out.ok;
}
async function add8({ issuer, with: resource, proofs: proofs2, audience }, root2, shards, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await pRetry(async () => {
    return await add7.invoke({
      issuer,
      /* c8 ignore next */
      audience: audience ?? servicePrincipal,
      with: SpaceDID2.from(resource),
      nb: input6(root2, shards),
      proofs: proofs2,
      nonce: options.nonce
    }).execute(conn);
  }, {
    onFailedAttempt: console.warn,
    retries: options.retries ?? REQUEST_RETRIES
  });
  if (!result.out.ok) {
    throw new Error(`failed ${add7.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out.ok;
}
async function get8({ issuer, with: resource, proofs: proofs2, audience }, root2, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await pRetry(async () => {
    return await get7.invoke({
      issuer,
      /* c8 ignore next */
      audience: audience ?? servicePrincipal,
      with: SpaceDID2.from(resource),
      nb: input7(root2),
      proofs: proofs2,
      nonce: options.nonce
    }).execute(conn);
  }, {
    onFailedAttempt: console.warn,
    retries: options.retries ?? REQUEST_RETRIES
  });
  if (!result.out.ok) {
    throw new Error(`failed ${get7.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out.ok;
}
async function list6({ issuer, with: resource, proofs: proofs2, audience }, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await list5.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? servicePrincipal,
    with: SpaceDID2.from(resource),
    proofs: proofs2,
    nb: input8(options.cursor, options.size, options.pre),
    nonce: options.nonce
  }).execute(conn);
  if (!result.out.ok) {
    throw new Error(`failed ${list5.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out.ok;
}
async function remove6({ issuer, with: resource, proofs: proofs2, audience }, root2, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await remove5.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? servicePrincipal,
    with: SpaceDID2.from(resource),
    nb: input9(root2),
    proofs: proofs2,
    nonce: options.nonce
  }).execute(conn);
  if (!result.out.ok) {
    throw new Error(`failed ${remove5.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out.ok;
}
function decodeVarint2(bytes22, offset22) {
  let v = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset22 >= bytes22.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b = bytes22[offset22++];
    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
    if (b < 128) {
      break;
    }
  }
  return [v, offset22];
}
function decodeBytes(bytes22, offset22) {
  let byteLen;
  [byteLen, offset22] = decodeVarint2(bytes22, offset22);
  const postOffset = offset22 + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes22.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [bytes22.subarray(offset22, postOffset), postOffset];
}
function decodeKey(bytes22, index2) {
  let wire;
  [wire, index2] = decodeVarint2(bytes22, index2);
  return [wire & 7, wire >> 3, index2];
}
function decodeLink(bytes22) {
  const link5 = {};
  const l2 = bytes22.length;
  let index2 = 0;
  while (index2 < l2) {
    let wireType, fieldNum;
    [wireType, fieldNum, index2] = decodeKey(bytes22, index2);
    if (fieldNum === 1) {
      if (link5.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link5.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link5.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      [link5.Hash, index2] = decodeBytes(bytes22, index2);
    } else if (fieldNum === 2) {
      if (link5.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link5.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index2] = decodeBytes(bytes22, index2);
      link5.Name = textDecoder2.decode(byts);
    } else if (fieldNum === 3) {
      if (link5.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      [link5.Tsize, index2] = decodeVarint2(bytes22, index2);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index2 > l2) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link5;
}
function decodeNode(bytes22) {
  const l2 = bytes22.length;
  let index2 = 0;
  let links3 = void 0;
  let linksBeforeData = false;
  let data = void 0;
  while (index2 < l2) {
    let wireType, fieldNum;
    [wireType, fieldNum, index2] = decodeKey(bytes22, index2);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      [data, index2] = decodeBytes(bytes22, index2);
      if (links3) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links3) {
        links3 = [];
      }
      let byts;
      [byts, index2] = decodeBytes(bytes22, index2);
      links3.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index2 > l2) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links3 || [];
  return node;
}
function encodeLink(link5, bytes22) {
  let i = bytes22.length;
  if (typeof link5.Tsize === "number") {
    if (link5.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link5.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i = encodeVarint(bytes22, i, link5.Tsize) - 1;
    bytes22[i] = 24;
  }
  if (typeof link5.Name === "string") {
    const nameBytes = textEncoder2.encode(link5.Name);
    i -= nameBytes.length;
    bytes22.set(nameBytes, i);
    i = encodeVarint(bytes22, i, nameBytes.length) - 1;
    bytes22[i] = 18;
  }
  if (link5.Hash) {
    i -= link5.Hash.length;
    bytes22.set(link5.Hash, i);
    i = encodeVarint(bytes22, i, link5.Hash.length) - 1;
    bytes22[i] = 10;
  }
  return bytes22.length - i;
}
function encodeNode(node) {
  const size5 = sizeNode(node);
  const bytes22 = new Uint8Array(size5);
  let i = size5;
  if (node.Data) {
    i -= node.Data.length;
    bytes22.set(node.Data, i);
    i = encodeVarint(bytes22, i, node.Data.length) - 1;
    bytes22[i] = 10;
  }
  if (node.Links) {
    for (let index2 = node.Links.length - 1; index2 >= 0; index2--) {
      const size6 = encodeLink(node.Links[index2], bytes22.subarray(0, i));
      i -= size6;
      i = encodeVarint(bytes22, i, size6) - 1;
      bytes22[i] = 18;
    }
  }
  return bytes22;
}
function sizeLink(link5) {
  let n2 = 0;
  if (link5.Hash) {
    const l2 = link5.Hash.length;
    n2 += 1 + l2 + sov(l2);
  }
  if (typeof link5.Name === "string") {
    const l2 = textEncoder2.encode(link5.Name).length;
    n2 += 1 + l2 + sov(l2);
  }
  if (typeof link5.Tsize === "number") {
    n2 += 1 + sov(link5.Tsize);
  }
  return n2;
}
function sizeNode(node) {
  let n2 = 0;
  if (node.Data) {
    const l2 = node.Data.length;
    n2 += 1 + l2 + sov(l2);
  }
  if (node.Links) {
    for (const link5 of node.Links) {
      const l2 = sizeLink(link5);
      n2 += 1 + l2 + sov(l2);
    }
  }
  return n2;
}
function encodeVarint(bytes22, offset22, v) {
  offset22 -= sov(v);
  const base42 = offset22;
  while (v >= maxUInt32) {
    bytes22[offset22++] = v & 127 | 128;
    v /= 128;
  }
  while (v >= 128) {
    bytes22[offset22++] = v & 127 | 128;
    v >>>= 7;
  }
  bytes22[offset22] = v;
  return base42;
}
function sov(x) {
  if (x % 2 === 0) {
    x++;
  }
  return Math.floor((len64(x) + 6) / 7);
}
function len64(x) {
  let n2 = 0;
  if (x >= maxInt32) {
    x = Math.floor(x / maxInt32);
    n2 = 32;
  }
  if (x >= 1 << 16) {
    x >>>= 16;
    n2 += 16;
  }
  if (x >= 1 << 8) {
    x >>>= 8;
    n2 += 8;
  }
  return n2 + len8tab[x];
}
function linkComparator(a, b) {
  if (a === b) {
    return 0;
  }
  const abuf = a.Name ? textEncoder3.encode(a.Name) : [];
  const bbuf = b.Name ? textEncoder3.encode(b.Name) : [];
  let x = abuf.length;
  let y = bbuf.length;
  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (abuf[i] !== bbuf[i]) {
      x = abuf[i];
      y = bbuf[i];
      break;
    }
  }
  return x < y ? -1 : y < x ? 1 : 0;
}
function hasOnlyProperties(node, properties) {
  return !Object.keys(node).some((p) => !properties.includes(p));
}
function asLink(link5) {
  if (typeof link5.asCID === "object") {
    const Hash2 = CID.asCID(link5);
    if (!Hash2) {
      throw new TypeError("Invalid DAG-PB form");
    }
    return { Hash: Hash2 };
  }
  if (typeof link5 !== "object" || Array.isArray(link5)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbl = {};
  if (link5.Hash) {
    let cid = CID.asCID(link5.Hash);
    try {
      if (!cid) {
        if (typeof link5.Hash === "string") {
          cid = CID.parse(link5.Hash);
        } else if (link5.Hash instanceof Uint8Array) {
          cid = CID.decode(link5.Hash);
        }
      }
    } catch (e) {
      throw new TypeError(`Invalid DAG-PB form: ${e.message}`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (typeof link5.Name === "string") {
    pbl.Name = link5.Name;
  }
  if (typeof link5.Tsize === "number") {
    pbl.Tsize = link5.Tsize;
  }
  return pbl;
}
function prepare2(node) {
  if (node instanceof Uint8Array || typeof node === "string") {
    node = { Data: node };
  }
  if (typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbn = {};
  if (node.Data !== void 0) {
    if (typeof node.Data === "string") {
      pbn.Data = textEncoder3.encode(node.Data);
    } else if (node.Data instanceof Uint8Array) {
      pbn.Data = node.Data;
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  }
  if (node.Links !== void 0) {
    if (Array.isArray(node.Links)) {
      pbn.Links = node.Links.map(asLink);
      pbn.Links.sort(linkComparator);
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate(node) {
  if (!node || typeof node !== "object" || Array.isArray(node) || node instanceof Uint8Array || node["/"] && node["/"] === node.bytes) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties(node, pbNodeProperties)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be bytes)");
  }
  if (!Array.isArray(node.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be a list)");
  }
  for (let i = 0; i < node.Links.length; i++) {
    const link5 = node.Links[i];
    if (!link5 || typeof link5 !== "object" || Array.isArray(link5) || link5 instanceof Uint8Array || link5["/"] && link5["/"] === link5.bytes) {
      throw new TypeError("Invalid DAG-PB form (bad link)");
    }
    if (!hasOnlyProperties(link5, pbLinkProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link)");
    }
    if (link5.Hash === void 0) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link5.Hash == null || !link5.Hash["/"] || link5.Hash["/"] !== link5.Hash.bytes) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link5.Name !== void 0 && typeof link5.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link5.Tsize !== void 0) {
      if (typeof link5.Tsize !== "number" || link5.Tsize % 1 !== 0) {
        throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
      }
      if (link5.Tsize < 0) {
        throw new TypeError("Invalid DAG-PB form (link Tsize cannot be negative)");
      }
    }
    if (i > 0 && linkComparator(link5, node.Links[i - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
function toByteView3(buf22) {
  if (buf22 instanceof ArrayBuffer) {
    return new Uint8Array(buf22, 0, buf22.byteLength);
  }
  return buf22;
}
function encode28(node) {
  validate(node);
  const pbn = {};
  if (node.Links) {
    pbn.Links = node.Links.map((l2) => {
      const link5 = {};
      if (l2.Hash) {
        link5.Hash = l2.Hash.bytes;
      }
      if (l2.Name !== void 0) {
        link5.Name = l2.Name;
      }
      if (l2.Tsize !== void 0) {
        link5.Tsize = l2.Tsize;
      }
      return link5;
    });
  }
  if (node.Data) {
    pbn.Data = node.Data;
  }
  return encodeNode(pbn);
}
function decode37(bytes22) {
  const buf22 = toByteView3(bytes22);
  const pbn = decodeNode(buf22);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l2) => {
      const link5 = {};
      try {
        link5.Hash = CID.decode(l2.Hash);
      } catch (e) {
      }
      if (!link5.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l2.Name !== void 0) {
        link5.Name = l2.Name;
      }
      if (l2.Tsize !== void 0) {
        link5.Tsize = l2.Tsize;
      }
      return link5;
    });
  }
  return node;
}
function* current() {
  return (
    /** @type {Task.Controller<T, X, M>} */
    yield CURRENT
  );
}
function* wake(task) {
  enqueue(task);
}
function* batch(effects2) {
  const forks = [];
  for (const effect2 of effects2) {
    forks.push(yield* fork(effect2));
  }
  yield* group(forks);
}
function* conclude2(handle, result) {
  try {
    const task = handle;
    const state = result.ok ? task.return(result.value) : task.throw(result.error);
    if (!state.done) {
      if (state.value === SUSPEND) {
        const { idle } = Group.of(task).stack;
        idle.add(task);
      } else {
        enqueue(task);
      }
    }
  } catch (error3) {
  }
}
function* group(forks) {
  if (forks.length === 0) return;
  const self2 = yield* current();
  const group2 = new Group(self2);
  let failure = null;
  for (const fork5 of forks) {
    const { result } = fork5;
    if (result) {
      if (!result.ok && !failure) {
        failure = result;
      }
      continue;
    }
    move(fork5, group2);
  }
  try {
    if (failure) {
      throw failure.error;
    }
    while (true) {
      yield* step(group2);
      if (Stack.size(group2.stack) > 0) {
        yield* suspend();
      } else {
        break;
      }
    }
  } catch (error3) {
    for (const task of group2.stack.active) {
      yield* abort(task, error3);
    }
    for (const task of group2.stack.idle) {
      yield* abort(task, error3);
      enqueue(task);
    }
    throw error3;
  }
}
function* join(fork5) {
  if (fork5.status === IDLE) {
    yield* fork5;
  }
  if (!fork5.result) {
    yield* group([fork5]);
  }
  const result = (
    /** @type {Task.Result<T, X>} */
    fork5.result
  );
  if (result.ok) {
    return result.value;
  } else {
    throw result.error;
  }
}
function Indexed() {
}
function* iterate2(buffer22) {
  for (const part of buffer22.segments) {
    yield* part;
  }
}
function fromNumberTo32BitBuf(number22) {
  const bytes22 = new Array(4);
  for (let i = 0; i < 4; i++) {
    bytes22[i] = number22 & 255;
    number22 = number22 >> 8;
  }
  return new Uint8Array(bytes22);
}
function readonly({ enumerable = true, configurable = false } = {}) {
  return { enumerable, configurable, writable: false };
}
function* linksWithin(path, value) {
  if (value != null && typeof value === "object") {
    if (Array.isArray(value)) {
      for (const [index2, element] of value.entries()) {
        const elementPath = [...path, index2];
        const cid = CID2.asCID(element);
        if (cid) {
          yield [elementPath.join("/"), cid];
        } else if (typeof element === "object") {
          yield* links2(element, elementPath);
        }
      }
    } else {
      const cid = CID2.asCID(value);
      if (cid) {
        yield [path.join("/"), cid];
      } else {
        yield* links2(value, path);
      }
    }
  }
}
function* links2(source, base42) {
  if (source == null || source instanceof Uint8Array) {
    return;
  }
  const cid = CID2.asCID(source);
  if (cid) {
    yield [base42.join("/"), cid];
  }
  for (const [key, value] of Object.entries(source)) {
    const path = (
      /** @type {[string|number, string]} */
      [...base42, key]
    );
    yield* linksWithin(path, value);
  }
}
function* treeWithin(path, value) {
  if (Array.isArray(value)) {
    for (const [index2, element] of value.entries()) {
      const elementPath = [...path, index2];
      yield elementPath.join("/");
      if (typeof element === "object" && !CID2.asCID(element)) {
        yield* tree(element, elementPath);
      }
    }
  } else {
    yield* tree(value, path);
  }
}
function* tree(source, base42) {
  if (source == null || typeof source !== "object") {
    return;
  }
  for (const [key, value] of Object.entries(source)) {
    const path = (
      /** @type {[string|number, string]} */
      [...base42, key]
    );
    yield path.join("/");
    if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID2.asCID(value)) {
      yield* treeWithin(path, value);
    }
  }
}
function get14(source, path) {
  let node = (
    /** @type {Record<string, any>} */
    source
  );
  for (const [index2, key] of path.entries()) {
    node = node[key];
    if (node == null) {
      throw new Error(`Object has no property at ${path.slice(0, index2 + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID2.asCID(node);
    if (cid) {
      return { value: cid, remaining: path.slice(index2 + 1).join("/") };
    }
  }
  return { value: node };
}
async function encodeHAMTShardBlock(shard, settings) {
  const bytes22 = encodeHAMTShard(shard);
  const hash = await settings.hasher.digest(bytes22);
  const cid = settings.linker.createLink(code15, hash);
  return new Block({ cid, bytes: bytes22, value: shard });
}
async function encodeFile2(blob3, options) {
  const readable = createFileEncoderStream(blob3, options);
  const blocks = await collect2(readable);
  return { cid: blocks.at(-1).cid, blocks };
}
function createFileEncoderStream(blob3, options) {
  const { readable, writable } = new TransformStream({}, queuingStrategy);
  const settings = options?.settings ?? defaultSettings;
  const unixfsWriter = createWriter3({ writable, settings });
  const fileBuilder = new UnixFSFileBuilder("", blob3);
  void (async () => {
    await fileBuilder.finalize(unixfsWriter);
    await unixfsWriter.close();
  })();
  return readable;
}
async function encodeDirectory2(files, options) {
  const readable = createDirectoryEncoderStream(files, options);
  const blocks = await collect2(readable);
  return { cid: blocks.at(-1).cid, blocks };
}
function createDirectoryEncoderStream(files, options) {
  const rootDir = new UnixFSDirectoryBuilder("", options);
  for (const file of files) {
    const path = file.name.split("/");
    if (path[0] === "" || path[0] === ".") {
      path.shift();
    }
    let dir = rootDir;
    for (const [i, name142] of path.entries()) {
      if (i === path.length - 1) {
        dir.entries.set(name142, new UnixFSFileBuilder(path.join("/"), file));
        break;
      }
      let dirBuilder = dir.entries.get(name142);
      if (dirBuilder == null) {
        const dirName = dir === rootDir ? name142 : `${dir.name}/${name142}`;
        dirBuilder = new UnixFSDirectoryBuilder(dirName, options);
        dir.entries.set(name142, dirBuilder);
      }
      if (!(dirBuilder instanceof UnixFSDirectoryBuilder)) {
        throw new Error(`"${file.name}" cannot be a file and a directory`);
      }
      dir = dirBuilder;
    }
  }
  const { readable, writable } = new TransformStream({}, queuingStrategy);
  const settings = options?.settings ?? defaultSettings;
  const unixfsWriter = createWriter3({ writable, settings });
  void (async () => {
    const link5 = await rootDir.finalize(unixfsWriter);
    if (options?.onDirectoryEntryLink) {
      options.onDirectoryEntryLink({ name: "", ...link5 });
    }
    await unixfsWriter.close();
  })();
  return readable;
}
async function collect2(collectable) {
  const chunks = [];
  await collectable.pipeTo(new WritableStream({
    write(chunk) {
      chunks.push(chunk);
    }
  }));
  return chunks;
}
async function readHeader2(reader, strictVersion) {
  const length42 = decodeVarint(await reader.upTo(8), reader);
  if (length42 === 0) {
    throw new Error("Invalid CAR header (zero length)");
  }
  const header = await reader.exactly(length42, true);
  const block = decode6(header);
  if (CarV1HeaderOrV2Pragma.toTyped(block) === void 0) {
    throw new Error("Invalid CAR header format");
  }
  if (block.version !== 1 && block.version !== 2 || strictVersion !== void 0 && block.version !== strictVersion) {
    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== void 0 ? ` (expected ${strictVersion})` : ""}`);
  }
  if (block.version === 1) {
    if (!Array.isArray(block.roots)) {
      throw new Error("Invalid CAR header format");
    }
    return block;
  }
  if (block.roots !== void 0) {
    throw new Error("Invalid CAR header format");
  }
  const v2Header = decodeV2Header(await reader.exactly(V2_HEADER_LENGTH, true));
  reader.seek(v2Header.dataOffset - reader.pos);
  const v1Header = await readHeader2(reader, 1);
  return Object.assign(v1Header, v2Header);
}
async function readCid2(reader) {
  const first = await reader.exactly(2, false);
  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {
    const bytes3 = await reader.exactly(34, true);
    const multihash2 = decode5(bytes3);
    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash2);
  }
  const version22 = decodeVarint(await reader.upTo(8), reader);
  if (version22 !== 1) {
    throw new Error(`Unexpected CID version (${version22})`);
  }
  const codec = decodeVarint(await reader.upTo(8), reader);
  const bytes22 = await reader.exactly(getMultihashLength(await reader.upTo(8)), true);
  const multihash = decode5(bytes22);
  return CID.create(version22, codec, multihash);
}
async function readBlockHead2(reader) {
  const start = reader.pos;
  let length42 = decodeVarint(await reader.upTo(8), reader);
  if (length42 === 0) {
    throw new Error("Invalid CAR section (zero length)");
  }
  length42 += reader.pos - start;
  const cid = await readCid2(reader);
  const blockLength2 = length42 - Number(reader.pos - start);
  return { cid, length: length42, blockLength: blockLength2 };
}
async function readBlock(reader) {
  const { cid, blockLength: blockLength2 } = await readBlockHead2(reader);
  const bytes22 = await reader.exactly(blockLength2, true);
  return { bytes: bytes22, cid };
}
async function readBlockIndex(reader) {
  const offset22 = reader.pos;
  const { cid, length: length42, blockLength: blockLength2 } = await readBlockHead2(reader);
  const index2 = { cid, length: length42, blockLength: blockLength2, offset: offset22, blockOffset: reader.pos };
  reader.seek(index2.blockLength);
  return index2;
}
function createDecoder(reader) {
  const headerPromise = (async () => {
    const header = await readHeader2(reader);
    if (header.version === 2) {
      const v1length = reader.pos - header.dataOffset;
      reader = limitReader2(reader, header.dataSize - v1length);
    }
    return header;
  })();
  return {
    header: () => headerPromise,
    async *blocks() {
      await headerPromise;
      while ((await reader.upTo(8)).length > 0) {
        yield await readBlock(reader);
      }
    },
    async *blocksIndex() {
      await headerPromise;
      while ((await reader.upTo(8)).length > 0) {
        yield await readBlockIndex(reader);
      }
    }
  };
}
function bytesReader2(bytes22) {
  let pos = 0;
  return {
    async upTo(length42) {
      const out = bytes22.subarray(pos, pos + Math.min(length42, bytes22.length - pos));
      return out;
    },
    async exactly(length42, seek = false) {
      if (length42 > bytes22.length - pos) {
        throw new Error("Unexpected end of data");
      }
      const out = bytes22.subarray(pos, pos + length42);
      if (seek) {
        pos += length42;
      }
      return out;
    },
    seek(length42) {
      pos += length42;
    },
    get pos() {
      return pos;
    }
  };
}
function chunkReader(readChunk) {
  let pos = 0;
  let have = 0;
  let offset22 = 0;
  let currentChunk = new Uint8Array(0);
  const read92 = async (length42) => {
    have = currentChunk.length - offset22;
    const bufa = [currentChunk.subarray(offset22)];
    while (have < length42) {
      const chunk = await readChunk();
      if (chunk == null) {
        break;
      }
      if (have < 0) {
        if (chunk.length > have) {
          bufa.push(chunk.subarray(-have));
        }
      } else {
        bufa.push(chunk);
      }
      have += chunk.length;
    }
    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));
    let off = 0;
    for (const b of bufa) {
      currentChunk.set(b, off);
      off += b.length;
    }
    offset22 = 0;
  };
  return {
    async upTo(length42) {
      if (currentChunk.length - offset22 < length42) {
        await read92(length42);
      }
      return currentChunk.subarray(offset22, offset22 + Math.min(currentChunk.length - offset22, length42));
    },
    async exactly(length42, seek = false) {
      if (currentChunk.length - offset22 < length42) {
        await read92(length42);
      }
      if (currentChunk.length - offset22 < length42) {
        throw new Error("Unexpected end of data");
      }
      const out = currentChunk.subarray(offset22, offset22 + length42);
      if (seek) {
        pos += length42;
        offset22 += length42;
      }
      return out;
    },
    seek(length42) {
      pos += length42;
      offset22 += length42;
    },
    get pos() {
      return pos;
    }
  };
}
function asyncIterableReader(asyncIterable) {
  const iterator = asyncIterable[Symbol.asyncIterator]();
  async function readChunk() {
    const next = await iterator.next();
    if (next.done) {
      return null;
    }
    return next.value;
  }
  return chunkReader(readChunk);
}
function limitReader2(reader, byteLimit) {
  let bytesRead = 0;
  return {
    async upTo(length42) {
      let bytes22 = await reader.upTo(length42);
      if (bytes22.length + bytesRead > byteLimit) {
        bytes22 = bytes22.subarray(0, byteLimit - bytesRead);
      }
      return bytes22;
    },
    async exactly(length42, seek = false) {
      const bytes22 = await reader.exactly(length42, seek);
      if (bytes22.length + bytesRead > byteLimit) {
        throw new Error("Unexpected end of data");
      }
      if (seek) {
        bytesRead += length42;
      }
      return bytes22;
    },
    seek(length42) {
      bytesRead += length42;
      reader.seek(length42);
    },
    get pos() {
      return reader.pos;
    }
  };
}
async function fromBytes5(bytes22) {
  if (!(bytes22 instanceof Uint8Array)) {
    throw new TypeError("fromBytes() requires a Uint8Array");
  }
  return decodeIterator(bytesReader2(bytes22));
}
async function fromIterable(asyncIterable) {
  if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
    throw new TypeError("fromIterable() requires an async iterable");
  }
  return decodeIterator(asyncIterableReader(asyncIterable));
}
async function decodeIterator(reader) {
  const decoder32 = createDecoder(reader);
  const { version: version22, roots } = await decoder32.header();
  return { version: version22, roots, iterator: decoder32.blocks() };
}
function createHeader(roots) {
  const headerBytes = encode4({ version: CAR_V1_VERSION, roots });
  const varintBytes = import_varint6.default.encode(headerBytes.length);
  const header = new Uint8Array(varintBytes.length + headerBytes.length);
  header.set(varintBytes, 0);
  header.set(headerBytes, varintBytes.length);
  return header;
}
function createEncoder(writer) {
  return {
    /**
     * @param {CID[]} roots
     * @returns {Promise<void>}
     */
    async setRoots(roots) {
      const bytes22 = createHeader(roots);
      await writer.write(bytes22);
    },
    /**
     * @param {Block} block
     * @returns {Promise<void>}
     */
    async writeBlock(block) {
      const { cid, bytes: bytes22 } = block;
      await writer.write(new Uint8Array(import_varint6.default.encode(cid.bytes.length + bytes22.length)));
      await writer.write(cid.bytes);
      if (bytes22.length) {
        await writer.write(bytes22);
      }
    },
    /**
     * @returns {Promise<void>}
     */
    async close() {
      await writer.end();
    },
    /**
     * @returns {number}
     */
    version() {
      return CAR_V1_VERSION;
    }
  };
}
function noop() {
}
function create16() {
  const chunkQueue = [];
  let drainer = null;
  let drainerResolver = noop;
  let ended = false;
  let outWait = null;
  let outWaitResolver = noop;
  const makeDrainer = () => {
    if (!drainer) {
      drainer = new Promise((resolve2) => {
        drainerResolver = () => {
          drainer = null;
          drainerResolver = noop;
          resolve2();
        };
      });
    }
    return drainer;
  };
  const writer = {
    /**
     * @param {T} chunk
     * @returns {Promise<void>}
     */
    write(chunk) {
      chunkQueue.push(chunk);
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    },
    async end() {
      ended = true;
      const drainer2 = makeDrainer();
      outWaitResolver();
      await drainer2;
    }
  };
  const iterator = {
    /** @returns {Promise<IteratorResult<T>>} */
    async next() {
      const chunk = chunkQueue.shift();
      if (chunk) {
        if (chunkQueue.length === 0) {
          drainerResolver();
        }
        return { done: false, value: chunk };
      }
      if (ended) {
        drainerResolver();
        return { done: true, value: void 0 };
      }
      if (!outWait) {
        outWait = new Promise((resolve2) => {
          outWaitResolver = () => {
            outWait = null;
            outWaitResolver = noop;
            return resolve2(iterator.next());
          };
        });
      }
      return outWait;
    }
  };
  return { writer, iterator };
}
function encodeWriter() {
  const iw = create16();
  const { writer, iterator } = iw;
  const encoder32 = createEncoder(writer);
  return { encoder: encoder32, iterator };
}
function toRoots(roots) {
  if (roots === void 0) {
    return [];
  }
  if (!Array.isArray(roots)) {
    const cid = CID.asCID(roots);
    if (!cid) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    return [cid];
  }
  const _roots = [];
  for (const root2 of roots) {
    const _root = CID.asCID(root2);
    if (!_root) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    _roots.push(_root);
  }
  return _roots;
}
function headerEncodingLength(root2) {
  if (!root2)
    return NO_ROOTS_HEADER_LENGTH;
  const headerLength2 = encode4({ version: 1, roots: [root2] }).length;
  const varintLength = import_varint7.default.encodingLength(headerLength2);
  return varintLength + headerLength2;
}
function blockHeaderEncodingLength(block) {
  const payloadLength = block.cid.bytes.length + block.bytes.length;
  const varintLength = import_varint7.default.encodingLength(payloadLength);
  return varintLength + block.cid.bytes.length;
}
function blockEncodingLength(block) {
  return blockHeaderEncodingLength(block) + block.bytes.length;
}
async function encode30(blocks, root2) {
  const { writer, out } = CarWriter.create(root2);
  let error3;
  void (async () => {
    try {
      for await (const block of blocks) {
        await writer.put(block);
      }
    } catch (err) {
      error3 = err;
    } finally {
      await writer.close();
    }
  })();
  const chunks = [];
  for await (const chunk of out)
    chunks.push(chunk);
  if (error3 != null)
    throw error3;
  const roots = root2 != null ? [root2] : [];
  return Object.assign(new Blob(chunks), { version: 1, roots });
}
function toIterable(stream4) {
  return Symbol.asyncIterator in stream4 ? stream4 : async function* () {
    const reader = stream4.getReader();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          return;
        yield value;
      }
    } finally {
      reader.releaseLock();
    }
  }();
}
function alloc2(size5 = 0) {
  return new Uint8Array(size5);
}
function allocUnsafe(size5 = 0) {
  return new Uint8Array(size5);
}
function asUint8Array2(buf22) {
  return buf22;
}
function compare2(a, b) {
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] < b[i]) {
      return -1;
    }
    if (a[i] > b[i]) {
      return 1;
    }
  }
  if (a.byteLength > b.byteLength) {
    return 1;
  }
  if (a.byteLength < b.byteLength) {
    return -1;
  }
  return 0;
}
function concat2(arrays, length42) {
  if (length42 == null) {
    length42 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output2 = allocUnsafe(length42);
  let offset22 = 0;
  for (const arr of arrays) {
    output2.set(arr, offset22);
    offset22 += arr.length;
  }
  return asUint8Array2(output2);
}
function encode31(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
function decode39(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
function digest4(input10) {
  return create(code18, encode32(input10));
}
function sha3(name142) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name142, data));
}
function createCodec(name142, prefix2, encode342, decode412) {
  return {
    name: name142,
    prefix: prefix2,
    encoder: {
      name: name142,
      prefix: prefix2,
      encode: encode342
    },
    decoder: {
      decode: decode412
    }
  };
}
function createLegacy2(digest52) {
  return CID.create(0, DAG_PB_CODE5, digest52);
}
function create17(code192, digest52) {
  return CID.create(1, code192, digest52);
}
function findBufAndOffset(bufs, index2) {
  if (index2 == null || index2 < 0) {
    throw new RangeError("index is out of bounds");
  }
  let offset22 = 0;
  for (const buf22 of bufs) {
    const bufEnd = offset22 + buf22.byteLength;
    if (index2 < bufEnd) {
      return {
        buf: buf22,
        index: index2 - offset22
      };
    }
    offset22 = bufEnd;
  }
  throw new RangeError("index is out of bounds");
}
function isUint8ArrayList(value) {
  return Boolean(value?.[symbol]);
}
async function indexShardedDAG(root2, shards, shardIndexes) {
  const index2 = create18(root2);
  for (const [i, shard] of shards.entries()) {
    const slices = shardIndexes[i];
    index2.shards.set(shard.multihash, slices);
  }
  return await index2.archive();
}
function ascending(a, b, getComparedValue) {
  const ask = getComparedValue(a);
  const bsk = getComparedValue(b);
  if (ask === bsk)
    return 0;
  else if (ask < bsk)
    return -1;
  return 1;
}
async function uploadFile(conf, file, options = {}) {
  return await uploadBlockStream(conf, createFileEncoderStream(file, options), options);
}
async function uploadDirectory(conf, files, options = {}) {
  const { customOrder = false } = options;
  const entries3 = customOrder ? files : [...files].sort(defaultFileComparator);
  return await uploadBlockStream(conf, createDirectoryEncoderStream(entries3, options), options);
}
async function uploadCAR(conf, car, options = {}) {
  const blocks = new BlockStream(car);
  options.rootCID = options.rootCID ?? (await blocks.getRoots())[0];
  return await uploadBlockStream(conf, blocks, options);
}
async function uploadBlockStream(conf, blocks, { pieceHasher = multihash_exports, ...options } = {}) {
  const configure62 = typeof conf === "function" ? conf : () => conf;
  const shardIndexes = [];
  const shards = [];
  let root2 = null;
  await blocks.pipeThrough(new ShardingStream(options)).pipeThrough(
    /** @type {TransformStream<import('./types.js').IndexedCARFile, import('./types.js').CARMetadata>} */
    new TransformStream({
      async transform(car, controller) {
        const bytes22 = new Uint8Array(await car.arrayBuffer());
        const digest52 = await sha2563.digest(bytes22);
        const conf2 = await configure62([
          {
            can: ability,
            nb: input(digest52, bytes22.length)
          }
        ]);
        await add4(conf2, digest52, bytes22, options);
        const cid = create10(code17, digest52);
        let piece;
        if (pieceHasher) {
          const multihashDigest = await pieceHasher.digest(bytes22);
          piece = create10(code10, multihashDigest);
          const content2 = create10(code10, digest52);
          const result = await storefront_exports.filecoinOffer({
            issuer: conf2.issuer,
            audience: conf2.audience,
            // Resource of invocation is the issuer did for being self issued
            with: conf2.issuer.did(),
            proofs: conf2.proofs
          }, content2, piece, options);
          if (result.out.error) {
            throw new Error("failed to offer piece for aggregation into filecoin deal", { cause: result.out.error });
          }
        }
        const { version: version22, roots, size: size5, slices } = car;
        controller.enqueue({ version: version22, roots, size: size5, cid, piece, slices });
      }
    })
  ).pipeTo(new WritableStream({
    write(meta) {
      root2 = root2 || meta.roots[0];
      shards.push(meta.cid);
      meta.slices.set(meta.cid.multihash, [0, meta.size]);
      shardIndexes.push(meta.slices);
      if (options.onShardStored)
        options.onShardStored(meta);
    }
  }));
  if (!root2)
    throw new Error("missing root CID");
  const indexBytes = await indexShardedDAG(root2, shards, shardIndexes);
  if (!indexBytes.ok) {
    throw new Error("failed to archive DAG index", { cause: indexBytes.error });
  }
  const indexDigest = await sha2563.digest(indexBytes.ok);
  const indexLink = create10(code17, indexDigest);
  const [blobAddConf, indexAddConf, uploadAddConf] = await Promise.all([
    configure62([
      {
        can: ability,
        nb: input(indexDigest, indexBytes.ok.length)
      }
    ]),
    configure62([
      {
        can: ability5,
        nb: input5(indexLink)
      }
    ]),
    configure62([
      {
        can: ability6,
        nb: input6(root2, shards)
      }
    ])
  ]);
  await add4(blobAddConf, indexDigest, indexBytes.ok, options);
  await add6(indexAddConf, indexLink, options);
  await add8(uploadAddConf, root2, shards, options);
  return root2;
}
var require_retry_operation, require_retry, require_retry2, require_longbits, require_minimal, require_writer, require_writer_buffer, require_reader, require_reader_buffer, require_service, require_rpc, require_roots, require_index_minimal, require_minimal2, require_murmurHash3js, require_murmurhash3js_revisited, multihash_exports, BITS_PER_BYTE, FRS_PER_QUAD, LEAFS_PER_QUAD, IN_BITS_FR, OUT_BITS_FR, IN_BYTES_PER_QUAD, OUT_BYTES_PER_QUAD, PADDED_BYTES_PER_QUAD, EXPANDED_BYTES_PER_QUAD, BYTES_PER_FR, FR_RATIO, NODE_SIZE, EXPANDED_BYTES_PER_NODE, MIN_PAYLOAD_SIZE, from, empty, EMPTY, empty2, equals, coerce, sha256_exports, name, code, size, prefix, Digest, digest, code2, typeofs, objectTypeNames, Type, Token, useBuffer, textDecoder, textEncoder, toString, fromString, fromArray, slice, concat, alloc, MAX_ARGUMENTS_LENGTH, defaultChunkSize, Bl, decodeErrPrefix, encodeErrPrefix, uintMinorPrefixBytes, uintBoundaries, neg1b, pos1b, encodeString, MINOR_FALSE, MINOR_TRUE, MINOR_NULL, MINOR_UNDEFINED, buffer, dataView, ui8a, jump, quick, defaultEncodeOptions, cborEncoders, buf, Ref, simpleTokens, typeEncoders, defaultDecodeOptions, Tokeniser, DONE, BREAK, base32_exports, bytes_exports2, empty3, src, _brrp__multiformats_scope_baseX, base_x_default, Encoder, Decoder, ComposedDecoder, Codec, base32, base32upper, base32pad, base32padupper, base32hex, base32hexupper, base32hexpad, base32hexpadupper, base32z, base58_exports, base58btc, base58flickr, encode_1, MSB, REST, MSBALL, INT, decode3, MSB$1, REST$1, N1, N2, N3, N4, N5, N6, N7, N8, N9, length, varint, _brrp_varint, varint_default, Digest2, cache, _a, CID, DAG_PB_CODE, SHA_256_CODE, cidSymbol, CID_CBOR_TAG, _encodeOptions, encodeOptions, _decodeOptions, decodeOptions, name2, code3, encode4, decode6, varint_exports2, encode_12, MSB2, REST2, MSBALL2, INT2, decode7, MSB$12, REST$12, N12, N22, N32, N42, N52, N62, N72, N82, N92, length2, varint2, _brrp_varint2, varint_default2, decode8, encodeTo2, encodingLength2, create2, decode9, equals4, Digest3, src2, _brrp__multiformats_scope_baseX2, base_x_default2, Encoder2, Decoder2, ComposedDecoder2, or2, Codec2, from3, baseX2, decode10, encode6, rfc46482, base58btc2, base58flickr2, base322, base32upper2, base32pad2, base32padupper2, base32hex2, base32hexupper2, base32hexpad2, base32hexpadupper2, base32z2, format2, cache2, baseCache2, CID2, parseCIDtoBytes2, toStringV02, toStringV12, DAG_PB_CODE2, SHA_256_CODE2, encodeCID2, cidSymbol2, DAG_PB_CODE3, createLegacy, create3, isLink, parse, computeNode, MAX_LEVEL, ZeroComm, ZERO_COMM, fromLevel, MAX_LEAF_COUNT, split, toPieceSize, pad, log2Floor, log2Ceil, fromHeight, unpadded_exports, fromPiece, toPadding, toPadded, toExpanded, toWidth, toHeight, toQauds, fromHeight2, fromWidth, digest_exports3, from4, Hasher, name3, code4, MAX_PADDING_SIZE, HEIGHT_SIZE, ROOT_SIZE, MAX_DIGEST_SIZE, TAG_SIZE, MAX_SIZE, MAX_HEIGHT, MAX_PAYLOAD_SIZE, fromPiece2, fromBytes, toBytes2, height, padding, root, Digest4, name4, code5, MAX_HEIGHT2, MAX_PAYLOAD_SIZE2, digest2, create4, Hasher2, prune, build, flush, storefront_exports, delegation_exports, encoder, decoder, encode7, decode11, code6, name5, encode8, digest3, identity, DID_PREFIX, DID_PREFIX_SIZE, DID_KEY_PREFIX, DID_KEY_PREFIX_SIZE, ED25519, RSA, P256, P384, P521, SECP256K1, BLS12381G1, BLS12381G2, DID_CORE, METHOD_OFFSET, parse2, format3, from5, decode12, encode9, DID, DIDKey, code7, signature_exports, base64, base64pad, base64url, base64urlpad, NON_STANDARD, ES256K, BLS12381G12, BLS12381G22, EdDSA, ES256, ES384, ES512, RS256, EIP191, codeName, nameCode, Signature, algorithm, size2, create5, createNamed, createNonStandard, view, decode13, encode10, format4, parse3, toJSON2, fromJSON2, readPayload, readJWTPayload, readPayloadWith, readSignature, readInt, readCapability, readCapabilities, asCapability, readAbility, readResource, parseURL, readArray, readOptionalArray, readStruct, readFact, readProof, readStringProof, parseProof, readPrincipal, readStringPrincipal, readOptional, readNullable, readString, readBytes, readVersion, readLiteral, ParseError, fail, JSONEncoder, defaultEncodeOptions2, Tokenizer, Hasher3, base64_exports, base642, base64pad2, base64url2, base64urlpad2, encodeOptions2, DagJsonTokenizer, decodeOptions2, encode12, decode15, utf8Decoder, utf8Encoder, format5, formatSignPayload, formatHeader, formatPayload, formatSignature, encodeHeader, encodePayload, encodeProof, toJSON3, View, code8, from7, encode13, encodeSignature, decode16, CBORView, parse4, parseHeader, parsePayload, decode17, encode14, format6, JWTView, sha, sha2562, sha512, VERSION, defaultHasher, decode18, write, issue, encodeSignaturePayload, now, cbor_exports3, contentType, prepare, encode15, link, write2, iterate, createStore, EMBED_CODE, get, notFound, writeInto, addInto, addEveryInto, car_exports, import_varint3, CIDV0_BYTES, V2_HEADER_LENGTH, Kinds, Types, Reprs, CarV1HeaderOrV2Pragma, CarBufferReader, cborEncoders2, defaultEncodeOptions3, import_varint4, CarBufferWriter, addRoot, blockLength, addBlock, close, resizeHeader, writeBytes, writeHeader, headerPreludeTokens, CID_TAG, calculateHeaderLength, headerLength, createWriter, contentType2, name6, code9, Writer, createWriter2, encode16, decode19, link2, write3, schema_exports3, uri_exports, ok, error, panic, fail2, Failure, API, Never, never, Unknown, unknown, Nullable, nullable, Optional, Default, optional, ArrayOf, array, Tuple, tuple, Dictionary, dictionary, Enum, createEnum, Union, union, or3, Intersection, intersection, and, Boolean2, anyBoolean, boolean, UnknownNumber, AnyNumber, anyNumber, number2, RefinedNumber, LessThan, lessThan, GreaterThan, greaterThan, Integer, anyInteger, integer, MAX_UINT64, Uint64Schema, Uint64, uint64, Float, anyFloat, float, UnknownString, RefinedString, AnyString, anyString, string, BytesSchema, Bytes, bytes2, StartsWith, startsWith, EndsWith, endsWith, Refine, refine, Literal, literal, Struct, struct, Variant, variant, error2, SchemaError, TypeError2, typeError, toString3, LiteralError, ElementError, FieldError, memberError, UnionError, IntersectionError, indent, li, URISchema, schema, uri, read3, match, from9, link_exports2, LinkSchema, schema2, link3, match2, read4, optional2, did_exports2, DIDSchema, schema3, did, read5, match3, from10, text_exports, schema4, match4, text, read6, Match, isLink2, isDelegation, allows, iterateCapabilities, matchAbility, Delegation, archive, ArchiveSchema, extract, it, decodeCache, decode20, delegate, exportDAG, exportSubDAG, importDAG, create6, view2, proofs, invocation_exports, isInvocation, invoke, create7, view3, IssuedInvocation, Invocation, message_exports, receipt_exports, view4, Receipt, ReceptBuilder, NOFX, issue2, MessageSchema, build2, view5, MessageBuilder, writeInvocations, writeReceipts, Message, connect, Connection, execute, delegate2, car_exports2, request_exports, contentType3, HEADERS, encode17, decode22, response_exports, contentType4, HEADERS2, encode18, decode23, inbound, Inbound, outbound, Outbound, parseMediaType, formatMediaType, parseAcceptHeader, formatAcceptHeader, contentType5, inbound2, outbound2, http_exports, open, Channel, HTTPError, encoder2, decoder2, response_exports2, contentType6, HEADERS3, encode19, request_exports2, contentType7, decode24, contentType8, inbound3, the, entries, combine, intersection2, EscalatedCapability, DelegationError, MalformedCapability, UnknownCapability, format7, indent2, li2, capability, defaultNBSchema, or4, and2, derive, View2, Unit, Capability, createCapability, isEmpty, Or, And, Derive, Match2, DerivedMatch, AndMatch, resolveAbility, resolveResource, parseCapability, resolveCapability, CapabilityView, select, selectGroup, defaultDerives, FR32_SHA2_256_TRUNC254_PADDED_BINARY_TREE, RAW_CODE, PieceLink, ProviderDID, SpaceDID, AccountDID, Await, checkLink, and3, filecoinOffer, filecoinSubmit, filecoinAccept, filecoinInfo, services, connection, pieceOffer, pieceAccept, connection2, aggregateOffer, aggregateAccept, connection3, dealInfo, connection4, src3, _brrp__multiformats_scope_baseX3, base_x_default3, empty4, equals6, coerce3, Encoder3, Decoder3, ComposedDecoder3, or5, Codec3, from11, baseX3, decode25, encode20, rfc46483, base323, base32upper3, base32pad3, base32padupper3, base32hex3, base32hexupper3, base32hexpad3, base32hexpadupper3, base32z3, base58btc3, base58flickr3, encode_13, MSB3, REST3, MSBALL3, INT3, decode26, MSB$13, REST$13, N13, N23, N33, N43, N53, N63, N73, N83, N93, length3, varint5, _brrp_varint3, varint_default3, decode27, encodeTo3, encodingLength3, create9, decode28, equals7, Digest5, format8, cache3, baseCache3, CID3, parseCIDtoBytes3, toStringV03, toStringV13, DAG_PB_CODE4, SHA_256_CODE3, encodeCID3, cidSymbol3, create10, raw_exports2, name7, code10, encode22, decode29, from12, Hasher4, sha2, sha2563, sha5122, store_exports, ProviderDID2, SpaceDID2, AccountDID2, Await2, equalLink, equalBlob, equalBody, checkLink2, and4, code11, CARLink, store, add, get2, remove, list, all, import_retry, networkErrorMsgs, AbortError, decorateErrorWithCounts, isNetworkError, getDOMException, serviceURL, servicePrincipal, receiptsEndpoint, connection5, REQUEST_RETRIES, blob_exports3, ed25519_exports, signer_exports, _0n, _1n, _2n, _8n, CU_O, CURVE, POW_2_256, SQRT_M1, SQRT_D, SQRT_AD_MINUS_ONE, INVSQRT_A_MINUS_D, ONE_MINUS_D_SQ, D_MINUS_ONE_SQ, ExtendedPoint, RistrettoPoint, pointPrecomputes, Point, Signature2, hexes, MAX_255B, _sha512Sync, crypto2, utils, verifier_exports, parseWith, or6, Parser, withDID, VerifierWithDID, code12, name8, signatureCode, signatureAlgorithm, PUBLIC_TAG_SIZE, SIZE, parse5, decode30, format9, encode23, Ed25519Verifier, or7, or8, Importer, create11, importWith, withDID2, SignerWithDID, code13, name9, signatureAlgorithm2, signatureCode2, PRIVATE_TAG_SIZE, PUBLIC_TAG_SIZE2, KEY_SIZE, SIZE2, PUB_KEY_OFFSET, generate, derive2, from13, or9, decode31, encode24, format10, parse6, Ed25519Signer, rsa_exports, _globalReference, webcrypto, tagWith, untagWith, encodingLength4, encodeTo4, decode32, TAG_SIZE2, INT_TAG, BITSTRING_TAG, OCTET_STRING_TAG, SEQUENCE_TAG, UNUSED_BIT_PAD, encodeDERLength, readDERLength, skip, into, encodeBitString, encodeOctetString, encodeSequence, readSequence, encodeInt, enterSequence, skipSequence, skipInt, readBitString, readInt2, readOctetString, readSequenceWith, SPKI_PARAMS_ENCODED, encode25, decode33, PKSC8_HEADER, decode34, encode26, encode27, VERSION2, decode35, name10, code14, verifierCode, signatureCode3, signatureAlgorithm3, ALG, HASH_ALG, KEY_SIZE2, SALT_LENGTH, IMPORT_PARAMS, generate2, from14, or10, decode36, RSAVerifier, RSASigner, ExtractableRSASigner, UnextractableRSASigner, Verifier, Signer, UCANLink, ucan, revoke, conclude, attest, blob, content, add3, remove3, list3, get4, blob2, allocate, accept, put, receipts_exports, ReceiptNotFound, ReceiptMissing, ability, input, ability2, input2, ability3, input3, ability4, input4, index_exports2, index, add5, ability5, input5, upload_exports2, upload, CARLink2, add7, get7, remove5, list5, all2, ability6, input6, ability7, input7, ability8, input8, ability9, input9, unixfs_exports3, codec_exports2, textDecoder2, textEncoder2, maxInt32, maxUInt32, len8tab, pbNodeProperties, pbLinkProperties, textEncoder3, code15, import_minimal, $Reader, $Writer, $util, $root, Data, UnixTime, Metadata, NodeType, EMPTY2, EMPTY_BUFFER, BLANK, DEFAULT_FILE_MODE, DEFAULT_DIRECTORY_MODE, code16, name11, encodePB, createRaw, createEmptyFile, createSimpleFile, createFileChunk, createAdvancedFile, createFileShard, createComplexFile, createFlatDirectory, createShardedDirectory, createDirectoryShard, encodeRaw, encodeFile, encodeFileChunk, encodeFileShard, encodeAdvancedFile, encodeLink2, encodeSimpleFile, encodeComplexFile, encodeDirectory, encodeHAMTShard, readFanout, readInt3, createSymlink, encodeSymlink, encode29, decode38, decodeMtime, decodeFileLinks, decodeDirectoryLinks, cumulativeContentByteLength, cumulativeDagByteLength, contentByteLength, encodeNamedLink, encodeDirectoryMetadata, encodeMetadata, decodeMetadata, encodeMTime, encodeMode, decodeMode, matchFile, SimpleFileView, AdvancedFileView, ComplexFileView, filesize, effect, suspend, wait, isAsync, send, listen, effects, tag, Tagger, none, withTag, CURRENT, SUSPEND, Group, Main, Stack, main, enqueue, resume, step, fork, exit, abort, move, Future, Fork, loop, ID, IDLE, ACTIVE, FINISHED, INIT, BLANK2, NONE, MAIN, empty5, slice2, push, get9, copyTo, BufferView, panic2, unreachable, EMPTY_BUFFER2, EMPTY3, open2, write4, close2, split2, mutable, addNodes, addLink, patch, assign, patchDict, append, collect, EMPTY4, BLANK3, update, init, write5, link4, close3, encodeLeaves, encodeLeaf, encodeBranches, encodeBranch, writeBlock, asUint8Array, isLeafNode, fixed_exports, name12, context, type, withMaxChunkSize, cut, Node, withWidth, defaults, open3, write6, flush2, close4, grow, EMPTY5, defaults2, configure, UnixFSLeaf, create12, write7, close5, perform, FileWriterView, defaults3, create13, set, remove7, asWritable, close6, links, fork2, DirectoryWriter, Uint32_exports, api_exports2, empty6, from15, size3, mask, offset, popcount, set2, unset, get10, bitCount, and5, or11, toBytes22, fromBytes3, import_murmurhash3js_revisited, utf8, hash32, configure2, BitmapIndexedNode, HashCollisionNode, lookupCollision, associateCollision, dissociateCollision, forkCollision, findHashCollisionNodeIndex, create14, get11, lookup, set3, associate, remove8, dissociate, entries2, fork3, keys, values, forkAndSet, inlineChild, copyAndSetChild, migrateLeafToBranch, mergeTwoLeaves, keyAt, keyPosition, valueAt, valuePosition, resolveNode, nodePosition, canEdit, hasSingleLeaf, hasSingleNode, import_murmurhash3js_revisited2, murmur332, murmur3128, murmur364, utf82, hash64, configure3, toInt, Uint8Array_exports, empty7, from16, size4, at, setByte, set4, unset2, get12, toBytes3, fromBytes4, popcount2, or12, and6, NOT_FOUND, configure4, from17, has, get13, builder, PersistentHashMap, HashMapBuilder, utf83, hash642, configure5, read8, appendByte, bitWidth, config, tableSize, builder2, from18, bitField, withoutLeadingZeros, iterate3, Block, defaults4, create15, asWritable2, close7, iterateBlocks, fork4, HAMTDirectoryWriter, HashMap, createWriter3, close8, FileSystemWriter, BLOCK_SIZE_LIMIT, defaultCapacity, withCapacity, SHARD_THRESHOLD, queuingStrategy, defaultSettings, _file, UnixFSFileBuilder, _options, UnixFSDirectoryBuilder, car_exports3, CarIteratorBase, CarBlockIterator, import_varint6, CAR_V1_VERSION, CarWriter, CarWriterOut, import_varint7, code17, NO_ROOTS_HEADER_LENGTH, BlockStream, base10_exports, base10, base16_exports, base16, base16upper, base2_exports, base22, base256emoji_exports, alphabet, alphabetBytesToChars, alphabetCharsToBytes, base256emoji, base36_exports, base36, base36upper, base8_exports, base8, identity_exports, identity2, textEncoder4, textDecoder3, identity_exports2, code18, name13, encode32, identity3, sha2_browser_exports, sha2564, sha5123, bases, hashes, string2, ascii, BASES, DAG_PB_CODE5, cache4, toBase58String, _data, DigestMap, version, ShardedDAGIndexSchema, MultihashSchema, BlobIndexSchema, _content, _shards, ShardedDAGIndex, create18, archive2, symbol, _a2, Uint8ArrayList, MSB4, REST4, MSBALL4, INT4, encode33, decode40, State, CIDV0_BYTES2, _headerPromise, CARReaderStream, getMultihashLength2, encodeHeader2, encodeBlock, CARWriterStream, SHARD_SIZE, ShardingStream, defaultFileComparator, encodeCAR;
var init_chunk_BOSPY7YV = __esm({
  "node_modules/@fleek-platform/sdk/dist/browser/chunk-BOSPY7YV.js"() {
    init_process_shim();
    init_chunk_UHP4SR3D();
    init_chunk_77WUQNS7();
    init_chunk_DNE4QC7K();
    init_sha256();
    require_retry_operation = __commonJS2({
      "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js"(exports2, module2) {
        function RetryOperation(timeouts, options) {
          if (typeof options === "boolean") {
            options = { forever: options };
          }
          this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
          this._timeouts = timeouts;
          this._options = options || {};
          this._maxRetryTime = options && options.maxRetryTime || Infinity;
          this._fn = null;
          this._errors = [];
          this._attempts = 1;
          this._operationTimeout = null;
          this._operationTimeoutCb = null;
          this._timeout = null;
          this._operationStart = null;
          this._timer = null;
          if (this._options.forever) {
            this._cachedTimeouts = this._timeouts.slice(0);
          }
        }
        module2.exports = RetryOperation;
        RetryOperation.prototype.reset = function() {
          this._attempts = 1;
          this._timeouts = this._originalTimeouts.slice(0);
        };
        RetryOperation.prototype.stop = function() {
          if (this._timeout) {
            clearTimeout(this._timeout);
          }
          if (this._timer) {
            clearTimeout(this._timer);
          }
          this._timeouts = [];
          this._cachedTimeouts = null;
        };
        RetryOperation.prototype.retry = function(err) {
          if (this._timeout) {
            clearTimeout(this._timeout);
          }
          if (!err) {
            return false;
          }
          var currentTime = (/* @__PURE__ */ new Date()).getTime();
          if (err && currentTime - this._operationStart >= this._maxRetryTime) {
            this._errors.push(err);
            this._errors.unshift(new Error("RetryOperation timeout occurred"));
            return false;
          }
          this._errors.push(err);
          var timeout = this._timeouts.shift();
          if (timeout === void 0) {
            if (this._cachedTimeouts) {
              this._errors.splice(0, this._errors.length - 1);
              timeout = this._cachedTimeouts.slice(-1);
            } else {
              return false;
            }
          }
          var self2 = this;
          this._timer = setTimeout(function() {
            self2._attempts++;
            if (self2._operationTimeoutCb) {
              self2._timeout = setTimeout(function() {
                self2._operationTimeoutCb(self2._attempts);
              }, self2._operationTimeout);
              if (self2._options.unref) {
                self2._timeout.unref();
              }
            }
            self2._fn(self2._attempts);
          }, timeout);
          if (this._options.unref) {
            this._timer.unref();
          }
          return true;
        };
        RetryOperation.prototype.attempt = function(fn, timeoutOps) {
          this._fn = fn;
          if (timeoutOps) {
            if (timeoutOps.timeout) {
              this._operationTimeout = timeoutOps.timeout;
            }
            if (timeoutOps.cb) {
              this._operationTimeoutCb = timeoutOps.cb;
            }
          }
          var self2 = this;
          if (this._operationTimeoutCb) {
            this._timeout = setTimeout(function() {
              self2._operationTimeoutCb();
            }, self2._operationTimeout);
          }
          this._operationStart = (/* @__PURE__ */ new Date()).getTime();
          this._fn(this._attempts);
        };
        RetryOperation.prototype.try = function(fn) {
          console.log("Using RetryOperation.try() is deprecated");
          this.attempt(fn);
        };
        RetryOperation.prototype.start = function(fn) {
          console.log("Using RetryOperation.start() is deprecated");
          this.attempt(fn);
        };
        RetryOperation.prototype.start = RetryOperation.prototype.try;
        RetryOperation.prototype.errors = function() {
          return this._errors;
        };
        RetryOperation.prototype.attempts = function() {
          return this._attempts;
        };
        RetryOperation.prototype.mainError = function() {
          if (this._errors.length === 0) {
            return null;
          }
          var counts = {};
          var mainError = null;
          var mainErrorCount = 0;
          for (var i = 0; i < this._errors.length; i++) {
            var error3 = this._errors[i];
            var message2 = error3.message;
            var count = (counts[message2] || 0) + 1;
            counts[message2] = count;
            if (count >= mainErrorCount) {
              mainError = error3;
              mainErrorCount = count;
            }
          }
          return mainError;
        };
      }
    });
    require_retry = __commonJS2({
      "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js"(exports2) {
        var RetryOperation = require_retry_operation();
        exports2.operation = function(options) {
          var timeouts = exports2.timeouts(options);
          return new RetryOperation(timeouts, {
            forever: options && (options.forever || options.retries === Infinity),
            unref: options && options.unref,
            maxRetryTime: options && options.maxRetryTime
          });
        };
        exports2.timeouts = function(options) {
          if (options instanceof Array) {
            return [].concat(options);
          }
          var opts = {
            retries: 10,
            factor: 2,
            minTimeout: 1 * 1e3,
            maxTimeout: Infinity,
            randomize: false
          };
          for (var key in options) {
            opts[key] = options[key];
          }
          if (opts.minTimeout > opts.maxTimeout) {
            throw new Error("minTimeout is greater than maxTimeout");
          }
          var timeouts = [];
          for (var i = 0; i < opts.retries; i++) {
            timeouts.push(this.createTimeout(i, opts));
          }
          if (options && options.forever && !timeouts.length) {
            timeouts.push(this.createTimeout(i, opts));
          }
          timeouts.sort(function(a, b) {
            return a - b;
          });
          return timeouts;
        };
        exports2.createTimeout = function(attempt, opts) {
          var random2 = opts.randomize ? Math.random() + 1 : 1;
          var timeout = Math.round(random2 * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
          timeout = Math.min(timeout, opts.maxTimeout);
          return timeout;
        };
        exports2.wrap = function(obj, options, methods) {
          if (options instanceof Array) {
            methods = options;
            options = null;
          }
          if (!methods) {
            methods = [];
            for (var key in obj) {
              if (typeof obj[key] === "function") {
                methods.push(key);
              }
            }
          }
          for (var i = 0; i < methods.length; i++) {
            var method = methods[i];
            var original = obj[method];
            obj[method] = function retryWrapper(original2) {
              var op = exports2.operation(options);
              var args = Array.prototype.slice.call(arguments, 1);
              var callback = args.pop();
              args.push(function(err) {
                if (op.retry(err)) {
                  return;
                }
                if (err) {
                  arguments[0] = op.mainError();
                }
                callback.apply(this, arguments);
              });
              op.attempt(function() {
                original2.apply(obj, args);
              });
            }.bind(obj, original);
            obj[method].options = options;
          }
        };
      }
    });
    require_retry2 = __commonJS2({
      "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js"(exports2, module2) {
        module2.exports = require_retry();
      }
    });
    require_longbits = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
        "use strict";
        module2.exports = LongBits;
        var util2 = require_minimal();
        function LongBits(lo, hi) {
          this.lo = lo >>> 0;
          this.hi = hi >>> 0;
        }
        var zero = LongBits.zero = new LongBits(0, 0);
        zero.toNumber = function() {
          return 0;
        };
        zero.zzEncode = zero.zzDecode = function() {
          return this;
        };
        zero.length = function() {
          return 1;
        };
        var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
        LongBits.fromNumber = function fromNumber(value) {
          if (value === 0)
            return zero;
          var sign22 = value < 0;
          if (sign22)
            value = -value;
          var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
          if (sign22) {
            hi = ~hi >>> 0;
            lo = ~lo >>> 0;
            if (++lo > 4294967295) {
              lo = 0;
              if (++hi > 4294967295)
                hi = 0;
            }
          }
          return new LongBits(lo, hi);
        };
        LongBits.from = function from19(value) {
          if (typeof value === "number")
            return LongBits.fromNumber(value);
          if (util2.isString(value)) {
            if (util2.Long)
              value = util2.Long.fromString(value);
            else
              return LongBits.fromNumber(parseInt(value, 10));
          }
          return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
        };
        LongBits.prototype.toNumber = function toNumber(unsigned) {
          if (!unsigned && this.hi >>> 31) {
            var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
            if (!lo)
              hi = hi + 1 >>> 0;
            return -(lo + hi * 4294967296);
          }
          return this.lo + this.hi * 4294967296;
        };
        LongBits.prototype.toLong = function toLong(unsigned) {
          return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
        };
        var charCodeAt = String.prototype.charCodeAt;
        LongBits.fromHash = function fromHash(hash) {
          if (hash === zeroHash)
            return zero;
          return new LongBits(
            (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
            (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
          );
        };
        LongBits.prototype.toHash = function toHash() {
          return String.fromCharCode(
            this.lo & 255,
            this.lo >>> 8 & 255,
            this.lo >>> 16 & 255,
            this.lo >>> 24,
            this.hi & 255,
            this.hi >>> 8 & 255,
            this.hi >>> 16 & 255,
            this.hi >>> 24
          );
        };
        LongBits.prototype.zzEncode = function zzEncode() {
          var mask2 = this.hi >> 31;
          this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask2) >>> 0;
          this.lo = (this.lo << 1 ^ mask2) >>> 0;
          return this;
        };
        LongBits.prototype.zzDecode = function zzDecode() {
          var mask2 = -(this.lo & 1);
          this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask2) >>> 0;
          this.hi = (this.hi >>> 1 ^ mask2) >>> 0;
          return this;
        };
        LongBits.prototype.length = function length42() {
          var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
          return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
        };
      }
    });
    require_minimal = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/util/minimal.js"(exports2) {
        "use strict";
        var util2 = exports2;
        util2.asPromise = require_aspromise();
        util2.base64 = require_base64();
        util2.EventEmitter = require_eventemitter();
        util2.float = require_float();
        util2.inquire = require_inquire();
        util2.utf8 = require_utf8();
        util2.pool = require_pool();
        util2.LongBits = require_longbits();
        util2.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
        util2.global = util2.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
        util2.emptyArray = Object.freeze ? Object.freeze([]) : (
          /* istanbul ignore next */
          []
        );
        util2.emptyObject = Object.freeze ? Object.freeze({}) : (
          /* istanbul ignore next */
          {}
        );
        util2.isInteger = Number.isInteger || /* istanbul ignore next */
        function isInteger2(value) {
          return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
        };
        util2.isString = function isString3(value) {
          return typeof value === "string" || value instanceof String;
        };
        util2.isObject = function isObject3(value) {
          return value && typeof value === "object";
        };
        util2.isset = /**
        * Checks if a property on a message is considered to be present.
        * @param {Object} obj Plain object or message instance
        * @param {string} prop Property name
        * @returns {boolean} `true` if considered to be present, otherwise `false`
        */
        util2.isSet = function isSet(obj, prop) {
          var value = obj[prop];
          if (value != null && obj.hasOwnProperty(prop))
            return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
          return false;
        };
        util2.Buffer = function() {
          try {
            var Buffer2 = util2.inquire("buffer").Buffer;
            return Buffer2.prototype.utf8Write ? Buffer2 : (
              /* istanbul ignore next */
              null
            );
          } catch (e) {
            return null;
          }
        }();
        util2._Buffer_from = null;
        util2._Buffer_allocUnsafe = null;
        util2.newBuffer = function newBuffer(sizeOrArray) {
          return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
        };
        util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        util2.Long = /* istanbul ignore next */
        util2.global.dcodeIO && /* istanbul ignore next */
        util2.global.dcodeIO.Long || /* istanbul ignore next */
        util2.global.Long || util2.inquire("long");
        util2.key2Re = /^true|false|0|1$/;
        util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
        util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
        util2.longToHash = function longToHash(value) {
          return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;
        };
        util2.longFromHash = function longFromHash(hash, unsigned) {
          var bits = util2.LongBits.fromHash(hash);
          if (util2.Long)
            return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
          return bits.toNumber(Boolean(unsigned));
        };
        function merge3(dst, src42, ifNotSet) {
          for (var keys2 = Object.keys(src42), i = 0; i < keys2.length; ++i)
            if (dst[keys2[i]] === void 0 || !ifNotSet)
              dst[keys2[i]] = src42[keys2[i]];
          return dst;
        }
        util2.merge = merge3;
        util2.lcFirst = function lcFirst(str) {
          return str.charAt(0).toLowerCase() + str.substring(1);
        };
        function newError(name142) {
          function CustomError(message2, properties) {
            if (!(this instanceof CustomError))
              return new CustomError(message2, properties);
            Object.defineProperty(this, "message", { get: function() {
              return message2;
            } });
            if (Error.captureStackTrace)
              Error.captureStackTrace(this, CustomError);
            else
              Object.defineProperty(this, "stack", { value: new Error().stack || "" });
            if (properties)
              merge3(this, properties);
          }
          CustomError.prototype = Object.create(Error.prototype, {
            constructor: {
              value: CustomError,
              writable: true,
              enumerable: false,
              configurable: true
            },
            name: {
              get: function get15() {
                return name142;
              },
              set: void 0,
              enumerable: false,
              // configurable: false would accurately preserve the behavior of
              // the original, but I'm guessing that was not intentional.
              // For an actual error subclass, this property would
              // be configurable.
              configurable: true
            },
            toString: {
              value: function value() {
                return this.name + ": " + this.message;
              },
              writable: true,
              enumerable: false,
              configurable: true
            }
          });
          return CustomError;
        }
        util2.newError = newError;
        util2.ProtocolError = newError("ProtocolError");
        util2.oneOfGetter = function getOneOf(fieldNames) {
          var fieldMap = {};
          for (var i = 0; i < fieldNames.length; ++i)
            fieldMap[fieldNames[i]] = 1;
          return function() {
            for (var keys2 = Object.keys(this), i2 = keys2.length - 1; i2 > -1; --i2)
              if (fieldMap[keys2[i2]] === 1 && this[keys2[i2]] !== void 0 && this[keys2[i2]] !== null)
                return keys2[i2];
          };
        };
        util2.oneOfSetter = function setOneOf(fieldNames) {
          return function(name142) {
            for (var i = 0; i < fieldNames.length; ++i)
              if (fieldNames[i] !== name142)
                delete this[fieldNames[i]];
          };
        };
        util2.toJSONOptions = {
          longs: String,
          enums: String,
          bytes: String,
          json: true
        };
        util2._configure = function() {
          var Buffer2 = util2.Buffer;
          if (!Buffer2) {
            util2._Buffer_from = util2._Buffer_allocUnsafe = null;
            return;
          }
          util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
          function Buffer_from(value, encoding) {
            return new Buffer2(value, encoding);
          };
          util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
          function Buffer_allocUnsafe(size5) {
            return new Buffer2(size5);
          };
        };
      }
    });
    require_writer = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/writer.js"(exports2, module2) {
        "use strict";
        module2.exports = Writer2;
        var util2 = require_minimal();
        var BufferWriter;
        var LongBits = util2.LongBits;
        var base6432 = util2.base64;
        var utf84 = util2.utf8;
        function Op(fn, len, val) {
          this.fn = fn;
          this.len = len;
          this.next = void 0;
          this.val = val;
        }
        function noop22() {
        }
        function State2(writer) {
          this.head = writer.head;
          this.tail = writer.tail;
          this.len = writer.len;
          this.next = writer.states;
        }
        function Writer2() {
          this.len = 0;
          this.head = new Op(noop22, 0, 0);
          this.tail = this.head;
          this.states = null;
        }
        var create19 = function create20() {
          return util2.Buffer ? function create_buffer_setup() {
            return (Writer2.create = function create_buffer() {
              return new BufferWriter();
            })();
          } : function create_array() {
            return new Writer2();
          };
        };
        Writer2.create = create19();
        Writer2.alloc = function alloc32(size5) {
          return new util2.Array(size5);
        };
        if (util2.Array !== Array)
          Writer2.alloc = util2.pool(Writer2.alloc, util2.Array.prototype.subarray);
        Writer2.prototype._push = function push2(fn, len, val) {
          this.tail = this.tail.next = new Op(fn, len, val);
          this.len += len;
          return this;
        };
        function writeByte(val, buf22, pos) {
          buf22[pos] = val & 255;
        }
        function writeVarint32(val, buf22, pos) {
          while (val > 127) {
            buf22[pos++] = val & 127 | 128;
            val >>>= 7;
          }
          buf22[pos] = val;
        }
        function VarintOp(len, val) {
          this.len = len;
          this.next = void 0;
          this.val = val;
        }
        VarintOp.prototype = Object.create(Op.prototype);
        VarintOp.prototype.fn = writeVarint32;
        Writer2.prototype.uint32 = function write_uint32(value) {
          this.len += (this.tail = this.tail.next = new VarintOp(
            (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
            value
          )).len;
          return this;
        };
        Writer2.prototype.int32 = function write_int32(value) {
          return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
        };
        Writer2.prototype.sint32 = function write_sint32(value) {
          return this.uint32((value << 1 ^ value >> 31) >>> 0);
        };
        function writeVarint64(val, buf22, pos) {
          while (val.hi) {
            buf22[pos++] = val.lo & 127 | 128;
            val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
            val.hi >>>= 7;
          }
          while (val.lo > 127) {
            buf22[pos++] = val.lo & 127 | 128;
            val.lo = val.lo >>> 7;
          }
          buf22[pos++] = val.lo;
        }
        Writer2.prototype.uint64 = function write_uint64(value) {
          var bits = LongBits.from(value);
          return this._push(writeVarint64, bits.length(), bits);
        };
        Writer2.prototype.int64 = Writer2.prototype.uint64;
        Writer2.prototype.sint64 = function write_sint64(value) {
          var bits = LongBits.from(value).zzEncode();
          return this._push(writeVarint64, bits.length(), bits);
        };
        Writer2.prototype.bool = function write_bool(value) {
          return this._push(writeByte, 1, value ? 1 : 0);
        };
        function writeFixed32(val, buf22, pos) {
          buf22[pos] = val & 255;
          buf22[pos + 1] = val >>> 8 & 255;
          buf22[pos + 2] = val >>> 16 & 255;
          buf22[pos + 3] = val >>> 24;
        }
        Writer2.prototype.fixed32 = function write_fixed32(value) {
          return this._push(writeFixed32, 4, value >>> 0);
        };
        Writer2.prototype.sfixed32 = Writer2.prototype.fixed32;
        Writer2.prototype.fixed64 = function write_fixed64(value) {
          var bits = LongBits.from(value);
          return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
        };
        Writer2.prototype.sfixed64 = Writer2.prototype.fixed64;
        Writer2.prototype.float = function write_float(value) {
          return this._push(util2.float.writeFloatLE, 4, value);
        };
        Writer2.prototype.double = function write_double(value) {
          return this._push(util2.float.writeDoubleLE, 8, value);
        };
        var writeBytes2 = util2.Array.prototype.set ? function writeBytes_set(val, buf22, pos) {
          buf22.set(val, pos);
        } : function writeBytes_for(val, buf22, pos) {
          for (var i = 0; i < val.length; ++i)
            buf22[pos + i] = val[i];
        };
        Writer2.prototype.bytes = function write_bytes(value) {
          var len = value.length >>> 0;
          if (!len)
            return this._push(writeByte, 1, 0);
          if (util2.isString(value)) {
            var buf22 = Writer2.alloc(len = base6432.length(value));
            base6432.decode(value, buf22, 0);
            value = buf22;
          }
          return this.uint32(len)._push(writeBytes2, len, value);
        };
        Writer2.prototype.string = function write_string(value) {
          var len = utf84.length(value);
          return len ? this.uint32(len)._push(utf84.write, len, value) : this._push(writeByte, 1, 0);
        };
        Writer2.prototype.fork = function fork5() {
          this.states = new State2(this);
          this.head = this.tail = new Op(noop22, 0, 0);
          this.len = 0;
          return this;
        };
        Writer2.prototype.reset = function reset() {
          if (this.states) {
            this.head = this.states.head;
            this.tail = this.states.tail;
            this.len = this.states.len;
            this.states = this.states.next;
          } else {
            this.head = this.tail = new Op(noop22, 0, 0);
            this.len = 0;
          }
          return this;
        };
        Writer2.prototype.ldelim = function ldelim() {
          var head = this.head, tail = this.tail, len = this.len;
          this.reset().uint32(len);
          if (len) {
            this.tail.next = head.next;
            this.tail = tail;
            this.len += len;
          }
          return this;
        };
        Writer2.prototype.finish = function finish() {
          var head = this.head.next, buf22 = this.constructor.alloc(this.len), pos = 0;
          while (head) {
            head.fn(head.val, buf22, pos);
            pos += head.len;
            head = head.next;
          }
          return buf22;
        };
        Writer2._configure = function(BufferWriter_) {
          BufferWriter = BufferWriter_;
          Writer2.create = create19();
          BufferWriter._configure();
        };
      }
    });
    require_writer_buffer = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
        "use strict";
        module2.exports = BufferWriter;
        var Writer2 = require_writer();
        (BufferWriter.prototype = Object.create(Writer2.prototype)).constructor = BufferWriter;
        var util2 = require_minimal();
        function BufferWriter() {
          Writer2.call(this);
        }
        BufferWriter._configure = function() {
          BufferWriter.alloc = util2._Buffer_allocUnsafe;
          BufferWriter.writeBytesBuffer = util2.Buffer && util2.Buffer.prototype instanceof Uint8Array && util2.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf22, pos) {
            buf22.set(val, pos);
          } : function writeBytesBuffer_copy(val, buf22, pos) {
            if (val.copy)
              val.copy(buf22, pos, 0, val.length);
            else for (var i = 0; i < val.length; )
              buf22[pos++] = val[i++];
          };
        };
        BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
          if (util2.isString(value))
            value = util2._Buffer_from(value, "base64");
          var len = value.length >>> 0;
          this.uint32(len);
          if (len)
            this._push(BufferWriter.writeBytesBuffer, len, value);
          return this;
        };
        function writeStringBuffer(val, buf22, pos) {
          if (val.length < 40)
            util2.utf8.write(val, buf22, pos);
          else if (buf22.utf8Write)
            buf22.utf8Write(val, pos);
          else
            buf22.write(val, pos);
        }
        BufferWriter.prototype.string = function write_string_buffer(value) {
          var len = util2.Buffer.byteLength(value);
          this.uint32(len);
          if (len)
            this._push(writeStringBuffer, len, value);
          return this;
        };
        BufferWriter._configure();
      }
    });
    require_reader = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/reader.js"(exports2, module2) {
        "use strict";
        module2.exports = Reader;
        var util2 = require_minimal();
        var BufferReader;
        var LongBits = util2.LongBits;
        var utf84 = util2.utf8;
        function indexOutOfRange(reader, writeLength) {
          return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
        }
        function Reader(buffer22) {
          this.buf = buffer22;
          this.pos = 0;
          this.len = buffer22.length;
        }
        var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer22) {
          if (buffer22 instanceof Uint8Array || Array.isArray(buffer22))
            return new Reader(buffer22);
          throw Error("illegal buffer");
        } : function create_array2(buffer22) {
          if (Array.isArray(buffer22))
            return new Reader(buffer22);
          throw Error("illegal buffer");
        };
        var create19 = function create20() {
          return util2.Buffer ? function create_buffer_setup(buffer22) {
            return (Reader.create = function create_buffer(buffer3) {
              return util2.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
            })(buffer22);
          } : create_array;
        };
        Reader.create = create19();
        Reader.prototype._slice = util2.Array.prototype.subarray || /* istanbul ignore next */
        util2.Array.prototype.slice;
        Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
          var value = 4294967295;
          return function read_uint32() {
            value = (this.buf[this.pos] & 127) >>> 0;
            if (this.buf[this.pos++] < 128) return value;
            value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
            if (this.buf[this.pos++] < 128) return value;
            value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
            if (this.buf[this.pos++] < 128) return value;
            value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
            if (this.buf[this.pos++] < 128) return value;
            value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
            if (this.buf[this.pos++] < 128) return value;
            if ((this.pos += 5) > this.len) {
              this.pos = this.len;
              throw indexOutOfRange(this, 10);
            }
            return value;
          };
        }();
        Reader.prototype.int32 = function read_int32() {
          return this.uint32() | 0;
        };
        Reader.prototype.sint32 = function read_sint32() {
          var value = this.uint32();
          return value >>> 1 ^ -(value & 1) | 0;
        };
        function readLongVarint() {
          var bits = new LongBits(0, 0);
          var i = 0;
          if (this.len - this.pos > 4) {
            for (; i < 4; ++i) {
              bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
              if (this.buf[this.pos++] < 128)
                return bits;
            }
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
            i = 0;
          } else {
            for (; i < 3; ++i) {
              if (this.pos >= this.len)
                throw indexOutOfRange(this);
              bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
              if (this.buf[this.pos++] < 128)
                return bits;
            }
            bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
            return bits;
          }
          if (this.len - this.pos > 4) {
            for (; i < 5; ++i) {
              bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
              if (this.buf[this.pos++] < 128)
                return bits;
            }
          } else {
            for (; i < 5; ++i) {
              if (this.pos >= this.len)
                throw indexOutOfRange(this);
              bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
              if (this.buf[this.pos++] < 128)
                return bits;
            }
          }
          throw Error("invalid varint encoding");
        }
        Reader.prototype.bool = function read_bool() {
          return this.uint32() !== 0;
        };
        function readFixed32_end(buf22, end) {
          return (buf22[end - 4] | buf22[end - 3] << 8 | buf22[end - 2] << 16 | buf22[end - 1] << 24) >>> 0;
        }
        Reader.prototype.fixed32 = function read_fixed32() {
          if (this.pos + 4 > this.len)
            throw indexOutOfRange(this, 4);
          return readFixed32_end(this.buf, this.pos += 4);
        };
        Reader.prototype.sfixed32 = function read_sfixed32() {
          if (this.pos + 4 > this.len)
            throw indexOutOfRange(this, 4);
          return readFixed32_end(this.buf, this.pos += 4) | 0;
        };
        function readFixed64() {
          if (this.pos + 8 > this.len)
            throw indexOutOfRange(this, 8);
          return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
        }
        Reader.prototype.float = function read_float() {
          if (this.pos + 4 > this.len)
            throw indexOutOfRange(this, 4);
          var value = util2.float.readFloatLE(this.buf, this.pos);
          this.pos += 4;
          return value;
        };
        Reader.prototype.double = function read_double() {
          if (this.pos + 8 > this.len)
            throw indexOutOfRange(this, 4);
          var value = util2.float.readDoubleLE(this.buf, this.pos);
          this.pos += 8;
          return value;
        };
        Reader.prototype.bytes = function read_bytes() {
          var length42 = this.uint32(), start = this.pos, end = this.pos + length42;
          if (end > this.len)
            throw indexOutOfRange(this, length42);
          this.pos += length42;
          if (Array.isArray(this.buf))
            return this.buf.slice(start, end);
          if (start === end) {
            var nativeBuffer = util2.Buffer;
            return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
          }
          return this._slice.call(this.buf, start, end);
        };
        Reader.prototype.string = function read_string() {
          var bytes22 = this.bytes();
          return utf84.read(bytes22, 0, bytes22.length);
        };
        Reader.prototype.skip = function skip2(length42) {
          if (typeof length42 === "number") {
            if (this.pos + length42 > this.len)
              throw indexOutOfRange(this, length42);
            this.pos += length42;
          } else {
            do {
              if (this.pos >= this.len)
                throw indexOutOfRange(this);
            } while (this.buf[this.pos++] & 128);
          }
          return this;
        };
        Reader.prototype.skipType = function(wireType) {
          switch (wireType) {
            case 0:
              this.skip();
              break;
            case 1:
              this.skip(8);
              break;
            case 2:
              this.skip(this.uint32());
              break;
            case 3:
              while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
              }
              break;
            case 5:
              this.skip(4);
              break;
            default:
              throw Error("invalid wire type " + wireType + " at offset " + this.pos);
          }
          return this;
        };
        Reader._configure = function(BufferReader_) {
          BufferReader = BufferReader_;
          Reader.create = create19();
          BufferReader._configure();
          var fn = util2.Long ? "toLong" : (
            /* istanbul ignore next */
            "toNumber"
          );
          util2.merge(Reader.prototype, {
            int64: function read_int64() {
              return readLongVarint.call(this)[fn](false);
            },
            uint64: function read_uint64() {
              return readLongVarint.call(this)[fn](true);
            },
            sint64: function read_sint64() {
              return readLongVarint.call(this).zzDecode()[fn](false);
            },
            fixed64: function read_fixed64() {
              return readFixed64.call(this)[fn](true);
            },
            sfixed64: function read_sfixed64() {
              return readFixed64.call(this)[fn](false);
            }
          });
        };
      }
    });
    require_reader_buffer = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
        "use strict";
        module2.exports = BufferReader;
        var Reader = require_reader();
        (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
        var util2 = require_minimal();
        function BufferReader(buffer22) {
          Reader.call(this, buffer22);
        }
        BufferReader._configure = function() {
          if (util2.Buffer)
            BufferReader.prototype._slice = util2.Buffer.prototype.slice;
        };
        BufferReader.prototype.string = function read_string_buffer() {
          var len = this.uint32();
          return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
        };
        BufferReader._configure();
      }
    });
    require_service = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
        "use strict";
        module2.exports = Service;
        var util2 = require_minimal();
        (Service.prototype = Object.create(util2.EventEmitter.prototype)).constructor = Service;
        function Service(rpcImpl, requestDelimited, responseDelimited) {
          if (typeof rpcImpl !== "function")
            throw TypeError("rpcImpl must be a function");
          util2.EventEmitter.call(this);
          this.rpcImpl = rpcImpl;
          this.requestDelimited = Boolean(requestDelimited);
          this.responseDelimited = Boolean(responseDelimited);
        }
        Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
          if (!request)
            throw TypeError("request must be specified");
          var self2 = this;
          if (!callback)
            return util2.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
          if (!self2.rpcImpl) {
            setTimeout(function() {
              callback(Error("already ended"));
            }, 0);
            return void 0;
          }
          try {
            return self2.rpcImpl(
              method,
              requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
              function rpcCallback(err, response) {
                if (err) {
                  self2.emit("error", err, method);
                  return callback(err);
                }
                if (response === null) {
                  self2.end(
                    /* endedByRPC */
                    true
                  );
                  return void 0;
                }
                if (!(response instanceof responseCtor)) {
                  try {
                    response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
                  } catch (err2) {
                    self2.emit("error", err2, method);
                    return callback(err2);
                  }
                }
                self2.emit("data", response, method);
                return callback(null, response);
              }
            );
          } catch (err) {
            self2.emit("error", err, method);
            setTimeout(function() {
              callback(err);
            }, 0);
            return void 0;
          }
        };
        Service.prototype.end = function end(endedByRPC) {
          if (this.rpcImpl) {
            if (!endedByRPC)
              this.rpcImpl(null, null, null);
            this.rpcImpl = null;
            this.emit("end").off();
          }
          return this;
        };
      }
    });
    require_rpc = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/rpc.js"(exports2) {
        "use strict";
        var rpc = exports2;
        rpc.Service = require_service();
      }
    });
    require_roots = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/roots.js"(exports2, module2) {
        "use strict";
        module2.exports = {};
      }
    });
    require_index_minimal = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/index-minimal.js"(exports2) {
        "use strict";
        var protobuf = exports2;
        protobuf.build = "minimal";
        protobuf.Writer = require_writer();
        protobuf.BufferWriter = require_writer_buffer();
        protobuf.Reader = require_reader();
        protobuf.BufferReader = require_reader_buffer();
        protobuf.util = require_minimal();
        protobuf.rpc = require_rpc();
        protobuf.roots = require_roots();
        protobuf.configure = configure62;
        function configure62() {
          protobuf.util._configure();
          protobuf.Writer._configure(protobuf.BufferWriter);
          protobuf.Reader._configure(protobuf.BufferReader);
        }
        configure62();
      }
    });
    require_minimal2 = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/minimal.js"(exports2, module2) {
        "use strict";
        module2.exports = require_index_minimal();
      }
    });
    require_murmurHash3js = __commonJS2({
      "../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js"(exports2, module2) {
        (function(root2, undefined2) {
          "use strict";
          var library = {
            "version": "3.0.0",
            "x86": {},
            "x64": {},
            "inputValidation": true
          };
          function _validBytes(bytes22) {
            if (!Array.isArray(bytes22) && !ArrayBuffer.isView(bytes22)) {
              return false;
            }
            for (var i = 0; i < bytes22.length; i++) {
              if (!Number.isInteger(bytes22[i]) || bytes22[i] < 0 || bytes22[i] > 255) {
                return false;
              }
            }
            return true;
          }
          function _x86Multiply(m, n2) {
            return (m & 65535) * n2 + (((m >>> 16) * n2 & 65535) << 16);
          }
          function _x86Rotl(m, n2) {
            return m << n2 | m >>> 32 - n2;
          }
          function _x86Fmix(h) {
            h ^= h >>> 16;
            h = _x86Multiply(h, 2246822507);
            h ^= h >>> 13;
            h = _x86Multiply(h, 3266489909);
            h ^= h >>> 16;
            return h;
          }
          function _x64Add(m, n2) {
            m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
            n2 = [n2[0] >>> 16, n2[0] & 65535, n2[1] >>> 16, n2[1] & 65535];
            var o = [0, 0, 0, 0];
            o[3] += m[3] + n2[3];
            o[2] += o[3] >>> 16;
            o[3] &= 65535;
            o[2] += m[2] + n2[2];
            o[1] += o[2] >>> 16;
            o[2] &= 65535;
            o[1] += m[1] + n2[1];
            o[0] += o[1] >>> 16;
            o[1] &= 65535;
            o[0] += m[0] + n2[0];
            o[0] &= 65535;
            return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
          }
          function _x64Multiply(m, n2) {
            m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
            n2 = [n2[0] >>> 16, n2[0] & 65535, n2[1] >>> 16, n2[1] & 65535];
            var o = [0, 0, 0, 0];
            o[3] += m[3] * n2[3];
            o[2] += o[3] >>> 16;
            o[3] &= 65535;
            o[2] += m[2] * n2[3];
            o[1] += o[2] >>> 16;
            o[2] &= 65535;
            o[2] += m[3] * n2[2];
            o[1] += o[2] >>> 16;
            o[2] &= 65535;
            o[1] += m[1] * n2[3];
            o[0] += o[1] >>> 16;
            o[1] &= 65535;
            o[1] += m[2] * n2[2];
            o[0] += o[1] >>> 16;
            o[1] &= 65535;
            o[1] += m[3] * n2[1];
            o[0] += o[1] >>> 16;
            o[1] &= 65535;
            o[0] += m[0] * n2[3] + m[1] * n2[2] + m[2] * n2[1] + m[3] * n2[0];
            o[0] &= 65535;
            return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
          }
          function _x64Rotl(m, n2) {
            n2 %= 64;
            if (n2 === 32) {
              return [m[1], m[0]];
            } else if (n2 < 32) {
              return [m[0] << n2 | m[1] >>> 32 - n2, m[1] << n2 | m[0] >>> 32 - n2];
            } else {
              n2 -= 32;
              return [m[1] << n2 | m[0] >>> 32 - n2, m[0] << n2 | m[1] >>> 32 - n2];
            }
          }
          function _x64LeftShift(m, n2) {
            n2 %= 64;
            if (n2 === 0) {
              return m;
            } else if (n2 < 32) {
              return [m[0] << n2 | m[1] >>> 32 - n2, m[1] << n2];
            } else {
              return [m[1] << n2 - 32, 0];
            }
          }
          function _x64Xor(m, n2) {
            return [m[0] ^ n2[0], m[1] ^ n2[1]];
          }
          function _x64Fmix(h) {
            h = _x64Xor(h, [0, h[0] >>> 1]);
            h = _x64Multiply(h, [4283543511, 3981806797]);
            h = _x64Xor(h, [0, h[0] >>> 1]);
            h = _x64Multiply(h, [3301882366, 444984403]);
            h = _x64Xor(h, [0, h[0] >>> 1]);
            return h;
          }
          library.x86.hash32 = function(bytes22, seed) {
            if (library.inputValidation && !_validBytes(bytes22)) {
              return undefined2;
            }
            seed = seed || 0;
            var remainder = bytes22.length % 4;
            var blocks = bytes22.length - remainder;
            var h1 = seed;
            var k1 = 0;
            var c1 = 3432918353;
            var c2 = 461845907;
            for (var i = 0; i < blocks; i = i + 4) {
              k1 = bytes22[i] | bytes22[i + 1] << 8 | bytes22[i + 2] << 16 | bytes22[i + 3] << 24;
              k1 = _x86Multiply(k1, c1);
              k1 = _x86Rotl(k1, 15);
              k1 = _x86Multiply(k1, c2);
              h1 ^= k1;
              h1 = _x86Rotl(h1, 13);
              h1 = _x86Multiply(h1, 5) + 3864292196;
            }
            k1 = 0;
            switch (remainder) {
              case 3:
                k1 ^= bytes22[i + 2] << 16;
              case 2:
                k1 ^= bytes22[i + 1] << 8;
              case 1:
                k1 ^= bytes22[i];
                k1 = _x86Multiply(k1, c1);
                k1 = _x86Rotl(k1, 15);
                k1 = _x86Multiply(k1, c2);
                h1 ^= k1;
            }
            h1 ^= bytes22.length;
            h1 = _x86Fmix(h1);
            return h1 >>> 0;
          };
          library.x86.hash128 = function(bytes22, seed) {
            if (library.inputValidation && !_validBytes(bytes22)) {
              return undefined2;
            }
            seed = seed || 0;
            var remainder = bytes22.length % 16;
            var blocks = bytes22.length - remainder;
            var h1 = seed;
            var h2 = seed;
            var h3 = seed;
            var h4 = seed;
            var k1 = 0;
            var k2 = 0;
            var k3 = 0;
            var k4 = 0;
            var c1 = 597399067;
            var c2 = 2869860233;
            var c3 = 951274213;
            var c4 = 2716044179;
            for (var i = 0; i < blocks; i = i + 16) {
              k1 = bytes22[i] | bytes22[i + 1] << 8 | bytes22[i + 2] << 16 | bytes22[i + 3] << 24;
              k2 = bytes22[i + 4] | bytes22[i + 5] << 8 | bytes22[i + 6] << 16 | bytes22[i + 7] << 24;
              k3 = bytes22[i + 8] | bytes22[i + 9] << 8 | bytes22[i + 10] << 16 | bytes22[i + 11] << 24;
              k4 = bytes22[i + 12] | bytes22[i + 13] << 8 | bytes22[i + 14] << 16 | bytes22[i + 15] << 24;
              k1 = _x86Multiply(k1, c1);
              k1 = _x86Rotl(k1, 15);
              k1 = _x86Multiply(k1, c2);
              h1 ^= k1;
              h1 = _x86Rotl(h1, 19);
              h1 += h2;
              h1 = _x86Multiply(h1, 5) + 1444728091;
              k2 = _x86Multiply(k2, c2);
              k2 = _x86Rotl(k2, 16);
              k2 = _x86Multiply(k2, c3);
              h2 ^= k2;
              h2 = _x86Rotl(h2, 17);
              h2 += h3;
              h2 = _x86Multiply(h2, 5) + 197830471;
              k3 = _x86Multiply(k3, c3);
              k3 = _x86Rotl(k3, 17);
              k3 = _x86Multiply(k3, c4);
              h3 ^= k3;
              h3 = _x86Rotl(h3, 15);
              h3 += h4;
              h3 = _x86Multiply(h3, 5) + 2530024501;
              k4 = _x86Multiply(k4, c4);
              k4 = _x86Rotl(k4, 18);
              k4 = _x86Multiply(k4, c1);
              h4 ^= k4;
              h4 = _x86Rotl(h4, 13);
              h4 += h1;
              h4 = _x86Multiply(h4, 5) + 850148119;
            }
            k1 = 0;
            k2 = 0;
            k3 = 0;
            k4 = 0;
            switch (remainder) {
              case 15:
                k4 ^= bytes22[i + 14] << 16;
              case 14:
                k4 ^= bytes22[i + 13] << 8;
              case 13:
                k4 ^= bytes22[i + 12];
                k4 = _x86Multiply(k4, c4);
                k4 = _x86Rotl(k4, 18);
                k4 = _x86Multiply(k4, c1);
                h4 ^= k4;
              case 12:
                k3 ^= bytes22[i + 11] << 24;
              case 11:
                k3 ^= bytes22[i + 10] << 16;
              case 10:
                k3 ^= bytes22[i + 9] << 8;
              case 9:
                k3 ^= bytes22[i + 8];
                k3 = _x86Multiply(k3, c3);
                k3 = _x86Rotl(k3, 17);
                k3 = _x86Multiply(k3, c4);
                h3 ^= k3;
              case 8:
                k2 ^= bytes22[i + 7] << 24;
              case 7:
                k2 ^= bytes22[i + 6] << 16;
              case 6:
                k2 ^= bytes22[i + 5] << 8;
              case 5:
                k2 ^= bytes22[i + 4];
                k2 = _x86Multiply(k2, c2);
                k2 = _x86Rotl(k2, 16);
                k2 = _x86Multiply(k2, c3);
                h2 ^= k2;
              case 4:
                k1 ^= bytes22[i + 3] << 24;
              case 3:
                k1 ^= bytes22[i + 2] << 16;
              case 2:
                k1 ^= bytes22[i + 1] << 8;
              case 1:
                k1 ^= bytes22[i];
                k1 = _x86Multiply(k1, c1);
                k1 = _x86Rotl(k1, 15);
                k1 = _x86Multiply(k1, c2);
                h1 ^= k1;
            }
            h1 ^= bytes22.length;
            h2 ^= bytes22.length;
            h3 ^= bytes22.length;
            h4 ^= bytes22.length;
            h1 += h2;
            h1 += h3;
            h1 += h4;
            h2 += h1;
            h3 += h1;
            h4 += h1;
            h1 = _x86Fmix(h1);
            h2 = _x86Fmix(h2);
            h3 = _x86Fmix(h3);
            h4 = _x86Fmix(h4);
            h1 += h2;
            h1 += h3;
            h1 += h4;
            h2 += h1;
            h3 += h1;
            h4 += h1;
            return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
          };
          library.x64.hash128 = function(bytes22, seed) {
            if (library.inputValidation && !_validBytes(bytes22)) {
              return undefined2;
            }
            seed = seed || 0;
            var remainder = bytes22.length % 16;
            var blocks = bytes22.length - remainder;
            var h1 = [0, seed];
            var h2 = [0, seed];
            var k1 = [0, 0];
            var k2 = [0, 0];
            var c1 = [2277735313, 289559509];
            var c2 = [1291169091, 658871167];
            for (var i = 0; i < blocks; i = i + 16) {
              k1 = [bytes22[i + 4] | bytes22[i + 5] << 8 | bytes22[i + 6] << 16 | bytes22[i + 7] << 24, bytes22[i] | bytes22[i + 1] << 8 | bytes22[i + 2] << 16 | bytes22[i + 3] << 24];
              k2 = [bytes22[i + 12] | bytes22[i + 13] << 8 | bytes22[i + 14] << 16 | bytes22[i + 15] << 24, bytes22[i + 8] | bytes22[i + 9] << 8 | bytes22[i + 10] << 16 | bytes22[i + 11] << 24];
              k1 = _x64Multiply(k1, c1);
              k1 = _x64Rotl(k1, 31);
              k1 = _x64Multiply(k1, c2);
              h1 = _x64Xor(h1, k1);
              h1 = _x64Rotl(h1, 27);
              h1 = _x64Add(h1, h2);
              h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
              k2 = _x64Multiply(k2, c2);
              k2 = _x64Rotl(k2, 33);
              k2 = _x64Multiply(k2, c1);
              h2 = _x64Xor(h2, k2);
              h2 = _x64Rotl(h2, 31);
              h2 = _x64Add(h2, h1);
              h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
            }
            k1 = [0, 0];
            k2 = [0, 0];
            switch (remainder) {
              case 15:
                k2 = _x64Xor(k2, _x64LeftShift([0, bytes22[i + 14]], 48));
              case 14:
                k2 = _x64Xor(k2, _x64LeftShift([0, bytes22[i + 13]], 40));
              case 13:
                k2 = _x64Xor(k2, _x64LeftShift([0, bytes22[i + 12]], 32));
              case 12:
                k2 = _x64Xor(k2, _x64LeftShift([0, bytes22[i + 11]], 24));
              case 11:
                k2 = _x64Xor(k2, _x64LeftShift([0, bytes22[i + 10]], 16));
              case 10:
                k2 = _x64Xor(k2, _x64LeftShift([0, bytes22[i + 9]], 8));
              case 9:
                k2 = _x64Xor(k2, [0, bytes22[i + 8]]);
                k2 = _x64Multiply(k2, c2);
                k2 = _x64Rotl(k2, 33);
                k2 = _x64Multiply(k2, c1);
                h2 = _x64Xor(h2, k2);
              case 8:
                k1 = _x64Xor(k1, _x64LeftShift([0, bytes22[i + 7]], 56));
              case 7:
                k1 = _x64Xor(k1, _x64LeftShift([0, bytes22[i + 6]], 48));
              case 6:
                k1 = _x64Xor(k1, _x64LeftShift([0, bytes22[i + 5]], 40));
              case 5:
                k1 = _x64Xor(k1, _x64LeftShift([0, bytes22[i + 4]], 32));
              case 4:
                k1 = _x64Xor(k1, _x64LeftShift([0, bytes22[i + 3]], 24));
              case 3:
                k1 = _x64Xor(k1, _x64LeftShift([0, bytes22[i + 2]], 16));
              case 2:
                k1 = _x64Xor(k1, _x64LeftShift([0, bytes22[i + 1]], 8));
              case 1:
                k1 = _x64Xor(k1, [0, bytes22[i]]);
                k1 = _x64Multiply(k1, c1);
                k1 = _x64Rotl(k1, 31);
                k1 = _x64Multiply(k1, c2);
                h1 = _x64Xor(h1, k1);
            }
            h1 = _x64Xor(h1, [0, bytes22.length]);
            h2 = _x64Xor(h2, [0, bytes22.length]);
            h1 = _x64Add(h1, h2);
            h2 = _x64Add(h2, h1);
            h1 = _x64Fmix(h1);
            h2 = _x64Fmix(h2);
            h1 = _x64Add(h1, h2);
            h2 = _x64Add(h2, h1);
            return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
          };
          if (typeof exports2 !== "undefined") {
            if (typeof module2 !== "undefined" && module2.exports) {
              exports2 = module2.exports = library;
            }
            exports2.murmurHash3 = library;
          } else if (typeof define === "function" && define.amd) {
            define([], function() {
              return library;
            });
          } else {
            library._murmurHash3 = root2.murmurHash3;
            library.noConflict = function() {
              root2.murmurHash3 = library._murmurHash3;
              library._murmurHash3 = undefined2;
              library.noConflict = undefined2;
              return library;
            };
            root2.murmurHash3 = library;
          }
        })(exports2);
      }
    });
    require_murmurhash3js_revisited = __commonJS2({
      "../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/index.js"(exports2, module2) {
        module2.exports = require_murmurHash3js();
      }
    });
    multihash_exports = {};
    __export2(multihash_exports, {
      Digest: () => digest_exports3,
      MAX_HEIGHT: () => MAX_HEIGHT2,
      MAX_PAYLOAD_SIZE: () => MAX_PAYLOAD_SIZE2,
      code: () => code5,
      create: () => create4,
      digest: () => digest2,
      name: () => name4
    });
    BITS_PER_BYTE = 8;
    FRS_PER_QUAD = 4;
    LEAFS_PER_QUAD = /** @type {4n} */
    BigInt(FRS_PER_QUAD);
    IN_BITS_FR = 254;
    OUT_BITS_FR = 256;
    IN_BYTES_PER_QUAD = /** @type {127} */
    FRS_PER_QUAD * IN_BITS_FR / BITS_PER_BYTE;
    OUT_BYTES_PER_QUAD = /** @type {128} */
    FRS_PER_QUAD * OUT_BITS_FR / BITS_PER_BYTE;
    PADDED_BYTES_PER_QUAD = /** @type {127n} */
    BigInt(IN_BYTES_PER_QUAD);
    EXPANDED_BYTES_PER_QUAD = /** @type {128n} */
    BigInt(OUT_BYTES_PER_QUAD);
    BYTES_PER_FR = /** @type {32} */
    OUT_BYTES_PER_QUAD / FRS_PER_QUAD;
    FR_RATIO = IN_BITS_FR / OUT_BITS_FR;
    NODE_SIZE = /** @type {32} */
    OUT_BYTES_PER_QUAD / FRS_PER_QUAD;
    EXPANDED_BYTES_PER_NODE = /** @type {32n} */
    BigInt(NODE_SIZE);
    MIN_PAYLOAD_SIZE = 2 * NODE_SIZE + 1;
    from = (bytes22) => {
      if (bytes22 instanceof Uint8Array) {
        if (bytes22.length > NODE_SIZE) {
          return bytes22.subarray(0, NODE_SIZE);
        } else if (bytes22.length == NODE_SIZE) {
          return bytes22;
        }
      }
      const node = new Uint8Array(NODE_SIZE);
      node.set([...bytes22]);
      return node;
    };
    empty = () => EMPTY;
    EMPTY = from(new Uint8Array(NODE_SIZE).fill(0));
    Object.freeze(EMPTY.buffer);
    empty2 = new Uint8Array(0);
    equals = (aa, bb) => {
      if (aa === bb) return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    coerce = (o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") return o;
      if (o instanceof ArrayBuffer) return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    sha256_exports = {};
    __export2(sha256_exports, {
      code: () => code2,
      digest: () => digest,
      name: () => name,
      size: () => size
    });
    name = "sha2-256";
    code = 18;
    size = 32;
    prefix = new Uint8Array([18, 32]);
    Digest = class {
      /**
       * @param {Uint8Array} bytes
       */
      constructor(bytes22) {
        this.code = code;
        this.name = name;
        this.bytes = bytes22;
        this.size = size;
        this.digest = bytes22.subarray(2);
      }
    };
    digest = (payload) => {
      const digest52 = new Uint8Array(prefix.length + size);
      digest52.set(prefix, 0);
      digest52.set(sha256(payload), prefix.length);
      return new Digest(digest52);
    };
    code2 = code;
    typeofs = [
      "string",
      "number",
      "bigint",
      "symbol"
    ];
    objectTypeNames = [
      "Function",
      "Generator",
      "AsyncGenerator",
      "GeneratorFunction",
      "AsyncGeneratorFunction",
      "AsyncFunction",
      "Observable",
      "Array",
      "Buffer",
      "Object",
      "RegExp",
      "Date",
      "Error",
      "Map",
      "Set",
      "WeakMap",
      "WeakSet",
      "ArrayBuffer",
      "SharedArrayBuffer",
      "DataView",
      "Promise",
      "URL",
      "HTMLElement",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Uint16Array",
      "Int32Array",
      "Uint32Array",
      "Float32Array",
      "Float64Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
    Type = class {
      /**
       * @param {number} major
       * @param {string} name
       * @param {boolean} terminal
       */
      constructor(major, name142, terminal) {
        this.major = major;
        this.majorEncoded = major << 5;
        this.name = name142;
        this.terminal = terminal;
      }
      /* c8 ignore next 3 */
      toString() {
        return `Type[${this.major}].${this.name}`;
      }
      /**
       * @param {Type} typ
       * @returns {number}
       */
      compare(typ) {
        return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
      }
    };
    Type.uint = new Type(0, "uint", true);
    Type.negint = new Type(1, "negint", true);
    Type.bytes = new Type(2, "bytes", true);
    Type.string = new Type(3, "string", true);
    Type.array = new Type(4, "array", false);
    Type.map = new Type(5, "map", false);
    Type.tag = new Type(6, "tag", false);
    Type.float = new Type(7, "float", true);
    Type.false = new Type(7, "false", true);
    Type.true = new Type(7, "true", true);
    Type.null = new Type(7, "null", true);
    Type.undefined = new Type(7, "undefined", true);
    Type.break = new Type(7, "break", true);
    Token = class {
      /**
       * @param {Type} type
       * @param {any} [value]
       * @param {number} [encodedLength]
       */
      constructor(type2, value, encodedLength) {
        this.type = type2;
        this.value = value;
        this.encodedLength = encodedLength;
        this.encodedBytes = void 0;
        this.byteValue = void 0;
      }
      /* c8 ignore next 3 */
      toString() {
        return `Token[${this.type}].${this.value}`;
      }
    };
    useBuffer = globalThis.process && // @ts-ignore
    !globalThis.process.browser && // @ts-ignore
    globalThis.Buffer && // @ts-ignore
    typeof globalThis.Buffer.isBuffer === "function";
    textDecoder = new TextDecoder();
    textEncoder = new TextEncoder();
    toString = useBuffer ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array} bytes
       * @param {number} start
       * @param {number} end
       */
      (bytes22, start, end) => {
        return end - start > 64 ? (
          // eslint-disable-line operator-linebreak
          // @ts-ignore
          globalThis.Buffer.from(bytes22.subarray(start, end)).toString("utf8")
        ) : utf8Slice(bytes22, start, end);
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array} bytes
       * @param {number} start
       * @param {number} end
       */
      (bytes22, start, end) => {
        return end - start > 64 ? textDecoder.decode(bytes22.subarray(start, end)) : utf8Slice(bytes22, start, end);
      }
    );
    fromString = useBuffer ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {string} string
       */
      (string32) => {
        return string32.length > 64 ? (
          // eslint-disable-line operator-linebreak
          // @ts-ignore
          globalThis.Buffer.from(string32)
        ) : utf8ToBytes2(string32);
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {string} string
       */
      (string32) => {
        return string32.length > 64 ? textEncoder.encode(string32) : utf8ToBytes2(string32);
      }
    );
    fromArray = (arr) => {
      return Uint8Array.from(arr);
    };
    slice = useBuffer ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array} bytes
       * @param {number} start
       * @param {number} end
       */
      (bytes22, start, end) => {
        if (isBuffer2(bytes22)) {
          return new Uint8Array(bytes22.subarray(start, end));
        }
        return bytes22.slice(start, end);
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array} bytes
       * @param {number} start
       * @param {number} end
       */
      (bytes22, start, end) => {
        return bytes22.slice(start, end);
      }
    );
    concat = useBuffer ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array[]} chunks
       * @param {number} length
       * @returns {Uint8Array}
       */
      (chunks, length42) => {
        chunks = chunks.map((c) => c instanceof Uint8Array ? c : (
          // eslint-disable-line operator-linebreak
          // @ts-ignore
          globalThis.Buffer.from(c)
        ));
        return asU8A(globalThis.Buffer.concat(chunks, length42));
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array[]} chunks
       * @param {number} length
       * @returns {Uint8Array}
       */
      (chunks, length42) => {
        const out = new Uint8Array(length42);
        let off = 0;
        for (let b of chunks) {
          if (off + b.length > out.length) {
            b = b.subarray(0, out.length - off);
          }
          out.set(b, off);
          off += b.length;
        }
        return out;
      }
    );
    alloc = useBuffer ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {number} size
       * @returns {Uint8Array}
       */
      (size5) => {
        return globalThis.Buffer.allocUnsafe(size5);
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {number} size
       * @returns {Uint8Array}
       */
      (size5) => {
        return new Uint8Array(size5);
      }
    );
    MAX_ARGUMENTS_LENGTH = 4096;
    defaultChunkSize = 256;
    Bl = class {
      /**
       * @param {number} [chunkSize]
       */
      constructor(chunkSize = defaultChunkSize) {
        this.chunkSize = chunkSize;
        this.cursor = 0;
        this.maxCursor = -1;
        this.chunks = [];
        this._initReuseChunk = null;
      }
      reset() {
        this.cursor = 0;
        this.maxCursor = -1;
        if (this.chunks.length) {
          this.chunks = [];
        }
        if (this._initReuseChunk !== null) {
          this.chunks.push(this._initReuseChunk);
          this.maxCursor = this._initReuseChunk.length - 1;
        }
      }
      /**
       * @param {Uint8Array|number[]} bytes
       */
      push(bytes22) {
        let topChunk = this.chunks[this.chunks.length - 1];
        const newMax = this.cursor + bytes22.length;
        if (newMax <= this.maxCursor + 1) {
          const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
          topChunk.set(bytes22, chunkPos);
        } else {
          if (topChunk) {
            const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
            if (chunkPos < topChunk.length) {
              this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
              this.maxCursor = this.cursor - 1;
            }
          }
          if (bytes22.length < 64 && bytes22.length < this.chunkSize) {
            topChunk = alloc(this.chunkSize);
            this.chunks.push(topChunk);
            this.maxCursor += topChunk.length;
            if (this._initReuseChunk === null) {
              this._initReuseChunk = topChunk;
            }
            topChunk.set(bytes22, 0);
          } else {
            this.chunks.push(bytes22);
            this.maxCursor += bytes22.length;
          }
        }
        this.cursor += bytes22.length;
      }
      /**
       * @param {boolean} [reset]
       * @returns {Uint8Array}
       */
      toBytes(reset = false) {
        let byts;
        if (this.chunks.length === 1) {
          const chunk = this.chunks[0];
          if (reset && this.cursor > chunk.length / 2) {
            byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
            this._initReuseChunk = null;
            this.chunks = [];
          } else {
            byts = slice(chunk, 0, this.cursor);
          }
        } else {
          byts = concat(this.chunks, this.cursor);
        }
        if (reset) {
          this.reset();
        }
        return byts;
      }
    };
    decodeErrPrefix = "CBOR decode error:";
    encodeErrPrefix = "CBOR encode error:";
    uintMinorPrefixBytes = [];
    uintMinorPrefixBytes[23] = 1;
    uintMinorPrefixBytes[24] = 2;
    uintMinorPrefixBytes[25] = 3;
    uintMinorPrefixBytes[26] = 5;
    uintMinorPrefixBytes[27] = 9;
    uintBoundaries = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
    encodeUint.encodedSize = function encodedSize(token) {
      return encodeUintValue.encodedSize(token.value);
    };
    encodeUintValue.encodedSize = function encodedSize2(uint) {
      if (uint < uintBoundaries[0]) {
        return 1;
      }
      if (uint < uintBoundaries[1]) {
        return 2;
      }
      if (uint < uintBoundaries[2]) {
        return 3;
      }
      if (uint < uintBoundaries[3]) {
        return 5;
      }
      return 9;
    };
    encodeUint.compareTokens = function compareTokens(tok1, tok2) {
      return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : (
        /* c8 ignore next */
        0
      );
    };
    neg1b = BigInt(-1);
    pos1b = BigInt(1);
    encodeNegint.encodedSize = function encodedSize3(token) {
      const negint = token.value;
      const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
      if (unsigned < uintBoundaries[0]) {
        return 1;
      }
      if (unsigned < uintBoundaries[1]) {
        return 2;
      }
      if (unsigned < uintBoundaries[2]) {
        return 3;
      }
      if (unsigned < uintBoundaries[3]) {
        return 5;
      }
      return 9;
    };
    encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
      return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : (
        /* c8 ignore next */
        0
      );
    };
    encodeBytes.encodedSize = function encodedSize4(token) {
      const bytes22 = tokenBytes(token);
      return encodeUintValue.encodedSize(bytes22.length) + bytes22.length;
    };
    encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
      return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
    };
    encodeString = encodeBytes;
    encodeArray.compareTokens = encodeUint.compareTokens;
    encodeArray.encodedSize = function encodedSize5(token) {
      return encodeUintValue.encodedSize(token.value);
    };
    encodeMap.compareTokens = encodeUint.compareTokens;
    encodeMap.encodedSize = function encodedSize6(token) {
      return encodeUintValue.encodedSize(token.value);
    };
    encodeTag.compareTokens = encodeUint.compareTokens;
    encodeTag.encodedSize = function encodedSize7(token) {
      return encodeUintValue.encodedSize(token.value);
    };
    MINOR_FALSE = 20;
    MINOR_TRUE = 21;
    MINOR_NULL = 22;
    MINOR_UNDEFINED = 23;
    encodeFloat.encodedSize = function encodedSize8(token, options) {
      const float2 = token.value;
      if (float2 === false || float2 === true || float2 === null || float2 === void 0) {
        return 1;
      }
      if (!options || options.float64 !== true) {
        encodeFloat16(float2);
        let decoded = readFloat16(ui8a, 1);
        if (float2 === decoded || Number.isNaN(float2)) {
          return 3;
        }
        encodeFloat32(float2);
        decoded = readFloat32(ui8a, 1);
        if (float2 === decoded) {
          return 5;
        }
      }
      return 9;
    };
    buffer = new ArrayBuffer(9);
    dataView = new DataView(buffer, 1);
    ui8a = new Uint8Array(buffer, 0);
    encodeFloat.compareTokens = encodeUint.compareTokens;
    jump = [];
    for (let i = 0; i <= 23; i++) {
      jump[i] = invalidMinor;
    }
    jump[24] = decodeUint8;
    jump[25] = decodeUint16;
    jump[26] = decodeUint32;
    jump[27] = decodeUint64;
    jump[28] = invalidMinor;
    jump[29] = invalidMinor;
    jump[30] = invalidMinor;
    jump[31] = invalidMinor;
    for (let i = 32; i <= 55; i++) {
      jump[i] = invalidMinor;
    }
    jump[56] = decodeNegint8;
    jump[57] = decodeNegint16;
    jump[58] = decodeNegint32;
    jump[59] = decodeNegint64;
    jump[60] = invalidMinor;
    jump[61] = invalidMinor;
    jump[62] = invalidMinor;
    jump[63] = invalidMinor;
    for (let i = 64; i <= 87; i++) {
      jump[i] = decodeBytesCompact;
    }
    jump[88] = decodeBytes8;
    jump[89] = decodeBytes16;
    jump[90] = decodeBytes32;
    jump[91] = decodeBytes64;
    jump[92] = invalidMinor;
    jump[93] = invalidMinor;
    jump[94] = invalidMinor;
    jump[95] = errorer("indefinite length bytes/strings are not supported");
    for (let i = 96; i <= 119; i++) {
      jump[i] = decodeStringCompact;
    }
    jump[120] = decodeString8;
    jump[121] = decodeString16;
    jump[122] = decodeString32;
    jump[123] = decodeString64;
    jump[124] = invalidMinor;
    jump[125] = invalidMinor;
    jump[126] = invalidMinor;
    jump[127] = errorer("indefinite length bytes/strings are not supported");
    for (let i = 128; i <= 151; i++) {
      jump[i] = decodeArrayCompact;
    }
    jump[152] = decodeArray8;
    jump[153] = decodeArray16;
    jump[154] = decodeArray32;
    jump[155] = decodeArray64;
    jump[156] = invalidMinor;
    jump[157] = invalidMinor;
    jump[158] = invalidMinor;
    jump[159] = decodeArrayIndefinite;
    for (let i = 160; i <= 183; i++) {
      jump[i] = decodeMapCompact;
    }
    jump[184] = decodeMap8;
    jump[185] = decodeMap16;
    jump[186] = decodeMap32;
    jump[187] = decodeMap64;
    jump[188] = invalidMinor;
    jump[189] = invalidMinor;
    jump[190] = invalidMinor;
    jump[191] = decodeMapIndefinite;
    for (let i = 192; i <= 215; i++) {
      jump[i] = decodeTagCompact;
    }
    jump[216] = decodeTag8;
    jump[217] = decodeTag16;
    jump[218] = decodeTag32;
    jump[219] = decodeTag64;
    jump[220] = invalidMinor;
    jump[221] = invalidMinor;
    jump[222] = invalidMinor;
    jump[223] = invalidMinor;
    for (let i = 224; i <= 243; i++) {
      jump[i] = errorer("simple values are not supported");
    }
    jump[244] = invalidMinor;
    jump[245] = invalidMinor;
    jump[246] = invalidMinor;
    jump[247] = decodeUndefined;
    jump[248] = errorer("simple values are not supported");
    jump[249] = decodeFloat16;
    jump[250] = decodeFloat32;
    jump[251] = decodeFloat64;
    jump[252] = invalidMinor;
    jump[253] = invalidMinor;
    jump[254] = invalidMinor;
    jump[255] = decodeBreak;
    quick = [];
    for (let i = 0; i < 24; i++) {
      quick[i] = new Token(Type.uint, i, 1);
    }
    for (let i = -1; i >= -24; i--) {
      quick[31 - i] = new Token(Type.negint, i, 1);
    }
    quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
    quick[96] = new Token(Type.string, "", 1);
    quick[128] = new Token(Type.array, 0, 1);
    quick[160] = new Token(Type.map, 0, 1);
    quick[244] = new Token(Type.false, false, 1);
    quick[245] = new Token(Type.true, true, 1);
    quick[246] = new Token(Type.null, null, 1);
    defaultEncodeOptions = {
      float64: false,
      mapSorter,
      quickEncodeToken
    };
    cborEncoders = makeCborEncoders();
    buf = new Bl();
    Ref = class _Ref {
      /**
       * @param {object|any[]} obj
       * @param {Reference|undefined} parent
       */
      constructor(obj, parent) {
        this.obj = obj;
        this.parent = parent;
      }
      /**
       * @param {object|any[]} obj
       * @returns {boolean}
       */
      includes(obj) {
        let p = this;
        do {
          if (p.obj === obj) {
            return true;
          }
        } while (p = p.parent);
        return false;
      }
      /**
       * @param {Reference|undefined} stack
       * @param {object|any[]} obj
       * @returns {Reference}
       */
      static createCheck(stack, obj) {
        if (stack && stack.includes(obj)) {
          throw new Error(`${encodeErrPrefix} object contains circular references`);
        }
        return new _Ref(obj, stack);
      }
    };
    simpleTokens = {
      null: new Token(Type.null, null),
      undefined: new Token(Type.undefined, void 0),
      true: new Token(Type.true, true),
      false: new Token(Type.false, false),
      emptyArray: new Token(Type.array, 0),
      emptyMap: new Token(Type.map, 0)
    };
    typeEncoders = {
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      number(obj, _typ, _options2, _refStack) {
        if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
          return new Token(Type.float, obj);
        } else if (obj >= 0) {
          return new Token(Type.uint, obj);
        } else {
          return new Token(Type.negint, obj);
        }
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      bigint(obj, _typ, _options2, _refStack) {
        if (obj >= BigInt(0)) {
          return new Token(Type.uint, obj);
        } else {
          return new Token(Type.negint, obj);
        }
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      Uint8Array(obj, _typ, _options2, _refStack) {
        return new Token(Type.bytes, obj);
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      string(obj, _typ, _options2, _refStack) {
        return new Token(Type.string, obj);
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      boolean(obj, _typ, _options2, _refStack) {
        return obj ? simpleTokens.true : simpleTokens.false;
      },
      /**
       * @param {any} _obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      null(_obj, _typ, _options2, _refStack) {
        return simpleTokens.null;
      },
      /**
       * @param {any} _obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      undefined(_obj, _typ, _options2, _refStack) {
        return simpleTokens.undefined;
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      ArrayBuffer(obj, _typ, _options2, _refStack) {
        return new Token(Type.bytes, new Uint8Array(obj));
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      DataView(obj, _typ, _options2, _refStack) {
        return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} options
       * @param {Reference} [refStack]
       * @returns {TokenOrNestedTokens}
       */
      Array(obj, _typ, options, refStack) {
        if (!obj.length) {
          if (options.addBreakTokens === true) {
            return [simpleTokens.emptyArray, new Token(Type.break)];
          }
          return simpleTokens.emptyArray;
        }
        refStack = Ref.createCheck(refStack, obj);
        const entries3 = [];
        let i = 0;
        for (const e of obj) {
          entries3[i++] = objectToTokens(e, options, refStack);
        }
        if (options.addBreakTokens) {
          return [new Token(Type.array, obj.length), entries3, new Token(Type.break)];
        }
        return [new Token(Type.array, obj.length), entries3];
      },
      /**
       * @param {any} obj
       * @param {string} typ
       * @param {EncodeOptions} options
       * @param {Reference} [refStack]
       * @returns {TokenOrNestedTokens}
       */
      Object(obj, typ, options, refStack) {
        const isMap = typ !== "Object";
        const keys2 = isMap ? obj.keys() : Object.keys(obj);
        const length42 = isMap ? obj.size : keys2.length;
        if (!length42) {
          if (options.addBreakTokens === true) {
            return [simpleTokens.emptyMap, new Token(Type.break)];
          }
          return simpleTokens.emptyMap;
        }
        refStack = Ref.createCheck(refStack, obj);
        const entries3 = [];
        let i = 0;
        for (const key of keys2) {
          entries3[i++] = [
            objectToTokens(key, options, refStack),
            objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
          ];
        }
        sortMapEntries(entries3, options);
        if (options.addBreakTokens) {
          return [new Token(Type.map, length42), entries3, new Token(Type.break)];
        }
        return [new Token(Type.map, length42), entries3];
      }
    };
    typeEncoders.Map = typeEncoders.Object;
    typeEncoders.Buffer = typeEncoders.Uint8Array;
    for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
      typeEncoders[`${typ}Array`] = typeEncoders.DataView;
    }
    defaultDecodeOptions = {
      strict: false,
      allowIndefinite: true,
      allowUndefined: true,
      allowBigInt: true
    };
    Tokeniser = class {
      /**
       * @param {Uint8Array} data
       * @param {DecodeOptions} options
       */
      constructor(data, options = {}) {
        this._pos = 0;
        this.data = data;
        this.options = options;
      }
      pos() {
        return this._pos;
      }
      done() {
        return this._pos >= this.data.length;
      }
      next() {
        const byt = this.data[this._pos];
        let token = quick[byt];
        if (token === void 0) {
          const decoder32 = jump[byt];
          if (!decoder32) {
            throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
          }
          const minor = byt & 31;
          token = decoder32(this.data, this._pos, minor, this.options);
        }
        this._pos += token.encodedLength;
        return token;
      }
    };
    DONE = Symbol.for("DONE");
    BREAK = Symbol.for("BREAK");
    base32_exports = {};
    __export2(base32_exports, {
      base32: () => base32,
      base32hex: () => base32hex,
      base32hexpad: () => base32hexpad,
      base32hexpadupper: () => base32hexpadupper,
      base32hexupper: () => base32hexupper,
      base32pad: () => base32pad,
      base32padupper: () => base32padupper,
      base32upper: () => base32upper,
      base32z: () => base32z
    });
    bytes_exports2 = {};
    __export2(bytes_exports2, {
      coerce: () => coerce2,
      empty: () => empty3,
      equals: () => equals2,
      fromHex: () => fromHex,
      fromString: () => fromString2,
      isBinary: () => isBinary,
      toHex: () => toHex,
      toString: () => toString2
    });
    empty3 = new Uint8Array(0);
    src = base;
    _brrp__multiformats_scope_baseX = src;
    base_x_default = _brrp__multiformats_scope_baseX;
    Encoder = class {
      constructor(name142, prefix2, baseEncode) {
        __publicField(this, "name");
        __publicField(this, "prefix");
        __publicField(this, "baseEncode");
        this.name = name142;
        this.prefix = prefix2;
        this.baseEncode = baseEncode;
      }
      encode(bytes22) {
        if (bytes22 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes22)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder = class {
      constructor(name142, prefix2, baseDecode) {
        __publicField(this, "name");
        __publicField(this, "prefix");
        __publicField(this, "baseDecode");
        __publicField(this, "prefixCodePoint");
        this.name = name142;
        this.prefix = prefix2;
        if (prefix2.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix2.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text2) {
        if (typeof text2 === "string") {
          if (text2.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text2.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder32) {
        return or(this, decoder32);
      }
    };
    ComposedDecoder = class {
      constructor(decoders) {
        __publicField(this, "decoders");
        this.decoders = decoders;
      }
      or(decoder32) {
        return or(this, decoder32);
      }
      decode(input10) {
        const prefix2 = input10[0];
        const decoder32 = this.decoders[prefix2];
        if (decoder32 != null) {
          return decoder32.decode(input10);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input10)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    Codec = class {
      constructor(name142, prefix2, baseEncode, baseDecode) {
        __publicField(this, "name");
        __publicField(this, "prefix");
        __publicField(this, "baseEncode");
        __publicField(this, "baseDecode");
        __publicField(this, "encoder");
        __publicField(this, "decoder");
        this.name = name142;
        this.prefix = prefix2;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name142, prefix2, baseEncode);
        this.decoder = new Decoder(name142, prefix2, baseDecode);
      }
      encode(input10) {
        return this.encoder.encode(input10);
      }
      decode(input10) {
        return this.decoder.decode(input10);
      }
    };
    base32 = rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper = rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad = rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper = rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex = rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper = rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad = rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper = rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z = rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
    base58_exports = {};
    __export2(base58_exports, {
      base58btc: () => base58btc,
      base58flickr: () => base58flickr
    });
    base58btc = baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr = baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
    encode_1 = encode3;
    MSB = 128;
    REST = 127;
    MSBALL = ~REST;
    INT = Math.pow(2, 31);
    decode3 = read;
    MSB$1 = 128;
    REST$1 = 127;
    N1 = Math.pow(2, 7);
    N2 = Math.pow(2, 14);
    N3 = Math.pow(2, 21);
    N4 = Math.pow(2, 28);
    N5 = Math.pow(2, 35);
    N6 = Math.pow(2, 42);
    N7 = Math.pow(2, 49);
    N8 = Math.pow(2, 56);
    N9 = Math.pow(2, 63);
    length = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
    varint = {
      encode: encode_1,
      decode: decode3,
      encodingLength: length
    };
    _brrp_varint = varint;
    varint_default = _brrp_varint;
    Digest2 = class {
      /**
       * Creates a multihash digest.
       */
      constructor(code192, size5, digest52, bytes22) {
        __publicField(this, "code");
        __publicField(this, "size");
        __publicField(this, "digest");
        __publicField(this, "bytes");
        this.code = code192;
        this.size = size5;
        this.digest = digest52;
        this.bytes = bytes22;
      }
    };
    cache = /* @__PURE__ */ new WeakMap();
    CID = class _CID {
      /**
       * @param version - Version of the CID
       * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param multihash - (Multi)hash of the of the content.
       */
      constructor(version22, code192, multihash, bytes22) {
        __publicField(this, "code");
        __publicField(this, "version");
        __publicField(this, "multihash");
        __publicField(this, "bytes");
        __publicField(this, "/");
        __publicField(this, _a, "CID");
        this.code = code192;
        this.version = version22;
        this.multihash = multihash;
        this.bytes = bytes22;
        this["/"] = bytes22;
      }
      /**
       * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
       * please either use `CID.asCID(cid)` or switch to new signalling mechanism
       *
       * @deprecated
       */
      get asCID() {
        return this;
      }
      // ArrayBufferView
      get byteOffset() {
        return this.bytes.byteOffset;
      }
      // ArrayBufferView
      get byteLength() {
        return this.bytes.byteLength;
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          case 1: {
            const { code: code192, multihash } = this;
            if (code192 !== DAG_PB_CODE) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return _CID.createV0(multihash);
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code192, digest: digest52 } = this.multihash;
            const multihash = create(code192, digest52);
            return _CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return _CID.equals(this, other);
      }
      static equals(self2, other) {
        const unknown2 = other;
        return unknown2 != null && self2.code === unknown2.code && self2.version === unknown2.version && equals3(self2.multihash, unknown2.multihash);
      }
      toString(base42) {
        return format(this, base42);
      }
      toJSON() {
        return { "/": format(this) };
      }
      link() {
        return this;
      }
      // Legacy
      [(_a = Symbol.toStringTag, Symbol.for("nodejs.util.inspect.custom"))]() {
        return `CID(${this.toString()})`;
      }
      /**
       * Takes any input `value` and returns a `CID` instance if it was
       * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
       * it will return value back. If `value` is not instance of this CID
       * class, but is compatible CID it will return new instance of this
       * `CID` class. Otherwise returns null.
       *
       * This allows two different incompatible versions of CID library to
       * co-exist and interop as long as binary interface is compatible.
       */
      static asCID(input10) {
        if (input10 == null) {
          return null;
        }
        const value = input10;
        if (value instanceof _CID) {
          return value;
        } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
          const { version: version22, code: code192, multihash, bytes: bytes22 } = value;
          return new _CID(version22, code192, multihash, bytes22 ?? encodeCID(version22, code192, multihash.bytes));
        } else if (value[cidSymbol] === true) {
          const { version: version22, multihash, code: code192 } = value;
          const digest52 = decode5(multihash);
          return _CID.create(version22, code192, digest52);
        } else {
          return null;
        }
      }
      /**
       * @param version - Version of the CID
       * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param digest - (Multi)hash of the of the content.
       */
      static create(version22, code192, digest52) {
        if (typeof code192 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        if (!(digest52.bytes instanceof Uint8Array)) {
          throw new Error("Invalid digest");
        }
        switch (version22) {
          case 0: {
            if (code192 !== DAG_PB_CODE) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
            } else {
              return new _CID(version22, code192, digest52, digest52.bytes);
            }
          }
          case 1: {
            const bytes22 = encodeCID(version22, code192, digest52.bytes);
            return new _CID(version22, code192, digest52, bytes22);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      /**
       * Simplified version of `create` for CIDv0.
       */
      static createV0(digest52) {
        return _CID.create(0, DAG_PB_CODE, digest52);
      }
      /**
       * Simplified version of `create` for CIDv1.
       *
       * @param code - Content encoding format code.
       * @param digest - Multihash of the content.
       */
      static createV1(code192, digest52) {
        return _CID.create(1, code192, digest52);
      }
      /**
       * Decoded a CID from its binary representation. The byte array must contain
       * only the CID with no additional bytes.
       *
       * An error will be thrown if the bytes provided do not contain a valid
       * binary representation of a CID.
       */
      static decode(bytes22) {
        const [cid, remainder] = _CID.decodeFirst(bytes22);
        if (remainder.length !== 0) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      /**
       * Decoded a CID from its binary representation at the beginning of a byte
       * array.
       *
       * Returns an array with the first element containing the CID and the second
       * element containing the remainder of the original byte array. The remainder
       * will be a zero-length byte array if the provided bytes only contained a
       * binary CID representation.
       */
      static decodeFirst(bytes22) {
        const specs = _CID.inspectBytes(bytes22);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce2(bytes22.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest52 = new Digest2(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? _CID.createV0(digest52) : _CID.createV1(specs.codec, digest52);
        return [cid, bytes22.subarray(specs.size)];
      }
      /**
       * Inspect the initial bytes of a CID to determine its properties.
       *
       * Involves decoding up to 4 varints. Typically this will require only 4 to 6
       * bytes but for larger multicodec code values and larger multihash digest
       * lengths these varints can be quite large. It is recommended that at least
       * 10 bytes be made available in the `initialBytes` argument for a complete
       * inspection.
       */
      static inspectBytes(initialBytes) {
        let offset22 = 0;
        const next = () => {
          const [i, length42] = decode4(initialBytes.subarray(offset22));
          offset22 += length42;
          return i;
        };
        let version22 = next();
        let codec = DAG_PB_CODE;
        if (version22 === 18) {
          version22 = 0;
          offset22 = 0;
        } else {
          codec = next();
        }
        if (version22 !== 0 && version22 !== 1) {
          throw new RangeError(`Invalid CID version ${version22}`);
        }
        const prefixSize = offset22;
        const multihashCode = next();
        const digestSize = next();
        const size5 = offset22 + digestSize;
        const multihashSize = size5 - prefixSize;
        return { version: version22, codec, multihashCode, digestSize, multihashSize, size: size5 };
      }
      /**
       * Takes cid in a string representation and creates an instance. If `base`
       * decoder is not provided will use a default from the configuration. It will
       * throw an error if encoding of the CID is not compatible with supplied (or
       * a default decoder).
       */
      static parse(source, base42) {
        const [prefix2, bytes22] = parseCIDtoBytes(source, base42);
        const cid = _CID.decode(bytes22);
        if (cid.version === 0 && source[0] !== "Q") {
          throw Error("Version 0 CID string must not include multibase prefix");
        }
        baseCache(cid).set(prefix2, source);
        return cid;
      }
    };
    DAG_PB_CODE = 112;
    SHA_256_CODE = 18;
    cidSymbol = Symbol.for("@ipld/js-cid/CID");
    CID_CBOR_TAG = 42;
    _encodeOptions = {
      float64: true,
      typeEncoders: {
        Object: cidEncoder,
        undefined: undefinedEncoder,
        number: numberEncoder
      }
    };
    encodeOptions = {
      ..._encodeOptions,
      typeEncoders: {
        ..._encodeOptions.typeEncoders
      }
    };
    _decodeOptions = {
      allowIndefinite: false,
      coerceUndefinedToNull: true,
      allowNaN: false,
      allowInfinity: false,
      allowBigInt: true,
      // this will lead to BigInt for ints outside of
      // safe-integer range, which may surprise users
      strict: true,
      useMaps: false,
      rejectDuplicateMapKeys: true,
      /** @type {import('cborg').TagDecoder[]} */
      tags: []
    };
    _decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
    decodeOptions = {
      ..._decodeOptions,
      tags: _decodeOptions.tags.slice()
    };
    name2 = "dag-cbor";
    code3 = 113;
    encode4 = (node) => encode(node, _encodeOptions);
    decode6 = (data) => decode(toByteView(data), _decodeOptions);
    varint_exports2 = {};
    __export2(varint_exports2, {
      decode: () => decode8,
      encodeTo: () => encodeTo2,
      encodingLength: () => encodingLength2
    });
    encode_12 = encode5;
    MSB2 = 128;
    REST2 = 127;
    MSBALL2 = ~REST2;
    INT2 = Math.pow(2, 31);
    decode7 = read2;
    MSB$12 = 128;
    REST$12 = 127;
    N12 = Math.pow(2, 7);
    N22 = Math.pow(2, 14);
    N32 = Math.pow(2, 21);
    N42 = Math.pow(2, 28);
    N52 = Math.pow(2, 35);
    N62 = Math.pow(2, 42);
    N72 = Math.pow(2, 49);
    N82 = Math.pow(2, 56);
    N92 = Math.pow(2, 63);
    length2 = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
    varint2 = {
      encode: encode_12,
      decode: decode7,
      encodingLength: length2
    };
    _brrp_varint2 = varint2;
    varint_default2 = _brrp_varint2;
    decode8 = (data, offset22 = 0) => {
      const code192 = varint_default2.decode(data, offset22);
      return [code192, varint_default2.decode.bytes];
    };
    encodeTo2 = (int2, target, offset22 = 0) => {
      varint_default2.encode(int2, target, offset22);
      return target;
    };
    encodingLength2 = (int2) => {
      return varint_default2.encodingLength(int2);
    };
    create2 = (code192, digest52) => {
      const size5 = digest52.byteLength;
      const sizeOffset = encodingLength2(code192);
      const digestOffset = sizeOffset + encodingLength2(size5);
      const bytes22 = new Uint8Array(digestOffset + size5);
      encodeTo2(code192, bytes22, 0);
      encodeTo2(size5, bytes22, sizeOffset);
      bytes22.set(digest52, digestOffset);
      return new Digest3(code192, size5, digest52, bytes22);
    };
    decode9 = (multihash) => {
      const bytes22 = coerce(multihash);
      const [code192, sizeOffset] = decode8(bytes22);
      const [size5, digestOffset] = decode8(bytes22.subarray(sizeOffset));
      const digest52 = bytes22.subarray(sizeOffset + digestOffset);
      if (digest52.byteLength !== size5) {
        throw new Error("Incorrect length");
      }
      return new Digest3(code192, size5, digest52, bytes22);
    };
    equals4 = (a, b) => {
      if (a === b) {
        return true;
      } else {
        const data = (
          /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
          b
        );
        return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals(a.bytes, data.bytes);
      }
    };
    Digest3 = class {
      /**
       * Creates a multihash digest.
       *
       * @param {Code} code
       * @param {Size} size
       * @param {Uint8Array} digest
       * @param {Uint8Array} bytes
       */
      constructor(code192, size5, digest52, bytes22) {
        this.code = code192;
        this.size = size5;
        this.digest = digest52;
        this.bytes = bytes22;
      }
    };
    src2 = base2;
    _brrp__multiformats_scope_baseX2 = src2;
    base_x_default2 = _brrp__multiformats_scope_baseX2;
    Encoder2 = class {
      /**
       * @param {Base} name
       * @param {Prefix} prefix
       * @param {(bytes:Uint8Array) => string} baseEncode
       */
      constructor(name142, prefix2, baseEncode) {
        this.name = name142;
        this.prefix = prefix2;
        this.baseEncode = baseEncode;
      }
      /**
       * @param {Uint8Array} bytes
       * @returns {API.Multibase<Prefix>}
       */
      encode(bytes22) {
        if (bytes22 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes22)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder2 = class {
      /**
       * @param {Base} name
       * @param {Prefix} prefix
       * @param {(text:string) => Uint8Array} baseDecode
       */
      constructor(name142, prefix2, baseDecode) {
        this.name = name142;
        this.prefix = prefix2;
        if (prefix2.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = /** @type {number} */
        prefix2.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      /**
       * @param {string} text
       */
      decode(text2) {
        if (typeof text2 === "string") {
          if (text2.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text2.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      /**
       * @template {string} OtherPrefix
       * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
       * @returns {ComposedDecoder<Prefix|OtherPrefix>}
       */
      or(decoder32) {
        return or2(this, decoder32);
      }
    };
    ComposedDecoder2 = class {
      /**
       * @param {Decoders<Prefix>} decoders
       */
      constructor(decoders) {
        this.decoders = decoders;
      }
      /**
       * @template {string} OtherPrefix
       * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
       * @returns {ComposedDecoder<Prefix|OtherPrefix>}
       */
      or(decoder32) {
        return or2(this, decoder32);
      }
      /**
       * @param {string} input
       * @returns {Uint8Array}
       */
      decode(input10) {
        const prefix2 = (
          /** @type {Prefix} */
          input10[0]
        );
        const decoder32 = this.decoders[prefix2];
        if (decoder32) {
          return decoder32.decode(input10);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input10)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    or2 = (left, right) => new ComposedDecoder2(
      /** @type {Decoders<L|R>} */
      {
        ...left.decoders || { [
          /** @type API.UnibaseDecoder<L> */
          left.prefix
        ]: left },
        ...right.decoders || { [
          /** @type API.UnibaseDecoder<R> */
          right.prefix
        ]: right }
      }
    );
    Codec2 = class {
      /**
       * @param {Base} name
       * @param {Prefix} prefix
       * @param {(bytes:Uint8Array) => string} baseEncode
       * @param {(text:string) => Uint8Array} baseDecode
       */
      constructor(name142, prefix2, baseEncode, baseDecode) {
        this.name = name142;
        this.prefix = prefix2;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder2(name142, prefix2, baseEncode);
        this.decoder = new Decoder2(name142, prefix2, baseDecode);
      }
      /**
       * @param {Uint8Array} input
       */
      encode(input10) {
        return this.encoder.encode(input10);
      }
      /**
       * @param {string} input
       */
      decode(input10) {
        return this.decoder.decode(input10);
      }
    };
    from3 = ({ name: name142, prefix: prefix2, encode: encode342, decode: decode412 }) => new Codec2(name142, prefix2, encode342, decode412);
    baseX2 = ({ prefix: prefix2, name: name142, alphabet: alphabet22 }) => {
      const { encode: encode342, decode: decode412 } = base_x_default2(alphabet22, name142);
      return from3({
        prefix: prefix2,
        name: name142,
        encode: encode342,
        /**
         * @param {string} text
         */
        decode: (text2) => coerce(decode412(text2))
      });
    };
    decode10 = (string32, alphabet22, bitsPerChar, name142) => {
      const codes = {};
      for (let i = 0; i < alphabet22.length; ++i) {
        codes[alphabet22[i]] = i;
      }
      let end = string32.length;
      while (string32[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer22 = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string32[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name142} character`);
        }
        buffer22 = buffer22 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer22 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer22 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    encode6 = (data, alphabet22, bitsPerChar) => {
      const pad2 = alphabet22[alphabet22.length - 1] === "=";
      const mask2 = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer22 = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer22 = buffer22 << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet22[mask2 & buffer22 >> bits];
        }
      }
      if (bits) {
        out += alphabet22[mask2 & buffer22 << bitsPerChar - bits];
      }
      if (pad2) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    rfc46482 = ({ name: name142, prefix: prefix2, bitsPerChar, alphabet: alphabet22 }) => {
      return from3({
        prefix: prefix2,
        name: name142,
        encode(input10) {
          return encode6(input10, alphabet22, bitsPerChar);
        },
        decode(input10) {
          return decode10(input10, alphabet22, bitsPerChar, name142);
        }
      });
    };
    base58btc2 = baseX2({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr2 = baseX2({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
    base322 = rfc46482({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper2 = rfc46482({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad2 = rfc46482({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper2 = rfc46482({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex2 = rfc46482({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper2 = rfc46482({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad2 = rfc46482({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper2 = rfc46482({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z2 = rfc46482({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
    format2 = (link5, base42) => {
      const { bytes: bytes22, version: version22 } = link5;
      switch (version22) {
        case 0:
          return toStringV02(
            bytes22,
            baseCache2(link5),
            /** @type {API.MultibaseEncoder<"z">} */
            base42 || base58btc2.encoder
          );
        default:
          return toStringV12(
            bytes22,
            baseCache2(link5),
            /** @type {API.MultibaseEncoder<Prefix>} */
            base42 || base322.encoder
          );
      }
    };
    cache2 = /* @__PURE__ */ new WeakMap();
    baseCache2 = (cid) => {
      const baseCache4 = cache2.get(cid);
      if (baseCache4 == null) {
        const baseCache5 = /* @__PURE__ */ new Map();
        cache2.set(cid, baseCache5);
        return baseCache5;
      }
      return baseCache4;
    };
    CID2 = class _CID2 {
      /**
       * @param {Version} version - Version of the CID
       * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
       * @param {Uint8Array} bytes
       *
       */
      constructor(version22, code192, multihash, bytes22) {
        this.code = code192;
        this.version = version22;
        this.multihash = multihash;
        this.bytes = bytes22;
        this["/"] = bytes22;
      }
      /**
       * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
       * please either use `CID.asCID(cid)` or switch to new signalling mechanism
       *
       * @deprecated
       */
      get asCID() {
        return this;
      }
      // ArrayBufferView
      get byteOffset() {
        return this.bytes.byteOffset;
      }
      // ArrayBufferView
      get byteLength() {
        return this.bytes.byteLength;
      }
      /**
       * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
       */
      toV0() {
        switch (this.version) {
          case 0: {
            return (
              /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
              this
            );
          }
          case 1: {
            const { code: code192, multihash } = this;
            if (code192 !== DAG_PB_CODE2) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE2) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return (
              /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
              _CID2.createV0(
                /** @type {API.MultihashDigest<API.SHA_256>} */
                multihash
              )
            );
          }
          default: {
            throw Error(
              `Can not convert CID version ${this.version} to version 0. This is a bug please report`
            );
          }
        }
      }
      /**
       * @returns {CID<Data, Format, Alg, 1>}
       */
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code192, digest: digest52 } = this.multihash;
            const multihash = create2(code192, digest52);
            return (
              /** @type {CID<Data, Format, Alg, 1>} */
              _CID2.createV1(this.code, multihash)
            );
          }
          case 1: {
            return (
              /** @type {CID<Data, Format, Alg, 1>} */
              this
            );
          }
          default: {
            throw Error(
              `Can not convert CID version ${this.version} to version 1. This is a bug please report`
            );
          }
        }
      }
      /**
       * @param {unknown} other
       * @returns {other is CID<Data, Format, Alg, Version>}
       */
      equals(other) {
        return _CID2.equals(this, other);
      }
      /**
       * @template {unknown} Data
       * @template {number} Format
       * @template {number} Alg
       * @template {API.Version} Version
       * @param {API.Link<Data, Format, Alg, Version>} self
       * @param {unknown} other
       * @returns {other is CID}
       */
      static equals(self2, other) {
        const unknown2 = (
          /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
          other
        );
        return unknown2 && self2.code === unknown2.code && self2.version === unknown2.version && equals4(self2.multihash, unknown2.multihash);
      }
      /**
       * @param {API.MultibaseEncoder<string>} [base]
       * @returns {string}
       */
      toString(base42) {
        return format2(this, base42);
      }
      toJSON() {
        return { "/": format2(this) };
      }
      link() {
        return this;
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      // Legacy
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return `CID(${this.toString()})`;
      }
      /**
       * Takes any input `value` and returns a `CID` instance if it was
       * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
       * it will return value back. If `value` is not instance of this CID
       * class, but is compatible CID it will return new instance of this
       * `CID` class. Otherwise returns null.
       *
       * This allows two different incompatible versions of CID library to
       * co-exist and interop as long as binary interface is compatible.
       *
       * @template {unknown} Data
       * @template {number} Format
       * @template {number} Alg
       * @template {API.Version} Version
       * @template {unknown} U
       * @param {API.Link<Data, Format, Alg, Version>|U} input
       * @returns {CID<Data, Format, Alg, Version>|null}
       */
      static asCID(input10) {
        if (input10 == null) {
          return null;
        }
        const value = (
          /** @type {any} */
          input10
        );
        if (value instanceof _CID2) {
          return value;
        } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
          const { version: version22, code: code192, multihash, bytes: bytes22 } = value;
          return new _CID2(
            version22,
            code192,
            /** @type {API.MultihashDigest<Alg>} */
            multihash,
            bytes22 || encodeCID2(version22, code192, multihash.bytes)
          );
        } else if (value[cidSymbol2] === true) {
          const { version: version22, multihash, code: code192 } = value;
          const digest52 = (
            /** @type {API.MultihashDigest<Alg>} */
            decode9(multihash)
          );
          return _CID2.create(version22, code192, digest52);
        } else {
          return null;
        }
      }
      /**
       *
       * @template {unknown} Data
       * @template {number} Format
       * @template {number} Alg
       * @template {API.Version} Version
       * @param {Version} version - Version of the CID
       * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
       * @returns {CID<Data, Format, Alg, Version>}
       */
      static create(version22, code192, digest52) {
        if (typeof code192 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        if (!(digest52.bytes instanceof Uint8Array)) {
          throw new Error("Invalid digest");
        }
        switch (version22) {
          case 0: {
            if (code192 !== DAG_PB_CODE2) {
              throw new Error(
                `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`
              );
            } else {
              return new _CID2(version22, code192, digest52, digest52.bytes);
            }
          }
          case 1: {
            const bytes22 = encodeCID2(version22, code192, digest52.bytes);
            return new _CID2(version22, code192, digest52, bytes22);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      /**
       * Simplified version of `create` for CIDv0.
       *
       * @template {unknown} [T=unknown]
       * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
       * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
       */
      static createV0(digest52) {
        return _CID2.create(0, DAG_PB_CODE2, digest52);
      }
      /**
       * Simplified version of `create` for CIDv1.
       *
       * @template {unknown} Data
       * @template {number} Code
       * @template {number} Alg
       * @param {Code} code - Content encoding format code.
       * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
       * @returns {CID<Data, Code, Alg, 1>}
       */
      static createV1(code192, digest52) {
        return _CID2.create(1, code192, digest52);
      }
      /**
       * Decoded a CID from its binary representation. The byte array must contain
       * only the CID with no additional bytes.
       *
       * An error will be thrown if the bytes provided do not contain a valid
       * binary representation of a CID.
       *
       * @template {unknown} Data
       * @template {number} Code
       * @template {number} Alg
       * @template {API.Version} Ver
       * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
       * @returns {CID<Data, Code, Alg, Ver>}
       */
      static decode(bytes22) {
        const [cid, remainder] = _CID2.decodeFirst(bytes22);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      /**
       * Decoded a CID from its binary representation at the beginning of a byte
       * array.
       *
       * Returns an array with the first element containing the CID and the second
       * element containing the remainder of the original byte array. The remainder
       * will be a zero-length byte array if the provided bytes only contained a
       * binary CID representation.
       *
       * @template {unknown} T
       * @template {number} C
       * @template {number} A
       * @template {API.Version} V
       * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
       * @returns {[CID<T, C, A, V>, Uint8Array]}
       */
      static decodeFirst(bytes22) {
        const specs = _CID2.inspectBytes(bytes22);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce(
          bytes22.subarray(prefixSize, prefixSize + specs.multihashSize)
        );
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(
          specs.multihashSize - specs.digestSize
        );
        const digest52 = new Digest3(
          specs.multihashCode,
          specs.digestSize,
          digestBytes,
          multihashBytes
        );
        const cid = specs.version === 0 ? _CID2.createV0(
          /** @type {API.MultihashDigest<API.SHA_256>} */
          digest52
        ) : _CID2.createV1(specs.codec, digest52);
        return [
          /** @type {CID<T, C, A, V>} */
          cid,
          bytes22.subarray(specs.size)
        ];
      }
      /**
       * Inspect the initial bytes of a CID to determine its properties.
       *
       * Involves decoding up to 4 varints. Typically this will require only 4 to 6
       * bytes but for larger multicodec code values and larger multihash digest
       * lengths these varints can be quite large. It is recommended that at least
       * 10 bytes be made available in the `initialBytes` argument for a complete
       * inspection.
       *
       * @template {unknown} T
       * @template {number} C
       * @template {number} A
       * @template {API.Version} V
       * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
       * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
       */
      static inspectBytes(initialBytes) {
        let offset22 = 0;
        const next = () => {
          const [i, length42] = decode8(initialBytes.subarray(offset22));
          offset22 += length42;
          return i;
        };
        let version22 = (
          /** @type {V} */
          next()
        );
        let codec = (
          /** @type {C} */
          DAG_PB_CODE2
        );
        if (
          /** @type {number} */
          version22 === 18
        ) {
          version22 = /** @type {V} */
          0;
          offset22 = 0;
        } else {
          codec = /** @type {C} */
          next();
        }
        if (version22 !== 0 && version22 !== 1) {
          throw new RangeError(`Invalid CID version ${version22}`);
        }
        const prefixSize = offset22;
        const multihashCode = (
          /** @type {A} */
          next()
        );
        const digestSize = next();
        const size5 = offset22 + digestSize;
        const multihashSize = size5 - prefixSize;
        return { version: version22, codec, multihashCode, digestSize, multihashSize, size: size5 };
      }
      /**
       * Takes cid in a string representation and creates an instance. If `base`
       * decoder is not provided will use a default from the configuration. It will
       * throw an error if encoding of the CID is not compatible with supplied (or
       * a default decoder).
       *
       * @template {string} Prefix
       * @template {unknown} Data
       * @template {number} Code
       * @template {number} Alg
       * @template {API.Version} Ver
       * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
       * @param {API.MultibaseDecoder<Prefix>} [base]
       * @returns {CID<Data, Code, Alg, Ver>}
       */
      static parse(source, base42) {
        const [prefix2, bytes22] = parseCIDtoBytes2(source, base42);
        const cid = _CID2.decode(bytes22);
        if (cid.version === 0 && source[0] !== "Q") {
          throw Error("Version 0 CID string must not include multibase prefix");
        }
        baseCache2(cid).set(prefix2, source);
        return cid;
      }
    };
    parseCIDtoBytes2 = (source, base42) => {
      switch (source[0]) {
        case "Q": {
          const decoder32 = base42 || base58btc2;
          return [
            /** @type {Prefix} */
            base58btc2.prefix,
            decoder32.decode(`${base58btc2.prefix}${source}`)
          ];
        }
        case base58btc2.prefix: {
          const decoder32 = base42 || base58btc2;
          return [
            /** @type {Prefix} */
            base58btc2.prefix,
            decoder32.decode(source)
          ];
        }
        case base322.prefix: {
          const decoder32 = base42 || base322;
          return [
            /** @type {Prefix} */
            base322.prefix,
            decoder32.decode(source)
          ];
        }
        default: {
          if (base42 == null) {
            throw Error(
              "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
            );
          }
          return [
            /** @type {Prefix} */
            source[0],
            base42.decode(source)
          ];
        }
      }
    };
    toStringV02 = (bytes22, cache5, base42) => {
      const { prefix: prefix2 } = base42;
      if (prefix2 !== base58btc2.prefix) {
        throw Error(`Cannot string encode V0 in ${base42.name} encoding`);
      }
      const cid = cache5.get(prefix2);
      if (cid == null) {
        const cid2 = base42.encode(bytes22).slice(1);
        cache5.set(prefix2, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    toStringV12 = (bytes22, cache5, base42) => {
      const { prefix: prefix2 } = base42;
      const cid = cache5.get(prefix2);
      if (cid == null) {
        const cid2 = base42.encode(bytes22);
        cache5.set(prefix2, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    DAG_PB_CODE2 = 112;
    SHA_256_CODE2 = 18;
    encodeCID2 = (version22, code192, multihash) => {
      const codeOffset = encodingLength2(version22);
      const hashOffset = codeOffset + encodingLength2(code192);
      const bytes22 = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo2(version22, bytes22, 0);
      encodeTo2(code192, bytes22, codeOffset);
      bytes22.set(multihash, hashOffset);
      return bytes22;
    };
    cidSymbol2 = Symbol.for("@ipld/js-cid/CID");
    DAG_PB_CODE3 = 112;
    createLegacy = (digest52) => CID2.create(0, DAG_PB_CODE3, digest52);
    create3 = (code192, digest52) => CID2.create(1, code192, digest52);
    isLink = (value) => {
      if (value == null) {
        return false;
      }
      const withSlash = (
        /** @type {{'/'?: Uint8Array, bytes: Uint8Array}} */
        value
      );
      if (withSlash["/"] != null && withSlash["/"] === withSlash.bytes) {
        return true;
      }
      const withAsCID = (
        /** @type {{'asCID'?: unknown}} */
        value
      );
      if (withAsCID.asCID === value) {
        return true;
      }
      return false;
    };
    parse = (source, base42) => CID2.parse(source, base42);
    computeNode = (left, right) => {
      const payload = new Uint8Array(left.length + right.length);
      payload.set(left, 0);
      payload.set(right, left.length);
      return truncatedHash(payload);
    };
    MAX_LEVEL = 64;
    ZeroComm = class {
      constructor() {
        this.bytes = new Uint8Array(MAX_LEVEL * NODE_SIZE);
        this.bytes.set(empty(), 0);
        this.node = empty();
        this.length = NODE_SIZE;
      }
      /**
       * @param {number} start
       * @param {number} end
       */
      slice(start, end) {
        while (this.length < end) {
          this.node = computeNode(this.node, this.node);
          this.bytes.set(this.node, this.length);
          this.length += NODE_SIZE;
        }
        return this.bytes.subarray(start, end);
      }
    };
    ZERO_COMM = new ZeroComm();
    fromLevel = (level) => {
      if (level < 0 || level >= MAX_LEVEL) {
        throw new Error(
          `Only levels between 0 and ${MAX_LEVEL - 1} inclusive are available`
        );
      }
      return ZERO_COMM.slice(NODE_SIZE * level, NODE_SIZE * (level + 1));
    };
    MAX_LEAF_COUNT = 2 ** 32 - 1;
    split = (source) => {
      const count = source.length / NODE_SIZE;
      const chunks = new Array(count);
      for (let n2 = 0; n2 < count; n2++) {
        const offset22 = n2 * NODE_SIZE;
        const chunk = source.subarray(offset22, offset22 + NODE_SIZE);
        chunks[n2] = chunk;
      }
      return chunks;
    };
    toPieceSize = (size5) => toZeroPaddedSize(size5) / FR_RATIO;
    pad = (source, output2 = new Uint8Array(toPieceSize(source.length))) => {
      const size5 = toZeroPaddedSize(source.byteLength);
      const quadCount = size5 / IN_BYTES_PER_QUAD;
      for (let n2 = 0; n2 < quadCount; n2++) {
        const readOffset = n2 * IN_BYTES_PER_QUAD;
        const writeOffset = n2 * OUT_BYTES_PER_QUAD;
        output2.set(source.subarray(readOffset, readOffset + 32), writeOffset);
        output2[writeOffset + 31] &= 63;
        for (let i = 32; i < 64; i++) {
          output2[writeOffset + i] = source[readOffset + i] << 2 | source[readOffset + i - 1] >> 6;
        }
        output2[writeOffset + 63] &= 63;
        for (let i = 64; i < 96; i++) {
          output2[writeOffset + i] = source[readOffset + i] << 4 | source[readOffset + i - 1] >> 4;
        }
        output2[writeOffset + 95] &= 63;
        for (let i = 96; i < 127; i++) {
          output2[writeOffset + i] = source[readOffset + i] << 6 | source[readOffset + i - 1] >> 2;
        }
        output2[writeOffset + 127] = source[readOffset + 126] >> 2;
      }
      return output2;
    };
    log2Floor = (n2) => {
      let result = 0n;
      while (n2 >>= 1n) result++;
      return Number(result);
    };
    log2Ceil = (n2) => n2 <= 1n ? 0 : log2Floor(BigInt(n2) - 1n) + 1;
    fromHeight = (height2) => {
      const quads = 2n ** BigInt(height2 - 2);
      return quads * PADDED_BYTES_PER_QUAD;
    };
    unpadded_exports = {};
    __export2(unpadded_exports, {
      fromPiece: () => fromPiece,
      toExpanded: () => toExpanded,
      toHeight: () => toHeight,
      toPadded: () => toPadded,
      toPadding: () => toPadding,
      toWidth: () => toWidth
    });
    fromPiece = ({ height: height2, padding: padding2 }) => fromHeight(height2) - padding2;
    toPadding = (size5) => toPadded(size5) - size5;
    toPadded = (size5) => toQauds(size5) * PADDED_BYTES_PER_QUAD;
    toExpanded = (size5) => toQauds(size5) * EXPANDED_BYTES_PER_QUAD;
    toWidth = (size5) => toQauds(size5) * LEAFS_PER_QUAD;
    toHeight = (size5) => log2Ceil(toWidth(size5));
    toQauds = (size5) => {
      const quadCount = (size5 + PADDED_BYTES_PER_QUAD - 1n) / PADDED_BYTES_PER_QUAD;
      return 2n ** BigInt(log2Ceil(quadCount));
    };
    fromHeight2 = (height2) => fromWidth(2n ** BigInt(height2));
    fromWidth = (width) => width * EXPANDED_BYTES_PER_NODE;
    digest_exports3 = {};
    __export2(digest_exports3, {
      HEIGHT_SIZE: () => HEIGHT_SIZE,
      MAX_DIGEST_SIZE: () => MAX_DIGEST_SIZE,
      MAX_HEIGHT: () => MAX_HEIGHT,
      MAX_PAYLOAD_SIZE: () => MAX_PAYLOAD_SIZE,
      MAX_SIZE: () => MAX_SIZE,
      ROOT_SIZE: () => ROOT_SIZE,
      TAG_SIZE: () => TAG_SIZE,
      code: () => code4,
      fromBytes: () => fromBytes,
      fromPiece: () => fromPiece2,
      height: () => height,
      name: () => name3,
      padding: () => padding,
      root: () => root,
      toBytes: () => toBytes2
    });
    from4 = ({ name: name142, code: code192, encode: encode342 }) => new Hasher(name142, code192, encode342);
    Hasher = class {
      /**
       *
       * @param {Name} name
       * @param {Code} code
       * @param {(input: Uint8Array) => Await<Uint8Array>} encode
       */
      constructor(name142, code192, encode342) {
        this.name = name142;
        this.code = code192;
        this.encode = encode342;
      }
      /**
       * @param {Uint8Array} input
       * @returns {Await<Digest.Digest<Code, number>>}
       */
      digest(input10) {
        if (input10 instanceof Uint8Array) {
          const result = this.encode(input10);
          return result instanceof Uint8Array ? create2(this.code, result) : result.then((digest52) => create2(this.code, digest52));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    name3 = /** @type {const} */
    "fr32-sha2-256-trunc254-padded-binary-tree";
    code4 = 4113;
    MAX_PADDING_SIZE = 9;
    HEIGHT_SIZE = 1;
    ROOT_SIZE = sha256_exports.size;
    MAX_DIGEST_SIZE = MAX_PADDING_SIZE + HEIGHT_SIZE + sha256_exports.size;
    TAG_SIZE = varint_exports2.encodingLength(code4);
    MAX_SIZE = TAG_SIZE + varint_exports2.encodingLength(MAX_DIGEST_SIZE) + MAX_DIGEST_SIZE;
    MAX_HEIGHT = 255;
    MAX_PAYLOAD_SIZE = fromHeight2(MAX_HEIGHT) * BigInt(IN_BITS_FR) / BigInt(OUT_BITS_FR);
    fromPiece2 = ({ padding: padding2, height: height2, root: root2 }) => {
      const paddingLength = varint_exports2.encodingLength(Number(padding2));
      const size5 = paddingLength + HEIGHT_SIZE + ROOT_SIZE;
      const sizeLength = varint_exports2.encodingLength(size5);
      const multihashLength = TAG_SIZE + sizeLength + size5;
      let offset22 = 0;
      const bytes22 = new Uint8Array(multihashLength);
      varint_exports2.encodeTo(code4, bytes22, offset22);
      offset22 += TAG_SIZE;
      varint_exports2.encodeTo(size5, bytes22, offset22);
      offset22 += sizeLength;
      varint_exports2.encodeTo(Number(padding2), bytes22, offset22);
      offset22 += paddingLength;
      bytes22[offset22] = height2;
      offset22 += HEIGHT_SIZE;
      bytes22.set(root2, offset22);
      return new Digest4(bytes22);
    };
    fromBytes = (bytes22) => new Digest4(bytes22);
    toBytes2 = ({ digest: digest52 }) => {
      const SIZE_BYTE_LENGTH = varint_exports2.encodingLength(digest52.length);
      const prefixByteLength = SIZE_BYTE_LENGTH + TAG_SIZE;
      if (digest52.byteOffset >= prefixByteLength) {
        const bytes3 = new Uint8Array(
          digest52.buffer,
          digest52.byteOffset - prefixByteLength,
          digest52.byteOffset + digest52.length
        );
        const [tag2, offset22] = varint_exports2.decode(bytes3);
        if (tag2 === code4 && varint_exports2.decode(bytes3, offset22)[0] === digest52.length) {
          return bytes3;
        }
      }
      const bytes22 = new Uint8Array(digest52.length + prefixByteLength);
      varint_exports2.encodeTo(code4, bytes22);
      varint_exports2.encodeTo(digest52.length, bytes22, TAG_SIZE);
      bytes22.set(digest52, prefixByteLength);
      return bytes22;
    };
    height = ({ digest: digest52 }) => {
      const [, offset22] = varint_exports2.decode(digest52);
      return digest52[offset22];
    };
    padding = ({ digest: digest52 }) => {
      const [padding2] = varint_exports2.decode(digest52);
      return BigInt(padding2);
    };
    root = ({ digest: digest52 }) => {
      const [, offset22] = varint_exports2.decode(digest52);
      return digest52.subarray(
        offset22 + HEIGHT_SIZE,
        offset22 + HEIGHT_SIZE + sha256_exports.size
      );
    };
    Digest4 = class {
      /**
       * @param {Uint8Array} bytes
       */
      constructor(bytes22) {
        this.bytes = bytes22;
        const [tag2] = varint_exports2.decode(bytes22);
        if (tag2 !== code4) {
          throw new RangeError(`Expected multihash with code ${code4}`);
        }
        let offset22 = TAG_SIZE;
        const [size5, length42] = varint_exports2.decode(bytes22, offset22);
        offset22 += length42;
        const digest52 = bytes22.subarray(offset22);
        if (digest52.length !== size5) {
          throw new RangeError(
            `Invalid multihash size expected ${offset22 + size5} bytes, got ${bytes22.length} bytes`
          );
        }
        this.digest = digest52;
      }
      get name() {
        return name3;
      }
      get code() {
        return code4;
      }
      get size() {
        return this.digest.length;
      }
      get padding() {
        return padding(this);
      }
      get height() {
        return height(this);
      }
      get root() {
        return root(this);
      }
    };
    name4 = /** @type {const} */
    "fr32-sha2-256-trunc254-padded-binary-tree";
    code5 = 4113;
    MAX_HEIGHT2 = 255;
    MAX_PAYLOAD_SIZE2 = fromHeight2(MAX_HEIGHT2) * BigInt(IN_BITS_FR) / BigInt(OUT_BITS_FR);
    digest2 = (payload) => {
      const hasher = new Hasher2();
      hasher.write(payload);
      return hasher.digest();
    };
    create4 = () => new Hasher2();
    Hasher2 = class {
      constructor() {
        this.bytesWritten = 0n;
        this.buffer = new Uint8Array(IN_BYTES_PER_QUAD);
        this.offset = 0;
        this.layers = [[]];
      }
      /**
       * Return the total number of bytes written into the hasher. Calling
       * {@link reset} will reset the hasher and the count will be reset to 0.
       *
       * @returns {bigint}
       */
      count() {
        return this.bytesWritten;
      }
      /**
       * Computes the digest of all the data that has been written into this hasher.
       * This method does not have side-effects, meaning that you can continue
       * writing and call this method again to compute digest of all the data
       * written from the very beginning.
       */
      digest() {
        const bytes22 = new Uint8Array(MAX_SIZE);
        const count = this.digestInto(bytes22, 0, true);
        return fromBytes(bytes22.subarray(0, count));
      }
      /**
       * Computes the digest and writes into the given buffer. You can provide
       * optional `byteOffset` to write digest at that offset in the buffer. By
       * default the multihash prefix will be written into the buffer, but you can
       * opt-out by passing `false` as the `asMultihash` argument.
       *
       * @param {Uint8Array} output
       * @param {number} [byteOffset]
       * @param {boolean} asMultihash
       */
      digestInto(output2, byteOffset = 0, asMultihash = true) {
        const { buffer: buffer22, layers, offset: offset22, bytesWritten } = this;
        let [leaves, ...nodes] = layers;
        if (offset22 > 0 || bytesWritten === 0n) {
          leaves = [...leaves, ...split(pad(buffer22.fill(0, offset22)))];
        }
        const tree2 = build([leaves, ...nodes]);
        const height2 = tree2.length - 1;
        const [root2] = tree2[height2];
        const padding2 = Number(unpadded_exports.toPadding(this.bytesWritten));
        const paddingLength = varint_exports2.encodingLength(
          /** @type {number & bigint} */
          padding2
        );
        let endOffset = byteOffset;
        if (asMultihash) {
          varint_exports2.encodeTo(code5, output2, endOffset);
          endOffset += TAG_SIZE;
          const size5 = paddingLength + HEIGHT_SIZE + ROOT_SIZE;
          const sizeLength = varint_exports2.encodingLength(size5);
          varint_exports2.encodeTo(size5, output2, endOffset);
          endOffset += sizeLength;
        }
        varint_exports2.encodeTo(padding2, output2, endOffset);
        endOffset += paddingLength;
        output2[endOffset] = height2;
        endOffset += 1;
        output2.set(root2, endOffset);
        endOffset += root2.length;
        return endOffset - byteOffset;
      }
      /**
       * @param {Uint8Array} bytes
       */
      write(bytes22) {
        const { buffer: buffer22, offset: offset22, layers } = this;
        const leaves = layers[0];
        const { length: length42 } = bytes22;
        if (length42 === 0) {
          return this;
        } else if (this.bytesWritten + BigInt(length42) > MAX_PAYLOAD_SIZE2) {
          throw new RangeError(
            `Writing ${length42} bytes exceeds max payload size of ${MAX_PAYLOAD_SIZE2}`
          );
        } else if (offset22 + length42 < buffer22.length) {
          buffer22.set(bytes22, offset22);
          this.offset += length42;
          this.bytesWritten += BigInt(length42);
          return this;
        } else {
          const bytesRequired = buffer22.length - offset22;
          buffer22.set(bytes22.subarray(0, bytesRequired), offset22);
          leaves.push(...split(pad(buffer22)));
          let readOffset = bytesRequired;
          while (readOffset + IN_BYTES_PER_QUAD < length42) {
            const quad = bytes22.subarray(readOffset, readOffset + IN_BYTES_PER_QUAD);
            leaves.push(...split(pad(quad)));
            readOffset += IN_BYTES_PER_QUAD;
          }
          this.buffer.set(bytes22.subarray(readOffset), 0);
          this.offset = length42 - readOffset;
          this.bytesWritten += BigInt(length42);
          prune(this.layers);
          return this;
        }
      }
      /**
       * Resets this hasher to its initial state so it could be recycled as new
       * instance.
       */
      reset() {
        this.offset = 0;
        this.bytesWritten = 0n;
        this.layers.length = 1;
        this.layers[0].length = 0;
        return this;
      }
      /* c8 ignore next 3 */
      dispose() {
        this.reset();
      }
      get code() {
        return code5;
      }
      get name() {
        return name4;
      }
    };
    prune = (layers) => flush(layers, false);
    build = (layers) => flush([...layers], true);
    flush = (layers, build3) => {
      let level = 0;
      while (level < layers.length) {
        let next = layers[level + 1];
        const layer = layers[level];
        if (build3 && layer.length % 2 > 0 && next) {
          layer.push(fromLevel(level));
        }
        level += 1;
        next = next ? build3 ? [...next] : next : [];
        let index2 = 0;
        while (index2 + 1 < layer.length) {
          const node = computeNode(layer[index2], layer[index2 + 1]);
          delete layer[index2];
          delete layer[index2 + 1];
          next.push(node);
          index2 += 2;
        }
        if (next.length) {
          layers[level] = next;
        }
        layer.splice(0, index2);
      }
      return layers;
    };
    storefront_exports = {};
    __export2(storefront_exports, {
      connection: () => connection,
      filecoinAccept: () => filecoinAccept2,
      filecoinInfo: () => filecoinInfo2,
      filecoinOffer: () => filecoinOffer2,
      filecoinSubmit: () => filecoinSubmit2
    });
    delegation_exports = {};
    __export2(delegation_exports, {
      ArchiveSchema: () => ArchiveSchema,
      Delegation: () => Delegation,
      View: () => Delegation,
      allows: () => allows,
      archive: () => archive,
      create: () => create6,
      delegate: () => delegate,
      exportDAG: () => exportDAG,
      extract: () => extract,
      importDAG: () => importDAG,
      isDelegation: () => isDelegation,
      isLink: () => isLink2,
      view: () => view2
    });
    encoder = new TextEncoder();
    decoder = new TextDecoder();
    encode7 = (text2) => encoder.encode(text2);
    decode11 = (bytes22) => decoder.decode(bytes22);
    code6 = 0;
    name5 = "identity";
    encode8 = coerce;
    digest3 = (input10) => create2(code6, encode8(input10));
    identity = { code: code6, name: name5, encode: encode8, digest: digest3 };
    DID_PREFIX = "did:";
    DID_PREFIX_SIZE = DID_PREFIX.length;
    DID_KEY_PREFIX = `did:key:`;
    DID_KEY_PREFIX_SIZE = DID_KEY_PREFIX.length;
    ED25519 = 237;
    RSA = 4613;
    P256 = 4608;
    P384 = 4609;
    P521 = 4610;
    SECP256K1 = 231;
    BLS12381G1 = 234;
    BLS12381G2 = 235;
    DID_CORE = 3357;
    METHOD_OFFSET = varint_exports2.encodingLength(DID_CORE);
    parse2 = (did2) => {
      if (!did2.startsWith(DID_PREFIX)) {
        throw new RangeError(`Invalid DID "${did2}", must start with 'did:'`);
      } else if (did2.startsWith(DID_KEY_PREFIX)) {
        const key = base58btc2.decode(did2.slice(DID_KEY_PREFIX_SIZE));
        return decode12(key);
      } else {
        const suffix = encode7(did2.slice(DID_PREFIX_SIZE));
        const bytes22 = new Uint8Array(suffix.byteLength + METHOD_OFFSET);
        varint_exports2.encodeTo(DID_CORE, bytes22);
        bytes22.set(suffix, METHOD_OFFSET);
        return new DID(bytes22);
      }
    };
    format3 = (id) => id.did();
    from5 = (principal) => {
      if (principal instanceof DID) {
        return principal;
      } else if (principal instanceof Uint8Array) {
        return decode12(principal);
      } else if (typeof principal === "string") {
        return parse2(principal);
      } else {
        return parse2(principal.did());
      }
    };
    decode12 = (bytes22) => {
      const [code192] = varint_exports2.decode(bytes22);
      const { buffer: buffer22, byteOffset, byteLength } = bytes22;
      switch (code192) {
        case P256:
          if (bytes22.length > 35) {
            throw new RangeError(`Only p256-pub compressed is supported.`);
          }
        case ED25519:
        case RSA:
        case P384:
        case P521:
        case BLS12381G1:
        case BLS12381G2:
        case SECP256K1:
          return (
            /** @type {UCAN.PrincipalView<any>} */
            new DIDKey(buffer22, byteOffset, byteLength)
          );
        case DID_CORE:
          return new DID(buffer22, byteOffset, byteLength);
        default:
          throw new RangeError(
            `Unsupported DID encoding, unknown multicode 0x${code192.toString(16)}.`
          );
      }
    };
    encode9 = (principal) => parse2(principal.did());
    DID = class extends Uint8Array {
      /**
       * @returns {ID}
       */
      did() {
        const bytes22 = new Uint8Array(this.buffer, this.byteOffset + METHOD_OFFSET);
        return (
          /** @type {ID} */
          `did:${decode11(bytes22)}`
        );
      }
      toJSON() {
        return this.did();
      }
    };
    DIDKey = class extends DID {
      /**
       * @return {`did:key:${string}`}
       */
      did() {
        return `did:key:${base58btc2.encode(this)}`;
      }
    };
    code7 = 85;
    signature_exports = {};
    __export2(signature_exports, {
      BLS12381G1: () => BLS12381G12,
      BLS12381G2: () => BLS12381G22,
      EIP191: () => EIP191,
      ES256: () => ES256,
      ES256K: () => ES256K,
      ES384: () => ES384,
      ES512: () => ES512,
      EdDSA: () => EdDSA,
      NON_STANDARD: () => NON_STANDARD,
      RS256: () => RS256,
      Signature: () => Signature,
      create: () => create5,
      createNamed: () => createNamed,
      createNonStandard: () => createNonStandard,
      decode: () => decode13,
      encode: () => encode10,
      format: () => format4,
      fromJSON: () => fromJSON2,
      nameCode: () => nameCode,
      parse: () => parse3,
      toJSON: () => toJSON2,
      view: () => view
    });
    base64 = rfc46482({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    base64pad = rfc46482({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    base64url = rfc46482({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    base64urlpad = rfc46482({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
    NON_STANDARD = 53248;
    ES256K = 53479;
    BLS12381G12 = 53482;
    BLS12381G22 = 53483;
    EdDSA = 53485;
    ES256 = 13636096;
    ES384 = 13636097;
    ES512 = 13636098;
    RS256 = 13636101;
    EIP191 = 53649;
    codeName = (code192) => {
      switch (code192) {
        case ES256K:
          return "ES256K";
        case BLS12381G12:
          return "BLS12381G1";
        case BLS12381G22:
          return "BLS12381G2";
        case EdDSA:
          return "EdDSA";
        case ES256:
          return "ES256";
        case ES384:
          return "ES384";
        case ES512:
          return "ES512";
        case RS256:
          return "RS256";
        case EIP191:
          return "EIP191";
        default:
          throw new RangeError(
            `Unknown signature algorithm code 0x${code192.toString(16)}`
          );
      }
    };
    nameCode = (name142) => {
      switch (name142) {
        case "ES256K":
          return ES256K;
        case "BLS12381G1":
          return BLS12381G12;
        case "BLS12381G2":
          return BLS12381G22;
        case "EdDSA":
          return EdDSA;
        case "ES256":
          return ES256;
        case "ES384":
          return ES384;
        case "ES512":
          return ES512;
        case "RS256":
          return RS256;
        case "EIP191":
          return EIP191;
        default:
          return NON_STANDARD;
      }
    };
    Signature = class extends Uint8Array {
      get code() {
        const [code192] = varint_exports2.decode(this);
        Object.defineProperties(this, { code: { value: code192 } });
        return (
          /** @type {A} */
          code192
        );
      }
      get size() {
        const value = size2(this);
        Object.defineProperties(this, { size: { value } });
        return value;
      }
      get algorithm() {
        const value = algorithm(this);
        Object.defineProperties(this, { algorithm: { value } });
        return value;
      }
      get raw() {
        const { buffer: buffer22, byteOffset, size: size5, code: code192 } = this;
        const codeSize = varint_exports2.encodingLength(code192);
        const rawSize = varint_exports2.encodingLength(size5);
        const value = new Uint8Array(buffer22, byteOffset + codeSize + rawSize, size5);
        Object.defineProperties(this, { raw: { value } });
        return value;
      }
      /**
       * Verify that this signature was created by the given key.
       *
       * @param {UCAN.Crypto.Verifier<A>} signer
       * @param {UCAN.ByteView<T>} payload
       */
      async verify(signer, payload) {
        try {
          if (await signer.verify(payload, this) === true) {
            return { ok: {} };
          } else {
            throw new Error("Invalid signature");
          }
        } catch (cause) {
          return { error: (
            /** @type {Error} */
            cause
          ) };
        }
      }
      toJSON() {
        return toJSON2(this);
      }
    };
    algorithm = (signature) => {
      const { code: code192, raw, buffer: buffer22, byteOffset } = signature;
      if (code192 === NON_STANDARD) {
        const offset22 = raw.byteLength + varint_exports2.encodingLength(code192) + varint_exports2.encodingLength(raw.byteLength);
        const bytes22 = new Uint8Array(buffer22, byteOffset + offset22);
        return decode11(bytes22);
      } else {
        return codeName(code192);
      }
    };
    size2 = (signature) => {
      const offset22 = varint_exports2.encodingLength(signature.code);
      const [size5] = varint_exports2.decode(
        new Uint8Array(signature.buffer, signature.byteOffset + offset22)
      );
      return size5;
    };
    create5 = (code192, raw) => {
      const _ = codeName(code192);
      const codeSize = varint_exports2.encodingLength(code192);
      const rawSize = varint_exports2.encodingLength(raw.byteLength);
      const signature = new Signature(codeSize + rawSize + raw.byteLength);
      varint_exports2.encodeTo(code192, signature);
      varint_exports2.encodeTo(raw.byteLength, signature, codeSize);
      signature.set(raw, codeSize + rawSize);
      Object.defineProperties(signature, {
        code: { value: code192 },
        size: { value: raw.byteLength }
      });
      return signature;
    };
    createNamed = (name142, raw) => {
      const code192 = nameCode(name142);
      return code192 === NON_STANDARD ? createNonStandard(name142, raw) : create5(code192, raw);
    };
    createNonStandard = (name142, raw) => {
      const code192 = NON_STANDARD;
      const codeSize = varint_exports2.encodingLength(code192);
      const rawSize = varint_exports2.encodingLength(raw.byteLength);
      const nameBytes = encode7(name142);
      const signature = new Signature(
        codeSize + rawSize + raw.byteLength + nameBytes.byteLength
      );
      varint_exports2.encodeTo(code192, signature);
      varint_exports2.encodeTo(raw.byteLength, signature, codeSize);
      signature.set(raw, codeSize + rawSize);
      signature.set(nameBytes, codeSize + rawSize + raw.byteLength);
      return signature;
    };
    view = (bytes22) => new Signature(bytes22.buffer, bytes22.byteOffset, bytes22.byteLength);
    decode13 = (bytes22) => {
      if (!(bytes22 instanceof Uint8Array)) {
        throw new TypeError(
          `Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(
            bytes22
          )}`
        );
      }
      const signature = view(bytes22);
      const { code: code192, algorithm: algorithm2, raw } = signature;
      return signature;
    };
    encode10 = (signature) => decode13(signature);
    format4 = (signature, base42) => (base42 || base64url).encode(signature);
    parse3 = (signature, base42) => (
      /** @type {UCAN.SignatureView<T, A>} */
      decode13((base42 || base64url).decode(signature))
    );
    toJSON2 = (signature) => ({
      "/": { bytes: base64.baseEncode(signature) }
    });
    fromJSON2 = (json) => decode13(base64.baseDecode(json["/"].bytes));
    readPayload = (data) => readPayloadWith(data, {
      readPrincipal,
      readProof
    });
    readJWTPayload = (data) => readPayloadWith(data, {
      readPrincipal: readStringPrincipal,
      readProof: readStringProof
    });
    readPayloadWith = (data, { readPrincipal: readPrincipal2, readProof: readProof2 }) => ({
      iss: readPrincipal2(data.iss, "iss"),
      aud: readPrincipal2(data.aud, "aud"),
      att: readCapabilities(data.att, "att"),
      prf: readOptionalArray(data.prf, readProof2, "prf") || [],
      exp: readNullable(data.exp === Infinity ? null : data.exp, readInt, "exp"),
      nbf: readOptional(data.nbf, readInt, "nbf"),
      fct: readOptionalArray(data.fct, readFact, "fct") || [],
      nnc: readOptional(data.nnc, readString, "nnc")
    });
    readSignature = (source) => {
      if (source instanceof Uint8Array) {
        return decode13(source);
      } else {
        throw new TypeError(
          `Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(
            source
          )}`
        );
      }
    };
    readInt = (input10, name142) => Number.isInteger(input10) ? (
      /** @type {number} */
      input10
    ) : ParseError.throw(
      `Expected ${name142} to be integer, instead got ${JSON.stringify(input10)}`
    );
    readCapability = (input10, context2) => readStruct(input10, asCapability, context2);
    readCapabilities = (input10, context2) => (
      /** @type {C} */
      readArray(input10, readCapability, context2)
    );
    asCapability = (input10) => (
      /** @type {C} */
      {
        ...input10,
        can: readAbility(input10.can),
        with: readResource(input10.with)
      }
    );
    readAbility = (input10) => typeof input10 !== "string" ? ParseError.throw(
      `Capability has invalid 'can: ${JSON.stringify(
        input10
      )}', value must be a string`
    ) : input10.slice(1, -1).includes("/") ? (
      /** @type {UCAN.Ability} */
      input10.toLocaleLowerCase()
    ) : input10 === "*" ? input10 : ParseError.throw(
      `Capability has invalid 'can: "${input10}"', value must have at least one path segment`
    );
    readResource = (input10) => typeof input10 !== "string" ? ParseError.throw(
      `Capability has invalid 'with: ${JSON.stringify(
        input10
      )}', value must be a string`
    ) : parseURL(input10) || ParseError.throw(
      `Capability has invalid 'with: "${input10}"', value must be a valid URI string`
    );
    parseURL = (input10) => {
      try {
        new URL(input10);
        return input10;
      } catch (_) {
        return null;
      }
    };
    readArray = (input10, read92, context2) => Array.isArray(input10) ? input10.map((element, n2) => read92(element, `${context2}[${n2}]`)) : ParseError.throw(`${context2} must be an array`);
    readOptionalArray = (input10, reader, context2) => input10 === void 0 ? input10 : readArray(input10, reader, context2);
    readStruct = (input10, reader, context2) => input10 != null && typeof input10 === "object" ? reader(input10) : ParseError.throw(
      `${context2} must be of type object, instead got ${input10}`
    );
    readFact = (input10, context2) => readStruct(input10, Object, context2);
    readProof = (source, context2) => isLink(source) ? (
      /** @type {UCAN.Link} */
      source
    ) : fail(
      `Expected ${context2} to be IPLD link, instead got ${JSON.stringify(
        source
      )}`
    );
    readStringProof = (source, context2) => parseProof(readString(source, context2));
    parseProof = (source) => {
      try {
        return parse(source);
      } catch (error3) {
        return create3(code7, identity.digest(encode7(source)));
      }
    };
    readPrincipal = (input10, context2) => decode12(readBytes(input10, context2));
    readStringPrincipal = (source, context2) => parse2(readString(source, context2));
    readOptional = (source, read92, context2 = "Field") => source !== void 0 ? read92(source, context2) : void 0;
    readNullable = (source, read92, context2) => source === null ? null : read92(source, context2);
    readString = (source, context2 = "Field") => typeof source === "string" ? source : fail(`${context2} has invalid value ${source}`);
    readBytes = (source, context2) => source instanceof Uint8Array ? source : fail(
      `Expected ${context2} to be Uint8Array, instead got ${JSON.stringify(
        source
      )}`
    );
    readVersion = (input10, context2) => /\d+\.\d+\.\d+/.test(
      /** @type {string} */
      input10
    ) ? (
      /** @type {UCAN.Version} */
      input10
    ) : ParseError.throw(`Invalid version '${context2}: ${JSON.stringify(input10)}'`);
    readLiteral = (input10, literal2, context2) => input10 === literal2 ? literal2 : ParseError.throw(
      `Expected ${context2} to be a ${JSON.stringify(
        literal2
      )} instead got ${JSON.stringify(input10)}`
    );
    ParseError = class extends TypeError {
      get name() {
        return "ParseError";
      }
      /**
       * @param {string} message
       * @returns {never}
       */
      static throw(message2) {
        throw new this(message2);
      }
    };
    fail = (reason) => ParseError.throw(reason);
    JSONEncoder = class extends Array {
      constructor() {
        super();
        this.inRecursive = [];
      }
      /**
       * @param {Bl} buf
       */
      prefix(buf22) {
        const recurs = this.inRecursive[this.inRecursive.length - 1];
        if (recurs) {
          if (recurs.type === Type.array) {
            recurs.elements++;
            if (recurs.elements !== 1) {
              buf22.push([44]);
            }
          }
          if (recurs.type === Type.map) {
            recurs.elements++;
            if (recurs.elements !== 1) {
              if (recurs.elements % 2 === 1) {
                buf22.push([44]);
              } else {
                buf22.push([58]);
              }
            }
          }
        }
      }
      /**
       * @param {Bl} buf
       * @param {Token} token
       */
      [Type.uint.major](buf22, token) {
        this.prefix(buf22);
        const is22 = String(token.value);
        const isa = [];
        for (let i = 0; i < is22.length; i++) {
          isa[i] = is22.charCodeAt(i);
        }
        buf22.push(isa);
      }
      /**
       * @param {Bl} buf
       * @param {Token} token
       */
      [Type.negint.major](buf22, token) {
        this[Type.uint.major](buf22, token);
      }
      /**
       * @param {Bl} _buf
       * @param {Token} _token
       */
      [Type.bytes.major](_buf, _token) {
        throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`);
      }
      /**
       * @param {Bl} buf
       * @param {Token} token
       */
      [Type.string.major](buf22, token) {
        this.prefix(buf22);
        const byts = fromString(JSON.stringify(token.value));
        buf22.push(byts.length > 32 ? asU8A(byts) : byts);
      }
      /**
       * @param {Bl} buf
       * @param {Token} _token
       */
      [Type.array.major](buf22, _token) {
        this.prefix(buf22);
        this.inRecursive.push({ type: Type.array, elements: 0 });
        buf22.push([91]);
      }
      /**
       * @param {Bl} buf
       * @param {Token} _token
       */
      [Type.map.major](buf22, _token) {
        this.prefix(buf22);
        this.inRecursive.push({ type: Type.map, elements: 0 });
        buf22.push([123]);
      }
      /**
       * @param {Bl} _buf
       * @param {Token} _token
       */
      [Type.tag.major](_buf, _token) {
      }
      /**
       * @param {Bl} buf
       * @param {Token} token
       */
      [Type.float.major](buf22, token) {
        if (token.type.name === "break") {
          const recurs = this.inRecursive.pop();
          if (recurs) {
            if (recurs.type === Type.array) {
              buf22.push([93]);
            } else if (recurs.type === Type.map) {
              buf22.push([125]);
            } else {
              throw new Error("Unexpected recursive type; this should not happen!");
            }
            return;
          }
          throw new Error("Unexpected break; this should not happen!");
        }
        if (token.value === void 0) {
          throw new Error(`${encodeErrPrefix} unsupported type: undefined`);
        }
        this.prefix(buf22);
        if (token.type.name === "true") {
          buf22.push([116, 114, 117, 101]);
          return;
        } else if (token.type.name === "false") {
          buf22.push([102, 97, 108, 115, 101]);
          return;
        } else if (token.type.name === "null") {
          buf22.push([110, 117, 108, 108]);
          return;
        }
        const is22 = String(token.value);
        const isa = [];
        let dp = false;
        for (let i = 0; i < is22.length; i++) {
          isa[i] = is22.charCodeAt(i);
          if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {
            dp = true;
          }
        }
        if (!dp) {
          isa.push(46);
          isa.push(48);
        }
        buf22.push(isa);
      }
    };
    defaultEncodeOptions2 = { addBreakTokens: true, mapSorter: mapSorter2 };
    Tokenizer = class {
      /**
       * @param {Uint8Array} data
       * @param {DecodeOptions} options
       */
      constructor(data, options = {}) {
        this._pos = 0;
        this.data = data;
        this.options = options;
        this.modeStack = ["value"];
        this.lastToken = "";
      }
      pos() {
        return this._pos;
      }
      /**
       * @returns {boolean}
       */
      done() {
        return this._pos >= this.data.length;
      }
      /**
       * @returns {number}
       */
      ch() {
        return this.data[this._pos];
      }
      /**
       * @returns {string}
       */
      currentMode() {
        return this.modeStack[this.modeStack.length - 1];
      }
      skipWhitespace() {
        let c = this.ch();
        while (c === 32 || c === 9 || c === 13 || c === 10) {
          c = this.data[++this._pos];
        }
      }
      /**
       * @param {number[]} str
       */
      expect(str) {
        if (this.data.length - this._pos < str.length) {
          throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this._pos}`);
        }
        for (let i = 0; i < str.length; i++) {
          if (this.data[this._pos++] !== str[i]) {
            throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}, expected to find '${String.fromCharCode(...str)}'`);
          }
        }
      }
      parseNumber() {
        const startPos = this._pos;
        let negative = false;
        let float2 = false;
        const swallow = (chars) => {
          while (!this.done()) {
            const ch = this.ch();
            if (chars.includes(ch)) {
              this._pos++;
            } else {
              break;
            }
          }
        };
        if (this.ch() === 45) {
          negative = true;
          this._pos++;
        }
        if (this.ch() === 48) {
          this._pos++;
          if (this.ch() === 46) {
            this._pos++;
            float2 = true;
          } else {
            return new Token(Type.uint, 0, this._pos - startPos);
          }
        }
        swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
        if (negative && this._pos === startPos + 1) {
          throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`);
        }
        if (!this.done() && this.ch() === 46) {
          if (float2) {
            throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`);
          }
          float2 = true;
          this._pos++;
          swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
        }
        if (!this.done() && (this.ch() === 101 || this.ch() === 69)) {
          float2 = true;
          this._pos++;
          if (!this.done() && (this.ch() === 43 || this.ch() === 45)) {
            this._pos++;
          }
          swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
        }
        const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this._pos));
        const num = parseFloat(numStr);
        if (float2) {
          return new Token(Type.float, num, this._pos - startPos);
        }
        if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {
          return new Token(num >= 0 ? Type.uint : Type.negint, num, this._pos - startPos);
        }
        return new Token(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this._pos - startPos);
      }
      /**
       * @returns {Token}
       */
      parseString() {
        if (this.ch() !== 34) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}; this shouldn't happen`);
        }
        this._pos++;
        for (let i = this._pos, l2 = 0; i < this.data.length && l2 < 65536; i++, l2++) {
          const ch = this.data[i];
          if (ch === 92 || ch < 32 || ch >= 128) {
            break;
          }
          if (ch === 34) {
            const str = String.fromCharCode.apply(null, this.data.subarray(this._pos, i));
            this._pos = i + 1;
            return new Token(Type.string, str, l2);
          }
        }
        const startPos = this._pos;
        const chars = [];
        const readu4 = () => {
          if (this._pos + 4 >= this.data.length) {
            throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this._pos}`);
          }
          let u4 = 0;
          for (let i = 0; i < 4; i++) {
            let ch = this.ch();
            if (ch >= 48 && ch <= 57) {
              ch -= 48;
            } else if (ch >= 97 && ch <= 102) {
              ch = ch - 97 + 10;
            } else if (ch >= 65 && ch <= 70) {
              ch = ch - 65 + 10;
            } else {
              throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this._pos}`);
            }
            u4 = u4 * 16 + ch;
            this._pos++;
          }
          return u4;
        };
        const readUtf8Char = () => {
          const firstByte = this.ch();
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (this._pos + bytesPerSequence > this.data.length) {
            throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this._pos}`);
          }
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = this.data[this._pos + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = this.data[this._pos + 1];
              thirdByte = this.data[this._pos + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = this.data[this._pos + 1];
              thirdByte = this.data[this._pos + 2];
              fourthByte = this.data[this._pos + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            chars.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          chars.push(codePoint);
          this._pos += bytesPerSequence;
        };
        while (!this.done()) {
          const ch = this.ch();
          let ch1;
          switch (ch) {
            case 92:
              this._pos++;
              if (this.done()) {
                throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this._pos}`);
              }
              ch1 = this.ch();
              this._pos++;
              switch (ch1) {
                case 34:
                case 39:
                case 92:
                case 47:
                  chars.push(ch1);
                  break;
                case 98:
                  chars.push(8);
                  break;
                case 116:
                  chars.push(9);
                  break;
                case 110:
                  chars.push(10);
                  break;
                case 102:
                  chars.push(12);
                  break;
                case 114:
                  chars.push(13);
                  break;
                case 117:
                  chars.push(readu4());
                  break;
                default:
                  throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this._pos}`);
              }
              break;
            case 34:
              this._pos++;
              return new Token(Type.string, decodeCodePointsArray(chars), this._pos - startPos);
            default:
              if (ch < 32) {
                throw new Error(`${decodeErrPrefix} invalid control character at position ${this._pos}`);
              } else if (ch < 128) {
                chars.push(ch);
                this._pos++;
              } else {
                readUtf8Char();
              }
          }
        }
        throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this._pos}`);
      }
      /**
       * @returns {Token}
       */
      parseValue() {
        switch (this.ch()) {
          case 123:
            this.modeStack.push("obj-start");
            this._pos++;
            return new Token(Type.map, Infinity, 1);
          case 91:
            this.modeStack.push("array-start");
            this._pos++;
            return new Token(Type.array, Infinity, 1);
          case 34: {
            return this.parseString();
          }
          case 110:
            this.expect([110, 117, 108, 108]);
            return new Token(Type.null, null, 4);
          case 102:
            this.expect([102, 97, 108, 115, 101]);
            return new Token(Type.false, false, 5);
          case 116:
            this.expect([116, 114, 117, 101]);
            return new Token(Type.true, true, 4);
          case 45:
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.parseNumber();
          default:
            throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}`);
        }
      }
      /**
       * @returns {Token}
       */
      next() {
        this.skipWhitespace();
        switch (this.currentMode()) {
          case "value":
            this.modeStack.pop();
            return this.parseValue();
          case "array-value": {
            this.modeStack.pop();
            if (this.ch() === 93) {
              this._pos++;
              this.skipWhitespace();
              return new Token(Type.break, void 0, 1);
            }
            if (this.ch() !== 44) {
              throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
            }
            this._pos++;
            this.modeStack.push("array-value");
            this.skipWhitespace();
            return this.parseValue();
          }
          case "array-start": {
            this.modeStack.pop();
            if (this.ch() === 93) {
              this._pos++;
              this.skipWhitespace();
              return new Token(Type.break, void 0, 1);
            }
            this.modeStack.push("array-value");
            this.skipWhitespace();
            return this.parseValue();
          }
          case "obj-key":
            if (this.ch() === 125) {
              this.modeStack.pop();
              this._pos++;
              this.skipWhitespace();
              return new Token(Type.break, void 0, 1);
            }
            if (this.ch() !== 44) {
              throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
            }
            this._pos++;
            this.skipWhitespace();
          case "obj-start": {
            this.modeStack.pop();
            if (this.ch() === 125) {
              this._pos++;
              this.skipWhitespace();
              return new Token(Type.break, void 0, 1);
            }
            const token = this.parseString();
            this.skipWhitespace();
            if (this.ch() !== 58) {
              throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
            }
            this._pos++;
            this.modeStack.push("obj-value");
            return token;
          }
          case "obj-value": {
            this.modeStack.pop();
            this.modeStack.push("obj-key");
            this.skipWhitespace();
            return this.parseValue();
          }
          default:
            throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this._pos}; this shouldn't happen`);
        }
      }
    };
    Hasher3 = class {
      constructor(name142, code192, encode342) {
        __publicField(this, "name");
        __publicField(this, "code");
        __publicField(this, "encode");
        this.name = name142;
        this.code = code192;
        this.encode = encode342;
      }
      digest(input10) {
        if (input10 instanceof Uint8Array) {
          const result = this.encode(input10);
          return result instanceof Uint8Array ? create(this.code, result) : result.then((digest52) => create(this.code, digest52));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    base64_exports = {};
    __export2(base64_exports, {
      base64: () => base642,
      base64pad: () => base64pad2,
      base64url: () => base64url2,
      base64urlpad: () => base64urlpad2
    });
    base642 = rfc4648({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    base64pad2 = rfc4648({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    base64url2 = rfc4648({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    base64urlpad2 = rfc4648({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
    encodeOptions2 = {
      typeEncoders: {
        Object: cidEncoder2,
        Buffer: bytesEncoder,
        Uint8Array: bytesEncoder,
        Int8Array: taBytesEncoder,
        Uint16Array: taBytesEncoder,
        Int16Array: taBytesEncoder,
        Uint32Array: taBytesEncoder,
        Int32Array: taBytesEncoder,
        Float32Array: taBytesEncoder,
        Float64Array: taBytesEncoder,
        Uint8ClampedArray: taBytesEncoder,
        BigInt64Array: taBytesEncoder,
        BigUint64Array: taBytesEncoder,
        DataView: taBytesEncoder,
        ArrayBuffer: abBytesEncoder,
        undefined: undefinedEncoder2,
        number: numberEncoder2
      }
    };
    DagJsonTokenizer = class extends Tokenizer {
      /**
       * @param {Uint8Array} data
       * @param {object} [options]
       */
      constructor(data, options) {
        super(data, options);
        this.tokenBuffer = [];
      }
      /**
       * @returns {boolean}
       */
      done() {
        return this.tokenBuffer.length === 0 && super.done();
      }
      /**
       * @returns {Token}
       */
      _next() {
        if (this.tokenBuffer.length > 0) {
          return this.tokenBuffer.pop();
        }
        return super.next();
      }
      /**
       * Implements rules outlined in https://github.com/ipld/specs/pull/356
       *
       * @returns {Token}
       */
      next() {
        const token = this._next();
        if (token.type === Type.map) {
          const keyToken = this._next();
          if (keyToken.type === Type.string && keyToken.value === "/") {
            const valueToken = this._next();
            if (valueToken.type === Type.string) {
              const breakToken = this._next();
              if (breakToken.type !== Type.break) {
                throw new Error("Invalid encoded CID form");
              }
              this.tokenBuffer.push(valueToken);
              return new Token(Type.tag, 42, 0);
            }
            if (valueToken.type === Type.map) {
              const innerKeyToken = this._next();
              if (innerKeyToken.type === Type.string && innerKeyToken.value === "bytes") {
                const innerValueToken = this._next();
                if (innerValueToken.type === Type.string) {
                  for (let i = 0; i < 2; i++) {
                    const breakToken = this._next();
                    if (breakToken.type !== Type.break) {
                      throw new Error("Invalid encoded Bytes form");
                    }
                  }
                  const bytes22 = base642.decode(`m${innerValueToken.value}`);
                  return new Token(Type.bytes, bytes22, innerValueToken.value.length);
                }
                this.tokenBuffer.push(innerValueToken);
              }
              this.tokenBuffer.push(innerKeyToken);
            }
            this.tokenBuffer.push(valueToken);
          }
          this.tokenBuffer.push(keyToken);
        }
        return token;
      }
    };
    decodeOptions2 = {
      allowIndefinite: false,
      allowUndefined: false,
      allowNaN: false,
      allowInfinity: false,
      allowBigInt: true,
      // this will lead to BigInt for ints outside of
      // safe-integer range, which may surprise users
      strict: true,
      useMaps: false,
      rejectDuplicateMapKeys: true,
      /** @type {import('cborg').TagDecoder[]} */
      tags: []
    };
    decodeOptions2.tags[42] = CID.parse;
    encode12 = (node) => encode11(node, encodeOptions2);
    decode15 = (data) => {
      const buf22 = toByteView2(data);
      const options = Object.assign(decodeOptions2, { tokenizer: new DagJsonTokenizer(buf22, decodeOptions2) });
      return decode14(buf22, options);
    };
    utf8Decoder = new TextDecoder();
    utf8Encoder = new TextEncoder();
    format5 = (model) => {
      const header = formatHeader(model.v, model.s.algorithm);
      const payload = formatPayload(model);
      const signature = formatSignature(model.s);
      return (
        /** @type {UCAN.JWT<C>} */
        `${header}.${payload}.${signature}`
      );
    };
    formatSignPayload = (payload, version22, alg) => `${formatHeader(version22, alg)}.${formatPayload(payload)}`;
    formatHeader = (version22, alg) => base64url.baseEncode(encodeHeader(version22, alg));
    formatPayload = (data) => base64url.baseEncode(encodePayload(data));
    formatSignature = (signature) => base64url.baseEncode(signature.raw);
    encodeHeader = (v, alg) => encode12({
      alg,
      ucv: v,
      typ: "JWT"
    });
    encodePayload = (data) => encode12({
      iss: format3(data.iss),
      aud: format3(data.aud),
      att: data.att,
      exp: data.exp,
      prf: data.prf.map(encodeProof),
      // leave out optionals and empty fields
      ...data.fct.length > 0 && { fct: data.fct },
      ...data.nnc && { nnc: data.nnc },
      ...data.nbf && { nbf: data.nbf }
    });
    encodeProof = (proof) => (
      /** @type {UCAN.ToString<UCAN.Link>} */
      proof.toString()
    );
    toJSON3 = (data) => JSON.parse(decode11(encode12(data)));
    View = class {
      /**
       * @param {UCAN.UCAN<C>} model
       */
      constructor(model) {
        this.model = model;
      }
      get version() {
        return this.model.v;
      }
      get issuer() {
        return from5(this.model.iss);
      }
      get audience() {
        return from5(this.model.aud);
      }
      /**
       * @returns {C}
       */
      get capabilities() {
        return this.model.att;
      }
      /**
       * @returns {number}
       */
      get expiration() {
        const { exp } = this.model;
        return exp === null ? Infinity : exp;
      }
      /**
       * @returns {undefined|number}
       */
      get notBefore() {
        return this.model.nbf;
      }
      /**
       * @returns {undefined|string}
       */
      get nonce() {
        return this.model.nnc;
      }
      /**
       * @returns {UCAN.Fact[]}
       */
      get facts() {
        return this.model.fct;
      }
      /**
       * @returns {UCAN.Link[]}
       */
      get proofs() {
        return this.model.prf;
      }
      get signature() {
        return this.model.s;
      }
      // compatibility with UCAN.UCAN
      get jwt() {
        return this.model.jwt;
      }
      get s() {
        return this.model.s;
      }
      get v() {
        return this.model.v;
      }
      get iss() {
        return this.model.iss;
      }
      get aud() {
        return this.model.aud;
      }
      get att() {
        return this.model.att;
      }
      get exp() {
        return this.model.exp;
      }
      get nbf() {
        return this.model.nbf;
      }
      get nnc() {
        return this.model.nnc;
      }
      get fct() {
        return this.model.fct;
      }
      get prf() {
        return this.model.prf;
      }
      /**
       * @returns {UCAN.ToJSON<UCAN.UCAN<C>, UCAN.UCANJSON<this>>}
       */
      toJSON() {
        const { v, iss, aud, s: s2, att, prf, exp, fct, nnc, nbf } = this.model;
        return {
          iss,
          aud,
          v,
          s: s2,
          exp,
          ...toJSON3({
            att,
            prf,
            ...fct.length > 0 && { fct }
          }),
          ...nnc != null && { nnc },
          ...nbf && { nbf }
        };
      }
    };
    code8 = code3;
    from7 = (model) => new CBORView(model);
    encode13 = (model) => {
      const { fct, nnc, nbf, ...payload } = readPayload(model);
      return (
        /** @type {Uint8Array} */
        encode4({
          // leave out optionals unless they are set
          ...fct.length > 0 && { fct },
          ...nnc != null && { nnc },
          ...nbf && { nbf },
          ...payload,
          // add version and signature
          v: readVersion(model.v, "v"),
          s: encodeSignature(model.s, "s")
        })
      );
    };
    encodeSignature = (signature, context2) => {
      try {
        return encode10(signature);
      } catch (cause) {
        throw new Error(
          `Expected signature ${context2}, instead got ${JSON.stringify(signature)}`,
          // @ts-expect-error - types don't know about second arg
          { cause }
        );
      }
    };
    decode16 = (bytes22) => {
      const model = decode6(bytes22);
      return new CBORView({
        ...readPayload(model),
        v: readVersion(model.v, "v"),
        s: readSignature(model.s)
      });
    };
    CBORView = class extends View {
      get code() {
        return code8;
      }
      format() {
        return format5(this.model);
      }
      encode() {
        return encode13(this.model);
      }
    };
    parse4 = (jwt) => {
      const segments = jwt.split(".");
      const [header, payload, signature] = segments.length === 3 ? segments : fail(
        `Can't parse UCAN: ${jwt}: Expected JWT format: 3 dot-separated base64url-encoded values.`
      );
      const { ucv, alg } = parseHeader(header);
      return {
        ...parsePayload(payload),
        v: ucv,
        s: createNamed(alg, base64url.baseDecode(signature))
      };
    };
    parseHeader = (header) => {
      const { ucv, alg, typ } = decode15(base64url.baseDecode(header));
      return {
        typ: readLiteral(typ, "JWT", "typ"),
        ucv: readVersion(ucv, "ucv"),
        alg: readString(alg, "alg")
      };
    };
    parsePayload = (source) => {
      const payload = decode15(base64url.baseDecode(source));
      return readJWTPayload(payload);
    };
    decode17 = (bytes22) => {
      const jwt = (
        /** @type {UCAN.JWT<C>} */
        decode11(bytes22)
      );
      return new JWTView({ ...parse4(jwt), jwt });
    };
    encode14 = ({ jwt }) => encode7(jwt);
    format6 = ({ jwt }) => jwt;
    JWTView = class extends View {
      /**
       * @param {UCAN.FromJWT<C>} model
       */
      constructor(model) {
        super(model);
        this.model = model;
      }
      get code() {
        return code7;
      }
      format() {
        return format6(this.model);
      }
      encode() {
        return encode14(this.model);
      }
    };
    sha = (name142) => (
      /**
       * @param {Uint8Array} data
       */
      async (data) => new Uint8Array(await crypto.subtle.digest(name142, data))
    );
    sha2562 = from4({
      name: "sha2-256",
      code: 18,
      encode: sha("SHA-256")
    });
    sha512 = from4({
      name: "sha2-512",
      code: 19,
      encode: sha("SHA-512")
    });
    VERSION = "0.9.1";
    defaultHasher = sha2562;
    decode18 = (bytes22) => {
      try {
        return decode16(bytes22);
      } catch (_) {
        return decode17(
          /** @type {UCAN.ByteView<UCAN.FromJWT<C>>} */
          bytes22
        );
      }
    };
    write = async (ucan2, { hasher = defaultHasher } = {}) => {
      const [code192, bytes22] = ucan2.jwt ? [code7, encode14(ucan2)] : [code8, encode13(ucan2)];
      const digest52 = await hasher.digest(bytes22);
      return {
        bytes: bytes22,
        cid: create3(code192, digest52),
        data: ucan2
      };
    };
    issue = async ({
      issuer,
      audience,
      capabilities,
      lifetimeInSeconds = 30,
      expiration = now() + lifetimeInSeconds,
      notBefore,
      facts = [],
      proofs: proofs2 = [],
      nonce
    }) => {
      const v = VERSION;
      const data = readPayload({
        iss: parse2(issuer.did()),
        aud: parse2(audience.did()),
        att: capabilities,
        fct: facts,
        exp: expiration,
        nbf: notBefore,
        prf: proofs2,
        nnc: nonce
      });
      const payload = encodeSignaturePayload(data, v, issuer.signatureAlgorithm);
      return from7({
        ...data,
        v,
        s: await issuer.sign(payload)
      });
    };
    encodeSignaturePayload = (payload, version22, algorithm2) => encode7(formatSignPayload(payload, version22, algorithm2));
    now = () => Math.floor(Date.now() / 1e3);
    cbor_exports3 = {};
    __export2(cbor_exports3, {
      code: () => code3,
      contentType: () => contentType,
      decode: () => decode6,
      encode: () => encode15,
      link: () => link,
      name: () => name2,
      write: () => write2
    });
    contentType = "application/vnd.ipld.dag-cbor";
    prepare = (data, seen) => {
      if (seen.has(data)) {
        throw new TypeError("Can not encode circular structure");
      }
      if (data === void 0 && seen.size === 0) {
        return null;
      }
      if (data === null) {
        return null;
      }
      if (typeof data === "symbol" && seen.size === 0) {
        return null;
      }
      if (isLink(data)) {
        return data;
      }
      if (ArrayBuffer.isView(data)) {
        return data;
      }
      if (Array.isArray(data)) {
        seen.add(data);
        const items = [];
        for (const item of data) {
          items.push(
            item === void 0 || typeof item === "symbol" ? null : prepare(item, seen)
          );
        }
        return items;
      }
      if (typeof /** @type {{toJSON?:unknown}} */
      data.toJSON === "function") {
        seen.add(data);
        const json = (
          /** @type {{toJSON():unknown}} */
          data.toJSON()
        );
        return prepare(json, seen);
      }
      if (typeof data === "object") {
        seen.add(data);
        const object = {};
        for (const [key, value] of Object.entries(data)) {
          if (value !== void 0 && typeof value !== "symbol") {
            object[key] = prepare(value, new Set(seen));
          }
        }
        return object;
      }
      return data;
    };
    encode15 = (data) => (
      /** @type {CBOR.ByteView<T>} */
      encode4(prepare(data, /* @__PURE__ */ new Set()))
    );
    link = async (bytes22, { hasher = sha2562 } = {}) => {
      return (
        /** @type {API.Link<T, typeof CBOR.code>} */
        create3(code3, await hasher.digest(bytes22))
      );
    };
    write2 = async (data, options) => {
      const bytes22 = encode15(data);
      const cid = await link(bytes22, options);
      return { cid, bytes: bytes22 };
    };
    iterate = function* (value) {
      if (value && typeof value === "object" && "iterateIPLDBlocks" in value && typeof value.iterateIPLDBlocks === "function") {
        yield* value.iterateIPLDBlocks();
      }
    };
    createStore = (blocks = []) => {
      const store2 = /* @__PURE__ */ new Map();
      addEveryInto(blocks, store2);
      return store2;
    };
    EMBED_CODE = identity.code;
    get = (cid, store2, fallback) => {
      if (cid.multihash.code === EMBED_CODE) {
        return { cid, bytes: cid.multihash.digest };
      }
      const block = (
        /** @type {API.Block<U, Format, Alg, V>|undefined} */
        store2.get(`${cid}`)
      );
      return block ? block : fallback === void 0 ? notFound(cid) : fallback;
    };
    notFound = (link5) => {
      throw new Error(`Block for the ${link5} is not found`);
    };
    writeInto = async (source, store2, options = {}) => {
      const codec = (
        /** @type {MF.BlockEncoder<C, U>} */
        options.codec || cbor_exports3
      );
      const hasher = (
        /** @type {MF.MultihashHasher<A>} */
        options.hasher || sha2562
      );
      const bytes22 = codec.encode(source);
      const digest52 = await hasher.digest(bytes22);
      const link5 = create3(codec.code, digest52);
      store2.set(
        /** @type {API.ToString<typeof link>} */
        link5.toString(),
        {
          bytes: bytes22,
          cid: link5
        }
      );
      return { bytes: bytes22, cid: link5, data: source };
    };
    addInto = ({ cid, bytes: bytes22 }, store2) => {
      store2.set(
        /** @type {API.ToString<typeof cid>} */
        cid.toString(),
        {
          bytes: bytes22,
          cid
        }
      );
      return { bytes: bytes22, cid };
    };
    addEveryInto = (source, store2) => {
      for (const block of source) {
        addInto(block, store2);
      }
    };
    car_exports = {};
    __export2(car_exports, {
      code: () => code9,
      contentType: () => contentType2,
      createWriter: () => createWriter2,
      decode: () => decode19,
      encode: () => encode16,
      link: () => link2,
      name: () => name6,
      write: () => write3
    });
    import_varint3 = __toESM2(require_varint(), 1);
    CIDV0_BYTES = {
      SHA2_256: 18,
      LENGTH: 32,
      DAG_PB: 112
    };
    V2_HEADER_LENGTH = /* characteristics */
    16 + 8 + 8 + 8;
    Kinds = {
      Null: (
        /** @returns {undefined|null} */
        (obj) => obj === null ? obj : void 0
      ),
      Int: (
        /** @returns {undefined|number} */
        (obj) => Number.isInteger(obj) ? obj : void 0
      ),
      Float: (
        /** @returns {undefined|number} */
        (obj) => typeof obj === "number" && Number.isFinite(obj) ? obj : void 0
      ),
      String: (
        /** @returns {undefined|string} */
        (obj) => typeof obj === "string" ? obj : void 0
      ),
      Bool: (
        /** @returns {undefined|boolean} */
        (obj) => typeof obj === "boolean" ? obj : void 0
      ),
      Bytes: (
        /** @returns {undefined|Uint8Array} */
        (obj) => obj instanceof Uint8Array ? obj : void 0
      ),
      Link: (
        /** @returns {undefined|object} */
        (obj) => obj !== null && typeof obj === "object" && obj.asCID === obj ? obj : void 0
      ),
      List: (
        /** @returns {undefined|Array<any>} */
        (obj) => Array.isArray(obj) ? obj : void 0
      ),
      Map: (
        /** @returns {undefined|object} */
        (obj) => obj !== null && typeof obj === "object" && obj.asCID !== obj && !Array.isArray(obj) && !(obj instanceof Uint8Array) ? obj : void 0
      )
    };
    Types = {
      "CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)": Kinds.Link,
      "CarV1HeaderOrV2Pragma > roots (anon)": (
        /** @returns {undefined|any} */
        (obj) => {
          if (Kinds.List(obj) === void 0) {
            return void 0;
          }
          for (let i = 0; i < obj.length; i++) {
            let v = obj[i];
            v = Types["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v);
            if (v === void 0) {
              return void 0;
            }
            if (v !== obj[i]) {
              const ret = obj.slice(0, i);
              for (let j = i; j < obj.length; j++) {
                let v2 = obj[j];
                v2 = Types["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v2);
                if (v2 === void 0) {
                  return void 0;
                }
                ret.push(v2);
              }
              return ret;
            }
          }
          return obj;
        }
      ),
      Int: Kinds.Int,
      CarV1HeaderOrV2Pragma: (
        /** @returns {undefined|any} */
        (obj) => {
          if (Kinds.Map(obj) === void 0) {
            return void 0;
          }
          const entries3 = Object.entries(obj);
          let ret = obj;
          let requiredCount = 1;
          for (let i = 0; i < entries3.length; i++) {
            const [key, value] = entries3[i];
            switch (key) {
              case "roots":
                {
                  const v = Types["CarV1HeaderOrV2Pragma > roots (anon)"](obj[key]);
                  if (v === void 0) {
                    return void 0;
                  }
                  if (v !== value || ret !== obj) {
                    if (ret === obj) {
                      ret = {};
                      for (let j = 0; j < i; j++) {
                        ret[entries3[j][0]] = entries3[j][1];
                      }
                    }
                    ret.roots = v;
                  }
                }
                break;
              case "version":
                {
                  requiredCount--;
                  const v = Types.Int(obj[key]);
                  if (v === void 0) {
                    return void 0;
                  }
                  if (v !== value || ret !== obj) {
                    if (ret === obj) {
                      ret = {};
                      for (let j = 0; j < i; j++) {
                        ret[entries3[j][0]] = entries3[j][1];
                      }
                    }
                    ret.version = v;
                  }
                }
                break;
              default:
                return void 0;
            }
          }
          if (requiredCount > 0) {
            return void 0;
          }
          return ret;
        }
      )
    };
    Reprs = {
      "CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)": Kinds.Link,
      "CarV1HeaderOrV2Pragma > roots (anon)": (
        /** @returns {undefined|any} */
        (obj) => {
          if (Kinds.List(obj) === void 0) {
            return void 0;
          }
          for (let i = 0; i < obj.length; i++) {
            let v = obj[i];
            v = Reprs["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v);
            if (v === void 0) {
              return void 0;
            }
            if (v !== obj[i]) {
              const ret = obj.slice(0, i);
              for (let j = i; j < obj.length; j++) {
                let v2 = obj[j];
                v2 = Reprs["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v2);
                if (v2 === void 0) {
                  return void 0;
                }
                ret.push(v2);
              }
              return ret;
            }
          }
          return obj;
        }
      ),
      Int: Kinds.Int,
      CarV1HeaderOrV2Pragma: (
        /** @returns {undefined|any} */
        (obj) => {
          if (Kinds.Map(obj) === void 0) {
            return void 0;
          }
          const entries3 = Object.entries(obj);
          let ret = obj;
          let requiredCount = 1;
          for (let i = 0; i < entries3.length; i++) {
            const [key, value] = entries3[i];
            switch (key) {
              case "roots":
                {
                  const v = Reprs["CarV1HeaderOrV2Pragma > roots (anon)"](value);
                  if (v === void 0) {
                    return void 0;
                  }
                  if (v !== value || ret !== obj) {
                    if (ret === obj) {
                      ret = {};
                      for (let j = 0; j < i; j++) {
                        ret[entries3[j][0]] = entries3[j][1];
                      }
                    }
                    ret.roots = v;
                  }
                }
                break;
              case "version":
                {
                  requiredCount--;
                  const v = Reprs.Int(value);
                  if (v === void 0) {
                    return void 0;
                  }
                  if (v !== value || ret !== obj) {
                    if (ret === obj) {
                      ret = {};
                      for (let j = 0; j < i; j++) {
                        ret[entries3[j][0]] = entries3[j][1];
                      }
                    }
                    ret.version = v;
                  }
                }
                break;
              default:
                return void 0;
            }
          }
          if (requiredCount > 0) {
            return void 0;
          }
          return ret;
        }
      )
    };
    CarV1HeaderOrV2Pragma = {
      toTyped: Types.CarV1HeaderOrV2Pragma,
      toRepresentation: Reprs.CarV1HeaderOrV2Pragma
    };
    CarBufferReader = class _CarBufferReader {
      /**
       * @constructs CarBufferReader
       * @param {CarHeader|CarV2Header} header
       * @param {Block[]} blocks
       */
      constructor(header, blocks) {
        this._header = header;
        this._blocks = blocks;
        this._cids = void 0;
      }
      /**
       * @property version
       * @memberof CarBufferReader
       * @instance
       */
      get version() {
        return this._header.version;
      }
      /**
       * Get the list of roots defined by the CAR referenced by this reader. May be
       * zero or more `CID`s.
       *
       * @function
       * @memberof CarBufferReader
       * @instance
       * @returns {CID[]}
       */
      getRoots() {
        return this._header.roots;
      }
      /**
       * Check whether a given `CID` exists within the CAR referenced by this
       * reader.
       *
       * @function
       * @memberof CarBufferReader
       * @instance
       * @param {CID} key
       * @returns {boolean}
       */
      has(key) {
        return this._blocks.some((b) => b.cid.equals(key));
      }
      /**
       * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR
       * referenced by this reader matching the provided `CID`. In the case where
       * the provided `CID` doesn't exist within the CAR, `undefined` will be
       * returned.
       *
       * @function
       * @memberof CarBufferReader
       * @instance
       * @param {CID} key
       * @returns {Block | undefined}
       */
      get(key) {
        return this._blocks.find((b) => b.cid.equals(key));
      }
      /**
       * Returns a `Block[]` of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within
       * the CAR referenced by this reader.
       *
       * @function
       * @memberof CarBufferReader
       * @instance
       * @returns {Block[]}
       */
      blocks() {
        return this._blocks;
      }
      /**
       * Returns a `CID[]` of the `CID`s contained within the CAR referenced by this reader.
       *
       * @function
       * @memberof CarBufferReader
       * @instance
       * @returns {CID[]}
       */
      cids() {
        if (!this._cids) {
          this._cids = this._blocks.map((b) => b.cid);
        }
        return this._cids;
      }
      /**
       * Instantiate a {@link CarBufferReader} from a `Uint8Array` blob. This performs a
       * decode fully in memory and maintains the decoded state in memory for full
       * access to the data via the `CarReader` API.
       *
       * @static
       * @memberof CarBufferReader
       * @param {Uint8Array} bytes
       * @returns {CarBufferReader}
       */
      static fromBytes(bytes22) {
        if (!(bytes22 instanceof Uint8Array)) {
          throw new TypeError("fromBytes() requires a Uint8Array");
        }
        const { header, blocks } = fromBytes2(bytes22);
        return new _CarBufferReader(header, blocks);
      }
    };
    cborEncoders2 = makeCborEncoders();
    defaultEncodeOptions3 = {
      float64: false,
      quickEncodeToken
    };
    import_varint4 = __toESM2(require_varint(), 1);
    CarBufferWriter = class {
      /**
       * @param {Uint8Array} bytes
       * @param {number} headerSize
       */
      constructor(bytes22, headerSize) {
        this.bytes = bytes22;
        this.byteOffset = headerSize;
        this.roots = [];
        this.headerSize = headerSize;
      }
      /**
       * Add a root to this writer, to be used to create a header when the CAR is
       * finalized with {@link CarBufferWriter.close `close()`}
       *
       * @param {CID} root
       * @param {{resize?:boolean}} [options]
       * @returns {CarBufferWriter}
       */
      addRoot(root2, options) {
        addRoot(this, root2, options);
        return this;
      }
      /**
       * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.
       * Throws if there is not enough capacity.
       *
       * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.
       * @returns {CarBufferWriter}
       */
      write(block) {
        addBlock(this, block);
        return this;
      }
      /**
       * Finalize the CAR and return it as a `Uint8Array`.
       *
       * @param {object} [options]
       * @param {boolean} [options.resize]
       * @returns {Uint8Array}
       */
      close(options) {
        return close(this, options);
      }
    };
    addRoot = (writer, root2, options = {}) => {
      const { resize = false } = options;
      const { bytes: bytes22, headerSize, byteOffset, roots } = writer;
      writer.roots.push(root2);
      const size5 = headerLength(writer);
      if (size5 > headerSize) {
        if (size5 - headerSize + byteOffset < bytes22.byteLength) {
          if (resize) {
            resizeHeader(writer, size5);
          } else {
            roots.pop();
            throw new RangeError(`Header of size ${headerSize} has no capacity for new root ${root2}.
  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`);
          }
        } else {
          roots.pop();
          throw new RangeError(`Buffer has no capacity for a new root ${root2}`);
        }
      }
    };
    blockLength = ({ cid, bytes: bytes22 }) => {
      const size5 = cid.bytes.byteLength + bytes22.byteLength;
      return import_varint4.default.encodingLength(size5) + size5;
    };
    addBlock = (writer, { cid, bytes: bytes22 }) => {
      const byteLength = cid.bytes.byteLength + bytes22.byteLength;
      const size5 = import_varint4.default.encode(byteLength);
      if (writer.byteOffset + size5.length + byteLength > writer.bytes.byteLength) {
        throw new RangeError("Buffer has no capacity for this block");
      } else {
        writeBytes(writer, size5);
        writeBytes(writer, cid.bytes);
        writeBytes(writer, bytes22);
      }
    };
    close = (writer, options = {}) => {
      const { resize = false } = options;
      const { roots, bytes: bytes22, byteOffset, headerSize } = writer;
      const headerBytes = encode4({ version: 1, roots });
      const varintBytes = import_varint4.default.encode(headerBytes.length);
      const size5 = varintBytes.length + headerBytes.byteLength;
      const offset22 = headerSize - size5;
      if (offset22 === 0) {
        writeHeader(writer, varintBytes, headerBytes);
        return bytes22.subarray(0, byteOffset);
      } else if (resize) {
        resizeHeader(writer, size5);
        writeHeader(writer, varintBytes, headerBytes);
        return bytes22.subarray(0, writer.byteOffset);
      } else {
        throw new RangeError(`Header size was overestimated.
You can use close({ resize: true }) to resize header`);
      }
    };
    resizeHeader = (writer, byteLength) => {
      const { bytes: bytes22, headerSize } = writer;
      bytes22.set(bytes22.subarray(headerSize, writer.byteOffset), byteLength);
      writer.byteOffset += byteLength - headerSize;
      writer.headerSize = byteLength;
    };
    writeBytes = (writer, bytes22) => {
      writer.bytes.set(bytes22, writer.byteOffset);
      writer.byteOffset += bytes22.length;
    };
    writeHeader = ({ bytes: bytes22 }, varint8, header) => {
      bytes22.set(varint8);
      bytes22.set(header, varint8.length);
    };
    headerPreludeTokens = [
      new Token(Type.map, 2),
      new Token(Type.string, "version"),
      new Token(Type.uint, 1),
      new Token(Type.string, "roots")
    ];
    CID_TAG = new Token(Type.tag, 42);
    calculateHeaderLength = (rootLengths) => {
      const tokens = [...headerPreludeTokens];
      tokens.push(new Token(Type.array, rootLengths.length));
      for (const rootLength of rootLengths) {
        tokens.push(CID_TAG);
        tokens.push(new Token(Type.bytes, { length: rootLength + 1 }));
      }
      const length42 = tokensToLength(tokens);
      return import_varint4.default.encodingLength(length42) + length42;
    };
    headerLength = ({ roots }) => calculateHeaderLength(roots.map((cid) => cid.bytes.byteLength));
    createWriter = (buffer22, options = {}) => {
      const {
        roots = [],
        byteOffset = 0,
        byteLength = buffer22.byteLength,
        headerSize = headerLength({ roots })
      } = options;
      const bytes22 = new Uint8Array(buffer22, byteOffset, byteLength);
      const writer = new CarBufferWriter(bytes22, headerSize);
      for (const root2 of roots) {
        writer.addRoot(root2);
      }
      return writer;
    };
    contentType2 = "application/vnd.ipld.car";
    name6 = "CAR";
    code9 = 514;
    Writer = class {
      /**
       * @param {API.IPLDBlock[]} blocks
       * @param {number} byteLength
       */
      constructor(blocks = [], byteLength = 0) {
        this.written = /* @__PURE__ */ new Set();
        this.blocks = blocks;
        this.byteLength = byteLength;
      }
      /**
       * @param {API.IPLDBlock[]} blocks
       */
      write(...blocks) {
        for (const block of blocks) {
          const id = block.cid.toString(base322);
          if (!this.written.has(id)) {
            this.blocks.push(block);
            this.byteLength += blockLength(
              /** @type {any} */
              block
            );
            this.written.add(id);
          }
        }
        return this;
      }
      /**
       * @param {API.IPLDBlock[]} rootBlocks
       */
      flush(...rootBlocks) {
        const roots = [];
        for (const block of rootBlocks.reverse()) {
          const id = block.cid.toString(base322);
          if (!this.written.has(id)) {
            this.blocks.unshift(block);
            this.byteLength += blockLength({
              cid: (
                /** @type {CarBufferWriter.CID} */
                block.cid
              ),
              bytes: block.bytes
            });
            this.written.add(id);
          }
          roots.unshift(
            /** @type {CarBufferWriter.CID} */
            block.cid
          );
        }
        this.byteLength += headerLength({ roots });
        const buffer22 = new ArrayBuffer(this.byteLength);
        const writer = createWriter(buffer22, { roots });
        for (
          const block of
          /** @type {CarBufferWriter.Block[]} */
          this.blocks
        ) {
          writer.write(block);
        }
        return writer.close();
      }
    };
    createWriter2 = () => new Writer();
    encode16 = ({ roots = [], blocks }) => {
      const writer = new Writer();
      if (blocks) {
        writer.write(...blocks.values());
      }
      return writer.flush(...roots);
    };
    decode19 = (bytes22) => {
      const reader = CarBufferReader.fromBytes(bytes22);
      const roots = [];
      const blocks = /* @__PURE__ */ new Map();
      for (const root2 of reader.getRoots()) {
        const block = (
          /** @type {API.IPLDBlock} */
          reader.get(root2)
        );
        if (block) {
          roots.push(block);
        }
      }
      for (const block of reader.blocks()) {
        blocks.set(block.cid.toString(), block);
      }
      return { roots, blocks };
    };
    link2 = async (bytes22, { hasher = sha2562 } = {}) => {
      return (
        /** @type {API.Link<T, typeof code, typeof hasher.code>} */
        create3(code9, await hasher.digest(bytes22))
      );
    };
    write3 = async (data, options) => {
      const bytes22 = encode16(data);
      const cid = await link2(bytes22, options);
      return { bytes: bytes22, cid };
    };
    schema_exports3 = {};
    __export2(schema_exports3, {
      API: () => API,
      Bytes: () => Bytes,
      DID: () => did_exports2,
      Link: () => link_exports2,
      Text: () => text_exports,
      URI: () => uri_exports,
      and: () => and,
      array: () => array,
      boolean: () => boolean,
      bytes: () => bytes2,
      dictionary: () => dictionary,
      did: () => match3,
      endsWith: () => endsWith,
      enum: () => createEnum,
      error: () => error2,
      float: () => float,
      greaterThan: () => greaterThan,
      integer: () => integer,
      intersection: () => intersection,
      lessThan: () => lessThan,
      link: () => match2,
      literal: () => literal,
      memberError: () => memberError,
      never: () => never,
      nullable: () => nullable,
      number: () => number2,
      ok: () => ok,
      optional: () => optional,
      or: () => or3,
      refine: () => refine,
      startsWith: () => startsWith,
      string: () => string,
      struct: () => struct,
      text: () => match4,
      toString: () => toString3,
      tuple: () => tuple,
      typeError: () => typeError,
      uint64: () => uint64,
      unknown: () => unknown,
      uri: () => match,
      variant: () => variant
    });
    uri_exports = {};
    __export2(uri_exports, {
      from: () => from9,
      match: () => match,
      read: () => read3,
      uri: () => uri
    });
    ok = (value) => {
      if (value == null) {
        throw new TypeError(`ok(${value}) is not allowed, consider ok({}) instead`);
      } else {
        return { ok: value };
      }
    };
    error = (cause) => {
      if (cause == null) {
        throw new TypeError(
          `error(${cause}) is not allowed, consider passing an error instead`
        );
      } else {
        return { error: cause };
      }
    };
    panic = (message2) => {
      throw new Failure(message2);
    };
    fail2 = (message2) => ({ error: new Failure(message2) });
    Failure = class extends Error {
      describe() {
        return this.toString();
      }
      get message() {
        return this.describe();
      }
      toJSON() {
        const { name: name142, message: message2, stack } = this;
        return { name: name142, message: message2, stack };
      }
    };
    API = class {
      /**
       * @param {Settings} settings
       */
      constructor(settings) {
        this.settings = settings;
      }
      toString() {
        return `new ${this.constructor.name}()`;
      }
      /**
       * @abstract
       * @param {I} input
       * @param {Settings} settings
       * @returns {Schema.ReadResult<T>}
       */
      /* c8 ignore next 3 */
      readWith(input10, settings) {
        throw new Error(`Abstract method readWith must be implemented by subclass`);
      }
      /**
       * @param {I} input
       * @returns {Schema.ReadResult<T>}
       */
      read(input10) {
        return this.readWith(input10, this.settings);
      }
      /**
       * @param {unknown} value
       * @returns {value is T}
       */
      is(value) {
        return !this.read(
          /** @type {I} */
          value
        )?.error;
      }
      /**
       * @param {unknown} value
       * @return {T}
       */
      from(value) {
        const result = this.read(
          /** @type {I} */
          value
        );
        if (result.error) {
          throw result.error;
        } else {
          return result.ok;
        }
      }
      /**
       * @returns {Schema.Schema<T|undefined, I>}
       */
      optional() {
        return optional(this);
      }
      /**
       * @returns {Schema.Schema<T|null, I>}
       */
      nullable() {
        return nullable(this);
      }
      /**
       * @returns {Schema.Schema<T[], I>}
       */
      array() {
        return array(this);
      }
      /**
       * @template U
       * @param {Schema.Reader<U, I>} schema
       * @returns {Schema.Schema<T | U, I>}
       */
      or(schema5) {
        return or3(this, schema5);
      }
      /**
       * @template U
       * @param {Schema.Reader<U, I>} schema
       * @returns {Schema.Schema<T & U, I>}
       */
      and(schema5) {
        return and(this, schema5);
      }
      /**
       * @template {T} U
       * @param {Schema.Reader<U, T>} schema
       * @returns {Schema.Schema<U, I>}
       */
      refine(schema5) {
        return refine(this, schema5);
      }
      /**
       * @template {string} Kind
       * @param {Kind} [kind]
       * @returns {Schema.Schema<Schema.Branded<T, Kind>, I>}
       */
      brand(kind) {
        return (
          /** @type {Schema.Schema<Schema.Branded<T, Kind>, I>} */
          this
        );
      }
      /**
       * @param {Schema.NotUndefined<T>} value
       * @returns {Schema.DefaultSchema<Schema.NotUndefined<T>, I>}
       */
      default(value) {
        const fallback = this.from(value);
        if (fallback === void 0) {
          throw new Error(`Value of type undefined is not a valid default`);
        }
        const schema5 = new Default({
          reader: (
            /** @type {Schema.Reader<T, I>} */
            this
          ),
          value: (
            /** @type {Schema.NotUndefined<T>} */
            fallback
          )
        });
        return (
          /** @type {Schema.DefaultSchema<Schema.NotUndefined<T>, I>} */
          schema5
        );
      }
    };
    Never = class extends API {
      toString() {
        return "never()";
      }
      /**
       * @param {I} input
       * @returns {Schema.ReadResult<never>}
       */
      read(input10) {
        return typeError({ expect: "never", actual: input10 });
      }
    };
    never = () => new Never();
    Unknown = class extends API {
      /**
       * @param {I} input
       */
      read(input10) {
        return (
          /** @type {Schema.ReadResult<unknown>}*/
          { ok: input10 }
        );
      }
      toString() {
        return "unknown()";
      }
    };
    unknown = () => new Unknown();
    Nullable = class extends API {
      /**
       * @param {I} input
       * @param {Schema.Reader<O, I>} reader
       */
      readWith(input10, reader) {
        const result = reader.read(input10);
        if (result.error) {
          return input10 === null ? { ok: null } : {
            error: new UnionError({
              causes: [
                result.error,
                typeError({ expect: "null", actual: input10 }).error
              ]
            })
          };
        } else {
          return result;
        }
      }
      toString() {
        return `${this.settings}.nullable()`;
      }
    };
    nullable = (schema5) => new Nullable(schema5);
    Optional = class extends API {
      optional() {
        return this;
      }
      /**
       * @param {I} input
       * @param {Schema.Reader<O, I>} reader
       * @returns {Schema.ReadResult<O|undefined>}
       */
      readWith(input10, reader) {
        const result = reader.read(input10);
        return result.error && input10 === void 0 ? { ok: void 0 } : result;
      }
      toString() {
        return `${this.settings}.optional()`;
      }
    };
    Default = class extends API {
      /**
       * @returns {Schema.DefaultSchema<O & Schema.NotUndefined<O>, I>}
       */
      optional() {
        return (
          /** @type {Schema.DefaultSchema<O & Schema.NotUndefined<O>, I>} */
          this
        );
      }
      /**
       * @param {I} input
       * @param {object} options
       * @param {Schema.Reader<O|undefined, I>} options.reader
       * @param {O} options.value
       * @returns {Schema.ReadResult<O>}
       */
      readWith(input10, { reader, value }) {
        if (input10 === void 0) {
          return (
            /** @type {Schema.ReadResult<O>} */
            { ok: value }
          );
        } else {
          const result = reader.read(input10);
          return result.error ? result : result.ok !== void 0 ? (
            // We just checked that result.ok is not undefined but still needs
            // reassurance
            /** @type {Schema.ReadResult<O>} */
            result
          ) : { ok: value };
        }
      }
      toString() {
        return `${this.settings.reader}.default(${JSON.stringify(
          this.settings.value
        )})`;
      }
      get value() {
        return this.settings.value;
      }
    };
    optional = (schema5) => new Optional(schema5);
    ArrayOf = class extends API {
      /**
       * @param {I} input
       * @param {Schema.Reader<O, I>} schema
       */
      readWith(input10, schema5) {
        if (!Array.isArray(input10)) {
          return typeError({ expect: "array", actual: input10 });
        }
        const results = [];
        for (const [index2, value] of input10.entries()) {
          const result = schema5.read(value);
          if (result.error) {
            return memberError({ at: index2, cause: result.error });
          } else {
            results.push(result.ok);
          }
        }
        return { ok: results };
      }
      get element() {
        return this.settings;
      }
      toString() {
        return `array(${this.element})`;
      }
    };
    array = (schema5) => new ArrayOf(schema5);
    Tuple = class extends API {
      /**
       * @param {I} input
       * @param {U} shape
       * @returns {Schema.ReadResult<Schema.InferTuple<U>>}
       */
      readWith(input10, shape) {
        if (!Array.isArray(input10)) {
          return typeError({ expect: "array", actual: input10 });
        }
        if (input10.length !== this.shape.length) {
          return error2(`Array must contain exactly ${this.shape.length} elements`);
        }
        const results = [];
        for (const [index2, reader] of shape.entries()) {
          const result = reader.read(input10[index2]);
          if (result.error) {
            return memberError({ at: index2, cause: result.error });
          } else {
            results[index2] = result.ok;
          }
        }
        return { ok: (
          /** @type {Schema.InferTuple<U>} */
          results
        ) };
      }
      /** @type {U} */
      get shape() {
        return this.settings;
      }
      toString() {
        return `tuple([${this.shape.map((reader) => reader.toString()).join(", ")}])`;
      }
    };
    tuple = (shape) => new Tuple(shape);
    Dictionary = class _Dictionary extends API {
      /**
       * @param {I} input
       * @param {object} schema
       * @param {Schema.Reader<K, string>} schema.key
       * @param {Schema.Reader<V, I>} schema.value
       */
      readWith(input10, { key, value }) {
        if (typeof input10 != "object" || input10 === null || Array.isArray(input10)) {
          return typeError({
            expect: "dictionary",
            actual: input10
          });
        }
        const dict = (
          /** @type {Schema.Dictionary<K, V>} */
          {}
        );
        for (const [k, v] of Object.entries(input10)) {
          const keyResult = key.read(k);
          if (keyResult.error) {
            return memberError({ at: k, cause: keyResult.error });
          }
          const valueResult = value.read(v);
          if (valueResult.error) {
            return memberError({ at: k, cause: valueResult.error });
          }
          if (valueResult.ok !== void 0) {
            dict[keyResult.ok] = valueResult.ok;
          }
        }
        return { ok: dict };
      }
      get key() {
        return this.settings.key;
      }
      get value() {
        return this.settings.value;
      }
      partial() {
        const { key, value } = this.settings;
        return new _Dictionary({
          key,
          value: optional(value)
        });
      }
      toString() {
        return `dictionary(${this.settings})`;
      }
    };
    dictionary = ({ value, key }) => new Dictionary({
      value,
      key: key || /** @type {Schema.Reader<K, string>} */
      string()
    });
    Enum = class extends API {
      /**
       * @param {I} input
       * @param {{type:string, variants:Set<T[number]>}} settings
       * @returns {Schema.ReadResult<T[number]>}
       */
      readWith(input10, { variants, type: type2 }) {
        if (variants.has(input10)) {
          return (
            /** @type {Schema.ReadResult<T[number]>} */
            { ok: input10 }
          );
        } else {
          return typeError({ expect: type2, actual: input10 });
        }
      }
      toString() {
        return this.settings.type;
      }
    };
    createEnum = (variants) => new Enum({
      type: variants.join("|"),
      variants: new Set(variants)
    });
    Union = class extends API {
      /**
       * @param {I} input
       * @param {U} variants
       */
      readWith(input10, variants) {
        const causes = [];
        for (const reader of variants) {
          const result = reader.read(input10);
          if (result.error) {
            causes.push(result.error);
          } else {
            return (
              /** @type {Schema.ReadResult<Schema.InferUnion<U>>} */
              result
            );
          }
        }
        return { error: new UnionError({ causes }) };
      }
      get variants() {
        return this.settings;
      }
      toString() {
        return `union([${this.variants.map((type2) => type2.toString()).join(", ")}])`;
      }
    };
    union = (variants) => new Union(variants);
    or3 = (left, right) => union([left, right]);
    Intersection = class extends API {
      /**
       * @param {I} input
       * @param {U} schemas
       * @returns {Schema.ReadResult<Schema.InferIntersection<U>>}
       */
      readWith(input10, schemas) {
        const causes = [];
        for (const schema5 of schemas) {
          const result = schema5.read(input10);
          if (result.error) {
            causes.push(result.error);
          }
        }
        return causes.length > 0 ? { error: new IntersectionError({ causes }) } : (
          /** @type {Schema.ReadResult<Schema.InferIntersection<U>>} */
          {
            ok: input10
          }
        );
      }
      toString() {
        return `intersection([${this.settings.map((type2) => type2.toString()).join(",")}])`;
      }
    };
    intersection = (variants) => new Intersection(variants);
    and = (left, right) => intersection([left, right]);
    Boolean2 = class extends API {
      /**
       * @param {I} input
       */
      readWith(input10) {
        switch (input10) {
          case true:
          case false:
            return { ok: (
              /** @type {boolean} */
              input10
            ) };
          default:
            return typeError({
              expect: "boolean",
              actual: input10
            });
        }
      }
      toString() {
        return `boolean()`;
      }
    };
    anyBoolean = new Boolean2();
    boolean = () => anyBoolean;
    UnknownNumber = class extends API {
      /**
       * @param {number} n
       */
      greaterThan(n2) {
        return this.refine(greaterThan(n2));
      }
      /**
       * @param {number} n
       */
      lessThan(n2) {
        return this.refine(lessThan(n2));
      }
      /**
       * @template {O} U
       * @param {Schema.Reader<U, O>} schema
       * @returns {Schema.NumberSchema<U, I>}
       */
      refine(schema5) {
        return new RefinedNumber({ base: this, schema: schema5 });
      }
    };
    AnyNumber = class extends UnknownNumber {
      /**
       * @param {I} input
       * @returns {Schema.ReadResult<number>}
       */
      readWith(input10) {
        return typeof input10 === "number" ? { ok: input10 } : typeError({ expect: "number", actual: input10 });
      }
      toString() {
        return `number()`;
      }
    };
    anyNumber = new AnyNumber();
    number2 = () => anyNumber;
    RefinedNumber = class extends UnknownNumber {
      /**
       * @param {I} input
       * @param {{base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}} settings
       * @returns {Schema.ReadResult<O>}
       */
      readWith(input10, { base: base42, schema: schema5 }) {
        const result = base42.read(input10);
        return result.error ? result : schema5.read(result.ok);
      }
      toString() {
        return `${this.settings.base}.refine(${this.settings.schema})`;
      }
    };
    LessThan = class extends API {
      /**
       * @param {T} input
       * @param {number} number
       * @returns {Schema.ReadResult<T>}
       */
      readWith(input10, number22) {
        if (input10 < number22) {
          return { ok: input10 };
        } else {
          return error2(`Expected ${input10} < ${number22}`);
        }
      }
      toString() {
        return `lessThan(${this.settings})`;
      }
    };
    lessThan = (n2) => new LessThan(n2);
    GreaterThan = class extends API {
      /**
       * @param {T} input
       * @param {number} number
       * @returns {Schema.ReadResult<T>}
       */
      readWith(input10, number22) {
        if (input10 > number22) {
          return { ok: input10 };
        } else {
          return error2(`Expected ${input10} > ${number22}`);
        }
      }
      toString() {
        return `greaterThan(${this.settings})`;
      }
    };
    greaterThan = (n2) => new GreaterThan(n2);
    Integer = {
      /**
       * @param {number} input
       * @returns {Schema.ReadResult<Schema.Integer>}
       */
      read(input10) {
        return Number.isInteger(input10) ? { ok: (
          /** @type {Schema.Integer} */
          input10
        ) } : typeError({
          expect: "integer",
          actual: input10
        });
      },
      toString() {
        return `Integer`;
      }
    };
    anyInteger = anyNumber.refine(Integer);
    integer = () => anyInteger;
    MAX_UINT64 = 2n ** 64n - 1n;
    Uint64Schema = class extends API {
      /**
       * @param {I} input
       * @returns {Schema.ReadResult<O>}
       */
      read(input10) {
        switch (typeof input10) {
          case "bigint":
            return input10 > MAX_UINT64 ? error2(`Integer is too big for uint64, ${input10} > ${MAX_UINT64}`) : input10 < 0 ? error2(
              `Negative integer can not be represented as uint64, ${input10} < ${0}`
            ) : { ok: (
              /** @type {I & O} */
              input10
            ) };
          case "number":
            return !Number.isInteger(input10) ? typeError({
              expect: "uint64",
              actual: input10
            }) : input10 < 0 ? error2(
              `Negative integer can not be represented as uint64, ${input10} < ${0}`
            ) : { ok: (
              /** @type {O} */
              BigInt(input10)
            ) };
          default:
            return typeError({
              expect: "uint64",
              actual: input10
            });
        }
      }
      toString() {
        return `uint64`;
      }
    };
    Uint64 = new Uint64Schema();
    uint64 = () => Uint64;
    Float = {
      /**
       * @param {number} number
       * @returns {Schema.ReadResult<Schema.Float>}
       */
      read(number22) {
        return Number.isFinite(number22) ? { ok: (
          /** @type {Schema.Float} */
          number22
        ) } : typeError({
          expect: "Float",
          actual: number22
        });
      },
      toString() {
        return "Float";
      }
    };
    anyFloat = anyNumber.refine(Float);
    float = () => anyFloat;
    UnknownString = class extends API {
      /**
       * @template {O|unknown} U
       * @param {Schema.Reader<U, O>} schema
       * @returns {Schema.StringSchema<O & U, I>}
       */
      refine(schema5) {
        const other = (
          /** @type {Schema.Reader<U, O>} */
          schema5
        );
        const rest = new RefinedString({
          base: this,
          schema: other
        });
        return (
          /** @type {Schema.StringSchema<O & U, I>} */
          rest
        );
      }
      /**
       * @template {string} Prefix
       * @param {Prefix} prefix
       */
      startsWith(prefix2) {
        return this.refine(startsWith(prefix2));
      }
      /**
       * @template {string} Suffix
       * @param {Suffix} suffix
       */
      endsWith(suffix) {
        return this.refine(endsWith(suffix));
      }
      toString() {
        return `string()`;
      }
    };
    RefinedString = class extends UnknownString {
      /**
       * @param {I} input
       * @param {{base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}} settings
       * @returns {Schema.ReadResult<T & O>}
       */
      readWith(input10, { base: base42, schema: schema5 }) {
        const result = base42.read(input10);
        return result.error ? result : (
          /** @type {Schema.ReadResult<T & O>} */
          schema5.read(result.ok)
        );
      }
      toString() {
        return `${this.settings.base}.refine(${this.settings.schema})`;
      }
    };
    AnyString = class extends UnknownString {
      /**
       * @param {I} input
       * @returns {Schema.ReadResult<string>}
       */
      readWith(input10) {
        return typeof input10 === "string" ? { ok: input10 } : typeError({ expect: "string", actual: input10 });
      }
    };
    anyString = new AnyString();
    string = () => anyString;
    BytesSchema = class extends API {
      /**
       * @param {I} input
       * @returns {Schema.ReadResult<Uint8Array>}
       */
      readWith(input10) {
        if (input10 instanceof Uint8Array) {
          return { ok: input10 };
        } else {
          return typeError({ expect: "Uint8Array", actual: input10 });
        }
      }
    };
    Bytes = new BytesSchema();
    bytes2 = () => Bytes;
    StartsWith = class extends API {
      /**
       * @param {Body} input
       * @param {Prefix} prefix
       */
      readWith(input10, prefix2) {
        const result = input10.startsWith(prefix2) ? (
          /** @type {Schema.ReadResult<Body & `${Prefix}${Body}`>} */
          {
            ok: input10
          }
        ) : error2(`Expect string to start with "${prefix2}" instead got "${input10}"`);
        return result;
      }
      get prefix() {
        return this.settings;
      }
      toString() {
        return `startsWith("${this.prefix}")`;
      }
    };
    startsWith = (prefix2) => new StartsWith(prefix2);
    EndsWith = class extends API {
      /**
       * @param {Body} input
       * @param {Suffix} suffix
       */
      readWith(input10, suffix) {
        return input10.endsWith(suffix) ? (
          /** @type {Schema.ReadResult<Body & `${Body}${Suffix}`>} */
          {
            ok: input10
          }
        ) : error2(`Expect string to end with "${suffix}" instead got "${input10}"`);
      }
      get suffix() {
        return this.settings;
      }
      toString() {
        return `endsWith("${this.suffix}")`;
      }
    };
    endsWith = (suffix) => new EndsWith(suffix);
    Refine = class extends API {
      /**
       * @param {I} input
       * @param {{ base: Schema.Reader<T, I>, schema: Schema.Reader<U, T> }} settings
       */
      readWith(input10, { base: base42, schema: schema5 }) {
        const result = base42.read(input10);
        return result.error ? result : schema5.read(result.ok);
      }
      toString() {
        return `${this.settings.base}.refine(${this.settings.schema})`;
      }
    };
    refine = (base42, schema5) => new Refine({ base: base42, schema: schema5 });
    Literal = class extends API {
      /**
       * @param {I} input
       * @param {T} expect
       * @returns {Schema.ReadResult<T>}
       */
      readWith(input10, expect) {
        return input10 !== /** @type {unknown} */
        expect ? { error: new LiteralError({ expect, actual: input10 }) } : { ok: expect };
      }
      get value() {
        return (
          /** @type {Exclude<T, undefined>} */
          this.settings
        );
      }
      /**
       * @template {Schema.NotUndefined<T>} U
       * @param {U} value
       */
      default(value = (
        /** @type {U} */
        this.value
      )) {
        return super.default(value);
      }
      toString() {
        return `literal(${toString3(this.value)})`;
      }
    };
    literal = (value) => new Literal(value);
    Struct = class _Struct extends API {
      /**
       * @param {I} input
       * @param {U} shape
       * @returns {Schema.ReadResult<Schema.InferStruct<U>>}
       */
      readWith(input10, shape) {
        if (typeof input10 != "object" || input10 === null || Array.isArray(input10)) {
          return typeError({
            expect: "object",
            actual: input10
          });
        }
        const source = (
          /** @type {{[K in keyof U]: unknown}} */
          input10
        );
        const struct2 = (
          /** @type {{[K in keyof U]: Schema.Infer<U[K]>}} */
          {}
        );
        const entries3 = (
          /** @type {{[K in keyof U]: [K & string, U[K]]}[keyof U][]} */
          Object.entries(shape)
        );
        for (const [at2, reader] of entries3) {
          const result = reader.read(source[at2]);
          if (result.error) {
            return memberError({ at: at2, cause: result.error });
          } else if (result.ok !== void 0) {
            struct2[at2] = /** @type {Schema.Infer<U[typeof at]>} */
            result.ok;
          }
        }
        return { ok: struct2 };
      }
      /**
       * @returns {Schema.MapRepresentation<Partial<Schema.InferStruct<U>>> & Schema.StructSchema}
       */
      partial() {
        return new _Struct(
          Object.fromEntries(
            Object.entries(this.shape).map(([key, value]) => [key, optional(value)])
          )
        );
      }
      /** @type {U} */
      get shape() {
        return this.settings;
      }
      toString() {
        return [
          `struct({ `,
          ...Object.entries(this.shape).map(([key, schema5]) => `${key}: ${schema5}`).join(", "),
          ` })`
        ].join("");
      }
      /**
       * @param {Schema.InferStructSource<U>} data
       */
      create(data) {
        return this.from(data || {});
      }
      /**
       * @template {{[key:string]: Schema.Reader}} E
       * @param {E} extension
       * @returns {Schema.StructSchema<U & E, I>}
       */
      extend(extension) {
        return new _Struct({ ...this.shape, ...extension });
      }
    };
    struct = (fields) => {
      const shape = (
        /** @type {{[K in keyof U]: Schema.Reader<unknown, unknown>}} */
        {}
      );
      const entries3 = Object.entries(fields);
      for (const [key, field] of entries3) {
        switch (typeof field) {
          case "number":
          case "string":
          case "boolean":
            shape[key] = literal(field);
            break;
          case "object":
            shape[key] = field === null ? literal(null) : field;
            break;
          default:
            throw new Error(
              `Invalid struct field "${key}", expected schema or literal, instead got ${typeof field}`
            );
        }
      }
      return new Struct(
        /** @type {V} */
        shape
      );
    };
    Variant = class extends API {
      /**
       * @param {I} input
       * @param {U} variants
       * @returns {Schema.ReadResult<Schema.InferVariant<U>>}
       */
      readWith(input10, variants) {
        if (typeof input10 != "object" || input10 === null || Array.isArray(input10)) {
          return typeError({
            expect: "object",
            actual: input10
          });
        }
        const keys2 = (
          /** @type {Array<keyof input & keyof variants & string>} */
          Object.keys(input10)
        );
        const [key] = keys2.length === 1 ? keys2 : [];
        const reader = key ? variants[key] : void 0;
        if (reader) {
          const result = reader.read(input10[key]);
          return result.error ? memberError({ at: key, cause: result.error }) : { ok: (
            /** @type {Schema.InferVariant<U>} */
            { [key]: result.ok }
          ) };
        } else if (variants._) {
          const result = variants._.read(input10);
          return result.error ? result : { ok: (
            /** @type {Schema.InferVariant<U>} */
            { _: result.ok }
          ) };
        } else if (key) {
          return error2(
            `Expected an object with one of the these keys: ${Object.keys(variants).sort().join(", ")} instead got object with key ${key}`
          );
        } else {
          return error2(
            "Expected an object with a single key instead got object with keys " + keys2.sort().join(", ")
          );
        }
      }
      /**
       * @template [E=never]
       * @param {I} input
       * @param {E} [fallback]
       */
      match(input10, fallback) {
        const result = this.read(input10);
        if (result.error) {
          if (fallback !== void 0) {
            return [null, fallback];
          } else {
            throw result.error;
          }
        } else {
          const [key] = Object.keys(result.ok);
          const value = result.ok[key];
          return (
            /** @type {any} */
            [key, value]
          );
        }
      }
      /**
       * @template {Schema.InferVariant<U>} O
       * @param {O} source
       * @returns {O}
       */
      create(source) {
        return (
          /** @type {O} */
          this.from(source)
        );
      }
    };
    variant = (variants) => new Variant(variants);
    error2 = (message2) => ({ error: new SchemaError(message2) });
    SchemaError = class extends Failure {
      get name() {
        return "SchemaError";
      }
      /* c8 ignore next 3 */
      describe() {
        return this.name;
      }
    };
    TypeError2 = class extends SchemaError {
      /**
       * @param {{expect:string, actual:unknown}} data
       */
      constructor({ expect, actual }) {
        super();
        this.expect = expect;
        this.actual = actual;
      }
      get name() {
        return "TypeError";
      }
      describe() {
        return `Expected value of type ${this.expect} instead got ${toString3(
          this.actual
        )}`;
      }
    };
    typeError = (data) => ({ error: new TypeError2(data) });
    toString3 = (value) => {
      const type2 = typeof value;
      switch (type2) {
        case "boolean":
        case "string":
          return JSON.stringify(value);
        case "bigint":
          return `${value}n`;
        case "number":
        case "symbol":
        case "undefined":
          return String(value);
        case "object":
          return value === null ? "null" : Array.isArray(value) ? "array" : Symbol.toStringTag in /** @type {object} */
          value ? value[Symbol.toStringTag] : "object";
        default:
          return type2;
      }
    };
    LiteralError = class extends SchemaError {
      /**
       * @param {{
       * expect:string|number|boolean|null
       * actual:unknown
       * }} data
       */
      constructor({ expect, actual }) {
        super();
        this.expect = expect;
        this.actual = actual;
      }
      get name() {
        return "LiteralError";
      }
      describe() {
        return `Expected literal ${toString3(this.expect)} instead got ${toString3(
          this.actual
        )}`;
      }
    };
    ElementError = class extends SchemaError {
      /**
       * @param {{at:number, cause:Schema.Error}} data
       */
      constructor({ at: at2, cause }) {
        super();
        this.at = at2;
        this.cause = cause;
      }
      get name() {
        return "ElementError";
      }
      describe() {
        return [
          `Array contains invalid element at ${this.at}:`,
          li(this.cause.message)
        ].join("\n");
      }
    };
    FieldError = class extends SchemaError {
      /**
       * @param {{at:string, cause:Schema.Error}} data
       */
      constructor({ at: at2, cause }) {
        super();
        this.at = at2;
        this.cause = cause;
      }
      get name() {
        return "FieldError";
      }
      describe() {
        return [
          `Object contains invalid field "${this.at}":`,
          li(this.cause.message)
        ].join("\n");
      }
    };
    memberError = ({ at: at2, cause }) => typeof at2 === "string" ? { error: new FieldError({ at: at2, cause }) } : { error: new ElementError({ at: at2, cause }) };
    UnionError = class extends SchemaError {
      /**
       * @param {{causes: Schema.Error[]}} data
       */
      constructor({ causes }) {
        super();
        this.causes = causes;
      }
      get name() {
        return "UnionError";
      }
      describe() {
        const { causes } = this;
        return [
          `Value does not match any type of the union:`,
          ...causes.map((cause) => li(cause.message))
        ].join("\n");
      }
    };
    IntersectionError = class extends SchemaError {
      /**
       * @param {{causes: Schema.Error[]}} data
       */
      constructor({ causes }) {
        super();
        this.causes = causes;
      }
      get name() {
        return "IntersectionError";
      }
      describe() {
        const { causes } = this;
        return [
          `Value does not match following types of the intersection:`,
          ...causes.map((cause) => li(cause.message))
        ].join("\n");
      }
    };
    indent = (message2, indent3 = "  ") => `${indent3}${message2.split("\n").join(`
${indent3}`)}`;
    li = (message2) => indent(`- ${message2}`);
    URISchema = class extends API {
      /**
       * @param {unknown} input
       * @param {Partial<O>} options
       * @returns {Schema.ReadResult<API.URI<O['protocol']>>}
       */
      readWith(input10, { protocol } = {}) {
        if (typeof input10 !== "string" && !(input10 instanceof URL)) {
          return error2(
            `Expected URI but got ${input10 === null ? "null" : typeof input10}`
          );
        }
        try {
          const url2 = new URL(String(input10));
          if (protocol != null && url2.protocol !== protocol) {
            return error2(`Expected ${protocol} URI instead got ${url2.href}`);
          } else {
            return { ok: (
              /** @type {API.URI<O['protocol']>} */
              url2.href
            ) };
          }
        } catch (_) {
          return error2(`Invalid URI`);
        }
      }
    };
    schema = new URISchema({});
    uri = () => schema;
    read3 = (input10) => schema.read(input10);
    match = (options) => new URISchema(options);
    from9 = (input10) => (
      /** @type {API.URI<`${Scheme}:`>} */
      schema.from(input10)
    );
    link_exports2 = {};
    __export2(link_exports2, {
      create: () => create3,
      createLegacy: () => createLegacy,
      isLink: () => isLink,
      link: () => link3,
      match: () => match2,
      optional: () => optional2,
      parse: () => parse,
      read: () => read4,
      schema: () => schema2
    });
    LinkSchema = class extends API {
      /**
       *
       * @param {unknown} cid
       * @param {Settings<Code, Alg, Version>} settings
       * @returns {Schema.ReadResult<API.Link<unknown, Code, Alg, Version>>}
       */
      readWith(cid, { code: code192, multihash = {}, version: version22 }) {
        if (cid == null) {
          return error2(`Expected link but got ${cid} instead`);
        } else {
          if (!isLink(cid)) {
            return error2(`Expected link to be a CID instead of ${cid}`);
          } else {
            if (code192 != null && cid.code !== code192) {
              return error2(
                `Expected link to be CID with 0x${code192.toString(16)} codec`
              );
            }
            if (multihash.code != null && cid.multihash.code !== multihash.code)
              return error2(
                `Expected link to be CID with 0x${multihash.code.toString(
                  16
                )} hashing algorithm`
              );
            if (version22 != null && cid.version !== version22) {
              return error2(
                `Expected link to be CID version ${version22} instead of ${cid.version}`
              );
            }
            const [expectDigest, actualDigest] = multihash.digest != null ? [
              base322.baseEncode(multihash.digest),
              base322.baseEncode(cid.multihash.digest)
            ] : ["", ""];
            if (expectDigest !== actualDigest) {
              return error2(
                `Expected link with "${expectDigest}" hash digest instead of "${actualDigest}"`
              );
            }
            return {
              ok: (
                /** @type {API.Link<unknown, any, any, any>} */
                cid
              )
            };
          }
        }
      }
    };
    schema2 = new LinkSchema({});
    link3 = () => schema2;
    match2 = (options = {}) => new LinkSchema(options);
    read4 = (input10) => schema2.read(input10);
    optional2 = () => schema2.optional();
    did_exports2 = {};
    __export2(did_exports2, {
      did: () => did,
      from: () => from10,
      match: () => match3,
      read: () => read5
    });
    DIDSchema = class extends API {
      /**
       * @param {string} source
       * @param {void|Method} method
       */
      readWith(source, method) {
        const prefix2 = method ? `did:${method}:` : `did:`;
        if (!source.startsWith(prefix2)) {
          return error2(`Expected a ${prefix2} but got "${source}" instead`);
        } else {
          return { ok: (
            /** @type {API.DID<Method>} */
            source
          ) };
        }
      }
    };
    schema3 = string().refine(new DIDSchema());
    did = () => schema3;
    read5 = (input10) => schema3.read(input10);
    match3 = (options = {}) => (
      /** @type {Schema.Schema<API.DID<Method> & API.URI<"did:">>} */
      string().refine(new DIDSchema(options.method))
    );
    from10 = (input10) => match3({}).from(input10);
    text_exports = {};
    __export2(text_exports, {
      match: () => match4,
      read: () => read6,
      text: () => text
    });
    schema4 = string();
    match4 = (options) => options ? schema4.refine(new Match(options.pattern)) : schema4;
    text = match4;
    read6 = (input10) => schema4.read(input10);
    Match = class extends API {
      /**
       * @param {string} source
       * @param {RegExp} pattern
       */
      readWith(source, pattern) {
        if (!pattern.test(source)) {
          return error2(
            `Expected to match ${pattern} but got "${source}" instead`
          );
        } else {
          return { ok: source };
        }
      }
    };
    isLink2 = isLink;
    isDelegation = (proof) => !isLink(proof);
    allows = (...delegations) => {
      let allow = {};
      for (const delegation of delegations) {
        for (const { with: uri2, can, nb } of iterateCapabilities(delegation)) {
          const resource = allow[uri2] || (allow[uri2] = {});
          const abilities = resource[can] || (resource[can] = []);
          abilities.push({ ...nb });
        }
      }
      return (
        /** @type {API.InferAllowedFromDelegations<T>} */
        allow
      );
    };
    iterateCapabilities = function* ({ issuer, capabilities, proofs: proofs2 }) {
      for (const own of capabilities) {
        if (own.with === "ucan:*") {
          yield {
            ...own,
            with: issuer.did()
          };
          for (const proof of proofs2) {
            if (isDelegation(proof)) {
              for (const capability2 of iterateCapabilities(proof)) {
                const can = matchAbility(capability2.can, own.can);
                if (can) {
                  yield {
                    ...capability2,
                    can,
                    // We do not know capability semantics so it is impossible
                    // for us to eliminate capabilities that do not satisfy imposed
                    // caveats (`own.nb`). Therefore we optimistically assume that
                    // `own.nb` further constraints `capability.nb` and do a shallow
                    // merge of the two. As a result we may include capabilities
                    // that during validation will be considered invalid due to
                    // constraint violations. While that is not ideal validator
                    // will treat them as if they were omitted and therefore it
                    // is a reasonable compromise.
                    nb: { ...capability2.nb, ...Object(own.nb) }
                  };
                }
              }
            }
          }
        } else {
          yield own;
        }
      }
    };
    matchAbility = (provided, claimed) => {
      if (provided === "*") {
        return claimed;
      }
      if (claimed === "*") {
        return provided;
      }
      if (claimed.endsWith("/*") && provided.startsWith(claimed.slice(0, -1))) {
        return provided;
      }
      if (provided.endsWith("/*") && claimed.startsWith(provided.slice(0, -1))) {
        return claimed;
      }
      if (provided === claimed) {
        return provided;
      }
      return null;
    };
    Delegation = class {
      /**
       * @param {API.UCANBlock<C>} root
       * @param {DAG.BlockStore} [blocks]
       */
      constructor(root2, blocks = /* @__PURE__ */ new Map()) {
        this.root = root2;
        this.blocks = blocks;
        Object.defineProperties(this, {
          blocks: {
            enumerable: false
          }
        });
      }
      /**
       * @returns {API.AttachedLinkSet}
       */
      get attachedLinks() {
        const _attachedLinks = /* @__PURE__ */ new Set();
        const ucanView = this.data;
        for (const capability2 of ucanView.capabilities) {
          const links3 = getLinksFromObject(capability2);
          for (const link5 of links3) {
            _attachedLinks.add(`${link5}`);
          }
        }
        for (const fact of ucanView.facts) {
          if (isLink(fact)) {
            _attachedLinks.add(`${fact}`);
          } else {
            const links3 = Object.values(fact).filter((e) => isLink(e));
            for (const link5 of links3) {
              _attachedLinks.add(`${link5}`);
            }
          }
        }
        return _attachedLinks;
      }
      get version() {
        return this.data.version;
      }
      get signature() {
        return this.data.signature;
      }
      get cid() {
        return this.root.cid;
      }
      link() {
        return this.root.cid;
      }
      get asCID() {
        return this.cid;
      }
      get bytes() {
        return this.root.bytes;
      }
      get data() {
        const data = decode20(this.root);
        Object.defineProperties(this, { data: { value: data, enumerable: false } });
        return data;
      }
      /**
       * Attach a block to the delegation DAG so it would be included in the
       * block iterator.
       * ⚠️ You can only attach blocks that are referenced from the `capabilities`
       * or `facts`.
       *
       * @param {API.Block} block
       */
      attach(block) {
        if (!this.attachedLinks.has(`${block.cid.link()}`)) {
          throw new Error(`given block with ${block.cid} is not an attached link`);
        }
        this.blocks.set(`${block.cid}`, block);
      }
      export() {
        return exportDAG(this.root, this.blocks, this.attachedLinks);
      }
      /**
       * @returns {API.Await<API.Result<Uint8Array, Error>>}
       */
      archive() {
        return archive(this);
      }
      iterateIPLDBlocks() {
        return exportDAG(this.root, this.blocks, this.attachedLinks);
      }
      /**
       * @type {API.Proof[]}
       */
      get proofs() {
        return proofs(this);
      }
      /**
       * @type {API.Principal}
       */
      get issuer() {
        return this.data.issuer;
      }
      /**
       * @type {API.Principal}
       */
      get audience() {
        return this.data.audience;
      }
      /**
       * @returns {C}
       */
      get capabilities() {
        return (
          /** @type {C} */
          this.data.capabilities
        );
      }
      /**
       * @returns {number}
       */
      get expiration() {
        return this.data.expiration;
      }
      /**
       * @returns {undefined|number}
       */
      get notBefore() {
        return this.data.notBefore;
      }
      /**
       * @returns {undefined|string}
       */
      get nonce() {
        return this.data.nonce;
      }
      /**
       * @returns {API.Fact[]}
       */
      get facts() {
        return this.data.facts;
      }
      /**
       * Iterate over the proofs
       *
       * @returns {IterableIterator<API.Delegation>}
       */
      iterate() {
        return it(this);
      }
      delegate() {
        return this;
      }
      buildIPLDView() {
        return this;
      }
      /**
       * @returns {API.DelegationJSON<this>}
       */
      toJSON() {
        return (
          /** @type {any} */
          {
            ...this.data.toJSON(),
            "/": this.cid.toString(),
            prf: this.proofs.map(
              (proof) => isDelegation(proof) ? proof : { "/": proof.toString() }
            )
          }
        );
      }
    };
    archive = async (delegation) => {
      try {
        const store2 = /* @__PURE__ */ new Map();
        for (const block of delegation.iterateIPLDBlocks()) {
          store2.set(`${block.cid}`, block);
        }
        const variant2 = await write2({
          [`ucan@${delegation.version}`]: delegation.root.cid
        });
        store2.set(`${variant2.cid}`, variant2);
        const bytes22 = encode16({
          roots: [variant2],
          blocks: store2
        });
        return ok(bytes22);
      } catch (cause) {
        return error(
          /** @type {Error} */
          cause
        );
      }
    };
    ArchiveSchema = variant({
      "ucan@0.9.1": (
        /** @type {Schema.Schema<API.UCANLink>} */
        match2({ version: 1 })
      )
    });
    extract = async (archive3) => {
      try {
        const { roots, blocks } = decode19(archive3);
        const [root2] = roots;
        if (root2 == null) {
          return error2("CAR archive does not contain a root block");
        }
        const { bytes: bytes22 } = root2;
        const variant2 = decode6(bytes22);
        const [, link5] = ArchiveSchema.match(variant2);
        return ok(view2({ root: link5, blocks }));
      } catch (cause) {
        return error(
          /** @type {Error} */
          cause
        );
      }
    };
    it = function* (delegation) {
      for (const proof of delegation.proofs) {
        if (isDelegation(proof)) {
          yield* it(proof);
          yield proof;
        }
      }
    };
    decodeCache = /* @__PURE__ */ new WeakMap();
    decode20 = ({ bytes: bytes22 }) => {
      const data = decodeCache.get(bytes22);
      if (!data) {
        const data2 = decode18(bytes22);
        decodeCache.set(bytes22, data2);
        return data2;
      }
      return data;
    };
    delegate = async ({ issuer, audience, proofs: proofs2 = [], attachedBlocks = /* @__PURE__ */ new Map(), ...input10 }, options) => {
      const links3 = [];
      const blocks = /* @__PURE__ */ new Map();
      for (const proof of proofs2) {
        if (!isDelegation(proof)) {
          links3.push(proof);
        } else {
          links3.push(proof.cid);
          for (const block of proof.export()) {
            blocks.set(block.cid.toString(), block);
          }
        }
      }
      const data = await issue({
        ...input10,
        issuer,
        audience,
        proofs: links3
      });
      const { cid, bytes: bytes22 } = await write(data, options);
      decodeCache.set(cid, data);
      const delegation = new Delegation({ cid, bytes: bytes22 }, blocks);
      Object.defineProperties(delegation, { proofs: { value: proofs2 } });
      for (const block of attachedBlocks.values()) {
        delegation.attach(block);
      }
      return delegation;
    };
    exportDAG = function* (root2, blocks, attachedLinks) {
      for (const link5 of decode20(root2).proofs) {
        const root3 = (
          /** @type {UCAN.Block} */
          blocks.get(`${link5}`)
        );
        if (root3) {
          yield* exportSubDAG(root3, blocks);
        }
      }
      for (const link5 of attachedLinks.values()) {
        const block = blocks.get(link5);
        if (block) {
          yield block;
        }
      }
      yield root2;
    };
    exportSubDAG = function* (root2, blocks) {
      for (const link5 of decode20(root2).proofs) {
        const root3 = (
          /** @type {UCAN.Block} */
          blocks.get(`${link5}`)
        );
        if (root3) {
          yield* exportSubDAG(root3, blocks);
        }
      }
      yield root2;
    };
    importDAG = (dag) => {
      let entries3 = [];
      for (const block of dag) {
        entries3.push([block.cid.toString(), block]);
      }
      const last = entries3.pop();
      if (!last) {
        throw new RangeError("Empty DAG can not be turned into a delegation");
      } else {
        const [, root2] = last;
        return new Delegation(
          /** @type {API.UCANBlock<C>} */
          root2,
          new Map(entries3)
        );
      }
    };
    create6 = ({ root: root2, blocks }) => new Delegation(root2, blocks);
    view2 = ({ root: root2, blocks }, fallback) => {
      const block = get(root2, blocks, null);
      if (block == null) {
        return fallback !== void 0 ? fallback : notFound(root2);
      }
      return create6({ root: block, blocks });
    };
    proofs = (delegation) => {
      const proofs2 = [];
      const { root: root2, blocks } = delegation;
      for (const link5 of decode20(root2).proofs) {
        const root3 = (
          /** @type {UCAN.Block} */
          blocks.get(link5.toString())
        );
        proofs2.push(root3 ? create6({ root: root3, blocks }) : link5);
      }
      Object.defineProperty(delegation, "proofs", { value: proofs2 });
      return proofs2;
    };
    invocation_exports = {};
    __export2(invocation_exports, {
      Invocation: () => Invocation,
      create: () => create7,
      invoke: () => invoke,
      isInvocation: () => isInvocation,
      view: () => view3
    });
    isInvocation = (value) => isDelegation(value);
    invoke = (options) => new IssuedInvocation(options);
    create7 = ({ root: root2, blocks }) => new Invocation(root2, blocks);
    view3 = ({ root: root2, blocks }, fallback) => {
      const block = get(root2, blocks, null);
      if (block == null) {
        return fallback !== void 0 ? fallback : notFound(root2);
      }
      return (
        /** @type {API.Invocation<C>} */
        create7({ root: block, blocks })
      );
    };
    IssuedInvocation = class {
      /**
       * @param {API.InvocationOptions<Capability>} data
       */
      constructor({
        issuer,
        audience,
        capability: capability2,
        proofs: proofs2 = [],
        expiration,
        lifetimeInSeconds,
        notBefore,
        nonce,
        facts = []
      }) {
        this.issuer = issuer;
        this.audience = audience;
        this.proofs = proofs2;
        this.capabilities = [capability2];
        this.expiration = expiration;
        this.lifetimeInSeconds = lifetimeInSeconds;
        this.notBefore = notBefore;
        this.nonce = nonce;
        this.facts = facts;
        this.attachedBlocks = /* @__PURE__ */ new Map();
      }
      /**
       * @param {API.Block} block
       */
      attach(block) {
        this.attachedBlocks.set(`${block.cid}`, block);
      }
      delegate() {
        return delegate(this);
      }
      buildIPLDView() {
        return delegate(this);
      }
      /**
       * @template {API.InvocationService<Capability>} Service
       * @param {API.ConnectionView<Service>} connection
       * @returns {Promise<API.InferReceipt<Capability, Service>>}
       */
      async execute(connection6) {
        const invocation = this;
        const [result] = await connection6.execute(invocation);
        return result;
      }
    };
    Invocation = class extends Delegation {
    };
    message_exports = {};
    __export2(message_exports, {
      MessageSchema: () => MessageSchema,
      build: () => build2,
      view: () => view5
    });
    receipt_exports = {};
    __export2(receipt_exports, {
      issue: () => issue2,
      view: () => view4
    });
    view4 = ({ root: root2, blocks }, fallback) => {
      const block = get(root2, blocks, null);
      if (block == null) {
        return fallback !== void 0 ? fallback : notFound(root2);
      }
      const data = decode6(block.bytes);
      return new Receipt({ root: { ...block, data }, store: blocks });
    };
    Receipt = class {
      /**
       * @param {object} input
       * @param {Required<API.Block<API.ReceiptModel<Ok, Error, Ran>>>} input.root
       * @param {DAG.BlockStore} input.store
       * @param {API.Meta} [input.meta]
       * @param {Ran|ReturnType<Ran['link']>} [input.ran]
       * @param {API.EffectsModel} [input.fx]
       * @param {API.SignatureView<API.OutcomeModel<Ok, Error, Ran>, SigAlg>} [input.signature]
       * @param {API.UCAN.Principal} [input.issuer]
       * @param {API.Proof[]} [input.proofs]
       */
      constructor({ root: root2, store: store2, ran, issuer, signature, proofs: proofs2 }) {
        this.store = store2;
        this.root = root2;
        this._ran = ran;
        this._fx = void 0;
        this._signature = signature;
        this._proofs = proofs2;
        this._issuer = issuer;
      }
      /**
       * @returns {Ran|ReturnType<Ran['link']>}
       */
      get ran() {
        const ran = this._ran;
        if (!ran) {
          const ran2 = (
            /** @type {Ran} */
            view3(
              {
                root: this.root.data.ocm.ran,
                blocks: this.store
              },
              this.root.data.ocm.ran
            )
          );
          this._ran = ran2;
          return ran2;
        } else {
          return ran;
        }
      }
      get proofs() {
        const proofs2 = this._proofs;
        if (proofs2) {
          return proofs2;
        } else {
          const { store: store2, root: root2 } = this;
          const { prf } = root2.data.ocm;
          const proofs3 = [];
          if (prf) {
            for (const link5 of prf) {
              const proof = view2({ root: link5, blocks: store2 }, link5);
              proofs3.push(proof);
            }
          }
          this._proofs = proofs3;
          return proofs3;
        }
      }
      link() {
        return this.root.cid;
      }
      get meta() {
        return this.root.data.ocm.meta;
      }
      get issuer() {
        const issuer = this._issuer;
        if (issuer) {
          return issuer;
        } else {
          const { iss } = this.root.data.ocm;
          if (iss) {
            const issuer2 = parse2(iss);
            this._issuer = issuer2;
            return issuer2;
          }
        }
      }
      get out() {
        return this.root.data.ocm.out;
      }
      get fx() {
        let fx = this._fx;
        if (!fx) {
          const { store: blocks } = this;
          const { fork: fork5, join: join2 } = this.root.data.ocm.fx;
          fx = {
            fork: fork5.map((root2) => view3({ root: root2, blocks }, root2))
          };
          if (join2) {
            fx.join = view3({ root: join2, blocks }, join2);
          }
          this._fx = fx;
        }
        return fx;
      }
      get signature() {
        const signature = this._signature;
        if (signature) {
          return signature;
        } else {
          const signature2 = (
            /** @type {API.SignatureView<API.OutcomeModel<Ok, Error, Ran>, SigAlg>} */
            view(this.root.data.sig)
          );
          this._signature = signature2;
          return signature2;
        }
      }
      /**
       * @param {API.Crypto.Verifier} signingPrincipal
       */
      verifySignature(signingPrincipal) {
        return this.signature.verify(
          signingPrincipal,
          encode15(this.root.data.ocm)
        );
      }
      buildIPLDView() {
        return this;
      }
      *iterateIPLDBlocks() {
        const { ran, fx, proofs: proofs2, root: root2 } = this;
        yield* iterate(ran);
        for (const fork5 of fx.fork) {
          yield* iterate(fork5);
        }
        if (fx.join) {
          yield* iterate(fx.join);
        }
        for (const proof of proofs2) {
          yield* iterate(proof);
        }
        yield root2;
      }
    };
    ReceptBuilder = class {
      /**
       * @param {object} options
       * @param {API.Signer<API.DID, SigAlg>} options.issuer
       * @param {Ran|ReturnType<Ran['link']>} options.ran
       * @param {API.Result<Ok, Error>} options.result
       * @param {API.Effects} [options.fx]
       * @param {API.Proof[]} [options.proofs]
       * @param {Record<string, unknown>} [options.meta]
       */
      constructor({ issuer, result, ran, fx = NOFX, proofs: proofs2 = [], meta = {} }) {
        this.issuer = issuer;
        this.result = result;
        this.ran = ran;
        this.fx = fx;
        this.proofs = proofs2;
        this.meta = meta;
      }
      async buildIPLDView({ hasher = sha2562, codec = cbor_exports3 } = {}) {
        const store2 = createStore();
        addEveryInto(iterate(this.ran), store2);
        const prf = [];
        for (const proof of this.proofs) {
          addEveryInto(iterate(proof), store2);
          prf.push(proof.link());
        }
        const fx = { fork: [] };
        for (const fork5 of this.fx.fork) {
          addEveryInto(iterate(fork5), store2);
          fx.fork.push(fork5.link());
        }
        if (this.fx.join) {
          addEveryInto(iterate(this.fx.join), store2);
          fx.join = this.fx.join.link();
        }
        const outcome = {
          ran: (
            /** @type {ReturnType<Ran['link']>} */
            this.ran.link()
          ),
          out: this.result,
          fx,
          meta: this.meta,
          iss: this.issuer.did(),
          prf
        };
        const signature = await this.issuer.sign(encode15(outcome));
        const model = {
          ocm: outcome,
          sig: signature
        };
        const root2 = await writeInto(model, store2, {
          hasher,
          codec
        });
        return new Receipt({
          root: root2,
          store: store2,
          signature,
          proofs: this.proofs,
          ran: this.ran
        });
      }
    };
    NOFX = Object.freeze({ fork: Object.freeze([]) });
    issue2 = (options) => new ReceptBuilder(options).buildIPLDView();
    MessageSchema = variant({
      "ucanto/message@7.0.0": struct({
        execute: match2().array().optional(),
        delegate: dictionary({
          key: string(),
          value: (
            /** @type {API.Reader<API.Link<API.ReceiptModel>>} */
            match2()
          )
        }).array().optional()
      })
    });
    build2 = ({ invocations, receipts }) => new MessageBuilder({ invocations, receipts }).buildIPLDView();
    view5 = ({ root: root2, store: store2 }, fallback) => {
      const block = get(root2, store2, null);
      if (block === null) {
        return fallback !== void 0 ? fallback : notFound(root2);
      }
      const data = cbor_exports3.decode(block.bytes);
      const [branch, value] = MessageSchema.match(data, fallback);
      switch (branch) {
        case "ucanto/message@7.0.0":
          return new Message({ root: { ...block, data }, store: store2 });
        default:
          return value;
      }
    };
    MessageBuilder = class {
      /**
       * @param {object} source
       * @param {I} [source.invocations]
       * @param {R} [source.receipts]
       */
      constructor({ invocations, receipts }) {
        this.invocations = invocations;
        this.receipts = receipts;
      }
      /**
       *
       * @param {API.BuildOptions} [options]
       * @returns {Promise<Message<{ In: API.InferInvocations<I>, Out: R }>>}
       */
      async buildIPLDView(options) {
        const store2 = /* @__PURE__ */ new Map();
        const { invocations, ...executeField } = await writeInvocations(
          this.invocations || [],
          store2
        );
        const { receipts, ...receiptsField } = await writeReceipts(
          this.receipts || [],
          store2
        );
        const root2 = await writeInto(
          /** @type {API.AgentMessageModel<{ In: API.InferInvocations<I>, Out: R }>} */
          {
            "ucanto/message@7.0.0": {
              ...executeField,
              ...receiptsField
            }
          },
          store2,
          options
        );
        return new Message({ root: root2, store: store2 }, { receipts, invocations });
      }
    };
    writeInvocations = async (run, store2) => {
      const invocations = [];
      const execute2 = [];
      for (const invocation of run) {
        const view6 = await invocation.buildIPLDView();
        execute2.push(view6.link());
        invocations.push(view6);
        for (const block of view6.iterateIPLDBlocks()) {
          store2.set(`${block.cid}`, block);
        }
      }
      return { invocations, ...execute2.length > 0 ? { execute: execute2 } : {} };
    };
    writeReceipts = async (source, store2) => {
      if (source.length === 0) {
        return {};
      }
      const receipts = /* @__PURE__ */ new Map();
      const report = {};
      for (const [n2, receipt] of source.entries()) {
        const view6 = await receipt.buildIPLDView();
        for (const block of view6.iterateIPLDBlocks()) {
          store2.set(`${block.cid}`, block);
        }
        const key = `${view6.ran.link()}`;
        if (!(key in report)) {
          report[key] = view6.root.cid;
          receipts.set(key, view6);
        } else {
          receipts.set(`${key}@${n2}`, view6);
        }
      }
      return { receipts, report };
    };
    Message = class {
      /**
       * @param {object} source
       * @param {Required<API.Block<API.AgentMessageModel<T>>>} source.root
       * @param {DAG.BlockStore} source.store
       * @param {object} build
       * @param {API.Invocation[]} [build.invocations]
       * @param {Map<string, API.Receipt>} [build.receipts]
       */
      constructor({ root: root2, store: store2 }, { invocations, receipts } = {}) {
        this.root = root2;
        this.store = store2;
        this._invocations = invocations;
        this._receipts = receipts;
      }
      *iterateIPLDBlocks() {
        for (const invocation of this.invocations) {
          yield* invocation.iterateIPLDBlocks();
        }
        for (const receipt of this.receipts.values()) {
          yield* receipt.iterateIPLDBlocks();
        }
        yield this.root;
      }
      /**
       * @template [E=never]
       * @param {API.Link} link
       * @param {E} [fallback]
       * @returns {API.Receipt|E}
       */
      get(link5, fallback) {
        const receipts = this.root.data["ucanto/message@7.0.0"].report || {};
        const receipt = receipts[`${link5}`];
        if (receipt) {
          return view4({ root: receipt, blocks: this.store });
        } else {
          return fallback !== void 0 ? fallback : panic(`Message does not include receipt for ${link5}`);
        }
      }
      get invocationLinks() {
        return this.root.data["ucanto/message@7.0.0"].execute || [];
      }
      get invocations() {
        let invocations = this._invocations;
        if (!invocations) {
          invocations = this.invocationLinks.map((link5) => {
            return invocation_exports.view({ root: link5, blocks: this.store });
          });
        }
        return invocations;
      }
      get receipts() {
        let receipts = this._receipts;
        if (!receipts) {
          receipts = /* @__PURE__ */ new Map();
          const report = this.root.data["ucanto/message@7.0.0"].report || {};
          for (const [key, link5] of Object.entries(report)) {
            const receipt = view4({ root: link5, blocks: this.store });
            receipts.set(`${receipt.ran.link()}`, receipt);
          }
        }
        return receipts;
      }
    };
    connect = (options) => new Connection(options);
    Connection = class {
      /**
       * @param {API.ConnectionOptions<T>} options
       */
      constructor(options) {
        this.id = options.id;
        this.options = options;
        this.codec = options.codec;
        this.channel = options.channel;
        this.hasher = options.hasher || sha2562;
      }
      /**
       * Execute invocations.
       *
       * @template {API.Capability} C
       * @template {API.Tuple<API.ServiceInvocation<C, T>>} I
       * @param {I} invocations
       * @returns {Promise<API.InferReceipts<I, T>>}
       */
      async execute(...invocations) {
        return execute(invocations, this);
      }
    };
    execute = async (invocations, connection6) => {
      const input10 = await message_exports.build({ invocations });
      const request = await connection6.codec.encode(input10, connection6);
      const response = await connection6.channel.request(request);
      try {
        const output2 = await connection6.codec.decode(response);
        const receipts = input10.invocationLinks.map((link5) => output2.get(link5));
        return (
          /** @type {API.InferReceipts<I, T>} */
          receipts
        );
      } catch (error3) {
        const { message: message2, name: name142 = "Error", ...cause } = (
          /** @type {Error} */
          error3
        );
        const receipts = [];
        for await (const ran of input10.invocationLinks) {
          const receipt = await receipt_exports.issue({
            ran,
            result: { error: { ...cause, name: name142, message: message2 } },
            // @ts-expect-error - we can not really sign a receipt without having
            // an access to a signer which client does not have. In the future
            // we will change client API requiring a signer to be passed in but
            // for now we just use a dummy signer.
            issuer: {
              did() {
                return connection6.id.did();
              },
              sign() {
                return signature_exports.createNonStandard("", new Uint8Array());
              }
            }
          });
          receipts.push(receipt);
        }
        return (
          /** @type {API.InferReceipts<I, T>} */
          receipts
        );
      }
    };
    delegate2 = delegation_exports.delegate;
    car_exports2 = {};
    __export2(car_exports2, {
      codec: () => car_exports,
      contentType: () => contentType5,
      inbound: () => inbound2,
      outbound: () => outbound2,
      request: () => request_exports,
      response: () => response_exports
    });
    request_exports = {};
    __export2(request_exports, {
      codec: () => car_exports,
      contentType: () => contentType3,
      decode: () => decode22,
      encode: () => encode17
    });
    contentType3 = car_exports.contentType;
    HEADERS = Object.freeze({
      "content-type": contentType3,
      // We will signal that we want to receive a CAR file in the response
      accept: contentType3
    });
    encode17 = (message2, options) => {
      const blocks = /* @__PURE__ */ new Map();
      for (const block of message2.iterateIPLDBlocks()) {
        blocks.set(`${block.cid}`, block);
      }
      const body = car_exports.encode({
        roots: [message2.root],
        blocks
      });
      return {
        headers: options?.headers || { ...HEADERS },
        body
      };
    };
    decode22 = async ({ headers, body }) => {
      const { roots, blocks } = car_exports.decode(
        /** @type {Uint8Array} */
        body
      );
      const message2 = message_exports.view({ root: roots[0].cid, store: blocks });
      return (
        /** @type {Message} */
        message2
      );
    };
    response_exports = {};
    __export2(response_exports, {
      codec: () => car_exports,
      contentType: () => contentType4,
      decode: () => decode23,
      encode: () => encode18
    });
    contentType4 = car_exports.contentType;
    HEADERS2 = Object.freeze({
      "content-type": contentType4
    });
    encode18 = (message2, options) => {
      const blocks = /* @__PURE__ */ new Map();
      for (const block of message2.iterateIPLDBlocks()) {
        blocks.set(`${block.cid}`, block);
      }
      const body = car_exports.encode({
        roots: [message2.root],
        blocks
      });
      return {
        headers: { ...HEADERS2 },
        body
      };
    };
    decode23 = async ({ headers, body }) => {
      const { roots, blocks } = car_exports.decode(
        /** @type {Uint8Array} */
        body
      );
      const message2 = message_exports.view({ root: roots[0].cid, store: blocks });
      return (
        /** @type {Message} */
        message2
      );
    };
    inbound = (source) => new Inbound(source);
    Inbound = class {
      /**
       * @param {API.HTTPRequest} request
       * @returns {API.Result<API.InboundAcceptCodec, API.HTTPError>} transport
       */
      accept({ headers }) {
        const contentType9 = headers["content-type"] || headers["Content-Type"];
        const decoder32 = this.decoders[contentType9];
        if (!decoder32) {
          return {
            error: {
              status: 415,
              message: `The server cannot process the request because the payload format is not supported. Please check the content-type header and try again with a supported media type.`,
              headers: {
                accept: Object.keys(this.decoders).join(", ")
              }
            }
          };
        }
        const accept2 = parseAcceptHeader(headers.accept || headers.Accept || "*/*");
        for (const { category, type: type2 } of accept2) {
          for (const encoder32 of this.encoders) {
            const select2 = (category === "*" || category === encoder32.category) && (type2 === "*" || type2 === encoder32.type);
            if (select2) {
              return { ok: { ...encoder32, decoder: decoder32 } };
            }
          }
        }
        return {
          error: {
            status: 406,
            message: `The requested resource cannot be served in the requested content type. Please specify a supported content type using the Accept header.`,
            headers: {
              accept: formatAcceptHeader(Object.values(this.encoders))
            }
          }
        };
      }
      /**
       * @param {object} source
       * @param {Record<string, API.Transport.RequestDecoder>} source.decoders
       * @param {Record<string, API.Transport.ResponseEncoder>} source.encoders
       */
      constructor({ decoders = {}, encoders = {} }) {
        this.decoders = decoders;
        if (Object.keys(decoders).length === 0) {
          throw new Error("At least one decoder MUST be provided");
        }
        this.encoders = Object.entries(encoders).map(([mediaType, encoder32]) => {
          return { ...parseMediaType(mediaType), encoder: encoder32 };
        }).sort((a, b) => b.preference - a.preference);
        if (this.encoders.length === 0) {
          throw new Error("At least one encoder MUST be provided");
        }
      }
    };
    outbound = (source) => new Outbound(source);
    Outbound = class {
      /**
       * @param {object} source
       * @param {Record<string, API.Transport.RequestEncoder>} source.encoders
       * @param {Record<string, API.Transport.ResponseDecoder>} source.decoders
       */
      constructor({ decoders = {}, encoders = {} }) {
        this.decoders = decoders;
        if (Object.keys(decoders).length === 0) {
          throw new Error("At least one decoder MUST be provided");
        }
        this.encoders = Object.entries(encoders).map(([mediaType, encoder32]) => {
          return { ...parseMediaType(mediaType), encoder: encoder32 };
        }).sort((a, b) => b.preference - a.preference);
        this.acceptType = formatAcceptHeader(this.encoders);
        if (this.encoders.length === 0) {
          throw new Error("At least one encoder MUST be provided");
        }
        this.encoder = this.encoders[0].encoder;
      }
      /**
       * @template {API.AgentMessage} Message
       * @param {Message} message
       */
      encode(message2) {
        return this.encoder.encode(message2, {
          accept: this.acceptType
        });
      }
      /**
       * @template {API.AgentMessage} Message
       * @param {API.HTTPResponse<Message>} response
       * @returns {API.Await<Message>}
       */
      decode(response) {
        const { headers } = response;
        const contentType9 = headers["content-type"] || headers["Content-Type"];
        const decoder32 = this.decoders[contentType9] || this.decoders["*/*"];
        switch (response.status) {
          case 415:
          case 406:
            throw Object.assign(
              new RangeError(new TextDecoder().decode(response.body)),
              {
                status: response.status,
                headers: response.headers
              }
            );
        }
        if (!decoder32) {
          throw Object.assign(
            TypeError(
              `Can not decode response with content-type '${contentType9}' because no matching transport decoder is configured.`
            ),
            {
              error: true
            }
          );
        }
        return decoder32.decode(response);
      }
    };
    parseMediaType = (source) => {
      const [mediaType = "*/*", mediaRange = ""] = source.trim().split(";");
      const [category = "*", type2 = "*"] = mediaType.split("/");
      const params = new URLSearchParams(mediaRange);
      const preference = parseFloat(params.get("q") || "0");
      return {
        category,
        type: type2,
        /* c8 ignore next */
        preference: isNaN(preference) ? 0 : preference
      };
    };
    formatMediaType = ({ category, type: type2, preference }) => (
      /** @type {MediaType}  */
      `${category}/${type2}${preference ? `;q=${preference}` : ""}`
    );
    parseAcceptHeader = (source) => source.split(",").map(parseMediaType).sort((a, b) => b.preference - a.preference);
    formatAcceptHeader = (source) => source.map(formatMediaType).join(", ");
    contentType5 = car_exports.contentType;
    inbound2 = inbound({
      decoders: {
        [contentType3]: request_exports
      },
      encoders: {
        [contentType4]: response_exports
      }
    });
    outbound2 = outbound({
      encoders: {
        [contentType3]: request_exports
      },
      decoders: {
        [contentType4]: response_exports
      }
    });
    http_exports = {};
    __export2(http_exports, {
      open: () => open
    });
    open = ({ url: url2, method = "POST", fetch: fetch3 }) => {
      if (!fetch3) {
        if (typeof globalThis.fetch !== "undefined") {
          fetch3 = globalThis.fetch.bind(globalThis);
        } else {
          throw new TypeError(
            `ucanto HTTP transport got undefined \`fetch\`. Try passing in a \`fetch\` implementation explicitly.`
          );
        }
      }
      return new Channel({ url: url2, method, fetch: fetch3 });
    };
    Channel = class {
      /**
       * @param {object} options
       * @param {URL} options.url
       * @param {Fetcher} options.fetch
       * @param {string} [options.method]
       */
      constructor({ url: url2, fetch: fetch3, method }) {
        this.fetch = fetch3;
        this.method = method;
        this.url = url2;
      }
      /**
       * @template {API.Tuple<API.ServiceInvocation<API.Capability, S>>} I
       * @param {API.HTTPRequest<API.AgentMessage<{ In: API.InferInvocations<I>, Out: API.Tuple<API.Receipt> }>>} request
       * @returns {Promise<API.HTTPResponse<API.AgentMessage<{ Out: API.InferReceipts<I, S>, In: API.Tuple<API.Invocation> }>>>}
       */
      async request({ headers, body }) {
        const response = await this.fetch(this.url.href, {
          headers,
          body,
          method: this.method
        });
        const buffer22 = response.ok ? await response.arrayBuffer() : HTTPError.throw(`HTTP Request failed. ${this.method} ${this.url.href} \u2192 ${response.status}`, response);
        return {
          headers: response.headers.entries ? Object.fromEntries(response.headers.entries()) : (
            /* c8 ignore next */
            {}
          ),
          body: new Uint8Array(buffer22)
        };
      }
    };
    HTTPError = class extends Error {
      /**
       * @param {string} message
       * @param {Options} options
       * @returns {never}
       */
      static throw(message2, options) {
        throw new this(message2, options);
      }
      /**
       * @param {string} message
       * @param {Options} options
       */
      constructor(message2, { url: url2, status = 500, statusText = "Server error" }) {
        super(message2);
        this.name = "HTTPError";
        this.url = url2;
        this.status = status;
        this.statusText = statusText;
      }
    };
    encoder2 = new TextEncoder();
    decoder2 = new TextDecoder();
    response_exports2 = {};
    __export2(response_exports2, {
      contentType: () => contentType6,
      encode: () => encode19
    });
    contentType6 = "application/cbor";
    HEADERS3 = Object.freeze({
      "content-type": contentType6
    });
    encode19 = (message2, options) => {
      const legacyResults = [];
      for (const receipt of message2.receipts.values()) {
        const result = receipt.out;
        if (result.ok) {
          legacyResults.push(result.ok);
        } else {
          legacyResults.push({
            ...result.error,
            error: true
          });
        }
      }
      const body = encode15(legacyResults);
      return (
        /** @type {API.HTTPResponse<Message>} */
        {
          headers: HEADERS3,
          body
        }
      );
    };
    request_exports2 = {};
    __export2(request_exports2, {
      contentType: () => contentType7,
      decode: () => decode24
    });
    contentType7 = "application/car";
    decode24 = async ({ body }) => {
      const { roots, blocks } = decode19(
        /** @type {Uint8Array} */
        body
      );
      const run = [];
      for (const { cid } of roots) {
        const invocation = invocation_exports.view({
          root: (
            /** @type {API.Link} */
            cid
          ),
          blocks
        });
        run.push(invocation);
      }
      const message2 = await message_exports.build({
        invocations: (
          /** @type {API.Tuple<API.IssuedInvocation>} */
          run
        )
      });
      return (
        /** @type {Message} */
        message2
      );
    };
    ({ contentType: contentType8 } = request_exports2);
    inbound3 = inbound({
      decoders: {
        [contentType8]: request_exports2,
        [contentType5]: request_exports
      },
      encoders: {
        // Here we configure encoders such that if accept header is `*/*` (which is
        // the default if omitted) we will encode the response in CBOR. If
        // `application/vnd.ipld.car` is set we will encode the response in current
        // format.
        // Here we exploit the fact that legacy clients do not send an accept header
        // and therefore will get response in legacy format. New clients on the other
        // hand will send `application/vnd.ipld.car` and consequently get response
        // in current format.
        "*/*;q=0.1": response_exports2,
        [contentType5]: response_exports
      }
    });
    the = (value) => value;
    entries = (object) => (
      /** @type {any} */
      Object.entries(object)
    );
    combine = ([first, ...rest]) => {
      const results = first.map((value) => [value]);
      for (const values2 of rest) {
        const tuples = results.splice(0);
        for (const value of values2) {
          for (const tuple2 of tuples) {
            results.push([...tuple2, value]);
          }
        }
      }
      return results;
    };
    intersection2 = (left, right) => {
      const [result, other] = left.length < right.length ? [new Set(left), new Set(right)] : [new Set(right), new Set(left)];
      for (const item of result) {
        if (!other.has(item)) {
          result.delete(item);
        }
      }
      return [...result];
    };
    EscalatedCapability = class extends Failure {
      /**
       * @param {API.ParsedCapability} claimed
       * @param {object} delegated
       * @param {API.Failure} cause
       */
      constructor(claimed, delegated, cause) {
        super();
        this.claimed = claimed;
        this.delegated = delegated;
        this.cause = cause;
        this.name = the("EscalatedCapability");
      }
      describe() {
        return `Constraint violation: ${this.cause.message}`;
      }
    };
    DelegationError = class extends Failure {
      /**
       * @param {(API.InvalidCapability | API.EscalatedDelegation | API.DelegationError)[]} causes
       * @param {object} context
       */
      constructor(causes, context2) {
        super();
        this.name = the("InvalidClaim");
        this.causes = causes;
        this.context = context2;
      }
      describe() {
        return [
          `Can not derive ${this.context} from delegated capabilities:`,
          ...this.causes.map((cause) => li2(cause.message))
        ].join("\n");
      }
      /**
       * @type {API.InvalidCapability | API.EscalatedDelegation | API.DelegationError}
       */
      get cause() {
        if (this.causes.length !== 1) {
          return this;
        } else {
          const [cause] = this.causes;
          const value = cause.name === "InvalidClaim" ? cause.cause : cause;
          Object.defineProperties(this, { cause: { value } });
          return value;
        }
      }
    };
    MalformedCapability = class extends Failure {
      /**
       * @param {API.Capability} capability
       * @param {API.Failure} cause
       */
      constructor(capability2, cause) {
        super();
        this.name = the("MalformedCapability");
        this.capability = capability2;
        this.cause = cause;
      }
      describe() {
        return [
          `Encountered malformed '${this.capability.can}' capability: ${format7(
            this.capability
          )}`,
          li2(this.cause.message)
        ].join("\n");
      }
    };
    UnknownCapability = class extends Failure {
      /**
       * @param {API.Capability} capability
       */
      constructor(capability2) {
        super();
        this.name = the("UnknownCapability");
        this.capability = capability2;
      }
      /* c8 ignore next 3 */
      describe() {
        return `Encountered unknown capability: ${format7(this.capability)}`;
      }
    };
    format7 = (capability2, space) => JSON.stringify(
      capability2,
      (_key, value) => {
        if (isLink(value)) {
          return value.toString();
        } else {
          return value;
        }
      },
      space
    );
    indent2 = (message2, indent3 = "  ") => `${indent3}${message2.split("\n").join(`
${indent3}`)}`;
    li2 = (message2) => indent2(`- ${message2}`);
    capability = ({
      derives = defaultDerives,
      nb = defaultNBSchema,
      ...etc
    }) => new Capability({ derives, nb, ...etc });
    defaultNBSchema = /** @type {Schema.MapRepresentation<any>} */
    schema_exports3.struct({});
    or4 = (left, right) => new Or(left, right);
    and2 = (...selectors) => new And(selectors);
    derive = ({ from: from19, to, derives }) => new Derive(from19, to, derives);
    View2 = class {
      /**
       * @param {API.Source} source
       * @returns {API.MatchResult<M>}
       */
      /* c8 ignore next 3 */
      match(source) {
        return { error: new UnknownCapability(source.capability) };
      }
      /**
       * @param {API.Source[]} capabilities
       * @returns {API.Select<M>}
       */
      select(capabilities) {
        return select(this, capabilities);
      }
      /**
       * @template {API.ParsedCapability} U
       * @param {object} source
       * @param {API.TheCapabilityParser<API.DirectMatch<U>>} source.to
       * @param {API.Derives<U, API.InferDeriveProof<M['value']>>} source.derives
       * @returns {API.TheCapabilityParser<API.DerivedMatch<U, M>>}
       */
      derive({ derives, to }) {
        return derive({ derives, to, from: this });
      }
    };
    Unit = class extends View2 {
      /**
       * @template {API.Match} W
       * @param {API.MatchSelector<W>} other
       * @returns {API.CapabilityParser<M | W>}
       */
      or(other) {
        return or4(this, other);
      }
      /**
       * @template {API.Match} W
       * @param {API.CapabilityParser<W>} other
       * @returns {API.CapabilitiesParser<[M, W]>}
       */
      and(other) {
        return and2(
          /** @type {API.CapabilityParser<M>} */
          this,
          other
        );
      }
    };
    Capability = class extends Unit {
      /**
       * @param {Required<Descriptor<A, R, C>>} descriptor
       */
      constructor(descriptor) {
        super();
        this.descriptor = descriptor;
        this.schema = schema_exports3.struct({
          can: schema_exports3.literal(descriptor.can),
          with: descriptor.with,
          nb: descriptor.nb
        });
      }
      /**
       * @param {API.InferCreateOptions<R, C>} options
       */
      create(options) {
        const { descriptor, can } = this;
        const decoders = descriptor.nb;
        const data = (
          /** @type {C} */
          options.nb || {}
        );
        const resource = descriptor.with.read(options.with);
        if (resource.error) {
          throw Object.assign(
            new Error(`Invalid 'with' - ${resource.error.message}`),
            {
              cause: resource
            }
          );
        }
        const nb = descriptor.nb.read(data);
        if (nb.error) {
          throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {
            cause: nb
          });
        }
        return createCapability({ can, with: resource.ok, nb: nb.ok });
      }
      /**
       * @param {API.InferInvokeOptions<R, C>} options
       */
      invoke({ with: with_, nb, ...options }) {
        return invoke({
          ...options,
          capability: this.create(
            /** @type {API.InferCreateOptions<R, C>} */
            { with: with_, nb }
          )
        });
      }
      /**
       * @param {API.InferDelegationOptions<R, C>} options
       * @returns {Promise<API.Delegation<[API.InferDelegatedCapability<API.ParsedCapability<A, R, C>>]>>}
       */
      async delegate({ nb: input10 = {}, with: with_, ...options }) {
        const { descriptor, can } = this;
        const readers = descriptor.nb;
        const resource = descriptor.with.read(with_);
        if (resource.error) {
          throw Object.assign(
            new Error(`Invalid 'with' - ${resource.error.message}`),
            {
              cause: resource
            }
          );
        }
        const nb = descriptor.nb.partial().read(input10);
        if (nb.error) {
          throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {
            cause: nb
          });
        }
        return delegate({
          capabilities: [createCapability({ can, with: resource.ok, nb: nb.ok })],
          ...options
        });
      }
      get can() {
        return this.descriptor.can;
      }
      /**
       * @param {API.Source} source
       * @returns {API.MatchResult<API.DirectMatch<API.ParsedCapability<A, R, C>>>}
       */
      match(source) {
        const result = parseCapability(this.descriptor, source);
        return result.error ? result : { ok: new Match2(source, result.ok, this.descriptor) };
      }
      toString() {
        return JSON.stringify({ can: this.descriptor.can });
      }
    };
    createCapability = ({ can, with: with_, nb }) => (
      /** @type {API.InferCapability<T>} */
      {
        can,
        with: with_,
        ...isEmpty(nb) ? {} : { nb }
      }
    );
    isEmpty = (object) => {
      for (const _ in object) {
        return false;
      }
      return true;
    };
    Or = class extends Unit {
      /**
       * @param {API.Matcher<M>} left
       * @param {API.Matcher<W>} right
       */
      constructor(left, right) {
        super();
        this.left = left;
        this.right = right;
      }
      /**
       * @param {API.Source} capability
       * @return {API.MatchResult<M|W>}
       */
      match(capability2) {
        const left = this.left.match(capability2);
        if (left.error) {
          const right = this.right.match(capability2);
          if (right.error) {
            return right.error.name === "MalformedCapability" ? (
              //
              right
            ) : (
              //
              left
            );
          } else {
            return right;
          }
        } else {
          return left;
        }
      }
      toString() {
        return `${this.left.toString()}|${this.right.toString()}`;
      }
    };
    And = class _And extends View2 {
      /**
       * @param {Selectors} selectors
       */
      constructor(selectors) {
        super();
        this.selectors = selectors;
      }
      /**
       * @param {API.Source} capability
       * @returns {API.MatchResult<API.Amplify<API.InferMembers<Selectors>>>}
       */
      match(capability2) {
        const group2 = [];
        for (const selector of this.selectors) {
          const result = selector.match(capability2);
          if (result.error) {
            return result;
          } else {
            group2.push(result.ok);
          }
        }
        return {
          ok: new AndMatch(
            /** @type {API.InferMembers<Selectors>} */
            group2
          )
        };
      }
      /**
       * @param {API.Source[]} capabilities
       */
      select(capabilities) {
        return selectGroup(this, capabilities);
      }
      /**
       * @template E
       * @template {API.Match} X
       * @param {API.MatchSelector<API.Match<E, X>>} other
       * @returns {API.CapabilitiesParser<[...API.InferMembers<Selectors>, API.Match<E, X>]>}
       */
      and(other) {
        return new _And([...this.selectors, other]);
      }
      toString() {
        return `[${this.selectors.map(String).join(", ")}]`;
      }
    };
    Derive = class extends Unit {
      /**
       * @param {API.MatchSelector<M>} from
       * @param {API.TheCapabilityParser<API.DirectMatch<T>>} to
       * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives
       */
      constructor(from19, to, derives) {
        super();
        this.from = from19;
        this.to = to;
        this.derives = derives;
      }
      /**
       * @type {typeof this.to['create']}
       */
      create(options) {
        return this.to.create(options);
      }
      /**
       * @type {typeof this.to['invoke']}
       */
      invoke(options) {
        return this.to.invoke(options);
      }
      /**
       * @type {typeof this.to['delegate']}
       */
      delegate(options) {
        return this.to.delegate(options);
      }
      get can() {
        return this.to.can;
      }
      /**
       * @param {API.Source} capability
       * @returns {API.MatchResult<API.DerivedMatch<T, M>>}
       */
      match(capability2) {
        const match52 = this.to.match(capability2);
        if (match52.error) {
          return match52;
        } else {
          return { ok: new DerivedMatch(match52.ok, this.from, this.derives) };
        }
      }
      toString() {
        return this.to.toString();
      }
    };
    Match2 = class _Match {
      /**
       * @param {API.Source} source
       * @param {API.ParsedCapability<A, R, C>} value
       * @param {Required<Descriptor<A, R, C>>} descriptor
       */
      constructor(source, value, descriptor) {
        this.source = [source];
        this.value = value;
        this.descriptor = descriptor;
      }
      get can() {
        return this.value.can;
      }
      get proofs() {
        const proofs2 = [this.source[0].delegation];
        Object.defineProperties(this, {
          proofs: { value: proofs2 }
        });
        return proofs2;
      }
      /**
       * @param {API.CanIssue} context
       * @returns {API.DirectMatch<API.ParsedCapability<A, R, C>>|null}
       */
      prune(context2) {
        if (context2.canIssue(this.value, this.source[0].delegation.issuer.did())) {
          return null;
        } else {
          return this;
        }
      }
      /**
       * @param {API.Source[]} capabilities
       * @returns {API.Select<API.DirectMatch<API.ParsedCapability<A, R, C>>>}
       */
      select(capabilities) {
        const unknown2 = [];
        const errors2 = [];
        const matches = [];
        for (const capability2 of capabilities) {
          const result = resolveCapability(this.descriptor, this.value, capability2);
          if (result.ok) {
            const claim = this.descriptor.derives(this.value, result.ok);
            if (claim.error) {
              errors2.push(
                new DelegationError(
                  [new EscalatedCapability(this.value, result.ok, claim.error)],
                  this
                )
              );
            } else {
              matches.push(new _Match(capability2, result.ok, this.descriptor));
            }
          } else {
            switch (result.error.name) {
              case "UnknownCapability":
                unknown2.push(result.error.capability);
                break;
              case "MalformedCapability":
              default:
                errors2.push(new DelegationError([result.error], this));
            }
          }
        }
        return { matches, unknown: unknown2, errors: errors2 };
      }
      toString() {
        const { nb } = this.value;
        return JSON.stringify({
          can: this.descriptor.can,
          with: this.value.with,
          nb: nb && Object.keys(nb).length > 0 ? nb : void 0
        });
      }
    };
    DerivedMatch = class _DerivedMatch {
      /**
       * @param {API.DirectMatch<T>} selected
       * @param {API.MatchSelector<M>} from
       * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives
       */
      constructor(selected, from19, derives) {
        this.selected = selected;
        this.from = from19;
        this.derives = derives;
      }
      get can() {
        return this.value.can;
      }
      get source() {
        return this.selected.source;
      }
      get proofs() {
        const proofs2 = [];
        for (const { delegation } of this.selected.source) {
          proofs2.push(delegation);
        }
        Object.defineProperties(this, { proofs: { value: proofs2 } });
        return proofs2;
      }
      get value() {
        return this.selected.value;
      }
      /**
       * @param {API.CanIssue} context
       */
      prune(context2) {
        const selected = (
          /** @type {API.DirectMatch<T>|null} */
          this.selected.prune(context2)
        );
        return selected ? new _DerivedMatch(selected, this.from, this.derives) : null;
      }
      /**
       * @param {API.Source[]} capabilities
       */
      select(capabilities) {
        const { derives, selected, from: from19 } = this;
        const { value } = selected;
        const direct = selected.select(capabilities);
        const derived = from19.select(capabilities);
        const matches = [];
        const errors2 = [];
        for (const match52 of derived.matches) {
          const result = derives(value, match52.value);
          if (result.error) {
            errors2.push(
              new DelegationError(
                [new EscalatedCapability(value, match52.value, result.error)],
                this
              )
            );
          } else {
            matches.push(match52);
          }
        }
        return {
          unknown: intersection2(direct.unknown, derived.unknown),
          errors: [
            ...errors2,
            ...direct.errors,
            ...derived.errors.map((error3) => new DelegationError([error3], this))
          ],
          matches: [
            ...direct.matches.map((match52) => new _DerivedMatch(match52, from19, derives)),
            ...matches
          ]
        };
      }
      toString() {
        return this.selected.toString();
      }
    };
    AndMatch = class _AndMatch {
      /**
       * @param {API.Match[]} matches
       */
      constructor(matches) {
        this.matches = matches;
      }
      get selectors() {
        return this.matches;
      }
      /**
       * @returns {API.Source[]}
       */
      get source() {
        const source = [];
        for (const match52 of this.matches) {
          source.push(...match52.source);
        }
        Object.defineProperties(this, { source: { value: source } });
        return source;
      }
      /**
       * @param {API.CanIssue} context
       */
      prune(context2) {
        const matches = [];
        for (const match52 of this.matches) {
          const pruned = match52.prune(context2);
          if (pruned) {
            matches.push(pruned);
          }
        }
        return matches.length === 0 ? null : new _AndMatch(matches);
      }
      get proofs() {
        const proofs2 = [];
        for (const { delegation } of this.source) {
          proofs2.push(delegation);
        }
        Object.defineProperties(this, { proofs: { value: proofs2 } });
        return proofs2;
      }
      /**
       * @type {API.InferValue<API.InferMembers<Selectors>>}
       */
      get value() {
        const value = [];
        for (const match52 of this.matches) {
          value.push(match52.value);
        }
        Object.defineProperties(this, { value: { value } });
        return (
          /** @type {any} */
          value
        );
      }
      /**
       * @param {API.Source[]} capabilities
       */
      select(capabilities) {
        return selectGroup(this, capabilities);
      }
      toString() {
        return `[${this.matches.map((match52) => match52.toString()).join(", ")}]`;
      }
    };
    resolveAbility = (pattern, can, fallback) => {
      switch (pattern) {
        case can:
        case "*":
          return can;
        default:
          return pattern.endsWith("/*") && can.startsWith(pattern.slice(0, -1)) ? can : fallback;
      }
    };
    resolveResource = (source, uri2, fallback) => {
      switch (source) {
        case uri2:
        case "ucan:*":
          return uri2;
        default:
          return fallback;
      }
    };
    parseCapability = (descriptor, source) => {
      const { delegation } = source;
      const capability2 = (
        /** @type {API.Capability<A, R, C>} */
        source.capability
      );
      if (descriptor.can !== capability2.can) {
        return { error: new UnknownCapability(capability2) };
      }
      const uri2 = descriptor.with.read(capability2.with);
      if (uri2.error) {
        return { error: new MalformedCapability(capability2, uri2.error) };
      }
      const nb = descriptor.nb.read(capability2.nb || {});
      if (nb.error) {
        return { error: new MalformedCapability(capability2, nb.error) };
      }
      return { ok: new CapabilityView(descriptor.can, uri2.ok, nb.ok, delegation) };
    };
    resolveCapability = (descriptor, claimed, { capability: capability2, delegation }) => {
      const can = resolveAbility(capability2.can, claimed.can, null);
      if (can == null) {
        return { error: new UnknownCapability(capability2) };
      }
      const resource = resolveResource(
        capability2.with,
        claimed.with,
        capability2.with
      );
      const uri2 = descriptor.with.read(resource);
      if (uri2.error) {
        return { error: new MalformedCapability(capability2, uri2.error) };
      }
      const nb = descriptor.nb.read({
        ...claimed.nb,
        ...capability2.nb
      });
      if (nb.error) {
        return { error: new MalformedCapability(capability2, nb.error) };
      }
      return { ok: new CapabilityView(can, uri2.ok, nb.ok, delegation) };
    };
    CapabilityView = class {
      /**
       * @param {A} can
       * @param {R} with_
       * @param {C} nb
       * @param {API.Delegation} delegation
       */
      constructor(can, with_, nb, delegation) {
        this.can = can;
        this.with = with_;
        this.delegation = delegation;
        this.nb = nb;
      }
    };
    select = (matcher, capabilities) => {
      const unknown2 = [];
      const matches = [];
      const errors2 = [];
      for (const capability2 of capabilities) {
        const result = matcher.match(capability2);
        if (result.error) {
          switch (result.error.name) {
            case "UnknownCapability":
              unknown2.push(result.error.capability);
              break;
            case "MalformedCapability":
            default:
              errors2.push(new DelegationError([result.error], result.error.capability));
          }
        } else {
          matches.push(result.ok);
        }
      }
      return { matches, errors: errors2, unknown: unknown2 };
    };
    selectGroup = (self2, capabilities) => {
      let unknown2;
      const data = [];
      const errors2 = [];
      for (const selector of self2.selectors) {
        const selected = selector.select(capabilities);
        unknown2 = unknown2 ? intersection2(unknown2, selected.unknown) : selected.unknown;
        for (const error3 of selected.errors) {
          errors2.push(new DelegationError([error3], self2));
        }
        data.push(selected.matches);
      }
      const matches = combine(data).map((group2) => new AndMatch(group2));
      return {
        unknown: (
          /* c8 ignore next */
          unknown2 || []
        ),
        errors: errors2,
        matches
      };
    };
    defaultDerives = (claimed, delegated) => {
      if (delegated.with.endsWith("*")) {
        if (!claimed.with.startsWith(delegated.with.slice(0, -1))) {
          return schema_exports3.error(
            `Resource ${claimed.with} does not match delegated ${delegated.with} `
          );
        }
      } else if (delegated.with !== claimed.with) {
        return schema_exports3.error(
          `Resource ${claimed.with} is not contained by ${delegated.with}`
        );
      }
      const caveats = delegated.nb || {};
      const nb = claimed.nb || {};
      const kv = entries(caveats);
      for (const [name142, value] of kv) {
        if (nb[name142] != value) {
          return schema_exports3.error(`${String(name142)}: ${nb[name142]} violates ${value}`);
        }
      }
      return { ok: true };
    };
    FR32_SHA2_256_TRUNC254_PADDED_BINARY_TREE = /** @type {const} */
    4113;
    RAW_CODE = /** @type {const} */
    85;
    PieceLink = /** @type {import('../types.js').PieceLinkSchema} */
    schema_exports3.link({
      code: RAW_CODE,
      version: 1,
      multihash: {
        code: FR32_SHA2_256_TRUNC254_PADDED_BINARY_TREE
      }
    });
    ProviderDID = did_exports2.match({ method: "web" });
    SpaceDID = did_exports2.match({ method: "key" });
    AccountDID = did_exports2.match({ method: "mailto" });
    Await = schema_exports3.struct({
      "ucan/await": schema_exports3.tuple([schema_exports3.string(), schema_exports3.link()])
    });
    checkLink = (claimed, imposed, at2) => {
      return equal(
        String(claimed),
        imposed === void 0 ? void 0 : String(imposed),
        at2
      );
    };
    and3 = (result) => result.error ? result : void 0;
    filecoinOffer = capability({
      can: "filecoin/offer",
      /**
       * DID of the space the content is stored in.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * CID of the content that resulted in Filecoin piece.
         */
        content: schema_exports3.link(),
        /**
         * CID of the piece.
         */
        piece: PieceLink
      }),
      derives: (claim, from19) => {
        return and3(equalWith(claim, from19)) || and3(checkLink(claim.nb.content, from19.nb.content, "nb.content")) || and3(checkLink(claim.nb.piece, from19.nb.piece, "nb.piece")) || ok({});
      }
    });
    filecoinSubmit = capability({
      can: "filecoin/submit",
      /**
       * DID of the Storefront.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * CID of the content that resulted in Filecoin piece.
         */
        content: schema_exports3.link(),
        /**
         * CID of the piece.
         *
         * @see https://github.com/filecoin-project/FIPs/pull/758/files
         */
        piece: PieceLink
      }),
      derives: (claim, from19) => {
        return and3(equalWith(claim, from19)) || and3(checkLink(claim.nb.content, from19.nb.content, "nb.content")) || and3(checkLink(claim.nb.piece, from19.nb.piece, "nb.piece")) || ok({});
      }
    });
    filecoinAccept = capability({
      can: "filecoin/accept",
      /**
       * DID of the Storefront.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * CID of the content that resulted in Filecoin piece.
         */
        content: schema_exports3.link(),
        /**
         * CID of the piece.
         *
         * @see https://github.com/filecoin-project/FIPs/pull/758/files
         */
        piece: PieceLink
      }),
      derives: (claim, from19) => {
        return and3(equalWith(claim, from19)) || and3(checkLink(claim.nb.content, from19.nb.content, "nb.content")) || and3(checkLink(claim.nb.piece, from19.nb.piece, "nb.piece")) || ok({});
      }
    });
    filecoinInfo = capability({
      can: "filecoin/info",
      /**
       * DID of the space the content is stored in.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * CID of the piece.
         *
         * @see https://github.com/filecoin-project/FIPs/pull/758/files
         */
        piece: PieceLink
      }),
      derives: (claim, from19) => {
        return and3(equalWith(claim, from19)) || and3(checkLink(claim.nb.piece, from19.nb.piece, "nb.piece")) || ok({});
      }
    });
    services = {
      STOREFRONT: {
        url: new URL("https://up.web3.storage"),
        principal: parse2("did:web:web3.storage")
      },
      AGGREGATOR: {
        url: new URL("https://aggregator.web3.storage"),
        principal: parse2("did:web:web3.storage")
      },
      DEALER: {
        url: new URL("https://dealer.web3.storage"),
        principal: parse2("did:web:web3.storage")
      },
      DEAL_TRACKER: {
        url: new URL("https://tracker.web3.storage"),
        principal: parse2("did:web:web3.storage")
      }
    };
    connection = connect({
      id: services.STOREFRONT.principal,
      codec: car_exports2.outbound,
      channel: http_exports.open({
        url: services.STOREFRONT.url,
        method: "POST"
      })
    });
    pieceOffer = capability({
      can: "piece/offer",
      /**
       * DID of an authorized Storefront.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * CID of the piece.
         */
        piece: PieceLink,
        /**
         * Grouping of joining segments into an aggregate.
         */
        group: schema_exports3.text()
      }),
      derives: (claim, from19) => {
        return and3(equalWith(claim, from19)) || and3(checkLink(claim.nb.piece, from19.nb.piece, "nb.piece")) || and3(equal(claim.nb.group, from19.nb.group, "nb.group")) || ok({});
      }
    });
    pieceAccept = capability({
      can: "piece/accept",
      /**
       * DID of the Aggregator.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * CID of the piece.
         *
         * @see https://github.com/filecoin-project/FIPs/pull/758/files
         */
        piece: PieceLink,
        /**
         * Grouping of joining segments into an aggregate.
         */
        group: schema_exports3.text()
      }),
      derives: (claim, from19) => {
        return and3(equalWith(claim, from19)) || and3(checkLink(claim.nb.piece, from19.nb.piece, "nb.piece")) || and3(equal(claim.nb.group, from19.nb.group, "nb.group")) || ok({});
      }
    });
    connection2 = connect({
      id: services.AGGREGATOR.principal,
      codec: car_exports2.outbound,
      channel: http_exports.open({
        url: services.AGGREGATOR.url,
        method: "POST"
      })
    });
    aggregateOffer = capability({
      can: "aggregate/offer",
      /**
       * DID of an authorized Storefront.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * Commitment proof for the aggregate being offered.
         */
        aggregate: PieceLink,
        /**
         * CID of the DAG-CBOR encoded block with offer details.
         * Service will queue given offer to be validated and handled.
         */
        pieces: schema_exports3.link({ version: 1 })
      }),
      derives: (claim, from19) => {
        return and3(equalWith(claim, from19)) || and3(checkLink(claim.nb.aggregate, from19.nb.aggregate, "nb.aggregate")) || and3(checkLink(claim.nb.pieces, from19.nb.pieces, "nb.pieces")) || ok({});
      }
    });
    aggregateAccept = capability({
      can: "aggregate/accept",
      /**
       * did:key identifier of the broker authority where offer is made available.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * Commitment proof for the aggregate being offered.
         */
        aggregate: PieceLink,
        /**
         * CID of the DAG-CBOR encoded block with offer details.
         * Service will queue given offer to be validated and handled.
         */
        pieces: schema_exports3.link()
      }),
      derives: (claim, from19) => {
        return and3(equalWith(claim, from19)) || and3(checkLink(claim.nb.aggregate, from19.nb.aggregate, "nb.aggregate")) || and3(checkLink(claim.nb.pieces, from19.nb.pieces, "nb.pieces")) || ok({});
      }
    });
    connection3 = connect({
      id: services.DEALER.principal,
      codec: car_exports2.outbound,
      channel: http_exports.open({
        url: services.DEALER.url,
        method: "POST"
      })
    });
    dealInfo = capability({
      can: "deal/info",
      /**
       * DID of the Storefront.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * CID of the piece.
         *
         * @see https://github.com/filecoin-project/FIPs/pull/758/files
         */
        piece: PieceLink
      }),
      derives: (claim, from19) => {
        return and3(equalWith(claim, from19)) || and3(checkLink(claim.nb.piece, from19.nb.piece, "nb.piece")) || ok({});
      }
    });
    connection4 = connect({
      id: services.DEAL_TRACKER.principal,
      codec: car_exports2.outbound,
      channel: http_exports.open({
        url: services.DEAL_TRACKER.url,
        method: "POST"
      })
    });
    src3 = base3;
    _brrp__multiformats_scope_baseX3 = src3;
    base_x_default3 = _brrp__multiformats_scope_baseX3;
    empty4 = new Uint8Array(0);
    equals6 = (aa, bb) => {
      if (aa === bb) return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    coerce3 = (o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") return o;
      if (o instanceof ArrayBuffer) return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    Encoder3 = class {
      /**
       * @param {Base} name
       * @param {Prefix} prefix
       * @param {(bytes:Uint8Array) => string} baseEncode
       */
      constructor(name142, prefix2, baseEncode) {
        this.name = name142;
        this.prefix = prefix2;
        this.baseEncode = baseEncode;
      }
      /**
       * @param {Uint8Array} bytes
       * @returns {API.Multibase<Prefix>}
       */
      encode(bytes22) {
        if (bytes22 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes22)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder3 = class {
      /**
       * @param {Base} name
       * @param {Prefix} prefix
       * @param {(text:string) => Uint8Array} baseDecode
       */
      constructor(name142, prefix2, baseDecode) {
        this.name = name142;
        this.prefix = prefix2;
        if (prefix2.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = /** @type {number} */
        prefix2.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      /**
       * @param {string} text
       */
      decode(text2) {
        if (typeof text2 === "string") {
          if (text2.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text2.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      /**
       * @template {string} OtherPrefix
       * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
       * @returns {ComposedDecoder<Prefix|OtherPrefix>}
       */
      or(decoder32) {
        return or5(this, decoder32);
      }
    };
    ComposedDecoder3 = class {
      /**
       * @param {Decoders<Prefix>} decoders
       */
      constructor(decoders) {
        this.decoders = decoders;
      }
      /**
       * @template {string} OtherPrefix
       * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
       * @returns {ComposedDecoder<Prefix|OtherPrefix>}
       */
      or(decoder32) {
        return or5(this, decoder32);
      }
      /**
       * @param {string} input
       * @returns {Uint8Array}
       */
      decode(input10) {
        const prefix2 = (
          /** @type {Prefix} */
          input10[0]
        );
        const decoder32 = this.decoders[prefix2];
        if (decoder32) {
          return decoder32.decode(input10);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input10)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    or5 = (left, right) => new ComposedDecoder3(
      /** @type {Decoders<L|R>} */
      {
        ...left.decoders || { [
          /** @type API.UnibaseDecoder<L> */
          left.prefix
        ]: left },
        ...right.decoders || { [
          /** @type API.UnibaseDecoder<R> */
          right.prefix
        ]: right }
      }
    );
    Codec3 = class {
      /**
       * @param {Base} name
       * @param {Prefix} prefix
       * @param {(bytes:Uint8Array) => string} baseEncode
       * @param {(text:string) => Uint8Array} baseDecode
       */
      constructor(name142, prefix2, baseEncode, baseDecode) {
        this.name = name142;
        this.prefix = prefix2;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder3(name142, prefix2, baseEncode);
        this.decoder = new Decoder3(name142, prefix2, baseDecode);
      }
      /**
       * @param {Uint8Array} input
       */
      encode(input10) {
        return this.encoder.encode(input10);
      }
      /**
       * @param {string} input
       */
      decode(input10) {
        return this.decoder.decode(input10);
      }
    };
    from11 = ({ name: name142, prefix: prefix2, encode: encode342, decode: decode412 }) => new Codec3(name142, prefix2, encode342, decode412);
    baseX3 = ({ prefix: prefix2, name: name142, alphabet: alphabet22 }) => {
      const { encode: encode342, decode: decode412 } = base_x_default3(alphabet22, name142);
      return from11({
        prefix: prefix2,
        name: name142,
        encode: encode342,
        /**
         * @param {string} text
         */
        decode: (text2) => coerce3(decode412(text2))
      });
    };
    decode25 = (string32, alphabet22, bitsPerChar, name142) => {
      const codes = {};
      for (let i = 0; i < alphabet22.length; ++i) {
        codes[alphabet22[i]] = i;
      }
      let end = string32.length;
      while (string32[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer22 = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string32[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name142} character`);
        }
        buffer22 = buffer22 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer22 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer22 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    encode20 = (data, alphabet22, bitsPerChar) => {
      const pad2 = alphabet22[alphabet22.length - 1] === "=";
      const mask2 = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer22 = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer22 = buffer22 << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet22[mask2 & buffer22 >> bits];
        }
      }
      if (bits) {
        out += alphabet22[mask2 & buffer22 << bitsPerChar - bits];
      }
      if (pad2) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    rfc46483 = ({ name: name142, prefix: prefix2, bitsPerChar, alphabet: alphabet22 }) => {
      return from11({
        prefix: prefix2,
        name: name142,
        encode(input10) {
          return encode20(input10, alphabet22, bitsPerChar);
        },
        decode(input10) {
          return decode25(input10, alphabet22, bitsPerChar, name142);
        }
      });
    };
    base323 = rfc46483({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper3 = rfc46483({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad3 = rfc46483({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper3 = rfc46483({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex3 = rfc46483({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper3 = rfc46483({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad3 = rfc46483({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper3 = rfc46483({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z3 = rfc46483({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
    base58btc3 = baseX3({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr3 = baseX3({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
    encode_13 = encode21;
    MSB3 = 128;
    REST3 = 127;
    MSBALL3 = ~REST3;
    INT3 = Math.pow(2, 31);
    decode26 = read7;
    MSB$13 = 128;
    REST$13 = 127;
    N13 = Math.pow(2, 7);
    N23 = Math.pow(2, 14);
    N33 = Math.pow(2, 21);
    N43 = Math.pow(2, 28);
    N53 = Math.pow(2, 35);
    N63 = Math.pow(2, 42);
    N73 = Math.pow(2, 49);
    N83 = Math.pow(2, 56);
    N93 = Math.pow(2, 63);
    length3 = function(value) {
      return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N53 ? 5 : value < N63 ? 6 : value < N73 ? 7 : value < N83 ? 8 : value < N93 ? 9 : 10;
    };
    varint5 = {
      encode: encode_13,
      decode: decode26,
      encodingLength: length3
    };
    _brrp_varint3 = varint5;
    varint_default3 = _brrp_varint3;
    decode27 = (data, offset22 = 0) => {
      const code192 = varint_default3.decode(data, offset22);
      return [code192, varint_default3.decode.bytes];
    };
    encodeTo3 = (int2, target, offset22 = 0) => {
      varint_default3.encode(int2, target, offset22);
      return target;
    };
    encodingLength3 = (int2) => {
      return varint_default3.encodingLength(int2);
    };
    create9 = (code192, digest52) => {
      const size5 = digest52.byteLength;
      const sizeOffset = encodingLength3(code192);
      const digestOffset = sizeOffset + encodingLength3(size5);
      const bytes22 = new Uint8Array(digestOffset + size5);
      encodeTo3(code192, bytes22, 0);
      encodeTo3(size5, bytes22, sizeOffset);
      bytes22.set(digest52, digestOffset);
      return new Digest5(code192, size5, digest52, bytes22);
    };
    decode28 = (multihash) => {
      const bytes22 = coerce3(multihash);
      const [code192, sizeOffset] = decode27(bytes22);
      const [size5, digestOffset] = decode27(bytes22.subarray(sizeOffset));
      const digest52 = bytes22.subarray(sizeOffset + digestOffset);
      if (digest52.byteLength !== size5) {
        throw new Error("Incorrect length");
      }
      return new Digest5(code192, size5, digest52, bytes22);
    };
    equals7 = (a, b) => {
      if (a === b) {
        return true;
      } else {
        const data = (
          /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
          b
        );
        return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals6(a.bytes, data.bytes);
      }
    };
    Digest5 = class {
      /**
       * Creates a multihash digest.
       *
       * @param {Code} code
       * @param {Size} size
       * @param {Uint8Array} digest
       * @param {Uint8Array} bytes
       */
      constructor(code192, size5, digest52, bytes22) {
        this.code = code192;
        this.size = size5;
        this.digest = digest52;
        this.bytes = bytes22;
      }
    };
    format8 = (link5, base42) => {
      const { bytes: bytes22, version: version22 } = link5;
      switch (version22) {
        case 0:
          return toStringV03(
            bytes22,
            baseCache3(link5),
            /** @type {API.MultibaseEncoder<"z">} */
            base42 || base58btc3.encoder
          );
        default:
          return toStringV13(
            bytes22,
            baseCache3(link5),
            /** @type {API.MultibaseEncoder<Prefix>} */
            base42 || base323.encoder
          );
      }
    };
    cache3 = /* @__PURE__ */ new WeakMap();
    baseCache3 = (cid) => {
      const baseCache4 = cache3.get(cid);
      if (baseCache4 == null) {
        const baseCache5 = /* @__PURE__ */ new Map();
        cache3.set(cid, baseCache5);
        return baseCache5;
      }
      return baseCache4;
    };
    CID3 = class _CID3 {
      /**
       * @param {Version} version - Version of the CID
       * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
       * @param {Uint8Array} bytes
       */
      constructor(version22, code192, multihash, bytes22) {
        this.code = code192;
        this.version = version22;
        this.multihash = multihash;
        this.bytes = bytes22;
        this["/"] = bytes22;
      }
      /**
       * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
       * please either use `CID.asCID(cid)` or switch to new signalling mechanism
       *
       * @deprecated
       */
      get asCID() {
        return this;
      }
      // ArrayBufferView
      get byteOffset() {
        return this.bytes.byteOffset;
      }
      // ArrayBufferView
      get byteLength() {
        return this.bytes.byteLength;
      }
      /**
       * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
       */
      toV0() {
        switch (this.version) {
          case 0: {
            return (
              /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
              this
            );
          }
          case 1: {
            const { code: code192, multihash } = this;
            if (code192 !== DAG_PB_CODE4) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE3) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return (
              /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
              _CID3.createV0(
                /** @type {API.MultihashDigest<API.SHA_256>} */
                multihash
              )
            );
          }
          default: {
            throw Error(
              `Can not convert CID version ${this.version} to version 0. This is a bug please report`
            );
          }
        }
      }
      /**
       * @returns {CID<Data, Format, Alg, 1>}
       */
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code192, digest: digest52 } = this.multihash;
            const multihash = create9(code192, digest52);
            return (
              /** @type {CID<Data, Format, Alg, 1>} */
              _CID3.createV1(this.code, multihash)
            );
          }
          case 1: {
            return (
              /** @type {CID<Data, Format, Alg, 1>} */
              this
            );
          }
          default: {
            throw Error(
              `Can not convert CID version ${this.version} to version 1. This is a bug please report`
            );
          }
        }
      }
      /**
       * @param {unknown} other
       * @returns {other is CID<Data, Format, Alg, Version>}
       */
      equals(other) {
        return _CID3.equals(this, other);
      }
      /**
       * @template {unknown} Data
       * @template {number} Format
       * @template {number} Alg
       * @template {API.Version} Version
       * @param {API.Link<Data, Format, Alg, Version>} self
       * @param {unknown} other
       * @returns {other is CID}
       */
      static equals(self2, other) {
        const unknown2 = (
          /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
          other
        );
        return unknown2 && self2.code === unknown2.code && self2.version === unknown2.version && equals7(self2.multihash, unknown2.multihash);
      }
      /**
       * @param {API.MultibaseEncoder<string>} [base]
       * @returns {string}
       */
      toString(base42) {
        return format8(this, base42);
      }
      /**
       * @returns {API.LinkJSON<this>}
       */
      toJSON() {
        return { "/": format8(this) };
      }
      link() {
        return this;
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      // Legacy
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return `CID(${this.toString()})`;
      }
      /**
       * Takes any input `value` and returns a `CID` instance if it was
       * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
       * it will return value back. If `value` is not instance of this CID
       * class, but is compatible CID it will return new instance of this
       * `CID` class. Otherwise returns null.
       *
       * This allows two different incompatible versions of CID library to
       * co-exist and interop as long as binary interface is compatible.
       *
       * @template {unknown} Data
       * @template {number} Format
       * @template {number} Alg
       * @template {API.Version} Version
       * @template {unknown} U
       * @param {API.Link<Data, Format, Alg, Version>|U} input
       * @returns {CID<Data, Format, Alg, Version>|null}
       */
      static asCID(input10) {
        if (input10 == null) {
          return null;
        }
        const value = (
          /** @type {any} */
          input10
        );
        if (value instanceof _CID3) {
          return value;
        } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
          const { version: version22, code: code192, multihash, bytes: bytes22 } = value;
          return new _CID3(
            version22,
            code192,
            /** @type {API.MultihashDigest<Alg>} */
            multihash,
            bytes22 || encodeCID3(version22, code192, multihash.bytes)
          );
        } else if (value[cidSymbol3] === true) {
          const { version: version22, multihash, code: code192 } = value;
          const digest52 = (
            /** @type {API.MultihashDigest<Alg>} */
            decode28(multihash)
          );
          return _CID3.create(version22, code192, digest52);
        } else {
          return null;
        }
      }
      /**
       *
       * @template {unknown} Data
       * @template {number} Format
       * @template {number} Alg
       * @template {API.Version} Version
       * @param {Version} version - Version of the CID
       * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
       * @returns {CID<Data, Format, Alg, Version>}
       */
      static create(version22, code192, digest52) {
        if (typeof code192 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        if (!(digest52.bytes instanceof Uint8Array)) {
          throw new Error("Invalid digest");
        }
        switch (version22) {
          case 0: {
            if (code192 !== DAG_PB_CODE4) {
              throw new Error(
                `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE4}) block encoding`
              );
            } else {
              return new _CID3(version22, code192, digest52, digest52.bytes);
            }
          }
          case 1: {
            const bytes22 = encodeCID3(version22, code192, digest52.bytes);
            return new _CID3(version22, code192, digest52, bytes22);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      /**
       * Simplified version of `create` for CIDv0.
       *
       * @template {unknown} [T=unknown]
       * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
       * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
       */
      static createV0(digest52) {
        return _CID3.create(0, DAG_PB_CODE4, digest52);
      }
      /**
       * Simplified version of `create` for CIDv1.
       *
       * @template {unknown} Data
       * @template {number} Code
       * @template {number} Alg
       * @param {Code} code - Content encoding format code.
       * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
       * @returns {CID<Data, Code, Alg, 1>}
       */
      static createV1(code192, digest52) {
        return _CID3.create(1, code192, digest52);
      }
      /**
       * Decoded a CID from its binary representation. The byte array must contain
       * only the CID with no additional bytes.
       *
       * An error will be thrown if the bytes provided do not contain a valid
       * binary representation of a CID.
       *
       * @template {unknown} Data
       * @template {number} Code
       * @template {number} Alg
       * @template {API.Version} Ver
       * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
       * @returns {CID<Data, Code, Alg, Ver>}
       */
      static decode(bytes22) {
        const [cid, remainder] = _CID3.decodeFirst(bytes22);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      /**
       * Decoded a CID from its binary representation at the beginning of a byte
       * array.
       *
       * Returns an array with the first element containing the CID and the second
       * element containing the remainder of the original byte array. The remainder
       * will be a zero-length byte array if the provided bytes only contained a
       * binary CID representation.
       *
       * @template {unknown} T
       * @template {number} C
       * @template {number} A
       * @template {API.Version} V
       * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
       * @returns {[CID<T, C, A, V>, Uint8Array]}
       */
      static decodeFirst(bytes22) {
        const specs = _CID3.inspectBytes(bytes22);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce3(
          bytes22.subarray(prefixSize, prefixSize + specs.multihashSize)
        );
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(
          specs.multihashSize - specs.digestSize
        );
        const digest52 = new Digest5(
          specs.multihashCode,
          specs.digestSize,
          digestBytes,
          multihashBytes
        );
        const cid = specs.version === 0 ? _CID3.createV0(
          /** @type {API.MultihashDigest<API.SHA_256>} */
          digest52
        ) : _CID3.createV1(specs.codec, digest52);
        return [
          /** @type {CID<T, C, A, V>} */
          cid,
          bytes22.subarray(specs.size)
        ];
      }
      /**
       * Inspect the initial bytes of a CID to determine its properties.
       *
       * Involves decoding up to 4 varints. Typically this will require only 4 to 6
       * bytes but for larger multicodec code values and larger multihash digest
       * lengths these varints can be quite large. It is recommended that at least
       * 10 bytes be made available in the `initialBytes` argument for a complete
       * inspection.
       *
       * @template {unknown} T
       * @template {number} C
       * @template {number} A
       * @template {API.Version} V
       * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
       * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
       */
      static inspectBytes(initialBytes) {
        let offset22 = 0;
        const next = () => {
          const [i, length42] = decode27(initialBytes.subarray(offset22));
          offset22 += length42;
          return i;
        };
        let version22 = (
          /** @type {V} */
          next()
        );
        let codec = (
          /** @type {C} */
          DAG_PB_CODE4
        );
        if (
          /** @type {number} */
          version22 === 18
        ) {
          version22 = /** @type {V} */
          0;
          offset22 = 0;
        } else {
          codec = /** @type {C} */
          next();
        }
        if (version22 !== 0 && version22 !== 1) {
          throw new RangeError(`Invalid CID version ${version22}`);
        }
        const prefixSize = offset22;
        const multihashCode = (
          /** @type {A} */
          next()
        );
        const digestSize = next();
        const size5 = offset22 + digestSize;
        const multihashSize = size5 - prefixSize;
        return { version: version22, codec, multihashCode, digestSize, multihashSize, size: size5 };
      }
      /**
       * Takes cid in a string representation and creates an instance. If `base`
       * decoder is not provided will use a default from the configuration. It will
       * throw an error if encoding of the CID is not compatible with supplied (or
       * a default decoder).
       *
       * @template {string} Prefix
       * @template {unknown} Data
       * @template {number} Code
       * @template {number} Alg
       * @template {API.Version} Ver
       * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
       * @param {API.MultibaseDecoder<Prefix>} [base]
       * @returns {CID<Data, Code, Alg, Ver>}
       */
      static parse(source, base42) {
        const [prefix2, bytes22] = parseCIDtoBytes3(source, base42);
        const cid = _CID3.decode(bytes22);
        if (cid.version === 0 && source[0] !== "Q") {
          throw Error("Version 0 CID string must not include multibase prefix");
        }
        baseCache3(cid).set(prefix2, source);
        return cid;
      }
    };
    parseCIDtoBytes3 = (source, base42) => {
      switch (source[0]) {
        case "Q": {
          const decoder32 = base42 || base58btc3;
          return [
            /** @type {Prefix} */
            base58btc3.prefix,
            decoder32.decode(`${base58btc3.prefix}${source}`)
          ];
        }
        case base58btc3.prefix: {
          const decoder32 = base42 || base58btc3;
          return [
            /** @type {Prefix} */
            base58btc3.prefix,
            decoder32.decode(source)
          ];
        }
        case base323.prefix: {
          const decoder32 = base42 || base323;
          return [
            /** @type {Prefix} */
            base323.prefix,
            decoder32.decode(source)
          ];
        }
        default: {
          if (base42 == null) {
            throw Error(
              "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
            );
          }
          return [
            /** @type {Prefix} */
            source[0],
            base42.decode(source)
          ];
        }
      }
    };
    toStringV03 = (bytes22, cache5, base42) => {
      const { prefix: prefix2 } = base42;
      if (prefix2 !== base58btc3.prefix) {
        throw Error(`Cannot string encode V0 in ${base42.name} encoding`);
      }
      const cid = cache5.get(prefix2);
      if (cid == null) {
        const cid2 = base42.encode(bytes22).slice(1);
        cache5.set(prefix2, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    toStringV13 = (bytes22, cache5, base42) => {
      const { prefix: prefix2 } = base42;
      const cid = cache5.get(prefix2);
      if (cid == null) {
        const cid2 = base42.encode(bytes22);
        cache5.set(prefix2, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    DAG_PB_CODE4 = 112;
    SHA_256_CODE3 = 18;
    encodeCID3 = (version22, code192, multihash) => {
      const codeOffset = encodingLength3(version22);
      const hashOffset = codeOffset + encodingLength3(code192);
      const bytes22 = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo3(version22, bytes22, 0);
      encodeTo3(code192, bytes22, codeOffset);
      bytes22.set(multihash, hashOffset);
      return bytes22;
    };
    cidSymbol3 = Symbol.for("@ipld/js-cid/CID");
    create10 = (code192, digest52) => CID3.create(1, code192, digest52);
    raw_exports2 = {};
    __export2(raw_exports2, {
      code: () => code10,
      decode: () => decode29,
      encode: () => encode22,
      name: () => name7
    });
    name7 = "raw";
    code10 = 85;
    encode22 = (node) => coerce3(node);
    decode29 = (data) => coerce3(data);
    from12 = ({ name: name142, code: code192, encode: encode342 }) => new Hasher4(name142, code192, encode342);
    Hasher4 = class {
      /**
       *
       * @param {Name} name
       * @param {Code} code
       * @param {(input: Uint8Array) => Await<Uint8Array>} encode
       */
      constructor(name142, code192, encode342) {
        this.name = name142;
        this.code = code192;
        this.encode = encode342;
      }
      /**
       * @param {Uint8Array} input
       * @returns {Await<Digest.Digest<Code, number>>}
       */
      digest(input10) {
        if (input10 instanceof Uint8Array) {
          const result = this.encode(input10);
          return result instanceof Uint8Array ? create9(this.code, result) : result.then((digest52) => create9(this.code, digest52));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    sha2 = (name142) => (
      /**
       * @param {Uint8Array} data
       */
      async (data) => new Uint8Array(await crypto.subtle.digest(name142, data))
    );
    sha2563 = from12({
      name: "sha2-256",
      code: 18,
      encode: sha2("SHA-256")
    });
    sha5122 = from12({
      name: "sha2-512",
      code: 19,
      encode: sha2("SHA-512")
    });
    store_exports = {};
    __export2(store_exports, {
      add: () => add2,
      get: () => get3,
      list: () => list2,
      remove: () => remove2
    });
    ProviderDID2 = did_exports2.match({ method: "web" });
    SpaceDID2 = did_exports2.match({ method: "key" });
    AccountDID2 = did_exports2.match({ method: "mailto" });
    Await2 = schema_exports3.struct({
      "ucan/await": schema_exports3.tuple([schema_exports3.string(), schema_exports3.link()])
    });
    equalLink = (claimed, delegated) => {
      if (claimed.with !== delegated.with) {
        return fail2(
          `Expected 'with: "${delegated.with}"' instead got '${claimed.with}'`
        );
      } else if (delegated.nb.link && `${delegated.nb.link}` !== `${claimed.nb.link}`) {
        return fail2(
          `Link ${claimed.nb.link ? `${claimed.nb.link}` : ""} violates imposed ${delegated.nb.link} constraint.`
        );
      } else {
        return ok({});
      }
    };
    equalBlob = (claimed, delegated) => {
      if (claimed.with !== delegated.with) {
        return fail2(
          `Expected 'with: "${delegated.with}"' instead got '${claimed.with}'`
        );
      } else if (delegated.nb.blob.digest && !equals5(delegated.nb.blob.digest, claimed.nb.blob.digest)) {
        return fail2(
          `Link ${claimed.nb.blob.digest ? `${claimed.nb.blob.digest}` : ""} violates imposed ${delegated.nb.blob.digest} constraint.`
        );
      } else if (claimed.nb.blob.size !== void 0 && delegated.nb.blob.size !== void 0) {
        return claimed.nb.blob.size > delegated.nb.blob.size ? fail2(
          `Size constraint violation: ${claimed.nb.blob.size} > ${delegated.nb.blob.size}`
        ) : ok({});
      } else {
        return ok({});
      }
    };
    equalBody = (claimed, delegated) => {
      if (claimed.with !== delegated.with) {
        return fail2(
          `Expected 'with: "${delegated.with}"' instead got '${claimed.with}'`
        );
      } else if (delegated.nb.body.digest && !equals5(delegated.nb.body.digest, claimed.nb.body.digest)) {
        return fail2(
          `Link ${claimed.nb.body.digest ? `${claimed.nb.body.digest}` : ""} violates imposed ${delegated.nb.body.digest} constraint.`
        );
      } else if (claimed.nb.body.size !== void 0 && delegated.nb.body.size !== void 0) {
        return claimed.nb.body.size > delegated.nb.body.size ? fail2(
          `Size constraint violation: ${claimed.nb.body.size} > ${delegated.nb.body.size}`
        ) : ok({});
      } else {
        return ok({});
      }
    };
    checkLink2 = (claimed, imposed, at2) => {
      return equal2(
        String(claimed),
        imposed === void 0 ? void 0 : String(imposed),
        at2
      );
    };
    and4 = (result) => result.error ? result : void 0;
    code11 = 514;
    CARLink = schema_exports3.link({ code: code11, version: 1 });
    store = capability({
      can: "store/*",
      /**
       * DID of the (memory) space where CAR is intended to
       * be stored.
       */
      with: SpaceDID2,
      derives: equalWith2
    });
    add = capability({
      can: "store/add",
      /**
       * DID of the (memory) space where CAR is intended to
       * be stored.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * CID of the CAR file to be stored. Service will provision write target
         * for this exact CAR file for agent to PUT or POST it. Attempt to write
         * any other content will fail.
         */
        link: CARLink,
        /**
         * Size of the CAR file to be stored. Service will provision write target
         * for this exact size. Attempt to write a larger CAR file will fail.
         */
        size: schema_exports3.integer(),
        /**
         * Agent may optionally provide a link to a related CAR file using `origin`
         * field. This is useful when storing large DAGs, agent could shard it
         * across multiple CAR files and then link each shard with a previous one.
         *
         * Providing this relation tells service that given CAR is shard of the
         * larger DAG as opposed to it being intentionally partial DAG. When DAG is
         * not sharded, there will be only one `store/add` with `origin` left out.
         */
        origin: link_exports2.optional()
      }),
      derives: (claim, from19) => {
        const result = equalLink(claim, from19);
        if (result.error) {
          return result;
        } else if (claim.nb.size !== void 0 && from19.nb.size !== void 0) {
          return claim.nb.size > from19.nb.size ? fail2(`Size constraint violation: ${claim.nb.size} > ${from19.nb.size}`) : ok({});
        } else {
          return ok({});
        }
      }
    });
    get2 = capability({
      can: "store/get",
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * shard CID to fetch info about.
         */
        link: CARLink.optional()
      }),
      derives: equalLink
    });
    remove = capability({
      can: "store/remove",
      /**
       * DID of the (memory) space where CAR is intended to
       * be stored.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * CID of the CAR file to be removed from the store.
         */
        link: CARLink
      }),
      derives: equalLink
    });
    list = capability({
      can: "store/list",
      /**
       * DID of the (memory) space where CAR is intended to
       * be stored.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * A pointer that can be moved back and forth on the list.
         * It can be used to paginate a list for instance.
         */
        cursor: schema_exports3.string().optional(),
        /**
         * Maximum number of items per page.
         */
        size: schema_exports3.integer().optional(),
        /**
         * If true, return page of results preceding cursor. Defaults to false.
         */
        pre: schema_exports3.boolean().optional()
      }),
      derives: (claimed, delegated) => {
        if (claimed.with !== delegated.with) {
          return fail2(
            `Expected 'with: "${delegated.with}"' instead got '${claimed.with}'`
          );
        }
        return ok({});
      }
    });
    all = add.or(remove).or(list);
    import_retry = __toESM2(require_retry2(), 1);
    networkErrorMsgs = /* @__PURE__ */ new Set([
      "Failed to fetch",
      // Chrome
      "NetworkError when attempting to fetch resource.",
      // Firefox
      "The Internet connection appears to be offline.",
      // Safari
      "Network request failed",
      // `cross-fetch`
      "fetch failed"
      // Undici (Node.js)
    ]);
    AbortError = class extends Error {
      constructor(message2) {
        super();
        if (message2 instanceof Error) {
          this.originalError = message2;
          ({ message: message2 } = message2);
        } else {
          this.originalError = new Error(message2);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message2;
      }
    };
    decorateErrorWithCounts = (error3, attemptNumber, options) => {
      const retriesLeft = options.retries - (attemptNumber - 1);
      error3.attemptNumber = attemptNumber;
      error3.retriesLeft = retriesLeft;
      return error3;
    };
    isNetworkError = (errorMessage) => networkErrorMsgs.has(errorMessage);
    getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new Error(errorMessage) : new DOMException(errorMessage);
    serviceURL = new URL("https://up.web3.storage");
    servicePrincipal = parse2("did:web:web3.storage");
    receiptsEndpoint = "https://up.web3.storage/receipt/";
    connection5 = connect({
      id: servicePrincipal,
      codec: car_exports2.outbound,
      channel: http_exports.open({
        url: serviceURL,
        method: "POST"
      })
    });
    REQUEST_RETRIES = 3;
    blob_exports3 = {};
    __export2(blob_exports3, {
      add: () => add4,
      get: () => get6,
      list: () => list4,
      remove: () => remove4
    });
    ed25519_exports = {};
    __export2(ed25519_exports, {
      PUB_KEY_OFFSET: () => PUB_KEY_OFFSET,
      Signer: () => signer_exports,
      Verifier: () => verifier_exports,
      code: () => code13,
      decode: () => decode31,
      derive: () => derive2,
      encode: () => encode24,
      format: () => format10,
      from: () => from13,
      generate: () => generate,
      name: () => name9,
      or: () => or9,
      parse: () => parse6,
      signatureAlgorithm: () => signatureAlgorithm2,
      signatureCode: () => signatureCode2
    });
    signer_exports = {};
    __export2(signer_exports, {
      PUB_KEY_OFFSET: () => PUB_KEY_OFFSET,
      code: () => code13,
      decode: () => decode31,
      derive: () => derive2,
      encode: () => encode24,
      format: () => format10,
      from: () => from13,
      generate: () => generate,
      name: () => name9,
      or: () => or9,
      parse: () => parse6,
      signatureAlgorithm: () => signatureAlgorithm2,
      signatureCode: () => signatureCode2
    });
    init_empty();
    _0n = BigInt(0);
    _1n = BigInt(1);
    _2n = BigInt(2);
    _8n = BigInt(8);
    CU_O = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989");
    CURVE = Object.freeze({
      a: BigInt(-1),
      d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
      P: BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
      l: CU_O,
      n: CU_O,
      h: BigInt(8),
      Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
      Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
    });
    POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
    SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
    SQRT_D = BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
    SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
    INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
    ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
    D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
    ExtendedPoint = class _ExtendedPoint {
      constructor(x, y, z, t) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.t = t;
      }
      static fromAffine(p) {
        if (!(p instanceof Point)) {
          throw new TypeError("ExtendedPoint#fromAffine: expected Point");
        }
        if (p.equals(Point.ZERO))
          return _ExtendedPoint.ZERO;
        return new _ExtendedPoint(p.x, p.y, _1n, mod2(p.x * p.y));
      }
      static toAffineBatch(points) {
        const toInv = invertBatch(points.map((p) => p.z));
        return points.map((p, i) => p.toAffine(toInv[i]));
      }
      static normalizeZ(points) {
        return this.toAffineBatch(points).map(this.fromAffine);
      }
      equals(other) {
        assertExtPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const X1Z2 = mod2(X1 * Z2);
        const X2Z1 = mod2(X2 * Z1);
        const Y1Z2 = mod2(Y1 * Z2);
        const Y2Z1 = mod2(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      negate() {
        return new _ExtendedPoint(mod2(-this.x), this.y, this.z, mod2(-this.t));
      }
      double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const { a } = CURVE;
        const A = mod2(X1 * X1);
        const B = mod2(Y1 * Y1);
        const C = mod2(_2n * mod2(Z1 * Z1));
        const D = mod2(a * A);
        const x1y1 = X1 + Y1;
        const E = mod2(mod2(x1y1 * x1y1) - A - B);
        const G = D + B;
        const F = G - C;
        const H = D - B;
        const X3 = mod2(E * F);
        const Y3 = mod2(G * H);
        const T3 = mod2(E * H);
        const Z3 = mod2(F * G);
        return new _ExtendedPoint(X3, Y3, Z3, T3);
      }
      add(other) {
        assertExtPoint(other);
        const { x: X1, y: Y1, z: Z1, t: T1 } = this;
        const { x: X2, y: Y2, z: Z2, t: T2 } = other;
        const A = mod2((Y1 - X1) * (Y2 + X2));
        const B = mod2((Y1 + X1) * (Y2 - X2));
        const F = mod2(B - A);
        if (F === _0n)
          return this.double();
        const C = mod2(Z1 * _2n * T2);
        const D = mod2(T1 * _2n * Z2);
        const E = D + C;
        const G = B + A;
        const H = D - C;
        const X3 = mod2(E * F);
        const Y3 = mod2(G * H);
        const T3 = mod2(E * H);
        const Z3 = mod2(F * G);
        return new _ExtendedPoint(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      precomputeWindow(W) {
        const windows = 1 + 256 / W;
        const points = [];
        let p = this;
        let base42 = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base42 = p;
          points.push(base42);
          for (let i = 1; i < 2 ** (W - 1); i++) {
            base42 = base42.add(p);
            points.push(base42);
          }
          p = base42.double();
        }
        return points;
      }
      wNAF(n2, affinePoint) {
        if (!affinePoint && this.equals(_ExtendedPoint.BASE))
          affinePoint = Point.BASE;
        const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
        if (256 % W) {
          throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
        }
        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
        if (!precomputes) {
          precomputes = this.precomputeWindow(W);
          if (affinePoint && W !== 1) {
            precomputes = _ExtendedPoint.normalizeZ(precomputes);
            pointPrecomputes.set(affinePoint, precomputes);
          }
        }
        let p = _ExtendedPoint.ZERO;
        let f = _ExtendedPoint.BASE;
        const windows = 1 + 256 / W;
        const windowSize = 2 ** (W - 1);
        const mask2 = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset22 = window2 * windowSize;
          let wbits = Number(n2 & mask2);
          n2 >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n2 += _1n;
          }
          const offset1 = offset22;
          const offset222 = offset22 + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f = f.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p = p.add(constTimeNegate(cond2, precomputes[offset222]));
          }
        }
        return _ExtendedPoint.normalizeZ([p, f])[0];
      }
      multiply(scalar, affinePoint) {
        return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);
      }
      multiplyUnsafe(scalar) {
        let n2 = normalizeScalar(scalar, CURVE.l, false);
        const G = _ExtendedPoint.BASE;
        const P0 = _ExtendedPoint.ZERO;
        if (n2 === _0n)
          return P0;
        if (this.equals(P0) || n2 === _1n)
          return this;
        if (this.equals(G))
          return this.wNAF(n2);
        let p = P0;
        let d = this;
        while (n2 > _0n) {
          if (n2 & _1n)
            p = p.add(d);
          d = d.double();
          n2 >>= _1n;
        }
        return p;
      }
      isSmallOrder() {
        return this.multiplyUnsafe(CURVE.h).equals(_ExtendedPoint.ZERO);
      }
      isTorsionFree() {
        let p = this.multiplyUnsafe(CURVE.l / _2n).double();
        if (CURVE.l % _2n)
          p = p.add(this);
        return p.equals(_ExtendedPoint.ZERO);
      }
      toAffine(invZ) {
        const { x, y, z } = this;
        const is0 = this.equals(_ExtendedPoint.ZERO);
        if (invZ == null)
          invZ = is0 ? _8n : invert(z);
        const ax = mod2(x * invZ);
        const ay = mod2(y * invZ);
        const zz = mod2(z * invZ);
        if (is0)
          return Point.ZERO;
        if (zz !== _1n)
          throw new Error("invZ was invalid");
        return new Point(ax, ay);
      }
      fromRistrettoBytes() {
        legacyRist();
      }
      toRistrettoBytes() {
        legacyRist();
      }
      fromRistrettoHash() {
        legacyRist();
      }
    };
    ExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod2(CURVE.Gx * CURVE.Gy));
    ExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);
    RistrettoPoint = class _RistrettoPoint {
      constructor(ep) {
        this.ep = ep;
      }
      static calcElligatorRistrettoMap(r0) {
        const { d } = CURVE;
        const r = mod2(SQRT_M1 * r0 * r0);
        const Ns = mod2((r + _1n) * ONE_MINUS_D_SQ);
        let c = BigInt(-1);
        const D = mod2((c - d * r) * mod2(r + d));
        let { isValid: Ns_D_is_sq, value: s2 } = uvRatio(Ns, D);
        let s_ = mod2(s2 * r0);
        if (!edIsNegative(s_))
          s_ = mod2(-s_);
        if (!Ns_D_is_sq)
          s2 = s_;
        if (!Ns_D_is_sq)
          c = r;
        const Nt = mod2(c * (r - _1n) * D_MINUS_ONE_SQ - D);
        const s22 = s2 * s2;
        const W0 = mod2((s2 + s2) * D);
        const W1 = mod2(Nt * SQRT_AD_MINUS_ONE);
        const W2 = mod2(_1n - s22);
        const W3 = mod2(_1n + s22);
        return new ExtendedPoint(mod2(W0 * W3), mod2(W2 * W1), mod2(W1 * W3), mod2(W0 * W2));
      }
      static hashToCurve(hex) {
        hex = ensureBytes(hex, 64);
        const r1 = bytes255ToNumberLE(hex.slice(0, 32));
        const R1 = this.calcElligatorRistrettoMap(r1);
        const r2 = bytes255ToNumberLE(hex.slice(32, 64));
        const R2 = this.calcElligatorRistrettoMap(r2);
        return new _RistrettoPoint(R1.add(R2));
      }
      static fromHex(hex) {
        hex = ensureBytes(hex, 32);
        const { a, d } = CURVE;
        const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
        const s2 = bytes255ToNumberLE(hex);
        if (!equalBytes(numberTo32BytesLE(s2), hex) || edIsNegative(s2))
          throw new Error(emsg);
        const s22 = mod2(s2 * s2);
        const u1 = mod2(_1n + a * s22);
        const u2 = mod2(_1n - a * s22);
        const u1_2 = mod2(u1 * u1);
        const u2_2 = mod2(u2 * u2);
        const v = mod2(a * d * u1_2 - u2_2);
        const { isValid, value: I } = invertSqrt(mod2(v * u2_2));
        const Dx = mod2(I * u2);
        const Dy = mod2(I * Dx * v);
        let x = mod2((s2 + s2) * Dx);
        if (edIsNegative(x))
          x = mod2(-x);
        const y = mod2(u1 * Dy);
        const t = mod2(x * y);
        if (!isValid || edIsNegative(t) || y === _0n)
          throw new Error(emsg);
        return new _RistrettoPoint(new ExtendedPoint(x, y, _1n, t));
      }
      toRawBytes() {
        let { x, y, z, t } = this.ep;
        const u1 = mod2(mod2(z + y) * mod2(z - y));
        const u2 = mod2(x * y);
        const u2sq = mod2(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod2(u1 * u2sq));
        const D1 = mod2(invsqrt * u1);
        const D2 = mod2(invsqrt * u2);
        const zInv = mod2(D1 * D2 * t);
        let D;
        if (edIsNegative(t * zInv)) {
          let _x = mod2(y * SQRT_M1);
          let _y = mod2(x * SQRT_M1);
          x = _x;
          y = _y;
          D = mod2(D1 * INVSQRT_A_MINUS_D);
        } else {
          D = D2;
        }
        if (edIsNegative(x * zInv))
          y = mod2(-y);
        let s2 = mod2((z - y) * D);
        if (edIsNegative(s2))
          s2 = mod2(-s2);
        return numberTo32BytesLE(s2);
      }
      toHex() {
        return bytesToHex(this.toRawBytes());
      }
      toString() {
        return this.toHex();
      }
      equals(other) {
        assertRstPoint(other);
        const a = this.ep;
        const b = other.ep;
        const one = mod2(a.x * b.y) === mod2(a.y * b.x);
        const two = mod2(a.y * b.y) === mod2(a.x * b.x);
        return one || two;
      }
      add(other) {
        assertRstPoint(other);
        return new _RistrettoPoint(this.ep.add(other.ep));
      }
      subtract(other) {
        assertRstPoint(other);
        return new _RistrettoPoint(this.ep.subtract(other.ep));
      }
      multiply(scalar) {
        return new _RistrettoPoint(this.ep.multiply(scalar));
      }
      multiplyUnsafe(scalar) {
        return new _RistrettoPoint(this.ep.multiplyUnsafe(scalar));
      }
    };
    RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
    RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
    pointPrecomputes = /* @__PURE__ */ new WeakMap();
    Point = class _Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
      }
      static fromHex(hex, strict = true) {
        const { d, P } = CURVE;
        hex = ensureBytes(hex, 32);
        const normed = hex.slice();
        normed[31] = hex[31] & ~128;
        const y = bytesToNumberLE(normed);
        if (strict && y >= P)
          throw new Error("Expected 0 < hex < P");
        if (!strict && y >= POW_2_256)
          throw new Error("Expected 0 < hex < 2**256");
        const y2 = mod2(y * y);
        const u = mod2(y2 - _1n);
        const v = mod2(d * y2 + _1n);
        let { isValid, value: x } = uvRatio(u, v);
        if (!isValid)
          throw new Error("Point.fromHex: invalid y coordinate");
        const isXOdd = (x & _1n) === _1n;
        const isLastByteOdd = (hex[31] & 128) !== 0;
        if (isLastByteOdd !== isXOdd) {
          x = mod2(-x);
        }
        return new _Point(x, y);
      }
      static async fromPrivateKey(privateKey) {
        return (await getExtendedPublicKey(privateKey)).point;
      }
      toRawBytes() {
        const bytes22 = numberTo32BytesLE(this.y);
        bytes22[31] |= this.x & _1n ? 128 : 0;
        return bytes22;
      }
      toHex() {
        return bytesToHex(this.toRawBytes());
      }
      toX25519() {
        const { y } = this;
        const u = mod2((_1n + y) * invert(_1n - y));
        return numberTo32BytesLE(u);
      }
      isTorsionFree() {
        return ExtendedPoint.fromAffine(this).isTorsionFree();
      }
      equals(other) {
        return this.x === other.x && this.y === other.y;
      }
      negate() {
        return new _Point(mod2(-this.x), this.y);
      }
      add(other) {
        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiply(scalar) {
        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
      }
    };
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
    Point.ZERO = new Point(_0n, _1n);
    Signature2 = class _Signature {
      constructor(r, s2) {
        this.r = r;
        this.s = s2;
        this.assertValidity();
      }
      static fromHex(hex) {
        const bytes22 = ensureBytes(hex, 64);
        const r = Point.fromHex(bytes22.slice(0, 32), false);
        const s2 = bytesToNumberLE(bytes22.slice(32, 64));
        return new _Signature(r, s2);
      }
      assertValidity() {
        const { r, s: s2 } = this;
        if (!(r instanceof Point))
          throw new Error("Expected Point instance");
        normalizeScalar(s2, CURVE.l, false);
        return this;
      }
      toRawBytes() {
        const u82 = new Uint8Array(64);
        u82.set(this.r.toRawBytes());
        u82.set(numberTo32BytesLE(this.s), 32);
        return u82;
      }
      toHex() {
        return bytesToHex(this.toRawBytes());
      }
    };
    hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    Point.BASE._setWindowSize(8);
    crypto2 = {
      node: empty_exports,
      web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
    };
    utils = {
      bytesToHex,
      hexToBytes,
      concatBytes,
      getExtendedPublicKey,
      mod: mod2,
      invert,
      TORSION_SUBGROUP: [
        "0100000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
        "0000000000000000000000000000000000000000000000000000000000000080",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
        "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
        "0000000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
      ],
      hashToPrivateScalar: (hash) => {
        hash = ensureBytes(hash);
        if (hash.length < 40 || hash.length > 1024)
          throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
        return mod2(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;
      },
      randomBytes: (bytesLength = 32) => {
        if (crypto2.web) {
          return crypto2.web.getRandomValues(new Uint8Array(bytesLength));
        } else if (crypto2.node) {
          const { randomBytes } = crypto2.node;
          return new Uint8Array(randomBytes(bytesLength).buffer);
        } else {
          throw new Error("The environment doesn't have randomBytes function");
        }
      },
      randomPrivateKey: () => {
        return utils.randomBytes(32);
      },
      sha512: async (...messages) => {
        const message2 = concatBytes(...messages);
        if (crypto2.web) {
          const buffer22 = await crypto2.web.subtle.digest("SHA-512", message2.buffer);
          return new Uint8Array(buffer22);
        } else if (crypto2.node) {
          return Uint8Array.from(crypto2.node.createHash("sha512").update(message2).digest());
        } else {
          throw new Error("The environment doesn't have sha512 function");
        }
      },
      precompute(windowSize = 8, point = Point.BASE) {
        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_2n);
        return cached;
      },
      sha512Sync: void 0
    };
    Object.defineProperties(utils, {
      sha512Sync: {
        configurable: false,
        get() {
          return _sha512Sync;
        },
        set(val) {
          if (!_sha512Sync)
            _sha512Sync = val;
        }
      }
    });
    verifier_exports = {};
    __export2(verifier_exports, {
      code: () => code12,
      decode: () => decode30,
      encode: () => encode23,
      format: () => format9,
      name: () => name8,
      or: () => or7,
      parse: () => parse5,
      signatureAlgorithm: () => signatureAlgorithm,
      signatureCode: () => signatureCode
    });
    parseWith = (did2, parsers) => {
      if (did2.startsWith("did:")) {
        for (const parser of parsers) {
          try {
            return parser.parse(did2);
          } catch (_) {
          }
        }
        throw new Error(`Unsupported did ${did2}`);
      } else {
        throw new Error(`Expected did instead got ${did2}`);
      }
    };
    or6 = (left, right) => new Parser([left, right]);
    Parser = class _Parser {
      /**
       * @param {API.PrincipalParser[]} variants
       */
      constructor(variants) {
        this.variants = variants;
      }
      /**
       * @param {API.DID} did
       */
      parse(did2) {
        return parseWith(did2, this.variants);
      }
      /**
       * @param {API.PrincipalParser} parser
       */
      or(parser) {
        return new _Parser([...this.variants, parser]);
      }
    };
    withDID = (key, id) => new VerifierWithDID(id, key);
    VerifierWithDID = class {
      /**
       * @param {ID} id
       * @param {API.VerifierKey<SigAlg>} key
       */
      constructor(id, key) {
        this.id = id;
        this.key = key;
      }
      did() {
        return this.id;
      }
      toDIDKey() {
        return this.key.toDIDKey();
      }
      /**
       * @template T
       * @param {API.ByteView<T>} payload
       * @param {API.Signature<T, SigAlg>} signature
       * @returns {API.Await<boolean>}
       */
      verify(payload, signature) {
        return this.key.verify(payload, signature);
      }
      /**
       * @template {API.DID} ID
       * @param {ID} id
       */
      withDID(id) {
        return withDID(this.key, id);
      }
    };
    code12 = 237;
    name8 = "Ed25519";
    signatureCode = EdDSA;
    signatureAlgorithm = "EdDSA";
    PUBLIC_TAG_SIZE = varint_exports2.encodingLength(code12);
    SIZE = 32 + PUBLIC_TAG_SIZE;
    parse5 = (did2) => decode30(parse2(did2));
    decode30 = (bytes22) => {
      const [algorithm2] = varint_exports2.decode(bytes22);
      if (algorithm2 !== code12) {
        throw new RangeError(
          `Unsupported key algorithm with multicode 0x${code12.toString(16)}`
        );
      } else if (bytes22.byteLength !== SIZE) {
        throw new RangeError(
          `Expected Uint8Array with byteLength ${SIZE}, instead got Uint8Array with byteLength ${bytes22.byteLength}`
        );
      } else {
        return new Ed25519Verifier(bytes22.buffer, bytes22.byteOffset, bytes22.byteLength);
      }
    };
    format9 = (principal) => format3(principal);
    encode23 = (principal) => encode9(principal);
    Ed25519Verifier = class extends Uint8Array {
      /** @type {typeof code} */
      get code() {
        return code12;
      }
      /** @type {typeof signatureCode} */
      get signatureCode() {
        return signatureCode;
      }
      /** @type {typeof signatureAlgorithm} */
      get signatureAlgorithm() {
        return signatureAlgorithm;
      }
      /**
       * Raw public key without a multiformat code.
       *
       * @readonly
       */
      get publicKey() {
        const key = new Uint8Array(this.buffer, this.byteOffset + PUBLIC_TAG_SIZE);
        Object.defineProperties(this, {
          publicKey: {
            value: key
          }
        });
        return key;
      }
      /**
       * DID of the Principal in `did:key` format.
       * @returns {API.DID<"key">}
       */
      did() {
        return `did:key:${base58btc2.encode(this)}`;
      }
      /**
       * @template T
       * @param {API.ByteView<T>} payload
       * @param {API.Signature<T, Signature.EdDSA>} signature
       * @returns {API.Await<boolean>}
       */
      verify(payload, signature) {
        return signature.code === signatureCode && verify(signature.raw, payload, this.publicKey);
      }
      /**
       * @template {API.DID} ID
       * @param {ID} id
       * @returns {API.Verifier<ID, typeof signatureCode>}
       */
      withDID(id) {
        return withDID(this, id);
      }
      toDIDKey() {
        return this.did();
      }
    };
    or7 = (other) => or6({ parse: parse5 }, other);
    or8 = (left, right) => new Importer([left, right]);
    Importer = class _Importer {
      /**
       * @param {Importers} variants
       */
      constructor(variants) {
        this.variants = variants;
        this.from = create11(variants);
      }
      /**
       * @template {API.SignerImporter} Other
       * @param {Other} other
       * @returns {API.CompositeImporter<[Other, ...Importers]>}
       */
      or(other) {
        return new _Importer([other, ...this.variants]);
      }
    };
    create11 = (importers) => {
      const from19 = (archive3) => {
        if (archive3.id.startsWith("did:key:")) {
          return (
            /** @type {API.Signer<ID, Alg>} */
            importWith(archive3, importers)
          );
        } else {
          for (const [name142, key] of Object.entries(archive3.keys)) {
            const id = (
              /** @type {API.DIDKey} */
              name142
            );
            const signer = (
              /** @type {API.Signer<API.DIDKey, Alg>} */
              importWith(
                {
                  id,
                  keys: { [id]: key }
                },
                importers
              )
            );
            return signer.withDID(archive3.id);
          }
          throw new Error(`Archive ${archive3.id} contains no keys`);
        }
      };
      return (
        /** @type {API.Intersection<Importers[number]['from']>} */
        from19
      );
    };
    importWith = (archive3, importers) => {
      for (const importer of importers) {
        try {
          return importer.from(archive3);
        } catch (_) {
        }
      }
      throw new Error(`Unsupported signer`);
    };
    withDID2 = ({ signer, verifier }, id) => new SignerWithDID(signer, verifier.withDID(id));
    SignerWithDID = class {
      /**
       * @param {API.Signer<API.DID<'key'>, Code>} key
       * @param {API.Verifier<ID, Code>} verifier
       */
      constructor(key, verifier) {
        this.key = key;
        this.verifier = verifier;
      }
      /** @type {API.Signer<ID, Code>} */
      get signer() {
        return this;
      }
      get signatureAlgorithm() {
        return this.key.signatureAlgorithm;
      }
      get signatureCode() {
        return this.key.signatureCode;
      }
      /**
       * @returns {ID}
       */
      did() {
        return this.verifier.did();
      }
      toDIDKey() {
        return this.verifier.toDIDKey();
      }
      /**
       * @template {API.DID} ID
       * @param {ID} id
       */
      withDID(id) {
        return withDID2(this.key, id);
      }
      /**
       * @template T
       * @param {API.ByteView<T>} payload
       */
      sign(payload) {
        return this.key.sign(payload);
      }
      /**
       * @template T
       * @param {API.ByteView<T>} payload
       * @param {API.Signature<T, Code>} signature
       */
      verify(payload, signature) {
        return this.verifier.verify(payload, signature);
      }
      toArchive() {
        const { keys: keys2 } = this.key.toArchive();
        return {
          id: this.did(),
          keys: keys2
        };
      }
    };
    code13 = 4864;
    name9 = name8;
    signatureAlgorithm2 = signatureAlgorithm;
    signatureCode2 = signatureCode;
    PRIVATE_TAG_SIZE = varint_exports2.encodingLength(code13);
    PUBLIC_TAG_SIZE2 = varint_exports2.encodingLength(code12);
    KEY_SIZE = 32;
    SIZE2 = PRIVATE_TAG_SIZE + KEY_SIZE + PUBLIC_TAG_SIZE2 + KEY_SIZE;
    PUB_KEY_OFFSET = PRIVATE_TAG_SIZE + KEY_SIZE;
    generate = () => derive2(utils.randomPrivateKey());
    derive2 = async (secret) => {
      if (secret.byteLength !== KEY_SIZE) {
        throw new Error(
          `Expected Uint8Array with byteLength of ${KEY_SIZE} instead not ${secret.byteLength}`
        );
      }
      const publicKey = await getPublicKey(secret);
      const signer = new Ed25519Signer(SIZE2);
      varint_exports2.encodeTo(code13, signer, 0);
      signer.set(secret, PRIVATE_TAG_SIZE);
      varint_exports2.encodeTo(code12, signer, PRIVATE_TAG_SIZE + KEY_SIZE);
      signer.set(publicKey, PRIVATE_TAG_SIZE + KEY_SIZE + PUBLIC_TAG_SIZE2);
      return signer;
    };
    from13 = ({ id, keys: keys2 }) => {
      if (id.startsWith("did:key:")) {
        const key = keys2[
          /** @type {API.DIDKey} */
          id
        ];
        if (key instanceof Uint8Array) {
          return decode31(key);
        }
      }
      throw new TypeError(`Unsupported archive format`);
    };
    or9 = (other) => or8({ from: from13 }, other);
    decode31 = (bytes22) => {
      if (bytes22.byteLength !== SIZE2) {
        throw new Error(
          `Expected Uint8Array with byteLength of ${SIZE2} instead not ${bytes22.byteLength}`
        );
      }
      {
        const [keyCode] = varint_exports2.decode(bytes22);
        if (keyCode !== code13) {
          throw new Error(`Given bytes must be a multiformat with ${code13} tag`);
        }
      }
      {
        const [code192] = varint_exports2.decode(bytes22.subarray(PUB_KEY_OFFSET));
        if (code192 !== code12) {
          throw new Error(
            `Given bytes must contain public key in multiformats with ${code12} tag`
          );
        }
      }
      return new Ed25519Signer(bytes22);
    };
    encode24 = (signer) => signer.encode();
    format10 = (signer, encoder32) => (encoder32 || base64pad).encode(encode24(signer));
    parse6 = (principal, decoder32) => decode31((decoder32 || base64pad).decode(principal));
    Ed25519Signer = class extends Uint8Array {
      /** @type {typeof code} */
      get code() {
        return code13;
      }
      get signer() {
        return this;
      }
      /** @type {API.EdVerifier} */
      get verifier() {
        const bytes22 = new Uint8Array(this.buffer, PRIVATE_TAG_SIZE + KEY_SIZE);
        const verifier = decode30(bytes22);
        Object.defineProperties(this, {
          verifier: {
            value: verifier
          }
        });
        return verifier;
      }
      /**
       * Raw public key without multiformat code.
       */
      get secret() {
        const secret = new Uint8Array(this.buffer, PRIVATE_TAG_SIZE, KEY_SIZE);
        Object.defineProperties(this, {
          secret: {
            value: secret
          }
        });
        return secret;
      }
      /**
       * DID of this principal in `did:key` format.
       */
      did() {
        return this.verifier.did();
      }
      toDIDKey() {
        return this.verifier.toDIDKey();
      }
      /**
       * @template {API.DID} ID
       * @param {ID} id
       * @returns {API.Signer<ID, typeof Signature.EdDSA>}
       */
      withDID(id) {
        return withDID2(this, id);
      }
      /**
       * @template T
       * @param {API.ByteView<T>} payload
       * @returns {Promise<API.SignatureView<T, typeof Signature.EdDSA>>}
       */
      async sign(payload) {
        const raw = await sign(payload, this.secret);
        return create5(this.signatureCode, raw);
      }
      /**
       * @template T
       * @param {API.ByteView<T>} payload
       * @param {API.Signature<T, typeof this.signatureCode>} signature
       */
      verify(payload, signature) {
        return this.verifier.verify(payload, signature);
      }
      get signatureAlgorithm() {
        return signatureAlgorithm2;
      }
      get signatureCode() {
        return EdDSA;
      }
      encode() {
        return this;
      }
      toArchive() {
        const id = this.did();
        return {
          id,
          keys: { [id]: this.encode() }
        };
      }
    };
    rsa_exports = {};
    __export2(rsa_exports, {
      Verifier: () => RSAVerifier,
      code: () => code14,
      decode: () => decode36,
      from: () => from14,
      generate: () => generate2,
      name: () => name10,
      or: () => or10,
      signatureAlgorithm: () => signatureAlgorithm3,
      signatureCode: () => signatureCode3
    });
    _globalReference = globalThis || window || self;
    webcrypto = _globalReference.crypto;
    tagWith = (code192, bytes22) => {
      const offset22 = varint_exports2.encodingLength(code192);
      const multiformat = new Uint8Array(bytes22.byteLength + offset22);
      varint_exports2.encodeTo(code192, multiformat, 0);
      multiformat.set(bytes22, offset22);
      return multiformat;
    };
    untagWith = (code192, source, byteOffset = 0) => {
      const bytes22 = byteOffset !== 0 ? source.subarray(byteOffset) : source;
      const [tag2, size5] = varint_exports2.decode(bytes22);
      if (tag2 !== code192) {
        throw new Error(
          `Expected multiformat with 0x${code192.toString(
            16
          )} tag instead got 0x${tag2.toString(16)}`
        );
      } else {
        return new Uint8Array(bytes22.buffer, bytes22.byteOffset + size5);
      }
    };
    encodingLength4 = varint_exports2.encodingLength;
    encodeTo4 = varint_exports2.encodeTo;
    decode32 = varint_exports2.decode;
    TAG_SIZE2 = 1;
    INT_TAG = 2;
    BITSTRING_TAG = 3;
    OCTET_STRING_TAG = 4;
    SEQUENCE_TAG = 48;
    UNUSED_BIT_PAD = 0;
    encodeDERLength = (length42) => {
      if (length42 <= 127) {
        return new Uint8Array([length42]);
      }
      const octets = [];
      while (length42 !== 0) {
        octets.push(length42 & 255);
        length42 = length42 >>> 8;
      }
      octets.reverse();
      return new Uint8Array([128 | octets.length & 255, ...octets]);
    };
    readDERLength = (bytes22, offset22 = 0) => {
      if ((bytes22[offset22] & 128) === 0) {
        return { number: bytes22[offset22], consumed: 1 };
      }
      const numberBytes = bytes22[offset22] & 127;
      if (bytes22.length < numberBytes + 1) {
        throw new Error(
          `ASN parsing error: Too few bytes. Expected encoded length's length to be at least ${numberBytes}`
        );
      }
      let length42 = 0;
      for (let i = 0; i < numberBytes; i++) {
        length42 = length42 << 8;
        length42 = length42 | bytes22[offset22 + i + 1];
      }
      return { number: length42, consumed: numberBytes + 1 };
    };
    skip = (input10, expectedTag, position) => {
      const parsed = into(input10, expectedTag, position);
      return parsed.position + parsed.length;
    };
    into = (input10, expectedTag, offset22) => {
      const actualTag = input10[offset22];
      if (actualTag !== expectedTag) {
        throw new Error(
          `ASN parsing error: Expected tag 0x${expectedTag.toString(
            16
          )} at position ${offset22}, but got 0x${actualTag.toString(16)}.`
        );
      }
      const length42 = readDERLength(input10, offset22 + TAG_SIZE2);
      const position = offset22 + TAG_SIZE2 + length42.consumed;
      return { position, length: length42.number };
    };
    encodeBitString = (input10) => {
      const length42 = encodeDERLength(input10.byteLength + 1);
      const bytes22 = new Uint8Array(
        TAG_SIZE2 + // ASN_BITSTRING_TAG
        length42.byteLength + 1 + // amount of unused bits at the end of our bitstring
        input10.byteLength
      );
      let byteOffset = 0;
      bytes22[byteOffset] = BITSTRING_TAG;
      byteOffset += TAG_SIZE2;
      bytes22.set(length42, byteOffset);
      byteOffset += length42.byteLength;
      bytes22[byteOffset] = UNUSED_BIT_PAD;
      byteOffset += 1;
      bytes22.set(input10, byteOffset);
      return bytes22;
    };
    encodeOctetString = (input10) => {
      const length42 = encodeDERLength(input10.byteLength);
      const bytes22 = new Uint8Array(TAG_SIZE2 + length42.byteLength + input10.byteLength);
      let byteOffset = 0;
      bytes22[byteOffset] = OCTET_STRING_TAG;
      byteOffset += TAG_SIZE2;
      bytes22.set(length42, byteOffset);
      byteOffset += length42.byteLength;
      bytes22.set(input10, byteOffset);
      return bytes22;
    };
    encodeSequence = (sequence) => {
      let byteLength = 0;
      for (const item of sequence) {
        byteLength += item.byteLength;
      }
      const length42 = encodeDERLength(byteLength);
      const bytes22 = new Uint8Array(TAG_SIZE2 + length42.byteLength + byteLength);
      let byteOffset = 0;
      bytes22[byteOffset] = SEQUENCE_TAG;
      byteOffset += TAG_SIZE2;
      bytes22.set(length42, byteOffset);
      byteOffset += length42.byteLength;
      for (const item of sequence) {
        bytes22.set(item, byteOffset);
        byteOffset += item.byteLength;
      }
      return bytes22;
    };
    readSequence = (bytes22, offset22 = 0) => {
      const { position, length: length42 } = into(bytes22, SEQUENCE_TAG, offset22);
      return new Uint8Array(bytes22.buffer, bytes22.byteOffset + position, length42);
    };
    encodeInt = (input10) => {
      const extra = input10.byteLength === 0 || input10[0] & 128 ? 1 : 0;
      const length42 = encodeDERLength(input10.byteLength + extra);
      const bytes22 = new Uint8Array(
        TAG_SIZE2 + // INT_TAG
        length42.byteLength + input10.byteLength + extra
      );
      let byteOffset = 0;
      bytes22[byteOffset] = INT_TAG;
      byteOffset += TAG_SIZE2;
      bytes22.set(length42, byteOffset);
      byteOffset += length42.byteLength;
      if (extra > 0) {
        bytes22[byteOffset] = UNUSED_BIT_PAD;
        byteOffset += extra;
      }
      bytes22.set(input10, byteOffset);
      return bytes22;
    };
    enterSequence = (bytes22, offset22 = 0) => into(bytes22, SEQUENCE_TAG, offset22).position;
    skipSequence = (bytes22, offset22 = 0) => skip(bytes22, SEQUENCE_TAG, offset22);
    skipInt = (bytes22, offset22 = 0) => skip(bytes22, INT_TAG, offset22);
    readBitString = (bytes22, offset22 = 0) => {
      const { position, length: length42 } = into(bytes22, BITSTRING_TAG, offset22);
      const tag2 = bytes22[position];
      if (tag2 !== UNUSED_BIT_PAD) {
        throw new Error(
          `Can not read bitstring, expected length to be multiple of 8, but got ${tag2} unused bits in last byte.`
        );
      }
      return new Uint8Array(
        bytes22.buffer,
        bytes22.byteOffset + position + 1,
        length42 - 1
      );
    };
    readInt2 = (bytes22, byteOffset = 0) => {
      const { position, length: length42 } = into(bytes22, INT_TAG, byteOffset);
      let delta = 0;
      while (bytes22[position + delta] === 0) {
        delta++;
      }
      return new Uint8Array(
        bytes22.buffer,
        bytes22.byteOffset + position + delta,
        length42 - delta
      );
    };
    readOctetString = (bytes22, offset22 = 0) => {
      const { position, length: length42 } = into(bytes22, OCTET_STRING_TAG, offset22);
      return new Uint8Array(bytes22.buffer, bytes22.byteOffset + position, length42);
    };
    readSequenceWith = (readers, source, byteOffset = 0) => {
      const results = [];
      const sequence = readSequence(source, byteOffset);
      let offset22 = 0;
      for (const read92 of readers) {
        const chunk = read92(sequence, offset22);
        results.push(chunk);
        offset22 = chunk.byteOffset + chunk.byteLength - sequence.byteOffset;
      }
      return results;
    };
    SPKI_PARAMS_ENCODED = new Uint8Array([
      48,
      13,
      6,
      9,
      42,
      134,
      72,
      134,
      247,
      13,
      1,
      1,
      1,
      5,
      0
    ]);
    encode25 = (key) => encodeSequence([SPKI_PARAMS_ENCODED, encodeBitString(key)]);
    decode33 = (info) => {
      const offset22 = enterSequence(info, 0);
      const keyOffset = skipSequence(info, offset22);
      return readBitString(info, keyOffset);
    };
    PKSC8_HEADER = new Uint8Array([
      // version
      2,
      1,
      0,
      // privateKeyAlgorithm
      48,
      13,
      6,
      9,
      42,
      134,
      72,
      134,
      247,
      13,
      1,
      1,
      1,
      5,
      0
    ]);
    decode34 = (info) => {
      let offset22 = 0;
      offset22 = enterSequence(info, offset22);
      offset22 = skipInt(info, offset22);
      offset22 = skipSequence(info, offset22);
      return readOctetString(info, offset22);
    };
    encode26 = (key) => encodeSequence([PKSC8_HEADER, encodeOctetString(key)]);
    encode27 = ({ n: n2, e }) => encodeSequence([encodeInt(n2), encodeInt(e)]);
    VERSION2 = new Uint8Array();
    decode35 = (source, byteOffset = 0) => {
      const [v, n2, e, d, p, q, dp, dq, qi] = readSequenceWith(
        [
          readInt2,
          readInt2,
          readInt2,
          readInt2,
          readInt2,
          readInt2,
          readInt2,
          readInt2,
          readInt2
        ],
        source,
        byteOffset
      );
      return { v, n: n2, e, d, p, q, dp, dq, qi };
    };
    name10 = "RSA";
    code14 = 4869;
    verifierCode = 4613;
    signatureCode3 = RS256;
    signatureAlgorithm3 = "RS256";
    ALG = "RSASSA-PKCS1-v1_5";
    HASH_ALG = "SHA-256";
    KEY_SIZE2 = 2048;
    SALT_LENGTH = 128;
    IMPORT_PARAMS = {
      name: ALG,
      hash: { name: HASH_ALG }
    };
    generate2 = async ({
      size: size5 = KEY_SIZE2,
      extractable = false
    } = {}) => {
      const { publicKey, privateKey } = await webcrypto.subtle.generateKey(
        {
          name: ALG,
          modulusLength: size5,
          publicExponent: new Uint8Array([1, 0, 1]),
          hash: { name: HASH_ALG }
        },
        extractable,
        ["sign", "verify"]
      );
      const spki = await webcrypto.subtle.exportKey("spki", publicKey);
      const publicBytes = tagWith(verifierCode, decode33(new Uint8Array(spki)));
      const verifier = new RSAVerifier({ bytes: publicBytes, publicKey });
      if (!extractable) {
        return new UnextractableRSASigner({
          privateKey,
          verifier
        });
      } else {
        const pkcs8 = await webcrypto.subtle.exportKey("pkcs8", privateKey);
        const bytes22 = tagWith(code14, decode34(new Uint8Array(pkcs8)));
        return new ExtractableRSASigner({
          privateKey,
          bytes: bytes22,
          verifier
        });
      }
    };
    from14 = ({ id, keys: keys2 }) => {
      if (id.startsWith("did:key:")) {
        const did2 = (
          /** @type {API.DIDKey} */
          id
        );
        const key = keys2[did2];
        if (key instanceof Uint8Array) {
          return decode36(key);
        } else {
          return new UnextractableRSASigner({
            privateKey: key,
            verifier: RSAVerifier.parse(did2)
          });
        }
      } else {
        throw new TypeError(
          `RSA can not import from ${id} archive, try generic Signer instead`
        );
      }
    };
    or10 = (other) => or8({ from: from14 }, other);
    decode36 = (bytes22) => {
      const rsa = decode35(untagWith(code14, bytes22));
      const publicBytes = tagWith(verifierCode, encode27(rsa));
      return new ExtractableRSASigner({
        bytes: bytes22,
        privateKey: webcrypto.subtle.importKey(
          "pkcs8",
          encode26(untagWith(code14, bytes22)),
          IMPORT_PARAMS,
          true,
          ["sign"]
        ),
        verifier: RSAVerifier.decode(publicBytes)
      });
    };
    RSAVerifier = class _RSAVerifier {
      /**
       * @param {object} options
       * @param {API.Await<CryptoKey>} options.publicKey
       * @param {API.ByteView<API.RSAVerifier>} options.bytes
       */
      constructor({ publicKey, bytes: bytes22 }) {
        this.publicKey = publicKey;
        this.bytes = bytes22;
      }
      /**
       * @template {API.DID} ID
       * @param {ID} id
       * @returns {API.Verifier<ID, typeof signatureCode>}
       */
      withDID(id) {
        return withDID(this, id);
      }
      toDIDKey() {
        return this.did();
      }
      /**
       * @param {API.ByteView<API.RSAVerifier>} bytes
       * @returns {API.RSAVerifier}
       */
      static decode(bytes22) {
        return new this({
          bytes: bytes22,
          publicKey: webcrypto.subtle.importKey(
            "spki",
            encode25(untagWith(verifierCode, bytes22)),
            IMPORT_PARAMS,
            true,
            ["verify"]
          )
        });
      }
      /**
       * @param {API.DIDKey} did
       * @returns {API.RSAVerifier}
       */
      static parse(did2) {
        return _RSAVerifier.decode(
          /** @type {Uint8Array} */
          parse2(did2)
        );
      }
      /**
       * @param {API.PrincipalParser} other
       */
      static or(other) {
        return or6(this, other);
      }
      /** @type {typeof verifierCode} */
      get code() {
        return verifierCode;
      }
      /**
       * @type {typeof signatureCode}
       */
      get signatureCode() {
        return signatureCode3;
      }
      /**
       * @type {typeof signatureAlgorithm}
       */
      get signatureAlgorithm() {
        return signatureAlgorithm3;
      }
      /**
       * DID of the Principal in `did:key` format.
       * @returns {API.DID<"key">}
       */
      did() {
        return `did:key:${base58btc2.encode(this.bytes)}`;
      }
      /**
       * @template T
       * @param {API.ByteView<T>} payload
       * @param {API.Signature<T, typeof this.signatureCode>} signature
       * @returns {Promise<boolean>}
       */
      async verify(payload, signature) {
        if (signature.code !== signatureCode3) {
          return false;
        }
        return webcrypto.subtle.verify(
          { name: ALG, hash: { name: HASH_ALG } },
          await this.publicKey,
          signature.raw,
          payload
        );
      }
    };
    RSASigner = class {
      /**
       * @param {object} options
       * @param {API.Await<CryptoKey>} options.privateKey
       * @param {API.RSAVerifier} options.verifier
       */
      constructor({ privateKey, verifier }) {
        this.verifier = verifier;
        this.privateKey = privateKey;
      }
      get signer() {
        return this;
      }
      /**
       * @type {typeof code}
       */
      get code() {
        return code14;
      }
      /**
       * @type {typeof signatureCode}
       */
      get signatureCode() {
        return signatureCode3;
      }
      /**
       * @type {typeof signatureAlgorithm}
       */
      get signatureAlgorithm() {
        return signatureAlgorithm3;
      }
      did() {
        return this.verifier.did();
      }
      toDIDKey() {
        return this.verifier.toDIDKey();
      }
      /**
       * @template T
       * @param {API.ByteView<T>} payload
       * @param {API.Signature<T, typeof this.signatureCode>} signature
       */
      verify(payload, signature) {
        return this.verifier.verify(payload, signature);
      }
      /**
       * @template T
       * @param {API.ByteView<T>} payload
       * @returns {Promise<API.SignatureView<T, typeof signatureCode>>}
       */
      async sign(payload) {
        const buffer22 = await webcrypto.subtle.sign(
          { name: ALG, saltLength: SALT_LENGTH },
          await this.privateKey,
          payload
        );
        return create5(signatureCode3, new Uint8Array(buffer22));
      }
    };
    ExtractableRSASigner = class extends RSASigner {
      /**
       * @param {object} options
       * @param {API.Await<CryptoKey>} options.privateKey
       * @param {EncodedSigner} options.bytes
       * @param {API.RSAVerifier} options.verifier
       */
      constructor(options) {
        super(options);
        this.bytes = options.bytes;
      }
      /**
       * @template {API.DID} ID
       * @param {ID} id
       * @returns {API.Signer<ID, typeof signatureCode>}
       */
      withDID(id) {
        return withDID2(this, id);
      }
      toArchive() {
        const id = this.did();
        return {
          id,
          keys: { [id]: this.bytes }
        };
      }
    };
    UnextractableRSASigner = class extends RSASigner {
      /**
       * @param {object} options
       * @param {CryptoKey} options.privateKey
       * @param {API.RSAVerifier} options.verifier
       */
      constructor(options) {
        super(options);
        this.privateKey = options.privateKey;
      }
      /**
       * @template {API.DID} ID
       * @param {ID} id
       * @returns {API.Signer<ID, typeof signatureCode>}
       */
      withDID(id) {
        return withDID2(this, id);
      }
      toArchive() {
        const id = this.did();
        return {
          id,
          keys: { [id]: this.privateKey }
        };
      }
    };
    Verifier = verifier_exports.or(RSAVerifier);
    Signer = or9(rsa_exports);
    UCANLink = /** @type {Schema.Schema<API.UCANLink, unknown>} */
    schema_exports3.link({ version: 1 });
    ucan = capability({
      can: "ucan/*",
      with: schema_exports3.did(),
      derives: equalWith2
    });
    revoke = capability({
      can: "ucan/revoke",
      /**
       * DID of the principal authorizing revocation.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * UCAN being revoked from all proof chains that lead to the UCAN that is
         * either issued (iss) by or delegated to (aud) the principal identified
         * by the `with` field.
         */
        ucan: UCANLink,
        /**
         * Proof chain illustrating the path from revoked UCAN to the one that is
         * either issued (iss) by or delegated to (aud) the principal identified
         * by the `with` field.
         *
         * If the UCAN being revoked is either issued (iss) by or delegated to (aud)
         * the principal identified by the `with` field no `proof` is required and
         * it can be omitted or set to an empty array.
         *
         * It is RECOMMENDED that `proof` is provided in all other cases otherwise
         * it MAY not be possible to verify that revoking principal is a participant
         * in the proof chain.
         */
        proof: UCANLink.array().optional()
      }),
      derives: (claim, from19) => (
        // With field MUST be the same
        and4(equalWith2(claim, from19)) ?? // UCAN being revoked MUST be the same
        and4(checkLink2(claim.nb.ucan, from19.nb.ucan, "nb.ucan")) ?? // And proof chain MUST be the same
        equal2(
          (claim.nb.proof ?? []).join("/"),
          (from19.nb.proof ?? []).join("/"),
          "nb.proof"
        )
      )
    });
    conclude = capability({
      can: "ucan/conclude",
      /**
       * DID of the principal representing the Conclusion Authority.
       * MUST be the DID of the audience of the ran invocation.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * CID of the content with the Receipt.
         */
        receipt: schema_exports3.link()
      }),
      derives: (claim, from19) => (
        // With field MUST be the same
        and4(equalWith2(claim, from19)) || and4(checkLink2(claim.nb.receipt, from19.nb.receipt, "nb.receipt")) || ok({})
      )
    });
    attest = capability({
      can: "ucan/attest",
      // Should be web3.storage DID
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        // UCAN delegation that is being attested.
        proof: schema_exports3.link({ version: 1 })
      }),
      derives: (claim, from19) => (
        // With field MUST be the same
        and4(equalWith2(claim, from19)) ?? // UCAN link MUST be the same
        checkLink2(claim.nb.proof, from19.nb.proof, "nb.proof")
      )
    });
    blob = capability({
      can: "space/blob/*",
      /**
       * DID of the (memory) space where Blob is intended to
       * be stored.
       */
      with: SpaceDID2,
      derives: equalWith2
    });
    content = schema_exports3.struct({
      /**
       * A multihash digest of the blob payload bytes, uniquely identifying blob.
       */
      digest: schema_exports3.bytes(),
      /**
       * Number of bytes contained by this blob. Service will provision write target
       * for this exact size. Attempt to write a larger Blob file will fail.
       */
      size: schema_exports3.integer()
    });
    add3 = capability({
      can: "space/blob/add",
      /**
       * DID of the (memory) space where Blob is intended to
       * be stored.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * Blob to be added on the space.
         */
        blob: content
      }),
      derives: equalBlob
    });
    remove3 = capability({
      can: "space/blob/remove",
      /**
       * DID of the (memory) space where Blob is stored.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * A multihash digest of the blob payload bytes, uniquely identifying blob.
         */
        digest: schema_exports3.bytes()
      }),
      derives: (claimed, delegated) => {
        if (claimed.with !== delegated.with) {
          return fail2(
            `Expected 'with: "${delegated.with}"' instead got '${claimed.with}'`
          );
        } else if (delegated.nb.digest && !equals5(delegated.nb.digest, claimed.nb.digest)) {
          return fail2(
            `Link ${claimed.nb.digest ? `${claimed.nb.digest}` : ""} violates imposed ${delegated.nb.digest} constraint.`
          );
        }
        return ok({});
      }
    });
    list3 = capability({
      can: "space/blob/list",
      /**
       * DID of the (memory) space where Blobs to be listed are stored.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * A pointer that can be moved back and forth on the list.
         * It can be used to paginate a list for instance.
         */
        cursor: schema_exports3.string().optional(),
        /**
         * Maximum number of items per page.
         */
        size: schema_exports3.integer().optional()
      }),
      derives: (claimed, delegated) => {
        if (claimed.with !== delegated.with) {
          return fail2(
            `Expected 'with: "${delegated.with}"' instead got '${claimed.with}'`
          );
        }
        return ok({});
      }
    });
    get4 = capability({
      can: "space/blob/get/0/1",
      /**
       * DID of the (memory) space where Blob is stored.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * A multihash digest of the blob payload bytes, uniquely identifying blob.
         */
        digest: schema_exports3.bytes()
      }),
      derives: (claimed, delegated) => {
        if (claimed.with !== delegated.with) {
          return fail2(
            `Expected 'with: "${delegated.with}"' instead got '${claimed.with}'`
          );
        } else if (delegated.nb.digest && !equals5(delegated.nb.digest, claimed.nb.digest)) {
          return fail2(
            `Link ${claimed.nb.digest ? `${claimed.nb.digest}` : ""} violates imposed ${delegated.nb.digest} constraint.`
          );
        }
        return ok({});
      }
    });
    blob2 = capability({
      can: "web3.storage/blob/*",
      /**
       * DID of the (memory) space where Blob is intended to
       * be stored.
       */
      with: SpaceDID2,
      derives: equalWith2
    });
    allocate = capability({
      can: "web3.storage/blob/allocate",
      /**
       * Provider DID.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * Blob to allocate on the space.
         */
        blob: content,
        /**
         * The Link for an Add Blob task, that caused an allocation
         */
        cause: link_exports2,
        /**
         * DID of the user space where allocation takes place
         */
        space: SpaceDID2
      }),
      derives: (claim, from19) => {
        return and4(equalWith2(claim, from19)) || and4(equalBlob(claim, from19)) || and4(checkLink2(claim.nb.cause, from19.nb.cause, "cause")) || and4(equal2(claim.nb.space, from19.nb.space, "space")) || ok({});
      }
    });
    accept = capability({
      can: "web3.storage/blob/accept",
      /**
       * Provider DID.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * Blob to accept.
         */
        blob: content,
        /**
         * Content location commitment time to live, which will be encoded as expiry of the issued location claim.
         */
        ttl: schema_exports3.integer().optional(),
        /**
         * DID of the user space where allocation took place
         */
        space: SpaceDID2,
        /**
         * This task is blocked on `http/put` receipt available
         */
        _put: Await2
      }),
      derives: (claim, from19) => {
        return and4(equalWith2(claim, from19)) || and4(equalBlob(claim, from19)) || and4(equal2(claim.nb.ttl, from19.nb.ttl, "ttl")) || and4(equal2(claim.nb.space, from19.nb.space, "space")) || ok({});
      }
    });
    put = capability({
      can: "http/put",
      /**
       * DID of the (memory) space where Blob is intended to
       * be stored.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * Description of body to send (digest/size).
         */
        body: content,
        /**
         * HTTP(S) location that can receive blob content via HTTP PUT request.
         */
        url: schema_exports3.string().or(Await2),
        /**
         * HTTP headers.
         */
        headers: schema_exports3.dictionary({ value: schema_exports3.string() }).or(Await2)
      }),
      derives: (claim, from19) => {
        return and4(equalWith2(claim, from19)) || and4(equalBody(claim, from19)) || and4(equal2(claim.nb.url, from19.nb, "url")) || and4(equal2(claim.nb.headers, from19.nb, "headers")) || ok({});
      }
    });
    receipts_exports = {};
    __export2(receipts_exports, {
      ReceiptMissing: () => ReceiptMissing,
      ReceiptNotFound: () => ReceiptNotFound,
      poll: () => poll
    });
    ReceiptNotFound = class extends Error {
      /**
       * @param {import('multiformats').UnknownLink} taskCid
       */
      constructor(taskCid) {
        super();
        this.taskCid = taskCid;
      }
      /* c8 ignore start */
      get reason() {
        return `receipt not found for task ${this.taskCid} in the indexed workflow`;
      }
      /* c8 ignore end */
      get name() {
        return "ReceiptNotFound";
      }
    };
    ReceiptMissing = class extends Error {
      /**
       * @param {import('multiformats').UnknownLink} taskCid
       */
      constructor(taskCid) {
        super();
        this.taskCid = taskCid;
      }
      /* c8 ignore start */
      get reason() {
        return `receipt missing for task ${this.taskCid}`;
      }
      /* c8 ignore end */
      get name() {
        return "ReceiptMissing";
      }
    };
    ability = add3.can;
    input = (digest52, size5) => ({
      blob: {
        digest: digest52.bytes,
        size: size5
      }
    });
    ability2 = get4.can;
    input2 = (digest52) => ({ digest: digest52.bytes });
    ability3 = list3.can;
    input3 = (cursor, size5) => ({ cursor, size: size5 });
    ability4 = remove3.can;
    input4 = (digest52) => ({ digest: digest52.bytes });
    index_exports2 = {};
    __export2(index_exports2, {
      add: () => add6
    });
    index = capability({
      can: "space/index/*",
      /** DID of the space where indexed data is stored. */
      with: SpaceDID2,
      derives: equalWith2
    });
    add5 = capability({
      can: "space/index/add",
      /** DID of the space where indexed data is stored. */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /** Content Archive (CAR) containing the `Index`. */
        index: schema_exports3.link({ code: car_exports.code })
      }),
      derives: (claimed, delegated) => and4(equalWith2(claimed, delegated)) || and4(equal2(claimed.nb.index, delegated.nb.index, "index")) || ok({})
    });
    ability5 = add5.can;
    input5 = (index2) => ({ index: index2 });
    upload_exports2 = {};
    __export2(upload_exports2, {
      add: () => add8,
      get: () => get8,
      list: () => list6,
      remove: () => remove6
    });
    upload = capability({
      can: "upload/*",
      /**
       * DID of the (memory) space where upload is add to the
       * upload list.
       */
      with: SpaceDID2,
      derives: equalWith2
    });
    CARLink2 = link_exports2.match({ code: car_exports.code, version: 1 });
    add7 = capability({
      can: "upload/add",
      /**
       * DID of the (memory) space where uploaded is added.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * Root CID of the DAG to be added to the upload list.
         */
        root: link_exports2,
        /**
         * CIDs to the CAR files that contain blocks of the DAG.
         */
        shards: CARLink2.array().optional()
      }),
      derives: (self2, from19) => {
        return and4(equalWith2(self2, from19)) || and4(equal2(self2.nb.root, from19.nb.root, "root")) || and4(equal2(self2.nb.shards, from19.nb.shards, "shards")) || ok({});
      }
    });
    get7 = capability({
      can: "upload/get",
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * Root CID of the DAG to fetch upload info about.
         */
        root: link_exports2.optional()
      }),
      derives: (self2, from19) => {
        const res = equalWith2(self2, from19);
        if (res.error) {
          return res;
        }
        if (!from19.nb.root) {
          return res;
        }
        return equal2(self2.nb.root, from19.nb.root, "root");
      }
    });
    remove5 = capability({
      can: "upload/remove",
      /**
       * DID of the (memory) space where uploaded is removed from.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * Root CID of the DAG to be removed from the upload list.
         */
        root: link_exports2
      }),
      derives: (self2, from19) => {
        return and4(equalWith2(self2, from19)) || and4(equal2(self2.nb.root, from19.nb.root, "root")) || ok({});
      }
    });
    list5 = capability({
      can: "upload/list",
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * A pointer that can be moved back and forth on the list.
         * It can be used to paginate a list for instance.
         */
        cursor: schema_exports3.string().optional(),
        /**
         * Maximum number of items per page.
         */
        size: schema_exports3.integer().optional(),
        /**
         * If true, return page of results preceding cursor. Defaults to false.
         */
        pre: schema_exports3.boolean().optional()
      })
    });
    all2 = add7.or(remove5).or(list5);
    ability6 = add7.can;
    input6 = (root2, shards) => ({ root: root2, shards });
    ability7 = get7.can;
    input7 = (root2) => ({ root: root2 });
    ability8 = list5.can;
    input8 = (cursor, size5, pre) => ({ cursor, size: size5, pre });
    ability9 = remove5.can;
    input9 = (root2) => ({ root: root2 });
    unixfs_exports3 = {};
    __export2(unixfs_exports3, {
      createDirectoryEncoderStream: () => createDirectoryEncoderStream,
      createFileEncoderStream: () => createFileEncoderStream,
      encodeDirectory: () => encodeDirectory2,
      encodeFile: () => encodeFile2
    });
    codec_exports2 = {};
    __export2(codec_exports2, {
      DEFAULT_DIRECTORY_MODE: () => DEFAULT_DIRECTORY_MODE,
      DEFAULT_FILE_MODE: () => DEFAULT_FILE_MODE,
      NodeType: () => NodeType,
      code: () => code16,
      createAdvancedFile: () => createAdvancedFile,
      createComplexFile: () => createComplexFile,
      createDirectoryShard: () => createDirectoryShard,
      createEmptyFile: () => createEmptyFile,
      createFileChunk: () => createFileChunk,
      createFileShard: () => createFileShard,
      createFlatDirectory: () => createFlatDirectory,
      createRaw: () => createRaw,
      createShardedDirectory: () => createShardedDirectory,
      createSimpleFile: () => createSimpleFile,
      createSymlink: () => createSymlink,
      cumulativeContentByteLength: () => cumulativeContentByteLength,
      cumulativeDagByteLength: () => cumulativeDagByteLength,
      decode: () => decode38,
      decodeMetadata: () => decodeMetadata,
      encode: () => encode29,
      encodeAdvancedFile: () => encodeAdvancedFile,
      encodeComplexFile: () => encodeComplexFile,
      encodeDirectory: () => encodeDirectory,
      encodeDirectoryMetadata: () => encodeDirectoryMetadata,
      encodeFile: () => encodeFile,
      encodeFileChunk: () => encodeFileChunk,
      encodeFileShard: () => encodeFileShard,
      encodeHAMTShard: () => encodeHAMTShard,
      encodeLink: () => encodeLink2,
      encodeMetadata: () => encodeMetadata,
      encodeMode: () => encodeMode,
      encodeRaw: () => encodeRaw,
      encodeSimpleFile: () => encodeSimpleFile,
      encodeSymlink: () => encodeSymlink,
      filesize: () => filesize,
      matchFile: () => matchFile,
      name: () => name11
    });
    textDecoder2 = new TextDecoder();
    textEncoder2 = new TextEncoder();
    maxInt32 = 2 ** 32;
    maxUInt32 = 2 ** 31;
    len8tab = [
      0,
      1,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ];
    pbNodeProperties = ["Data", "Links"];
    pbLinkProperties = ["Hash", "Name", "Tsize"];
    textEncoder3 = new TextEncoder();
    code15 = 112;
    import_minimal = __toESM2(require_minimal2(), 1);
    $Reader = import_minimal.default.Reader;
    $Writer = import_minimal.default.Writer;
    $util = import_minimal.default.util;
    $root = import_minimal.default.roots.unixfs || (import_minimal.default.roots.unixfs = {});
    Data = $root.Data = (() => {
      function Data22(p) {
        this.blocksizes = [];
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Data22.prototype.Type = 0;
      Data22.prototype.Data = $util.newBuffer([]);
      Data22.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
      Data22.prototype.blocksizes = $util.emptyArray;
      Data22.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
      Data22.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
      Data22.prototype.mode = 0;
      Data22.prototype.mtime = null;
      Data22.encode = function encode342(m, w) {
        if (!w)
          w = $Writer.create();
        w.uint32(8).int32(m.Type);
        if (m.Data != null && Object.hasOwnProperty.call(m, "Data"))
          w.uint32(18).bytes(m.Data);
        if (m.filesize != null && Object.hasOwnProperty.call(m, "filesize"))
          w.uint32(24).uint64(m.filesize);
        if (m.blocksizes != null && m.blocksizes.length) {
          for (var i = 0; i < m.blocksizes.length; ++i)
            w.uint32(32).uint64(m.blocksizes[i]);
        }
        if (m.hashType != null && Object.hasOwnProperty.call(m, "hashType"))
          w.uint32(40).uint64(m.hashType);
        if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
          w.uint32(48).uint64(m.fanout);
        if (m.mode != null && Object.hasOwnProperty.call(m, "mode"))
          w.uint32(56).uint32(m.mode);
        if (m.mtime != null && Object.hasOwnProperty.call(m, "mtime"))
          $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
        return w;
      };
      Data22.decode = function decode412(r, l2) {
        if (!(r instanceof $Reader))
          r = $Reader.create(r);
        var c = l2 === void 0 ? r.len : r.pos + l2, m = new $root.Data();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.Type = r.int32();
              break;
            case 2:
              m.Data = r.bytes();
              break;
            case 3:
              m.filesize = r.uint64();
              break;
            case 4:
              if (!(m.blocksizes && m.blocksizes.length))
                m.blocksizes = [];
              if ((t & 7) === 2) {
                var c2 = r.uint32() + r.pos;
                while (r.pos < c2)
                  m.blocksizes.push(r.uint64());
              } else
                m.blocksizes.push(r.uint64());
              break;
            case 5:
              m.hashType = r.uint64();
              break;
            case 6:
              m.fanout = r.uint64();
              break;
            case 7:
              m.mode = r.uint32();
              break;
            case 8:
              m.mtime = $root.UnixTime.decode(r, r.uint32());
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        if (!m.hasOwnProperty("Type"))
          throw $util.ProtocolError("missing required 'Type'", { instance: m });
        return m;
      };
      Data22.fromObject = function fromObject(d) {
        if (d instanceof $root.Data)
          return d;
        var m = new $root.Data();
        switch (d.Type) {
          case "Raw":
          case 0:
            m.Type = 0;
            break;
          case "Directory":
          case 1:
            m.Type = 1;
            break;
          case "File":
          case 2:
            m.Type = 2;
            break;
          case "Metadata":
          case 3:
            m.Type = 3;
            break;
          case "Symlink":
          case 4:
            m.Type = 4;
            break;
          case "HAMTShard":
          case 5:
            m.Type = 5;
            break;
        }
        if (d.Data != null) {
          if (typeof d.Data === "string")
            $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
          else if (d.Data.length)
            m.Data = d.Data;
        }
        if (d.filesize != null) {
          if ($util.Long)
            (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;
          else if (typeof d.filesize === "string")
            m.filesize = parseInt(d.filesize, 10);
          else if (typeof d.filesize === "number")
            m.filesize = d.filesize;
          else if (typeof d.filesize === "object")
            m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
        }
        if (d.blocksizes) {
          if (!Array.isArray(d.blocksizes))
            throw TypeError(".Data.blocksizes: array expected");
          m.blocksizes = [];
          for (var i = 0; i < d.blocksizes.length; ++i) {
            if ($util.Long)
              (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;
            else if (typeof d.blocksizes[i] === "string")
              m.blocksizes[i] = parseInt(d.blocksizes[i], 10);
            else if (typeof d.blocksizes[i] === "number")
              m.blocksizes[i] = d.blocksizes[i];
            else if (typeof d.blocksizes[i] === "object")
              m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);
          }
        }
        if (d.hashType != null) {
          if ($util.Long)
            (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;
          else if (typeof d.hashType === "string")
            m.hashType = parseInt(d.hashType, 10);
          else if (typeof d.hashType === "number")
            m.hashType = d.hashType;
          else if (typeof d.hashType === "object")
            m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
        }
        if (d.fanout != null) {
          if ($util.Long)
            (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;
          else if (typeof d.fanout === "string")
            m.fanout = parseInt(d.fanout, 10);
          else if (typeof d.fanout === "number")
            m.fanout = d.fanout;
          else if (typeof d.fanout === "object")
            m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
        }
        if (d.mode != null) {
          m.mode = d.mode >>> 0;
        }
        if (d.mtime != null) {
          if (typeof d.mtime !== "object")
            throw TypeError(".Data.mtime: object expected");
          m.mtime = $root.UnixTime.fromObject(d.mtime);
        }
        return m;
      };
      Data22.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.arrays || o.defaults) {
          d.blocksizes = [];
        }
        if (o.defaults) {
          d.Type = o.enums === String ? "Raw" : 0;
          if (o.bytes === String)
            d.Data = "";
          else {
            d.Data = [];
            if (o.bytes !== Array)
              d.Data = $util.newBuffer(d.Data);
          }
          if ($util.Long) {
            var n2 = new $util.Long(0, 0, true);
            d.filesize = o.longs === String ? n2.toString() : o.longs === Number ? n2.toNumber() : n2;
          } else
            d.filesize = o.longs === String ? "0" : 0;
          if ($util.Long) {
            var n2 = new $util.Long(0, 0, true);
            d.hashType = o.longs === String ? n2.toString() : o.longs === Number ? n2.toNumber() : n2;
          } else
            d.hashType = o.longs === String ? "0" : 0;
          if ($util.Long) {
            var n2 = new $util.Long(0, 0, true);
            d.fanout = o.longs === String ? n2.toString() : o.longs === Number ? n2.toNumber() : n2;
          } else
            d.fanout = o.longs === String ? "0" : 0;
          d.mode = 0;
          d.mtime = null;
        }
        if (m.Type != null && m.hasOwnProperty("Type")) {
          d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;
        }
        if (m.Data != null && m.hasOwnProperty("Data")) {
          d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
        }
        if (m.filesize != null && m.hasOwnProperty("filesize")) {
          if (typeof m.filesize === "number")
            d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
          else
            d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
        }
        if (m.blocksizes && m.blocksizes.length) {
          d.blocksizes = [];
          for (var j = 0; j < m.blocksizes.length; ++j) {
            if (typeof m.blocksizes[j] === "number")
              d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
            else
              d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
          }
        }
        if (m.hashType != null && m.hasOwnProperty("hashType")) {
          if (typeof m.hashType === "number")
            d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
          else
            d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
        }
        if (m.fanout != null && m.hasOwnProperty("fanout")) {
          if (typeof m.fanout === "number")
            d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
          else
            d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
        }
        if (m.mode != null && m.hasOwnProperty("mode")) {
          d.mode = m.mode;
        }
        if (m.mtime != null && m.hasOwnProperty("mtime")) {
          d.mtime = $root.UnixTime.toObject(m.mtime, o);
        }
        return d;
      };
      Data22.prototype.toJSON = function toJSON6() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      };
      Data22.DataType = function() {
        const valuesById = {}, values2 = Object.create(valuesById);
        values2[valuesById[0] = "Raw"] = 0;
        values2[valuesById[1] = "Directory"] = 1;
        values2[valuesById[2] = "File"] = 2;
        values2[valuesById[3] = "Metadata"] = 3;
        values2[valuesById[4] = "Symlink"] = 4;
        values2[valuesById[5] = "HAMTShard"] = 5;
        return values2;
      }();
      return Data22;
    })();
    UnixTime = $root.UnixTime = (() => {
      function UnixTime22(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      UnixTime22.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
      UnixTime22.prototype.FractionalNanoseconds = 0;
      UnixTime22.encode = function encode342(m, w) {
        if (!w)
          w = $Writer.create();
        w.uint32(8).int64(m.Seconds);
        if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, "FractionalNanoseconds"))
          w.uint32(21).fixed32(m.FractionalNanoseconds);
        return w;
      };
      UnixTime22.decode = function decode412(r, l2) {
        if (!(r instanceof $Reader))
          r = $Reader.create(r);
        var c = l2 === void 0 ? r.len : r.pos + l2, m = new $root.UnixTime();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.Seconds = r.int64();
              break;
            case 2:
              m.FractionalNanoseconds = r.fixed32();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        if (!m.hasOwnProperty("Seconds"))
          throw $util.ProtocolError("missing required 'Seconds'", { instance: m });
        return m;
      };
      UnixTime22.fromObject = function fromObject(d) {
        if (d instanceof $root.UnixTime)
          return d;
        var m = new $root.UnixTime();
        if (d.Seconds != null) {
          if ($util.Long)
            (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;
          else if (typeof d.Seconds === "string")
            m.Seconds = parseInt(d.Seconds, 10);
          else if (typeof d.Seconds === "number")
            m.Seconds = d.Seconds;
          else if (typeof d.Seconds === "object")
            m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
        }
        if (d.FractionalNanoseconds != null) {
          m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
        }
        return m;
      };
      UnixTime22.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if ($util.Long) {
            var n2 = new $util.Long(0, 0, false);
            d.Seconds = o.longs === String ? n2.toString() : o.longs === Number ? n2.toNumber() : n2;
          } else
            d.Seconds = o.longs === String ? "0" : 0;
          d.FractionalNanoseconds = 0;
        }
        if (m.Seconds != null && m.hasOwnProperty("Seconds")) {
          if (typeof m.Seconds === "number")
            d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
          else
            d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
        }
        if (m.FractionalNanoseconds != null && m.hasOwnProperty("FractionalNanoseconds")) {
          d.FractionalNanoseconds = m.FractionalNanoseconds;
        }
        return d;
      };
      UnixTime22.prototype.toJSON = function toJSON6() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      };
      return UnixTime22;
    })();
    Metadata = $root.Metadata = (() => {
      function Metadata22(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Metadata22.prototype.MimeType = "";
      Metadata22.encode = function encode342(m, w) {
        if (!w)
          w = $Writer.create();
        if (m.MimeType != null && Object.hasOwnProperty.call(m, "MimeType"))
          w.uint32(10).string(m.MimeType);
        return w;
      };
      Metadata22.decode = function decode412(r, l2) {
        if (!(r instanceof $Reader))
          r = $Reader.create(r);
        var c = l2 === void 0 ? r.len : r.pos + l2, m = new $root.Metadata();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.MimeType = r.string();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Metadata22.fromObject = function fromObject(d) {
        if (d instanceof $root.Metadata)
          return d;
        var m = new $root.Metadata();
        if (d.MimeType != null) {
          m.MimeType = String(d.MimeType);
        }
        return m;
      };
      Metadata22.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.MimeType = "";
        }
        if (m.MimeType != null && m.hasOwnProperty("MimeType")) {
          d.MimeType = m.MimeType;
        }
        return d;
      };
      Metadata22.prototype.toJSON = function toJSON6() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      };
      return Metadata22;
    })();
    NodeType = Data.DataType;
    EMPTY2 = Object.freeze([]);
    EMPTY_BUFFER = new Uint8Array(0);
    BLANK = Object.freeze({});
    DEFAULT_FILE_MODE = parseInt("0644", 8);
    DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
    code16 = code15;
    name11 = "UnixFS";
    encodePB = (data, links3) => {
      Object(globalThis).debug && console.log({ data, links: links3 });
      return encode28(
        // We run through prepare as links need to be sorted by name which it will
        // do.
        prepare2({
          Data: Data.encode(data).finish(),
          // We can cast to mutable array as we know no mutation occurs there
          Links: (
            /** @type {PB.PBLink[]} */
            links3
          )
        })
      );
    };
    createRaw = (content2) => ({
      type: NodeType.Raw,
      content: content2
    });
    createEmptyFile = (metadata) => createSimpleFile(EMPTY_BUFFER, metadata);
    createSimpleFile = (content2, metadata) => ({
      type: NodeType.File,
      layout: "simple",
      content: content2,
      metadata: decodeMetadata(metadata)
    });
    createFileChunk = (content2) => ({
      type: NodeType.File,
      layout: "simple",
      content: content2
    });
    createAdvancedFile = (parts, metadata) => ({
      type: NodeType.File,
      layout: "advanced",
      parts,
      metadata: decodeMetadata(metadata)
    });
    createFileShard = (parts) => ({
      type: NodeType.File,
      layout: "advanced",
      parts
    });
    createComplexFile = (content2, parts, metadata) => ({
      type: NodeType.File,
      layout: "complex",
      content: content2,
      parts,
      metadata: decodeMetadata(metadata)
    });
    createFlatDirectory = (entries3, metadata) => ({
      type: NodeType.Directory,
      metadata: decodeMetadata(metadata),
      entries: entries3
    });
    createShardedDirectory = (entries3, bitfield, fanout, hashType, metadata = BLANK) => ({
      type: NodeType.HAMTShard,
      bitfield,
      fanout: readFanout(fanout),
      hashType: readInt3(hashType),
      entries: entries3,
      metadata: decodeMetadata(metadata)
    });
    createDirectoryShard = (entries3, bitfield, fanout, hashType) => ({
      type: NodeType.HAMTShard,
      bitfield,
      fanout: readFanout(fanout),
      hashType: readInt3(hashType),
      entries: entries3
    });
    encodeRaw = (content2) => encodePB(
      {
        Type: NodeType.Raw,
        // TODO:
        Data: content2.byteLength > 0 ? content2 : void 0,
        filesize: content2.byteLength,
        // @ts-ignore
        blocksizes: EMPTY2
      },
      []
    );
    encodeFile = (node, ignoreMetadata = false) => {
      const metadata = ignoreMetadata ? BLANK : Object(node).metadata;
      switch (node.layout) {
        case "simple":
          return encodeSimpleFile(node.content, metadata);
        case "advanced":
          return encodeAdvancedFile(node.parts, metadata);
        case "complex":
          return encodeComplexFile(node.content, node.parts, metadata);
        default:
          throw new TypeError(
            `File with unknown layout "${Object(node).layout}" was passed`
          );
      }
    };
    encodeFileChunk = (content2) => encodeSimpleFile(content2, BLANK);
    encodeFileShard = (parts) => encodePB(
      {
        Type: NodeType.File,
        blocksizes: parts.map(contentByteLength),
        filesize: cumulativeContentByteLength(parts)
      },
      parts.map(encodeLink2)
    );
    encodeAdvancedFile = (parts, metadata = BLANK) => encodePB(
      {
        Type: NodeType.File,
        blocksizes: parts.map(contentByteLength),
        filesize: cumulativeContentByteLength(parts),
        ...encodeMetadata(metadata)
      },
      parts.map(encodeLink2)
    );
    encodeLink2 = (dag) => ({
      Name: "",
      Tsize: dag.dagByteLength,
      // @ts-ignore - @see https://github.com/multiformats/js-multiformats/pull/161
      Hash: dag.cid
    });
    encodeSimpleFile = (content2, metadata = BLANK) => encodePB(
      {
        Type: NodeType.File,
        // adding empty file to both go-ipfs and js-ipfs produces block in
        // which `Data` is omitted but filesize and blocksizes are present.
        // For the sake of hash consistency we do the same.
        Data: content2.byteLength > 0 ? content2 : void 0,
        filesize: content2.byteLength,
        blocksizes: [],
        ...encodeMetadata(metadata)
      },
      []
    );
    encodeComplexFile = (content2, parts, metadata = BLANK) => encodePB(
      {
        Type: NodeType.File,
        Data: content2,
        filesize: content2.byteLength + cumulativeContentByteLength(parts),
        blocksizes: parts.map(contentByteLength)
      },
      parts.map(encodeLink2)
    );
    encodeDirectory = (node) => encodePB(
      {
        Type: node.type,
        ...encodeDirectoryMetadata(node.metadata || BLANK)
      },
      node.entries.map(encodeNamedLink)
    );
    encodeHAMTShard = ({
      bitfield,
      fanout,
      hashType,
      entries: entries3,
      metadata = BLANK
    }) => encodePB(
      {
        Type: NodeType.HAMTShard,
        Data: bitfield.byteLength > 0 ? bitfield : void 0,
        fanout: readFanout(fanout),
        hashType: readInt3(hashType),
        ...encodeDirectoryMetadata(metadata)
      },
      entries3.map(encodeNamedLink)
    );
    readFanout = (n2) => {
      if (Math.log2(n2) % 1 === 0) {
        return n2;
      } else {
        throw new TypeError(
          `Expected hamt size to be a power of two instead got ${n2}`
        );
      }
    };
    readInt3 = (n2) => {
      if (Number.isInteger(n2)) {
        return n2;
      } else {
        throw new TypeError(`Expected an integer value instead got ${n2}`);
      }
    };
    createSymlink = (path, metadata = BLANK) => ({
      type: NodeType.Symlink,
      content: path,
      metadata: decodeMetadata(metadata)
    });
    encodeSymlink = (node, ignoreMetadata = false) => {
      const metadata = ignoreMetadata ? BLANK : Object(node).metadata;
      return encodePB(
        {
          Type: NodeType.Symlink,
          Data: node.content,
          ...encodeMetadata(metadata || BLANK)
        },
        []
      );
    };
    encode29 = (node, root2 = true) => {
      switch (node.type) {
        case NodeType.Raw:
          return encodeRaw(node.content);
        case NodeType.File:
          return encodeFile(node);
        case NodeType.Directory:
          return encodeDirectory(node);
        case NodeType.HAMTShard:
          return encodeHAMTShard(node);
        case NodeType.Symlink:
          return encodeSymlink(node);
        default:
          throw new Error(`Unknown node type ${Object(node).type}`);
      }
    };
    decode38 = (bytes22) => {
      const pb = decode37(bytes22);
      const message2 = Data.decode(
        /** @type {Uint8Array} */
        pb.Data
      );
      const {
        Type: type2,
        Data: data,
        mtime,
        mode,
        blocksizes,
        ...rest
      } = Data.toObject(message2, {
        defaults: false,
        arrays: true,
        longs: Number,
        objects: false
      });
      const metadata = {
        ...mode && { mode },
        ...decodeMtime(mtime)
      };
      const links3 = pb.Links;
      switch (message2.Type) {
        case NodeType.Raw:
          return createRaw(data);
        case NodeType.File:
          if (links3.length === 0) {
            return new SimpleFileView(data, metadata);
          } else if (data.byteLength === 0) {
            return new AdvancedFileView(
              decodeFileLinks(rest.blocksizes, links3),
              metadata
            );
          } else {
            return new ComplexFileView(
              data,
              decodeFileLinks(rest.blocksizes, links3),
              metadata
            );
          }
        case NodeType.Directory:
          return createFlatDirectory(decodeDirectoryLinks(links3), metadata);
        case NodeType.HAMTShard:
          return createShardedDirectory(
            decodeDirectoryLinks(links3),
            data || EMPTY_BUFFER,
            rest.fanout,
            rest.hashType,
            metadata
          );
        case NodeType.Symlink:
          return createSymlink(data, metadata);
        default:
          throw new TypeError(`Unsupported node type ${message2.Type}`);
      }
    };
    decodeMtime = (mtime) => mtime == null ? void 0 : {
      mtime: { secs: mtime.Seconds, nsecs: mtime.FractionalNanoseconds || 0 }
    };
    decodeFileLinks = (blocksizes, links3) => {
      const parts = [];
      const length42 = blocksizes.length;
      let n2 = 0;
      while (n2 < length42) {
        parts.push(
          /** @type {UnixFS.FileLink} */
          {
            cid: links3[n2].Hash,
            dagByteLength: links3[n2].Tsize || 0,
            contentByteLength: blocksizes[n2]
          }
        );
      }
      return parts;
    };
    decodeDirectoryLinks = (links3) => links3.map(
      (link5) => (
        /** @type {UnixFS.DirectoryEntryLink} */
        {
          cid: link5.Hash,
          name: link5.Name || "",
          dagByteLength: link5.Tsize || 0
        }
      )
    );
    cumulativeContentByteLength = (links3) => links3.reduce((size5, link5) => size5 + link5.contentByteLength, 0);
    cumulativeDagByteLength = (root2, links3) => links3.reduce((size5, link5) => size5 + link5.dagByteLength, root2.byteLength);
    contentByteLength = (link5) => link5.contentByteLength;
    encodeNamedLink = ({ name: name142, dagByteLength, cid }) => ({
      Name: name142,
      Tsize: dagByteLength,
      Hash: cid
    });
    encodeDirectoryMetadata = (metadata) => encodeMetadata(metadata, DEFAULT_DIRECTORY_MODE);
    encodeMetadata = ({ mode, mtime }, defaultMode = DEFAULT_FILE_MODE) => ({
      mode: mode != null ? encodeMode(mode, defaultMode) : void 0,
      mtime: mtime != null ? encodeMTime(mtime) : void 0
    });
    decodeMetadata = (data) => data == null ? BLANK : {
      ...data.mode == null ? void 0 : { mode: decodeMode(data.mode) },
      ...data.mtime == null ? void 0 : { mtime: data.mtime }
    };
    encodeMTime = (mtime) => {
      return mtime == null ? void 0 : mtime.nsecs !== 0 ? { Seconds: mtime.secs, FractionalNanoseconds: mtime.nsecs } : { Seconds: mtime.secs };
    };
    encodeMode = (specifiedMode, defaultMode) => {
      const mode = specifiedMode == null ? void 0 : decodeMode(specifiedMode);
      return mode === defaultMode || mode == null ? void 0 : mode;
    };
    decodeMode = (mode) => mode & 4095 | mode & 4294963200;
    matchFile = ({
      content: content2 = EMPTY_BUFFER,
      parts = EMPTY2,
      metadata = BLANK,
      ...rest
    }) => {
      if (parts.length === 0) {
        return new SimpleFileView(content2, metadata);
      } else if (content2.byteLength === 0) {
        return new AdvancedFileView(parts, metadata);
      } else {
        return new ComplexFileView(content2, parts, metadata);
      }
    };
    SimpleFileView = class {
      /**
       * @param {Uint8Array} content
       * @param {UnixFS.Metadata} metadata
       */
      constructor(content2, metadata) {
        this.content = content2;
        this.metadata = metadata;
        this.layout = "simple";
        this.type = NodeType.File;
      }
      get filesize() {
        return this.content.byteLength;
      }
      encode() {
        return encodeSimpleFile(this.content, this.metadata);
      }
    };
    AdvancedFileView = class {
      /**
       * @param {ReadonlyArray<UnixFS.FileLink>} parts
       * @param {UnixFS.Metadata} metadata
       */
      constructor(parts, metadata) {
        this.parts = parts;
        this.metadata = metadata;
      }
      /** @type {"advanced"} */
      get layout() {
        return "advanced";
      }
      /**
       * @returns {NodeType.File}
       */
      get type() {
        return NodeType.File;
      }
      get fileSize() {
        return cumulativeContentByteLength(this.parts);
      }
      get blockSizes() {
        return this.parts.map(contentByteLength);
      }
      encode() {
        return encodeAdvancedFile(this.parts, this.metadata);
      }
    };
    ComplexFileView = class {
      /**
       * @param {Uint8Array} content
       * @param {ReadonlyArray<UnixFS.FileLink>} parts
       * @param {UnixFS.Metadata} metadata
       */
      constructor(content2, parts, metadata) {
        this.content = content2;
        this.parts = parts;
        this.metadata = metadata;
      }
      /** @type {"complex"} */
      get layout() {
        return "complex";
      }
      /**
       * @returns {NodeType.File}
       */
      get type() {
        return NodeType.File;
      }
      get fileSize() {
        return this.content.byteLength + cumulativeContentByteLength(this.parts);
      }
      get blockSizes() {
        return this.parts.map(contentByteLength);
      }
      encode() {
        return encodeComplexFile(this.content, this.parts, this.metadata);
      }
    };
    filesize = (node) => {
      switch (node.type) {
        case NodeType.Raw:
        case NodeType.Symlink:
          return node.content.byteLength;
        case NodeType.File:
          switch (node.layout) {
            case "simple":
              return node.content.byteLength;
            case "advanced":
              return cumulativeContentByteLength(node.parts);
            case "complex":
              return node.content.byteLength + cumulativeContentByteLength(node.parts);
          }
        default:
          return 0;
      }
    };
    effect = function* (task) {
      const message2 = yield* task;
      yield* send(message2);
    };
    suspend = function* () {
      yield SUSPEND;
    };
    wait = function* (input10) {
      const task = yield* current();
      if (isAsync(input10)) {
        let failed = false;
        let output2 = void 0;
        input10.then(
          (value) => {
            failed = false;
            output2 = value;
            enqueue(task);
          },
          (error3) => {
            failed = true;
            output2 = error3;
            enqueue(task);
          }
        );
        yield* suspend();
        if (failed) {
          throw output2;
        } else {
          return (
            /** @type {T} */
            output2
          );
        }
      } else {
        main(wake(task));
        yield* suspend();
        return input10;
      }
    };
    isAsync = (node) => node != null && typeof /** @type {{then?:unknown}} */
    node.then === "function";
    send = function* (message2) {
      yield (
        /** @type {Task.Message<T>} */
        message2
      );
    };
    listen = function* (source) {
      const forks = [];
      for (const entry of Object.entries(source)) {
        const [name142, effect2] = (
          /** @type {[Tag, Task.Effect<T>]} */
          entry
        );
        if (effect2 !== NONE) {
          forks.push(yield* fork(tag(effect2, name142)));
        }
      }
      yield* group(forks);
    };
    effects = (tasks) => tasks.length > 0 ? batch(tasks.map(effect)) : NONE;
    tag = (effect2, tag2) => (
      // @ts-ignore
      effect2 === NONE ? NONE : effect2 instanceof Tagger ? new Tagger([...effect2.tags, tag2], effect2.source) : new Tagger([tag2], effect2)
    );
    Tagger = class {
      /**
       * @param {Task.Task<Success, Failure, Message>} source
       * @param {string[]} tags
       */
      constructor(tags, source) {
        this.tags = tags;
        this.source = source;
        this.controller;
      }
      /* c8 ignore next 3 */
      [Symbol.iterator]() {
        if (!this.controller) {
          this.controller = this.source[Symbol.iterator]();
        }
        return this;
      }
      /**
       * @param {Task.TaskState<Success, Message>} state
       * @returns {Task.TaskState<Success, Tagged<Tag, Message>>}
       */
      box(state) {
        if (state.done) {
          return state;
        } else {
          switch (state.value) {
            case SUSPEND:
            case CURRENT:
              return (
                /** @type {Task.TaskState<Success, Tagged<Tag, Message>>} */
                state
              );
            default: {
              const tagged = (
                /** @type {{ done: false, value: any }} */
                state
              );
              let { value } = tagged;
              for (const tag2 of this.tags) {
                value = withTag(tag2, value);
              }
              tagged.value = value;
              return tagged;
            }
          }
        }
      }
      /**
       *
       * @param {Task.Instruction<Message>} instruction
       */
      next(instruction) {
        return this.box(this.controller.next(instruction));
      }
      /**
       *
       * @param {Failure} error
       */
      throw(error3) {
        return this.box(this.controller.throw(error3));
      }
      /**
       * @param {Success} value
       */
      return(value) {
        return this.box(this.controller.return(value));
      }
      get [Symbol.toStringTag]() {
        return "TaggedEffect";
      }
    };
    none = () => NONE;
    withTag = (tag2, value) => (
      /** @type {Tagged<Tag, T>} */
      { type: tag2, [tag2]: value }
    );
    CURRENT = Symbol("current");
    SUSPEND = Symbol("suspend");
    Group = class _Group {
      /**
       * @template T, X, M
       * @param {Task.Controller<T, X, M>|Task.Fork<T, X, M>} member
       * @returns {Task.Group<T, X, M>}
       */
      static of(member) {
        return (
          /** @type {{group?:Task.TaskGroup<T, X, M>}} */
          member.group || MAIN
        );
      }
      /**
       * @template T, X, M
       * @param {(Task.Controller<T, X, M>|Task.Fork<T, X, M>) & {group?:Task.TaskGroup<T, X, M>}} member
       * @param {Task.TaskGroup<T, X, M>} group
       */
      static enqueue(member, group2) {
        member.group = group2;
        group2.stack.active.push(member);
      }
      /**
       * @param {Task.Controller<T, X, M>} driver
       * @param {Task.Controller<T, X, M>[]} [active]
       * @param {Set<Task.Controller<T, X, M>>} [idle]
       * @param {Task.Stack<T, X, M>} [stack]
       */
      constructor(driver, active = [], idle = /* @__PURE__ */ new Set(), stack = new Stack(active, idle)) {
        this.driver = driver;
        this.parent = _Group.of(driver);
        this.stack = stack;
        this.id = ++ID;
      }
    };
    Main = class {
      constructor() {
        this.status = IDLE;
        this.stack = new Stack();
        this.id = /** @type {0} */
        0;
      }
    };
    Stack = class {
      /**
       * @param {Task.Controller<T, X, M>[]} [active]
       * @param {Set<Task.Controller<T, X, M>>} [idle]
       */
      constructor(active = [], idle = /* @__PURE__ */ new Set()) {
        this.active = active;
        this.idle = idle;
      }
      /**
       *
       * @param {Task.Stack<unknown, unknown, unknown>} stack
       * @returns
       */
      static size({ active, idle }) {
        return active.length + idle.size;
      }
    };
    main = (task) => enqueue(task[Symbol.iterator]());
    enqueue = (task) => {
      let group2 = Group.of(task);
      group2.stack.active.push(task);
      group2.stack.idle.delete(task);
      while (group2.parent) {
        const { idle, active } = group2.parent.stack;
        if (idle.has(group2.driver)) {
          idle.delete(group2.driver);
          active.push(group2.driver);
        } else {
          break;
        }
        group2 = group2.parent;
      }
      if (MAIN.status === IDLE) {
        MAIN.status = ACTIVE;
        while (true) {
          try {
            for (const _message of step(MAIN)) {
            }
            MAIN.status = IDLE;
            break;
          } catch (_error) {
            MAIN.stack.active.shift();
          }
        }
      }
    };
    resume = (task) => enqueue(task);
    step = function* (group2) {
      const { active } = group2.stack;
      let task = active[0];
      group2.stack.idle.delete(task);
      while (task) {
        let state = INIT;
        loop: while (!state.done && task === active[0]) {
          const instruction = state.value;
          switch (instruction) {
            case SUSPEND:
              group2.stack.idle.add(task);
              break loop;
            case CURRENT:
              state = task.next(task);
              break;
            default:
              state = task.next(
                yield (
                  /** @type {M & Task.Message<M>}*/
                  instruction
                )
              );
              break;
          }
        }
        active.shift();
        task = active[0];
        group2.stack.idle.delete(task);
      }
    };
    fork = (task, options) => new Fork(task, options);
    exit = (handle, value) => conclude2(handle, { ok: true, value });
    abort = (handle, error3) => conclude2(handle, { ok: false, error: error3 });
    move = (fork5, group2) => {
      const from19 = Group.of(fork5);
      if (from19 !== group2) {
        const { active, idle } = from19.stack;
        const target = group2.stack;
        fork5.group = group2;
        if (idle.has(fork5)) {
          idle.delete(fork5);
          target.idle.add(fork5);
        } else {
          const index2 = active.indexOf(fork5);
          if (index2 >= 0) {
            active.splice(index2, 1);
            target.active.push(fork5);
          }
        }
      }
    };
    Future = class {
      /**
       * @param {Task.StateHandler<T, X>} handler
       */
      constructor(handler) {
        this.handler = handler;
        this.result;
      }
      /**
       * @type {Promise<T>}
       */
      get promise() {
        const { result } = this;
        const promise = result == null ? new Promise((succeed, fail3) => {
          this.handler.onsuccess = succeed;
          this.handler.onfailure = fail3;
        }) : result.ok ? Promise.resolve(result.value) : Promise.reject(result.error);
        Object.defineProperty(this, "promise", { value: promise });
        return promise;
      }
      /**
       * @template U, [E=never]
       * @param {((value:T) => U | PromiseLike<U>)|undefined|null} [onresolve]
       * @param {((error:X) => E|PromiseLike<E>)|undefined|null} [onreject]
       * @returns {Promise<U|E>}
       */
      then(onresolve, onreject) {
        return this.activate().promise.then(onresolve, onreject);
      }
      /**
       * @template [U=never]
       * @param {(error:X) => U} onreject
       */
      catch(onreject) {
        return (
          /** @type {Task.Future<T|U, never>} */
          this.activate().promise.catch(onreject)
        );
      }
      /**
       * @param {() => void} onfinally
       * @returns {Task.Future<T, X>}
       */
      finally(onfinally) {
        return (
          /** @type {Task.Future<T, X>} */
          this.activate().promise.finally(onfinally)
        );
      }
      /**
       * @abstract
       */
      /* c8 ignore next 3 */
      activate() {
        return this;
      }
    };
    Fork = class extends Future {
      /**
       * @param {Task.Task<T, X, M>} task
       * @param {Task.ForkOptions} [options]
       * @param {Task.StateHandler<T, X>} [handler]
       * @param {Task.TaskState<T, M>} [state]
       */
      constructor(task, options = BLANK2, handler = {}, state = INIT) {
        super(handler);
        this.id = ++ID;
        this.name = options.name || "";
        this.task = task;
        this.state = state;
        this.status = IDLE;
        this.result;
        this.handler = handler;
        this.controller;
      }
      *resume() {
        resume(this);
      }
      /**
       * @returns {Task.Task<T, X, M>}
       */
      join() {
        return join(this);
      }
      /**
       * @param {X} error
       */
      abort(error3) {
        return abort(this, error3);
      }
      /**
       * @param {T} value
       */
      exit(value) {
        return exit(this, value);
      }
      get [Symbol.toStringTag]() {
        return "Fork";
      }
      /**
       * @returns {Task.Controller<Task.Fork<T, X, M>, never, never>}
       */
      *[Symbol.iterator]() {
        return this.activate();
      }
      activate() {
        this.controller = this.task[Symbol.iterator]();
        this.status = ACTIVE;
        enqueue(this);
        return this;
      }
      /**
       * @private
       * @param {any} error
       * @returns {never}
       */
      panic(error3) {
        this.result = { ok: false, error: error3 };
        this.status = FINISHED;
        const { handler } = this;
        if (handler.onfailure) {
          handler.onfailure(error3);
        }
        throw error3;
      }
      /**
       * @private
       * @param {Task.TaskState<T, M>} state
       */
      step(state) {
        this.state = state;
        if (state.done) {
          this.result = { ok: true, value: state.value };
          this.status = FINISHED;
          const { handler } = this;
          if (handler.onsuccess) {
            handler.onsuccess(state.value);
          }
        }
        return state;
      }
      /**
       * @param {unknown} value
       */
      next(value) {
        try {
          return this.step(this.controller.next(value));
        } catch (error3) {
          return this.panic(error3);
        }
      }
      /**
       * @param {T} value
       */
      return(value) {
        try {
          return this.step(this.controller.return(value));
        } catch (error3) {
          return this.panic(error3);
        }
      }
      /**
       * @param {X} error
       */
      throw(error3) {
        try {
          return this.step(this.controller.throw(error3));
        } catch (error4) {
          return this.panic(error4);
        }
      }
    };
    loop = function* (init2, next) {
      const controller = yield* current();
      const group2 = new Group(controller);
      Group.enqueue(init2[Symbol.iterator](), group2);
      while (true) {
        for (const message2 of step(group2)) {
          Group.enqueue(next(message2)[Symbol.iterator](), group2);
        }
        if (Stack.size(group2.stack) > 0) {
          yield* suspend();
        } else {
          break;
        }
      }
    };
    ID = 0;
    IDLE = "idle";
    ACTIVE = "active";
    FINISHED = "finished";
    INIT = { done: false, value: CURRENT };
    BLANK2 = {};
    NONE = function* none2() {
    }();
    MAIN = new Main();
    Object.defineProperties(Indexed, {
      prototype: {
        value: new Proxy(Object.prototype, {
          /**
           * @param {object} target
           * @param {PropertyKey} property
           * @param {{get(key:PropertyKey): any}} receiver
           */
          get(target, property, receiver) {
            return typeof property === "symbol" ? Reflect.get(target, property, receiver) : receiver.get(property);
          }
        })
      }
    });
    empty5 = () => new BufferView();
    slice2 = (buffer22, startOffset = 0, endOffset = buffer22.byteLength) => {
      const segments = [];
      const start = startOffset < 0 ? buffer22.byteLength - startOffset : startOffset;
      const end = endOffset < 0 ? buffer22.byteLength - endOffset : endOffset;
      if (start === 0 && end >= buffer22.byteLength) {
        return buffer22;
      }
      if (start > end || start > buffer22.byteLength || end <= 0) {
        return empty5();
      }
      let byteLength = 0;
      let offset22 = 0;
      for (const segment of buffer22.segments) {
        const nextOffset = offset22 + segment.byteLength;
        if (byteLength === 0) {
          if (end <= nextOffset) {
            const range = segment.subarray(start - offset22, end - offset22);
            segments.push(range);
            byteLength = range.byteLength;
            break;
          } else if (start < nextOffset) {
            const range = start === offset22 ? segment : segment.subarray(start - offset22);
            segments.push(range);
            byteLength = range.byteLength;
          }
        } else if (end <= nextOffset) {
          const range = end === nextOffset ? segment : segment.subarray(0, end - offset22);
          segments.push(range);
          byteLength += range.byteLength;
          break;
        } else {
          segments.push(segment);
          byteLength += segment.byteLength;
        }
        offset22 = nextOffset;
      }
      return new BufferView(segments, buffer22.byteOffset + start, byteLength);
    };
    push = (buffer22, part) => {
      if (part.byteLength > 0) {
        buffer22.segments.push(part);
        return new BufferView(
          buffer22.segments,
          buffer22.byteOffset,
          buffer22.byteLength + part.byteLength
        );
      } else {
        return buffer22;
      }
    };
    get9 = (buffer22, n2) => {
      if (n2 < buffer22.byteLength) {
        let offset22 = 0;
        for (const segment of buffer22.segments) {
          if (n2 < offset22 + segment.byteLength) {
            return segment[n2 - offset22];
          } else {
            offset22 += segment.byteLength;
          }
        }
      }
      return void 0;
    };
    copyTo = (buffer22, target, byteOffset) => {
      let offset22 = byteOffset;
      for (const segment of buffer22.segments) {
        target.set(segment, offset22);
        offset22 += segment.byteLength;
      }
      return target;
    };
    BufferView = class extends Indexed {
      /**
       * @param {Uint8Array[]} segments
       * @param {number} byteOffset
       * @param {number} byteLength
       */
      constructor(segments = [], byteOffset = 0, byteLength = 0) {
        super();
        this.segments = segments;
        this.byteLength = byteLength;
        this.length = byteLength;
        this.byteOffset = byteOffset;
      }
      [Symbol.iterator]() {
        return iterate2(this);
      }
      /**
       * @param {number} [start]
       * @param {number} [end]
       */
      slice(start, end) {
        return (
          /** @type {BufferView} */
          slice2(this, start, end)
        );
      }
      /**
       * @param {number} [start]
       * @param {number} [end]
       */
      subarray(start, end) {
        return (
          /** @type {BufferView} */
          slice2(this, start, end)
        );
      }
      /**
       *
       * @param {Uint8Array} bytes
       */
      push(bytes22) {
        return (
          /** @type {BufferView} */
          push(this, bytes22)
        );
      }
      /**
       * @param {number} n
       */
      get(n2) {
        return get9(this, n2);
      }
      /**
       *
       * @param {Uint8Array} target
       * @param {number} offset
       */
      copyTo(target, offset22) {
        return copyTo(this, target, offset22);
      }
    };
    panic2 = (reason) => {
      throw new Error(reason);
    };
    unreachable = (template, subject, ...substitutions) => panic2(String.raw(template, JSON.stringify(subject), ...substitutions));
    EMPTY_BUFFER2 = new Uint8Array(0);
    EMPTY3 = [];
    open2 = (config2) => ({
      config: config2,
      buffer: empty5()
    });
    write4 = (state, bytes22) => bytes22.byteLength > 0 ? split2(state.config, state.buffer.push(bytes22), false) : { ...state, chunks: EMPTY3 };
    close2 = (state) => split2(state.config, state.buffer, true);
    split2 = (config2, buffer22, end) => {
      const chunker = config2.chunker;
      const chunks = [];
      let offset22 = 0;
      for (const size5 of chunker.cut(chunker.context, buffer22, end)) {
        if (size5 > 0) {
          const chunk = buffer22.subarray(offset22, offset22 + size5);
          chunks.push(chunk);
          offset22 += size5;
        }
      }
      return { config: config2, chunks, buffer: buffer22.subarray(offset22) };
    };
    mutable = () => ({
      mutable: true,
      needs: {},
      nodes: {},
      links: {},
      linked: EMPTY4
    });
    addNodes = (newNodes, input10) => {
      let queue = patch(input10, {});
      for (const node of newNodes) {
        const { ready, has: has2, wants } = collect(node.children, queue.links);
        if (wants.length === 0) {
          queue = patch(queue, {
            links: assign(void 0, has2),
            linked: [{ id: node.id, links: ready }]
          });
        } else {
          queue = patch(queue, {
            needs: assign(node.id, wants),
            nodes: {
              [node.id]: {
                children: node.children,
                count: wants.length
              }
            }
          });
        }
      }
      return queue;
    };
    addLink = (id, link5, queue) => {
      const nodeID = queue.needs[id];
      const node = queue.nodes[nodeID];
      if (node != null) {
        if (node.count === 1) {
          const { ready, has: has2 } = collect(node.children, {
            ...queue.links,
            [id]: link5
          });
          return patch(queue, {
            needs: { [id]: void 0 },
            links: assign(void 0, has2),
            nodes: { [nodeID]: void 0 },
            linked: [{ id: nodeID, links: ready }]
          });
        } else {
          return patch(queue, {
            needs: { [id]: void 0 },
            links: { [id]: link5 },
            nodes: {
              [nodeID]: {
                ...node,
                count: node.count - 1
              }
            }
          });
        }
      } else {
        return patch(queue, {
          links: { [id]: link5 }
        });
      }
    };
    patch = (queue, { needs, nodes, links: links3, linked }) => {
      const result = queue.mutable ? queue : { ...queue };
      const original = queue.mutable ? BLANK3 : void 0;
      if (needs) {
        result.needs = patchDict(queue.needs, needs, original);
      }
      if (nodes) {
        result.nodes = patchDict(queue.nodes, nodes, original);
      }
      if (links3) {
        result.links = patchDict(queue.links, links3, original);
      }
      result.linked = linked ? append(queue.linked || EMPTY4, linked, EMPTY4) : queue.linked || [];
      return (
        /** @type {Queue.Result} */
        result
      );
    };
    assign = (value, keys2) => {
      const delta = (
        /** @type {Record<K, V>} */
        {}
      );
      for (const key of keys2) {
        delta[key] = value;
      }
      return delta;
    };
    patchDict = (target, delta, original = target) => {
      const result = target === original ? { ...target } : target;
      for (const entry of Object.entries(delta)) {
        const [id, value] = (
          /** @type {[K, V|void]} */
          entry
        );
        if (value == null) {
          delete result[id];
        } else {
          result[id] = value;
        }
      }
      return result;
    };
    append = (target, items, original = target) => {
      if (target === original) {
        return [...target, ...items];
      } else {
        for (const item of items) {
          target.push(item);
        }
        return target;
      }
    };
    collect = (children, source) => {
      const has2 = [];
      const wants = [];
      const ready = [];
      for (const child of children) {
        const link5 = source[child];
        if (link5) {
          has2.push(child);
          ready.push(link5);
        } else {
          wants.push(child);
        }
      }
      return { has: has2, wants, ready };
    };
    EMPTY4 = /** @type {never[]} */
    Object.freeze([]);
    BLANK3 = /** @type {Record<never, never>} */
    Object.freeze({});
    update = (message2, state) => {
      switch (message2.type) {
        case "write":
          return write5(state, message2.bytes);
        case "link":
          return link4(state, message2.link);
        case "block":
          return { state, effect: none() };
        case "close":
          return close3(state);
        case "end":
          return { state, effect: none() };
        default:
          return unreachable`File Writer got unknown message ${message2}`;
      }
    };
    init = (writer, metadata, config2) => {
      return {
        status: "open",
        metadata,
        config: config2,
        writer,
        chunker: open2({ chunker: config2.chunker }),
        layout: config2.fileLayout.open(),
        // Note: Writing in large slices e.g. 1GiB at a time creates large queues
        // with around `16353` items. Immutable version ends up copying it every
        // time state of the queue changes, which introduces significant overhead.
        // To avoid this overhead we use mutable implementation which is API
        // compatible but makes in place updates.
        // TODO: We should consider using Persistent bit-partitioned vector tries
        // instead of arrays which would provide immutable interface with neglegable
        // overhead.
        // @see https://github.com/Gozala/vectrie
        nodeQueue: mutable()
      };
    };
    write5 = (state, bytes22) => {
      if (state.status === "open") {
        const { chunks, ...chunker } = write4(state.chunker, bytes22);
        const { nodes, leaves, layout } = state.config.fileLayout.write(
          state.layout,
          chunks
        );
        const { linked, ...nodeQueue } = addNodes(nodes, state.nodeQueue);
        const tasks = [
          ...encodeLeaves(leaves, state.config),
          ...encodeBranches(linked, state.config)
        ];
        return {
          state: {
            ...state,
            chunker,
            layout,
            nodeQueue
          },
          effect: listen({
            link: effects(tasks)
          })
        };
      } else {
        return panic2("Unable to perform write on closed file");
      }
    };
    link4 = (state, { id, link: link5, block }) => {
      let { linked, ...nodeQueue } = addLink(id, link5, state.nodeQueue);
      const tasks = encodeBranches(linked, state.config);
      const newState = state.status === "closed" && id === state.rootID ? {
        ...state,
        status: "linked",
        link: link5,
        nodeQueue
      } : { ...state, nodeQueue };
      const end = state.status === "closed" && id === state.rootID && state.end ? state.end.resume() : none();
      return {
        state: newState,
        effect: listen({
          link: effects(tasks),
          block: writeBlock(state.writer, block),
          end
        })
      };
    };
    close3 = (state) => {
      if (state.status === "open") {
        const { chunks } = close2(state.chunker);
        const { layout, ...write8 } = state.config.fileLayout.write(
          state.layout,
          chunks
        );
        const { root: root2, ...close9 } = state.config.fileLayout.close(
          layout,
          state.metadata
        );
        const [nodes, leaves] = isLeafNode(root2) ? [
          [...write8.nodes, ...close9.nodes],
          [...write8.leaves, ...close9.leaves, root2]
        ] : [
          [...write8.nodes, ...close9.nodes, root2],
          [...write8.leaves, ...close9.leaves]
        ];
        const { linked, ...nodeQueue } = addNodes(nodes, state.nodeQueue);
        const tasks = [
          ...encodeLeaves(leaves, state.config),
          ...encodeBranches(linked, state.config)
        ];
        const fork5 = fork(suspend());
        return {
          state: {
            ...state,
            chunker: null,
            layout: null,
            rootID: root2.id,
            status: "closed",
            end: fork5,
            nodeQueue
          },
          effect: listen({
            link: effects(tasks),
            end: join(fork5)
          })
        };
      } else {
        return { state, effect: none() };
      }
    };
    encodeLeaves = (leaves, config2) => leaves.map((leaf) => encodeLeaf(config2, leaf, config2.fileChunkEncoder));
    encodeLeaf = function* ({ hasher, linker }, { id, content: content2 }, encoder32) {
      const bytes22 = encoder32.encode(content2 ? asUint8Array(content2) : EMPTY_BUFFER2);
      const hash = yield* wait(hasher.digest(bytes22));
      const cid = linker.createLink(encoder32.code, hash);
      const block = { cid, bytes: bytes22 };
      const link5 = (
        /** @type {UnixFS.FileLink} */
        {
          cid,
          contentByteLength: content2 ? content2.byteLength : 0,
          dagByteLength: bytes22.byteLength
        }
      );
      return { id, block, link: link5 };
    };
    encodeBranches = (nodes, config2) => nodes.map((node) => encodeBranch(config2, node));
    encodeBranch = function* (config2, { id, links: links3 }, metadata) {
      const bytes22 = config2.fileEncoder.encode({
        type: NodeType.File,
        layout: "advanced",
        parts: links3,
        metadata
      });
      const hash = yield* wait(Promise.resolve(config2.hasher.digest(bytes22)));
      const cid = config2.linker.createLink(config2.fileEncoder.code, hash);
      const block = { bytes: bytes22, cid };
      const link5 = (
        /** @type {UnixFS.FileLink} */
        {
          cid,
          contentByteLength: cumulativeContentByteLength(links3),
          dagByteLength: cumulativeDagByteLength(bytes22, links3)
        }
      );
      return { id, block, link: link5 };
    };
    writeBlock = function* (writer, block) {
      if ((writer.desiredSize || 0) <= 0) {
        yield* wait(writer.ready);
      }
      writer.write(block);
    };
    asUint8Array = (buffer22) => buffer22 instanceof Uint8Array ? buffer22 : buffer22.copyTo(new Uint8Array(buffer22.byteLength), 0);
    isLeafNode = (node) => node.children == null;
    fixed_exports = {};
    __export2(fixed_exports, {
      context: () => context,
      cut: () => cut,
      name: () => name12,
      type: () => type,
      withMaxChunkSize: () => withMaxChunkSize
    });
    name12 = "fixed";
    context = {
      maxChunkSize: 262144
    };
    type = "Stateless";
    withMaxChunkSize = (maxChunkSize) => ({
      type: "Stateless",
      context: { maxChunkSize },
      name: name12,
      cut
    });
    cut = ({ maxChunkSize }, { byteLength }, end) => {
      const n2 = byteLength / maxChunkSize | 0;
      const chunks = new Array(n2).fill(maxChunkSize);
      const lastChunkSize = end ? byteLength - n2 * maxChunkSize : 0;
      if (lastChunkSize > 0) {
        chunks.push(lastChunkSize);
      }
      return chunks;
    };
    Node = class {
      /**
       *
       * @param {number} id
       * @param {number[]} children
       * @param {Layout.Metadata} [metadata]
       */
      constructor(id, children, metadata) {
        this.id = id;
        this.children = children;
        this.metadata = metadata;
      }
    };
    withWidth = (width) => ({
      open: () => open3({ width }),
      write: write6,
      close: close4
    });
    defaults = { width: 174 };
    open3 = ({ width } = defaults) => ({
      width,
      head: null,
      leafIndex: [],
      nodeIndex: [],
      lastID: 0
    });
    write6 = (layout, chunks) => {
      if (chunks.length === 0) {
        return { layout, nodes: EMPTY5, leaves: EMPTY5 };
      } else {
        let { lastID } = layout;
        const [head, slices] = layout.head ? (
          // If we had a head we have more then two chunks (we already checked
          // chunks weren't empty) so we process head along with other chunks.
          [null, (chunks.unshift(layout.head), chunks)]
        ) : (
          // If we have no head no leaves and got only one chunk we have to save it
          // until we can decide what to do with it.
          chunks.length === 1 && layout.leafIndex.length === 0 ? [chunks[0], EMPTY5] : (
            // Otherwise we have no head but got enough chunks to know we'll have a
            // node.
            [null, chunks]
          )
        );
        if (slices.length === 0) {
          return { layout: { ...layout, head }, nodes: EMPTY5, leaves: EMPTY5 };
        } else {
          const leafIndex = [...layout.leafIndex];
          const leaves = [];
          for (const chunk of slices) {
            const leaf = { id: ++lastID, content: chunk };
            leaves.push(leaf);
            leafIndex.push(leaf.id);
          }
          if (leafIndex.length > layout.width) {
            return flush2({ ...layout, leafIndex, head, lastID }, leaves);
          } else {
            return {
              layout: { ...layout, head, leafIndex, lastID },
              leaves,
              nodes: EMPTY5
            };
          }
        }
      }
    };
    flush2 = (state, leaves = EMPTY5, nodes = [], close9 = false) => {
      let { lastID } = state;
      const nodeIndex = state.nodeIndex.map((row) => [...row]);
      const leafIndex = [...state.leafIndex];
      const { width } = state;
      while (leafIndex.length > width || leafIndex.length > 0 && close9) {
        grow(nodeIndex, 1);
        const node = new Node(++lastID, leafIndex.splice(0, width));
        nodeIndex[0].push(node.id);
        nodes.push(node);
      }
      let depth = 0;
      while (depth < nodeIndex.length) {
        const row = nodeIndex[depth];
        depth++;
        while (row.length > width || row.length > 0 && close9 && depth < nodeIndex.length) {
          const node = new Node(++lastID, row.splice(0, width));
          grow(nodeIndex, depth + 1);
          nodeIndex[depth].push(node.id);
          nodes.push(node);
        }
      }
      return { layout: { ...state, lastID, leafIndex, nodeIndex }, leaves, nodes };
    };
    close4 = (layout, metadata) => {
      const state = layout;
      if (layout.head) {
        return {
          root: { id: 1, content: layout.head, metadata },
          leaves: EMPTY5,
          nodes: EMPTY5
        };
      } else if (layout.leafIndex.length === 0) {
        return {
          root: { id: 1, metadata },
          leaves: EMPTY5,
          nodes: EMPTY5
        };
      } else {
        const { nodes, layout: layout2 } = flush2(state, EMPTY5, [], true);
        const { nodeIndex } = layout2;
        const height2 = nodeIndex.length - 1;
        const top = nodeIndex[height2];
        if (top.length === 1) {
          const root2 = nodes[nodes.length - 1];
          nodes.length = nodes.length - 1;
          return { root: root2, nodes, leaves: EMPTY5 };
        } else {
          const root2 = new Node(layout2.lastID + 1, top, metadata);
          return { root: root2, nodes, leaves: EMPTY5 };
        }
      }
    };
    grow = (index2, length42) => {
      while (index2.length < length42) {
        index2.push([]);
      }
      return index2;
    };
    EMPTY5 = [];
    defaults2 = () => ({
      chunker: fixed_exports,
      fileChunkEncoder: UnixFSLeaf,
      smallFileEncoder: UnixFSLeaf,
      fileEncoder: codec_exports2,
      fileLayout: withWidth(174),
      hasher: sha2562,
      linker: { createLink: CID2.createV1 }
    });
    configure = (config2) => ({
      ...defaults2(),
      ...config2
    });
    UnixFSLeaf = {
      code: code16,
      name: name11,
      encode: encodeFileChunk
    };
    create12 = ({ writer, metadata = {}, settings = defaults2() }) => new FileWriterView(init(writer, metadata, configure(settings)));
    write7 = async (view6, bytes22) => {
      await perform(view6, send({ type: "write", bytes: bytes22 }));
      return view6;
    };
    close5 = async (view6, { releaseLock = false, closeWriter = false } = {}) => {
      await perform(view6, send({ type: "close" }));
      const { state } = view6;
      if (state.status === "linked") {
        if (closeWriter) {
          await view6.state.writer.close();
        } else if (releaseLock) {
          view6.state.writer.releaseLock();
        }
        return state.link;
      } else {
        panic2(
          `Expected writer to be in 'linked' state after close, but it is in "${state.status}" instead`
        );
      }
    };
    perform = (view6, effect2) => fork(
      loop(effect2, (message2) => {
        const { state, effect: effect3 } = update(message2, view6.state);
        view6.state = state;
        return effect3;
      })
    );
    FileWriterView = class {
      /**
       * @param {Writer.State<Layout>} state
       */
      constructor(state) {
        this.state = state;
      }
      get writer() {
        return this.state.writer;
      }
      get settings() {
        return this.state.config;
      }
      /**
       * @param {Uint8Array} bytes
       * @returns {Promise<API.View<Layout>>}
       */
      write(bytes22) {
        return write7(this, bytes22);
      }
      /**
       * @param {API.CloseOptions} [options]
       * @returns {Promise<UnixFS.FileLink>}
       */
      close(options) {
        return close5(this, options);
      }
    };
    defaults3 = defaults2;
    create13 = ({ writer, settings = defaults3(), metadata = {} }) => new DirectoryWriter({
      writer,
      metadata,
      settings,
      entries: /* @__PURE__ */ new Map(),
      closed: false
    });
    set = (view6, name142, link5, { overwrite = false } = {}) => {
      const writable = asWritable(view6.state);
      if (name142.includes("/")) {
        throw new Error(
          `Directory entry name "${name142}" contains forbidden "/" character`
        );
      }
      if (!overwrite && writable.entries.has(name142)) {
        throw new Error(`Directory already contains entry with name "${name142}"`);
      } else {
        writable.entries.set(name142, link5);
        return view6;
      }
    };
    remove7 = (view6, name142) => {
      const writer = asWritable(view6.state);
      writer.entries.delete(name142);
      return view6;
    };
    asWritable = (writer) => {
      if (!writer.closed) {
        return writer;
      } else {
        throw new Error(
          `Can not change written directory, but you can .fork() and make changes to it`
        );
      }
    };
    close6 = async (view6, { closeWriter = false, releaseLock = false } = {}) => {
      const { writer, settings, metadata } = asWritable(view6.state);
      view6.state.closed = true;
      const entries3 = [...links(view6)];
      const node = createFlatDirectory(entries3, metadata);
      const bytes22 = encodeDirectory(node);
      const digest52 = await settings.hasher.digest(bytes22);
      const cid = settings.linker.createLink(code16, digest52);
      if ((writer.desiredSize || 0) <= 0) {
        await writer.ready;
      }
      writer.write({ cid, bytes: bytes22 });
      if (closeWriter) {
        await writer.close();
      } else if (releaseLock) {
        writer.releaseLock();
      }
      return {
        cid,
        dagByteLength: cumulativeDagByteLength(bytes22, entries3)
      };
    };
    links = function* ({ state }) {
      for (const [name142, { dagByteLength, cid }] of state.entries) {
        yield (
          /** @type {UnixFS.DirectoryEntryLink} */
          {
            name: name142,
            dagByteLength,
            cid
          }
        );
      }
    };
    fork2 = ({ state }, {
      writer = state.writer,
      metadata = state.metadata,
      settings = state.settings
    } = {}) => new DirectoryWriter({
      writer,
      metadata,
      settings,
      entries: new Map(state.entries.entries()),
      closed: false
    });
    DirectoryWriter = class {
      /**
       * @param {API.State<Layout>} state
       */
      constructor(state) {
        this.state = state;
      }
      get writer() {
        return this.state.writer;
      }
      get settings() {
        return this.state.settings;
      }
      links() {
        return links(this);
      }
      /**
       * @param {string} name
       * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link
       * @param {API.WriteOptions} [options]
       */
      set(name142, link5, options) {
        return set(this, name142, link5, options);
      }
      /**
       * @param {string} name
       */
      remove(name142) {
        return remove7(this, name142);
      }
      /**
       * @template L
       * @param {Partial<API.Options<L>>} [options]
       * @returns {API.View<Layout|L>}
       */
      fork(options) {
        return fork2(this, options);
      }
      /**
       * @param {API.CloseOptions} [options]
       * @returns {Promise<UnixFS.DirectoryLink>}
       */
      close(options) {
        return close6(this, options);
      }
      entries() {
        return this.state.entries.entries();
      }
      /**
       * @param {string} name
       */
      has(name142) {
        return this.state.entries.has(name142);
      }
      get size() {
        return this.state.entries.size;
      }
    };
    Uint32_exports = {};
    __export2(Uint32_exports, {
      API: () => api_exports2,
      and: () => and5,
      bitCount: () => bitCount,
      empty: () => empty6,
      from: () => from15,
      fromBytes: () => fromBytes3,
      get: () => get10,
      or: () => or11,
      popcount: () => popcount,
      set: () => set2,
      size: () => size3,
      toBytes: () => toBytes22,
      unset: () => unset
    });
    api_exports2 = {};
    empty6 = (size5 = 32) => {
      if (size5 !== 32) {
        throw new Error(`Uint32 BitField does not support size: ${size5}`);
      }
      return 0;
    };
    from15 = (bits, size5) => {
      let bitfield = empty6(size5);
      for (const bit of bits) {
        bitfield = set2(bitfield, bit);
      }
      return bitfield;
    };
    size3 = (_bitField) => 32;
    mask = (bitField2, index2) => bitField2 >>> index2 & 31;
    offset = (bitField2, index2) => 1 << mask(bitField2, index2);
    popcount = (bitField2, index2 = 31) => bitCount(bitField2 & offset(index2, 0) - 1);
    set2 = (bitField2, index2) => bitField2 | 1 << index2;
    unset = (bitField2, index2) => bitField2 & (255 ^ 1 << index2);
    get10 = (bitField2, index2) => (bitField2 >> index2 & 1) !== 0;
    bitCount = (bitField2) => {
      const n1 = bitField2 - (bitField2 >> 1 & 1431655765);
      const n2 = (n1 & 858993459) + (n1 >> 2 & 858993459);
      const n3 = (n2 + (n2 >> 4) & 252645135) * 16843009;
      return n3 >> 24;
    };
    and5 = (left, right) => left & right;
    or11 = (left, right) => left | right;
    toBytes22 = (bitField2) => Uint8Array.of(
      bitField2 >> 24 & 255,
      bitField2 >> 16 & 255,
      bitField2 >> 8 & 255,
      bitField2 & 255
    );
    fromBytes3 = (bytes22) => {
      if (bytes22.length !== 4) {
        throw new Error(`Expected 4 bytes instead got ${bytes22.length}`);
      }
      return (bytes22[0] << 24) + (bytes22[1] << 16) + (bytes22[2] << 8) + bytes22[3];
    };
    import_murmurhash3js_revisited = __toESM2(require_murmurhash3js_revisited(), 1);
    utf8 = new TextEncoder();
    hash32 = import_murmurhash3js_revisited.default.x64.hash126;
    configure2 = ({ bitWidth: bitWidth2 = 5, hash = hash32 }) => {
      const hashSize = 4;
      if (bitWidth2 > hashSize * 8) {
        throw new RangeError(
          `Can not use bitWidth ${bitWidth2} which exceeds the hashSize ${hashSize}`
        );
      }
      if (hashSize * 8 > 32) {
        throw new RangeError(
          `Can not use hashSize ${hashSize} as it can not be encoded in Uint32`
        );
      }
      const mask2 = 4294967295 >>> 32 - bitWidth2;
      const at2 = (path, depth) => path >>> depth * bitWidth2 & mask2;
      const from19 = (key) => hash(utf8.encode(key));
      return { at: at2, from: from19, size: Math.ceil(hashSize * 8 / bitWidth2) };
    };
    BitmapIndexedNode = class {
      /**
       * @param {API.Edit|null} edit
       * @param {ReturnType<C['BitField']['empty']>} datamap
       * @param {ReturnType<C['BitField']['empty']>} nodemap
       * @param {API.Children<T, K, C>} children
       * @param {C} config
       */
      constructor(edit, datamap, nodemap, children, config2) {
        this.edit = edit;
        this.config = config2;
        this.datamap = datamap;
        this.nodemap = nodemap;
        this.children = children;
      }
      get nodeArity() {
        return this.config.BitField.popcount(this.nodemap);
      }
      get dataArity() {
        return this.config.BitField.popcount(this.datamap);
      }
      /**
       * @returns {API.BitmapIndexedNode<T, K, C>}
       */
      /* c8 ignore next 3 */
      empty() {
        return create14(this.config);
      }
      /**
       * @template X
       * @param {API.Uint32} depth
       * @param {ReturnType<C['Path']['from']>} path
       * @param {K} key
       * @param {X} notFound
       * @returns {T|X}
       */
      lookup(depth, path, key, notFound2) {
        return lookup(this, depth, path, key, notFound2);
      }
      /**
       * @template {string} R
       * @param {API.Edit|null} edit
       * @param {API.Uint32} depth
       * @param {ReturnType<C['Path']['from']>} path
       * @param {K|R} key
       * @param {T} value
       * @param {{value:boolean}} addedLeaf
       * @returns {API.BitmapIndexedNode<T, K | R, C>}
       */
      associate(edit, depth, path, key, value, addedLeaf) {
        return associate(this, edit, depth, path, key, value, addedLeaf);
      }
      /**
       * @param {API.Edit|null} edit
       * @param {API.Uint32} depth
       * @param {ReturnType<C['Path']['from']>} path
       * @param {K} key
       * @param {{value:boolean}} removedLeaf
       * @returns {API.BitmapIndexedNode<T, K, C>}
       */
      dissociate(edit, depth, path, key, removedLeaf) {
        return dissociate(this, edit, depth, path, key, removedLeaf);
      }
      /**
       * @param {API.Edit|null} edit
       * @returns {API.BitmapIndexedNode<T, K, C>}
       */
      fork(edit = null) {
        return fork3(this, edit);
      }
      /**
       * @returns {IterableIterator<[K, T]>}
       */
      entries() {
        return entries2(this);
      }
      /**
       * @returns {IterableIterator<K>}
       */
      keys() {
        return keys(this);
      }
      /**
       * @returns {IterableIterator<T>}
       */
      values() {
        return values(this);
      }
    };
    HashCollisionNode = class {
      /**
       * @param {API.Edit|null} edit
       * @param {number} count
       * @param {API.CollisionEntries<T, K>} children
       * @param {C} config
       */
      /* c8 ignore next 12 */
      constructor(edit, count, children, config2) {
        this.edit = edit;
        this.count = count;
        this.children = children;
        this.config = config2;
      }
      get nodeArity() {
        return (
          /** @type {0} */
          0
        );
      }
      get dataArity() {
        return this.count;
      }
      /**
       * @template X
       * @param {API.Uint32} _shift
       * @param {unknown} _path
       * @param {K} key
       * @param {X} notFound
       * @returns {T|X}
       */
      /* c8 ignore next 3 */
      lookup(_shift, _path, key, notFound2) {
        return lookupCollision(this, key, notFound2);
      }
      /**
       * @template {string} R
       * @param {API.Edit|null} edit
       * @param {API.Uint32} _shift
       * @param {ReturnType<C['Path']['from']>} path
       * @param {K|R} key
       * @param {T} value
       * @param {{value:boolean}} addedLeaf
       * @returns {API.HashCollisionNode<T, K | R, C>}
       */
      /* c8 ignore next 3 */
      associate(edit, _shift, path, key, value, addedLeaf) {
        return associateCollision(this, edit, path, key, value, addedLeaf);
      }
      /**
       * @param {API.Edit|null} edit
       * @param {API.Uint32} _shift
       * @param {ReturnType<C['Path']['from']>} path
       * @param {K} key
       * @param {{value:boolean}} removedLeaf
       * @returns {API.Node<T, K, C>}
       */
      /* c8 ignore next 3 */
      dissociate(edit, _shift, path, key, removedLeaf) {
        return dissociateCollision(this, edit, path, key, removedLeaf);
      }
      /**
       * @param {API.Edit|null} edit
       * @returns {this}
       */
      /* c8 ignore next 3 */
      fork(edit = null) {
        return (
          /** @type {this} */
          forkCollision(this, edit)
        );
      }
      /**
       * @returns {IterableIterator<[K, T]>}
       */
      /* c8 ignore next 3 */
      entries() {
        return entries2(this);
      }
      /**
       * @returns {IterableIterator<K>}
       */
      /* c8 ignore next 3 */
      keys() {
        return keys(this);
      }
      /**
       * @returns {IterableIterator<T>}
       */
      /* c8 ignore next 3 */
      values() {
        return values(this);
      }
    };
    lookupCollision = (node, name142, notFound2) => {
      const { children: entries3, count } = node;
      const n2 = findHashCollisionNodeIndex(entries3, count, name142);
      return entries3[n2] === name142 ? (
        /** @type {T} */
        entries3[n2 + 1]
      ) : notFound2;
    };
    associateCollision = (node, edit, key, name142, value, addedLeaf) => {
      const { children, count } = node;
      const index2 = findHashCollisionNodeIndex(children, count, name142);
      if (children[index2] !== name142) {
        const newNode = node.fork(edit);
        addedLeaf.value = true;
        newNode.count += 1;
        newNode.children.splice(index2, key, value);
        return newNode;
      } else if (children[index2 + 1] !== value) {
        const newNode = node.fork(edit);
        newNode.children[index2 + 1] = value;
        return newNode;
      } else {
        return node;
      }
    };
    dissociateCollision = (node, edit, hash, name142, removedLeaf) => {
      const { children: entries3, count, config: config2 } = node;
      const index2 = findHashCollisionNodeIndex(entries3, count, name142);
      if (entries3[index2] !== name142) {
        return node;
      } else {
        removedLeaf.value = true;
        if (count === 2) {
          const offset22 = index2 === 0 ? 2 : 0;
          return (
            /** @type {API.BitmapIndexedNode<T, K, C>} */
            associate(
              create14(config2),
              edit,
              0,
              hash,
              /** @type {K} */
              entries3[offset22],
              /** @type {T} */
              entries3[offset22 + 1],
              removedLeaf
            )
          );
        } else {
          const newNode = node.fork(edit);
          newNode.children.splice(index2, 2);
          newNode.count -= 1;
          return newNode;
        }
      }
    };
    forkCollision = (node, edit = null) => {
      if (canEdit(node.edit, edit)) {
        return node;
      } else {
        return new HashCollisionNode(
          edit,
          node.count,
          /** @type {API.CollisionEntries<T, K>} */
          node.children.slice(),
          node.config
        );
      }
    };
    findHashCollisionNodeIndex = (entries3, count, key) => {
      let index2 = 0;
      while (index2 < count && entries3[index2] > key) {
        index2 += 2;
      }
      return index2;
    };
    create14 = (config2, edit = null) => new BitmapIndexedNode(
      edit,
      config2.BitField.empty(Math.pow(2, config2.bitWidth)),
      config2.BitField.empty(Math.pow(2, config2.bitWidth)),
      /** @type {API.Children<T, K, C>} */
      [],
      config2
    );
    get11 = (node, key, notFound2) => lookup(node, 0, node.config.Path.from(key), key, notFound2);
    lookup = (node, depth, path, key, notFound2) => {
      const { datamap, nodemap, config: config2 } = node;
      const { Path, BitField } = config2;
      const offset22 = Path.at(path, depth);
      if (BitField.get(datamap, offset22)) {
        const index2 = BitField.popcount(datamap, offset22);
        if (keyAt(node, index2) === key) {
          return valueAt(node, index2);
        } else {
          return notFound2;
        }
      } else if (BitField.get(nodemap, offset22)) {
        const child = resolveNode(node, offset22);
        return child.lookup(depth + 1, path, key, notFound2);
      } else {
        return notFound2;
      }
    };
    set3 = (node, edit, key, value, addedLeaf) => associate(node, edit, 0, node.config.Path.from(key), key, value, addedLeaf);
    associate = (node, edit, depth, path, key, value, addedLeaf) => {
      const { datamap, nodemap, config: config2 } = node;
      const { Path, BitField } = config2;
      const offset22 = Path.at(path, depth);
      if (BitField.get(datamap, offset22)) {
        const index2 = BitField.popcount(datamap, offset22);
        const found = keyAt(node, index2);
        if (key === found) {
          return valueAt(node, index2) === value ? node : forkAndSet(node, edit, index2, value);
        } else {
          const branch = mergeTwoLeaves(
            config2,
            edit,
            depth + 1,
            Path.from(found),
            found,
            valueAt(node, index2),
            path,
            key,
            value
          );
          addedLeaf.value = true;
          return migrateLeafToBranch(node, edit, offset22, branch);
        }
      } else if (BitField.get(nodemap, offset22)) {
        const child = resolveNode(node, offset22);
        const newChild = child.associate(
          edit,
          depth + 1,
          path,
          key,
          value,
          addedLeaf
        );
        if (child === newChild) {
          return node;
        } else {
          return copyAndSetChild(node, edit, offset22, newChild);
        }
      } else {
        const index2 = BitField.popcount(datamap, offset22);
        addedLeaf.value = true;
        const newNode = node.fork(edit);
        newNode.datamap = BitField.set(datamap, offset22);
        newNode.children.splice(keyPosition(index2), 0, key, value);
        return newNode;
      }
    };
    remove8 = (node, edit, key, removedLeaf) => dissociate(node, edit, 0, node.config.Path.from(key), key, removedLeaf);
    dissociate = (source, edit, depth, path, key, removedLeaf) => {
      const { datamap, nodemap, config: config2 } = source;
      const { BitField, Path } = config2;
      const offset22 = Path.at(path, depth);
      if (BitField.get(datamap, offset22)) {
        const index2 = BitField.popcount(datamap, offset22);
        if (key === keyAt(source, index2)) {
          removedLeaf.value = true;
          const node = fork3(source, edit);
          node.datamap = BitField.unset(source.datamap, offset22);
          node.children.splice(keyPosition(index2), 2);
          return node;
        } else {
          return source;
        }
      } else if (BitField.get(nodemap, offset22)) {
        const node = resolveNode(source, offset22);
        const child = node.dissociate(edit, depth + 1, path, key, removedLeaf);
        if (hasSingleLeaf(child)) {
          return hasSingleNode(source) ? child : inlineChild(source, edit, offset22, child);
        } else if (node === child) {
          return source;
        } else {
          return copyAndSetChild(source, edit, offset22, child);
        }
      } else {
        return source;
      }
    };
    entries2 = function* ({ children }) {
      let offset22 = 0;
      const count = children.length;
      while (offset22 < count) {
        const key = children[offset22];
        if (typeof key === "string") {
          offset22 += 1;
          const value = children[offset22];
          yield (
            /** @type {[K, T]} */
            [key, value]
          );
          offset22 += 1;
        } else {
          break;
        }
      }
      while (offset22 < count) {
        const node = (
          /** @type {API.BitmapIndexedNode<T, K, C>} */
          children[offset22]
        );
        yield* node.entries();
        offset22 += 1;
      }
    };
    fork3 = (node, edit) => {
      if (canEdit(node.edit, edit)) {
        return node;
      } else {
        const newNode = new BitmapIndexedNode(
          edit,
          node.datamap,
          node.nodemap,
          node.children.slice(),
          node.config
        );
        return newNode;
      }
    };
    keys = function* ({ children }) {
      let offset22 = 0;
      const count = children.length;
      while (offset22 < count) {
        const key = children[offset22];
        if (typeof key === "string") {
          yield (
            /** @type {K} */
            key
          );
          offset22 += 2;
        } else {
          break;
        }
      }
      while (offset22 < count) {
        const node = (
          /** @type {API.BitmapIndexedNode<T, K>} */
          children[offset22]
        );
        yield* node.keys();
        offset22 += 1;
      }
    };
    values = function* ({ children }) {
      let offset22 = 0;
      const count = children.length;
      while (offset22 < count) {
        const key = children[offset22];
        if (typeof key === "string") {
          offset22 += 1;
          yield (
            /** @type {T} */
            children[offset22]
          );
          offset22 += 1;
        } else {
          break;
        }
      }
      while (offset22 < count) {
        const node = (
          /** @type {API.BitmapIndexedNode<T, K>} */
          children[offset22]
        );
        yield* node.values();
        offset22 += 1;
      }
    };
    forkAndSet = (node, edit, offset22, value) => {
      const newNode = node.fork(edit);
      newNode.children[valuePosition(offset22)] = value;
      return newNode;
    };
    inlineChild = (source, edit, offset22, child) => {
      const { datamap, nodemap, config: config2 } = source;
      const { BitField } = config2;
      const node = fork3(source, edit);
      node.children.splice(nodePosition(source, offset22), 1);
      node.children.splice(
        keyPosition(BitField.popcount(datamap, offset22)),
        0,
        child.children[0],
        child.children[1]
      );
      node.datamap = BitField.set(datamap, offset22);
      node.nodemap = BitField.unset(nodemap, offset22);
      return node;
    };
    copyAndSetChild = (node, edit, offset22, child) => {
      const newNode = fork3(node, edit);
      newNode.children[nodePosition(node, offset22)] = child;
      return newNode;
    };
    migrateLeafToBranch = (source, edit, offset22, branch) => {
      const { nodemap, datamap, config: config2 } = source;
      const { BitField } = config2;
      const index2 = BitField.popcount(datamap, offset22);
      const oldId = keyPosition(index2);
      const newId = nodePosition(source, offset22);
      const node = fork3(source, edit);
      node.datamap = BitField.unset(datamap, offset22);
      node.children.splice(oldId, 2);
      node.nodemap = BitField.set(nodemap, offset22);
      node.children.splice(newId - 1, 0, branch);
      return node;
    };
    mergeTwoLeaves = (config2, edit, depth, oldPath, oldKey, oldValue, newPath, newKey, newValue) => {
      const { BitField, Path } = config2;
      if (Path.size < depth) {
        return new HashCollisionNode(
          edit,
          2,
          [oldKey, oldValue, newKey, newValue],
          config2
        );
      } else {
        const oldOffset = Path.at(oldPath, depth);
        const newOffset = Path.at(newPath, depth);
        if (oldOffset === newOffset) {
          return new BitmapIndexedNode(
            edit,
            BitField.empty(Math.pow(2, config2.bitWidth)),
            BitField.from([oldOffset], Math.pow(2, config2.bitWidth)),
            [
              mergeTwoLeaves(
                config2,
                edit,
                depth + 1,
                oldPath,
                oldKey,
                oldValue,
                newPath,
                newKey,
                newValue
              )
            ],
            config2
          );
        } else {
          return new BitmapIndexedNode(
            edit,
            BitField.from([oldOffset, newOffset], Math.pow(2, config2.bitWidth)),
            BitField.empty(Math.pow(2, config2.bitWidth)),
            /** @type {API.Children<T, K, C>} */
            // We insert child with a lower index first so that we can derive it's
            // index on access via popcount
            oldOffset < newOffset ? [oldKey, oldValue, newKey, newValue] : [newKey, newValue, oldKey, oldValue],
            config2
          );
        }
      }
    };
    keyAt = ({ children }, index2) => (
      /** @type {K} */
      children[keyPosition(index2)]
    );
    keyPosition = (index2) => index2 * 2;
    valueAt = ({ children }, index2) => (
      /** @type {T} */
      children[valuePosition(index2)]
    );
    valuePosition = (index2) => index2 * 2 + 1;
    resolveNode = (node, offset22) => (
      /** @type {API.BitmapIndexedNode<T, K, C>|API.HashCollisionNode<T, K, C>} */
      node.children[nodePosition(node, offset22)]
    );
    nodePosition = ({ children, nodemap, config: config2 }, offset22) => children.length - 1 - config2.BitField.popcount(nodemap, offset22);
    canEdit = (owner, editor) => owner != null && owner === editor;
    hasSingleLeaf = (node) => node.nodeArity === 0 && node.dataArity === 1;
    hasSingleNode = ({ config: { BitField }, datamap, nodemap }) => BitField.popcount(datamap) === 0 && BitField.popcount(nodemap) === 1;
    import_murmurhash3js_revisited2 = __toESM2(require_murmurhash3js_revisited(), 1);
    murmur332 = from6({
      name: "murmur3-32",
      code: 35,
      encode: (input10) => fromNumberTo32BitBuf(import_murmurhash3js_revisited2.default.x86.hash32(input10))
    });
    murmur3128 = from6({
      name: "murmur3-128",
      code: 34,
      encode: (input10) => bytes_exports2.fromHex(import_murmurhash3js_revisited2.default.x64.hash128(input10))
    });
    murmur364 = from6({
      name: "murmur3-x64-64",
      code: 34,
      encode: (input10) => bytes_exports2.fromHex(import_murmurhash3js_revisited2.default.x64.hash128(input10)).subarray(0, 8)
    });
    utf82 = new TextEncoder();
    hash64 = (bytes22) => (
      /** @type {Uint8Array} */
      murmur364.encode(bytes22)
    );
    configure3 = ({ bitWidth: bitWidth2 = 8, hash = hash64 } = {}) => {
      const hashSize = hash(new Uint8Array()).byteLength;
      const at2 = (path, depth) => {
        const offset22 = depth * bitWidth2;
        if (offset22 > hashSize) {
          throw new RangeError(`Out of bounds`);
        }
        return toInt(path, offset22, bitWidth2);
      };
      const from19 = (key) => hash(utf82.encode(key));
      return { from: from19, at: at2, size: Math.ceil(hashSize * 8 / bitWidth2) };
    };
    toInt = (bytes22, offset22, count) => {
      let byteOffset = offset22 / 8 | 0;
      let bitOffset = offset22 % 8;
      let desired = count;
      let bits = 0;
      while (desired > 0 && byteOffset < bytes22.byteLength) {
        const byte = bytes22[byteOffset];
        const available = 8 - bitOffset;
        const taking = available < desired ? available : desired;
        const bitsLeft = 8 - bitOffset - taking;
        const mask2 = 255 >> bitOffset;
        const value = (mask2 & byte) >> bitsLeft;
        bits = (bits << taking) + value;
        desired -= taking;
        byteOffset++;
        bitOffset = 0;
      }
      return bits;
    };
    Uint8Array_exports = {};
    __export2(Uint8Array_exports, {
      API: () => api_exports2,
      and: () => and6,
      empty: () => empty7,
      from: () => from16,
      fromBytes: () => fromBytes4,
      get: () => get12,
      or: () => or12,
      popcount: () => popcount2,
      set: () => set4,
      size: () => size4,
      toBytes: () => toBytes3,
      unset: () => unset2
    });
    empty7 = (size5 = 256) => {
      if (size5 % 8 !== 0) {
        throw new Error(`Must be multiple of 8`);
      }
      return new Uint8Array(size5 / 8);
    };
    from16 = (bits, size5) => {
      let bitfield = empty7(size5);
      for (const index2 of bits) {
        const { byte, byteOffset, bitOffset } = at(bitfield, index2);
        bitfield[byteOffset] = byte | 1 << bitOffset;
      }
      return bitfield;
    };
    size4 = (bitfield) => bitfield.byteLength * 8;
    at = (bitfield, index2) => {
      const byteOffset = bitfield.byteLength - 1 - (index2 / 8 | 0);
      const bitOffset = index2 % 8;
      const byte = bitfield[byteOffset];
      return { byte, byteOffset, bitOffset };
    };
    setByte = (bytes22, index2, byte) => {
      if (bytes22[index2] !== byte) {
        const result = bytes22.slice(0);
        result[index2] = byte;
        return result;
      }
      return bytes22;
    };
    set4 = (bitfield, index2) => {
      const { byte, byteOffset, bitOffset } = at(bitfield, index2);
      return setByte(bitfield, byteOffset, byte | 1 << bitOffset);
    };
    unset2 = (bitfield, index2) => {
      const { byte, byteOffset, bitOffset } = at(bitfield, index2);
      return setByte(bitfield, byteOffset, byte & (255 ^ 1 << bitOffset));
    };
    get12 = (bitfield, index2) => {
      var { byte, bitOffset } = at(bitfield, index2);
      return (byte >> bitOffset & 1) !== 0;
    };
    toBytes3 = (bitfield) => bitfield;
    fromBytes4 = (bytes22) => bytes22;
    popcount2 = (bitfield, index2 = bitfield.byteLength * 8) => {
      const { byteOffset, bitOffset, byte } = at(bitfield, index2);
      let count = popcount(byte, bitOffset);
      let offset22 = bitfield.byteLength - 1;
      while (offset22 > byteOffset) {
        const byte2 = bitfield[offset22];
        count += bitCount(byte2);
        offset22--;
      }
      return count;
    };
    or12 = (left, right) => {
      const result = left.slice();
      let offset22 = 0;
      while (offset22 < left.length) {
        result[offset22] |= right[offset22];
        offset22++;
      }
      return result;
    };
    and6 = (left, right) => {
      const result = left.slice();
      let offset22 = 0;
      while (offset22 < left.length) {
        result[offset22] &= right[offset22];
        offset22++;
      }
      return result;
    };
    NOT_FOUND = new RangeError("Not Found");
    configure4 = ({
      bitWidth: bitWidth2 = 5,
      /* c8 ignore next 4 */
      BitField = bitWidth2 === 5 ? Uint32_exports : Uint8Array_exports,
      Path = bitWidth2 === 5 ? configure2({ bitWidth: bitWidth2 }) : configure3({ bitWidth: bitWidth2 })
    } = {}) => (
      /** @type {C} */
      { bitWidth: bitWidth2, BitField, Path }
    );
    from17 = (entries3, options) => {
      const node = (
        /** @type {API.HashMapBuilder<V, K, C>} */
        builder(options)
      );
      for (const [key, value] of entries3) {
        node.set(key, value);
      }
      return node.build();
    };
    has = (hamt, key) => get11(hamt.root, key, NOT_FOUND) !== NOT_FOUND;
    get13 = (hamt, key, notFound2 = (
      /** @type {U} */
      void 0
    )) => get11(hamt.root, key, notFound2);
    builder = (options) => {
      const edit = {};
      const config2 = configure4(options);
      return new HashMapBuilder(
        edit,
        0,
        create14(config2, edit),
        config2
      );
    };
    PersistentHashMap = class _PersistentHashMap {
      /**
       *
       * @param {number} count
       * @param {API.BitmapIndexedNode<T, K, C>} root
       * @param {C} config
       */
      constructor(count = 0, root2, config2) {
        this.count = count;
        this.root = root2;
        this.config = config2;
      }
      get size() {
        return this.count;
      }
      clone() {
        return new _PersistentHashMap(this.count, this.root, this.config);
      }
      /**
       * @returns {API.PersistentHashMap<T, K, C>}
       */
      empty() {
        return new _PersistentHashMap(
          0,
          create14(this.config, null),
          this.config
        );
      }
      /**
       * @param {K} key
       * @returns {boolean}
       */
      has(key) {
        return has(this, key);
      }
      /**
       * @param {K} key
       * @returns {T|undefined}
       */
      get(key) {
        return get11(this.root, key, void 0);
      }
      /**
       * @template {string} R
       * @param {R} key
       * @param {T} value
       * @returns {PersistentHashMap<T, K|R, C>}
       */
      set(key, value) {
        const addedLeaf = { value: false };
        const root2 = set3(this.root, null, key, value, addedLeaf);
        if (root2 === this.root) {
          return this;
        } else {
          return new _PersistentHashMap(
            addedLeaf.value ? this.count + 1 : this.count,
            root2,
            this.config
          );
        }
      }
      /**
       * @param {K} key
       */
      delete(key) {
        const root2 = remove8(this.root, null, key, { value: false });
        if (root2 === this.root) {
          return this;
        } else {
          return new _PersistentHashMap(this.count - 1, root2, this.config);
        }
      }
      /* c8 ignore next 3 */
      get bitField() {
        return this.config.BitField.or(this.root.datamap, this.root.nodemap);
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      entries() {
        return this.root.entries();
      }
      keys() {
        return this.root.keys();
      }
      values() {
        return this.root.values();
      }
      /**
       * @returns {API.HashMapBuilder<T, K, C>}
       */
      createBuilder() {
        return new HashMapBuilder({}, this.count, this.root, this.config);
      }
    };
    HashMapBuilder = class {
      /**
       * @param {API.Edit} edit
       * @param {number} count
       * @param {API.BitmapIndexedNode<T, K, C>} root
       * @param {C} config
       */
      constructor(edit, count, root2, config2) {
        this.edit = edit;
        this.count = count;
        this.root = root2;
        this.config = config2;
      }
      get size() {
        if (this.edit) {
          return this.count;
        } else {
          throw new Error(`.size was accessed on the finalized builder`);
        }
      }
      /**
       * @template {string} R
       * @param {R} key
       * @param {T} value
       * @returns {HashMapBuilder<T, K|R, C>}
       */
      set(key, value) {
        if (this.edit) {
          const addedLeaf = { value: false };
          const root2 = set3(this.root, this.edit, key, value, addedLeaf);
          if (this.root !== root2) {
            this.root = /** @type {API.BitmapIndexedNode<T, K, C>} */
            root2;
          }
          if (addedLeaf.value) {
            this.count += 1;
          }
          return this;
        } else {
          throw new Error(`.set was called on the finalized builder`);
        }
      }
      /**
       * @param {K} key
       */
      delete(key) {
        if (this.edit) {
          if (this.count === 0) {
            return this;
          }
          const removedLeaf = { value: false };
          const root2 = remove8(this.root, this.edit, key, removedLeaf);
          if (root2 !== this.root) {
            this.root = root2;
          }
          if (removedLeaf.value) {
            this.count -= 1;
          }
          return this;
        } else {
          throw new Error(`.delete was called on the finalized builder`);
        }
      }
      build() {
        if (this.edit) {
          this.edit = null;
          return new PersistentHashMap(this.count, this.root, this.config);
        } else {
          throw new Error(`.build was called on the finalized builder`);
        }
      }
    };
    utf83 = new TextEncoder();
    hash642 = (bytes22) => (
      /** @type {Uint8Array} */
      murmur364.encode(bytes22)
    );
    configure5 = ({ bitWidth: bitWidth2 = 8, hash = hash642 }) => {
      const hashSize = hash(new Uint8Array()).byteLength;
      const options = { bitWidth: bitWidth2, hash, hashSize };
      const at2 = (path, depth) => read8(path, depth, options);
      const from19 = (key) => utf83.encode(key);
      return { at: at2, from: from19, size: Infinity };
    };
    read8 = (key, depth = 0, { bitWidth: bitWidth2 = 8, hash, hashSize }) => {
      const frameBitSize = hashSize * 8;
      let digest52 = 0;
      let bitCount2 = bitWidth2;
      let bitOffset = bitWidth2 * depth;
      while (bitCount2 > 0) {
        const frameOffset = bitOffset / frameBitSize >> 0;
        const frame = frameOffset === 0 ? hash(key) : hash(appendByte(key, frameOffset));
        const offset22 = frameBitSize <= bitOffset ? bitOffset % frameBitSize : bitOffset;
        const maxBits = frameBitSize - offset22;
        const count = maxBits < bitCount2 ? maxBits : bitCount2;
        digest52 = (digest52 << count) + toInt(frame, offset22, count);
        bitCount2 -= count;
        bitOffset += count;
      }
      return digest52;
    };
    appendByte = (source, byte) => {
      const bytes22 = new Uint8Array(source.byteLength + 1).fill(
        byte,
        source.byteLength
      );
      bytes22.set(source);
      return bytes22;
    };
    bitWidth = 8;
    config = {
      bitWidth,
      Path: configure5({ bitWidth })
    };
    tableSize = (hamt) => Math.pow(2, hamt.config.bitWidth);
    builder2 = (options = (
      /** @type {C} */
      config
    )) => builder(options);
    from18 = (entries3, options = (
      /** @type {C} */
      config
    )) => from17(entries3, options);
    bitField = ({ datamap, nodemap, config: { BitField } }) => withoutLeadingZeros(BitField.toBytes(BitField.or(datamap, nodemap)));
    withoutLeadingZeros = (bytes22) => {
      let offset22 = 0;
      while (offset22 < bytes22.byteLength) {
        if (bytes22[offset22] !== 0) {
          return bytes22.subarray(offset22);
        }
        offset22 += 1;
      }
      return bytes22.subarray(offset22);
    };
    iterate3 = function* (root2) {
      const { config: config2, datamap, nodemap } = root2;
      const { BitField: bitfield } = config2;
      const size5 = bitfield.size(datamap);
      let bitOffset = 0;
      let dataCount = 0;
      while (bitOffset < size5) {
        const prefix2 = bitOffset.toString(16).toUpperCase().padStart(2, "0");
        if (bitfield.get(datamap, bitOffset)) {
          const key = keyAt(root2, dataCount);
          yield {
            prefix: prefix2,
            key,
            value: valueAt(root2, dataCount)
          };
          dataCount++;
        } else if (bitfield.get(nodemap, bitOffset)) {
          yield {
            prefix: prefix2,
            // UnixFS never contains hash collision nodes because it uses
            // inifinite hashes
            node: (
              /** @type {HAMT.BitmapIndexedNode<T, K, C>} */
              resolveNode(root2, bitOffset)
            )
          };
        }
        bitOffset++;
      }
    };
    Block = class {
      /**
       * @param {object} options
       * @param {CID<T, C, A, V>} options.cid
       * @param {API.ByteView<T>} options.bytes
       * @param {T} options.value
       */
      constructor({ cid, bytes: bytes22, value }) {
        if (!cid || !bytes22 || typeof value === "undefined") {
          throw new Error("Missing required argument");
        }
        this.cid = cid;
        this.bytes = bytes22;
        this.value = value;
        this.asBlock = this;
        Object.defineProperties(this, {
          cid: readonly(),
          bytes: readonly(),
          value: readonly(),
          asBlock: readonly()
        });
      }
      links() {
        return links2(this.value, []);
      }
      tree() {
        return tree(this.value, []);
      }
      /**
       *
       * @param {string} [path]
       * @returns {API.BlockCursorView<unknown>}
       */
      get(path = "/") {
        return get14(this.value, path.split("/").filter(Boolean));
      }
    };
    defaults4 = defaults2;
    create15 = ({ writer, settings = defaults4(), metadata = {} }) => new HAMTDirectoryWriter({
      writer,
      metadata,
      settings,
      entries: new HashMap(),
      closed: false
    });
    asWritable2 = (writer) => {
      if (!writer.closed) {
        return writer;
      } else {
        throw new Error("Can not change written HAMT directory, but you can .fork() and make changes to it");
      }
    };
    close7 = async (view6, { closeWriter = false, releaseLock = false } = {}) => {
      const { writer, settings, metadata } = asWritable2(view6.state);
      view6.state.closed = true;
      const { entries: entries3 } = view6.state;
      if (!(entries3 instanceof HashMap)) {
        throw new Error(`not a HAMT: ${entries3}`);
      }
      const hamt = entries3.builder.build();
      const blocks = iterateBlocks(hamt, hamt.root, settings);
      let root2 = null;
      for await (const block of blocks) {
        root2 = block;
        if ((writer.desiredSize || 0) <= 0) {
          await writer.ready;
        }
        writer.write(block);
      }
      if (root2 == null) throw new Error("no root block yielded");
      if (closeWriter) {
        await writer.close();
      } else if (releaseLock) {
        writer.releaseLock();
      }
      return {
        cid: root2.cid,
        dagByteLength: cumulativeDagByteLength(root2.bytes, root2.value.entries)
      };
    };
    iterateBlocks = async function* (hamt, node, settings) {
      const entries3 = [];
      for (const ent of iterate3(node)) {
        if ("key" in ent) {
          entries3.push(
            /** @type {UnixFS.DirectoryEntryLink} */
            {
              name: `${ent.prefix ?? ""}${ent.key ?? ""}`,
              dagByteLength: ent.value.dagByteLength,
              cid: ent.value.cid
            }
          );
        } else {
          let root2 = null;
          for await (const block of iterateBlocks(hamt, ent.node, settings)) {
            yield block;
            root2 = block;
          }
          if (root2 == null) throw new Error("no root block yielded");
          entries3.push(
            /** @type {UnixFS.ShardedDirectoryLink} */
            {
              name: ent.prefix,
              dagByteLength: cumulativeDagByteLength(root2.bytes, root2.value.entries),
              cid: root2.cid
            }
          );
        }
      }
      const shard = createDirectoryShard(
        entries3,
        bitField(node),
        tableSize(hamt),
        murmur364.code
      );
      yield await encodeHAMTShardBlock(shard, settings);
    };
    fork4 = ({ state }, {
      writer = state.writer,
      metadata = state.metadata,
      settings = state.settings
    } = {}) => new HAMTDirectoryWriter({
      writer,
      metadata,
      settings,
      entries: new HashMap(from18(state.entries.entries()).createBuilder()),
      closed: false
    });
    HAMTDirectoryWriter = class {
      /**
       * @param {API.State<Layout>} state
       */
      constructor(state) {
        this.state = state;
      }
      get writer() {
        return this.state.writer;
      }
      get settings() {
        return this.state.settings;
      }
      /**
       * @param {string} name
       * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link
       * @param {API.WriteOptions} [options]
       */
      set(name142, link5, options) {
        return set(this, name142, link5, options);
      }
      /**
       * @param {string} name
       */
      remove(name142) {
        return remove7(this, name142);
      }
      /**
       * @template L
       * @param {Partial<API.Options<L>>} [options]
       * @returns {API.View<Layout|L>}
       */
      fork(options) {
        return fork4(this, options);
      }
      /**
       * @param {API.CloseOptions} [options]
       * @returns {Promise<UnixFS.DirectoryLink>}
       */
      close(options) {
        return close7(this, options);
      }
      entries() {
        return this.state.entries.entries();
      }
      /**
       * @param {string} name
       */
      has(name142) {
        return this.state.entries.has(name142);
      }
      get size() {
        return this.state.entries.size;
      }
    };
    HashMap = class extends Map {
      /**
       * @param {UnixFSPermaMap.HashMapBuilder} [builder]
       */
      constructor(builder3 = builder2()) {
        super();
        this.builder = builder3;
      }
      clear() {
        this.builder = builder2();
      }
      /**
       * @param {string} key
       */
      delete(key) {
        const { root: root2 } = this.builder;
        this.builder.delete(key);
        return this.builder.root !== root2;
      }
      /**
       * @param {(value: API.EntryLink, key: string, map: Map<string, API.EntryLink>) => void} callbackfn
       * @param {any} [thisArg]
       */
      forEach(callbackfn, thisArg = this) {
        for (const [k, v] of this.builder.root.entries()) {
          callbackfn.call(thisArg, v, k, this);
        }
      }
      /**
       * @param {string} key
       */
      get(key) {
        return get13(this.builder, key);
      }
      /**
       * @param {string} key
       */
      has(key) {
        return has(this.builder, key);
      }
      /**
       * @param {string} key 
       * @param {API.EntryLink} value 
       */
      set(key, value) {
        this.builder.set(key, value);
        return this;
      }
      get size() {
        return this.builder.size;
      }
      [Symbol.iterator]() {
        return this.builder.root.entries();
      }
      entries() {
        return this.builder.root.entries();
      }
      keys() {
        return this.builder.root.keys();
      }
      values() {
        return this.builder.root.values();
      }
    };
    createWriter3 = ({ writable, settings = defaults2() }) => new FileSystemWriter({
      writer: writable.getWriter(),
      settings
    });
    close8 = async (view6, { releaseLock = true, closeWriter = true } = {}) => {
      if (closeWriter) {
        await view6.writer.close();
      } else if (releaseLock) {
        view6.writer.releaseLock();
      }
      return view6;
    };
    FileSystemWriter = class {
      /**
       * @param {object} options
       * @param {API.BlockWriter} options.writer
       * @param {Partial<API.EncoderSettings<Layout>>} options.settings
       */
      constructor({ writer, settings }) {
        this.writer = writer;
        this.settings = configure(settings);
      }
      /**
       * @template [L=unknown]
       * @param {API.WriterOptions<L|Layout>} config
       */
      createFileWriter({ settings = this.settings, metadata } = {}) {
        return create12({
          writer: this.writer,
          settings,
          metadata
        });
      }
      /**
       * @template [L=unknown]
       * @param {API.WriterOptions<L|Layout>} config
       */
      createDirectoryWriter({ settings = this.settings, metadata } = {}) {
        return create13({
          writer: this.writer,
          settings,
          metadata
        });
      }
      /**
       * @param {API.CloseOptions} [options]
       */
      close(options) {
        return close8(this, options);
      }
    };
    BLOCK_SIZE_LIMIT = 1048576;
    defaultCapacity = BLOCK_SIZE_LIMIT * 100;
    withCapacity = (byteLength = defaultCapacity) => ({
      highWaterMark: byteLength,
      size: (block) => block.bytes.length
    });
    SHARD_THRESHOLD = 1e3;
    queuingStrategy = withCapacity();
    defaultSettings = configure({
      fileChunkEncoder: raw_exports2,
      smallFileEncoder: raw_exports2,
      chunker: withMaxChunkSize(1024 * 1024),
      fileLayout: withWidth(1024)
    });
    UnixFSFileBuilder = class {
      /**
       * @param {string} name
       * @param {import('./types.js').BlobLike} file
       */
      constructor(name142, file) {
        __privateAdd(this, _file);
        this.name = name142;
        __privateSet(this, _file, file);
      }
      /** @param {import('@ipld/unixfs').View} writer */
      async finalize(writer) {
        const unixfsFileWriter = create12(writer);
        await __privateGet(this, _file).stream().pipeTo(new WritableStream({
          async write(chunk) {
            await unixfsFileWriter.write(chunk);
          }
        }));
        return await unixfsFileWriter.close();
      }
    };
    _file = /* @__PURE__ */ new WeakMap();
    UnixFSDirectoryBuilder = class {
      /**
       * @param {string} name
       * @param {import('./types.js').UnixFSDirectoryEncoderOptions} [options]
       */
      constructor(name142, options) {
        __privateAdd(this, _options);
        __publicField(this, "entries", /* @__PURE__ */ new Map());
        this.name = name142;
        __privateSet(this, _options, options);
      }
      /** @param {import('@ipld/unixfs').View} writer */
      async finalize(writer) {
        const dirWriter = this.entries.size <= SHARD_THRESHOLD ? create13(writer) : create15(writer);
        for (const [name142, entry] of this.entries) {
          const link5 = await entry.finalize(writer);
          if (__privateGet(this, _options)?.onDirectoryEntryLink) {
            __privateGet(this, _options).onDirectoryEntryLink({ name: entry.name, ...link5 });
          }
          dirWriter.set(name142, link5);
        }
        return await dirWriter.close();
      }
    };
    _options = /* @__PURE__ */ new WeakMap();
    car_exports3 = {};
    __export2(car_exports3, {
      BlockStream: () => BlockStream,
      blockEncodingLength: () => blockEncodingLength,
      blockHeaderEncodingLength: () => blockHeaderEncodingLength,
      code: () => code17,
      encode: () => encode30,
      headerEncodingLength: () => headerEncodingLength
    });
    init_empty();
    init_empty();
    CarIteratorBase = class {
      /**
       * @param {number} version
       * @param {CID[]} roots
       * @param {AsyncIterable<Block>|void} iterable
       */
      constructor(version22, roots, iterable) {
        this._version = version22;
        this._roots = roots;
        this._iterable = iterable;
        this._decoded = false;
      }
      get version() {
        return this._version;
      }
      /**
       * @returns {Promise<CID[]>}
       */
      async getRoots() {
        return this._roots;
      }
    };
    CarBlockIterator = class _CarBlockIterator extends CarIteratorBase {
      // inherited method
      /**
       * Get the list of roots defined by the CAR referenced by this iterator. May be
       * zero or more `CID`s.
       *
       * @function getRoots
       * @memberof CarBlockIterator
       * @instance
       * @async
       * @returns {Promise<CID[]>}
       */
      /**
       * @returns {AsyncIterator<Block>}
       */
      [Symbol.asyncIterator]() {
        if (this._decoded) {
          throw new Error("Cannot decode more than once");
        }
        if (!this._iterable) {
          throw new Error("Block iterable not found");
        }
        this._decoded = true;
        return this._iterable[Symbol.asyncIterator]();
      }
      /**
       * Instantiate a {@link CarBlockIterator} from a `Uint8Array` blob. Rather
       * than decoding the entire byte array prior to returning the iterator, as in
       * {@link CarReader.fromBytes}, only the header is decoded and the remainder
       * of the CAR is parsed as the `Block`s as yielded.
       *
       * @async
       * @static
       * @memberof CarBlockIterator
       * @param {Uint8Array} bytes
       * @returns {Promise<CarBlockIterator>}
       */
      static async fromBytes(bytes22) {
        const { version: version22, roots, iterator } = await fromBytes5(bytes22);
        return new _CarBlockIterator(version22, roots, iterator);
      }
      /**
       * Instantiate a {@link CarBlockIterator} from a `AsyncIterable<Uint8Array>`,
       * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).
       * Rather than decoding the entire byte array prior to returning the iterator,
       * as in {@link CarReader.fromIterable}, only the header is decoded and the
       * remainder of the CAR is parsed as the `Block`s as yielded.
       *
       * @async
       * @static
       * @param {AsyncIterable<Uint8Array>} asyncIterable
       * @returns {Promise<CarBlockIterator>}
       */
      static async fromIterable(asyncIterable) {
        const { version: version22, roots, iterator } = await fromIterable(asyncIterable);
        return new _CarBlockIterator(version22, roots, iterator);
      }
    };
    import_varint6 = __toESM2(require_varint(), 1);
    CAR_V1_VERSION = 1;
    CarWriter = class _CarWriter {
      /**
       * @param {CID[]} roots
       * @param {CarEncoder} encoder
       */
      constructor(roots, encoder32) {
        this._encoder = encoder32;
        this._mutex = encoder32.setRoots(roots);
        this._ended = false;
      }
      /**
       * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.
       *
       * @function
       * @memberof CarWriter
       * @instance
       * @async
       * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.
       * @returns {Promise<void>} The returned promise will only resolve once the
       * bytes this block generates are written to the `out` iterable.
       */
      async put(block) {
        if (!(block.bytes instanceof Uint8Array) || !block.cid) {
          throw new TypeError("Can only write {cid, bytes} objects");
        }
        if (this._ended) {
          throw new Error("Already closed");
        }
        const cid = CID.asCID(block.cid);
        if (!cid) {
          throw new TypeError("Can only write {cid, bytes} objects");
        }
        this._mutex = this._mutex.then(() => this._encoder.writeBlock({ cid, bytes: block.bytes }));
        return this._mutex;
      }
      /**
       * Finalise the CAR archive and signal that the `out` iterable should end once
       * any remaining bytes are written.
       *
       * @function
       * @memberof CarWriter
       * @instance
       * @async
       * @returns {Promise<void>}
       */
      async close() {
        if (this._ended) {
          throw new Error("Already closed");
        }
        await this._mutex;
        this._ended = true;
        return this._encoder.close();
      }
      /**
       * Returns the version number of the CAR file being written
       *
       * @returns {number}
       */
      version() {
        return this._encoder.version();
      }
      /**
       * Create a new CAR writer "channel" which consists of a
       * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.
       *
       * @async
       * @static
       * @memberof CarWriter
       * @param {CID[] | CID | void} roots
       * @returns {WriterChannel} The channel takes the form of
       * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.
       */
      static create(roots) {
        roots = toRoots(roots);
        const { encoder: encoder32, iterator } = encodeWriter();
        const writer = new _CarWriter(roots, encoder32);
        const out = new CarWriterOut(iterator);
        return { writer, out };
      }
      /**
       * Create a new CAR appender "channel" which consists of a
       * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.
       * This appender does not consider roots and does not produce a CAR header.
       * It is designed to append blocks to an _existing_ CAR archive. It is
       * expected that `out` will be concatenated onto the end of an existing
       * archive that already has a properly formatted header.
       *
       * @async
       * @static
       * @memberof CarWriter
       * @returns {WriterChannel} The channel takes the form of
       * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.
       */
      static createAppender() {
        const { encoder: encoder32, iterator } = encodeWriter();
        encoder32.setRoots = () => Promise.resolve();
        const writer = new _CarWriter([], encoder32);
        const out = new CarWriterOut(iterator);
        return { writer, out };
      }
      /**
       * Update the list of roots in the header of an existing CAR as represented
       * in a Uint8Array.
       *
       * This operation is an _overwrite_, the total length of the CAR will not be
       * modified. A rejection will occur if the new header will not be the same
       * length as the existing header, in which case the CAR will not be modified.
       * It is the responsibility of the user to ensure that the roots being
       * replaced encode as the same length as the new roots.
       *
       * The byte array passed in an argument will be modified and also returned
       * upon successful modification.
       *
       * @async
       * @static
       * @memberof CarWriter
       * @param {Uint8Array} bytes
       * @param {CID[]} roots - A new list of roots to replace the existing list in
       * the CAR header. The new header must take up the same number of bytes as the
       * existing header, so the roots should collectively be the same byte length
       * as the existing roots.
       * @returns {Promise<Uint8Array>}
       */
      static async updateRootsInBytes(bytes22, roots) {
        const reader = bytesReader2(bytes22);
        await readHeader2(reader);
        const newHeader = createHeader(roots);
        if (Number(reader.pos) !== newHeader.length) {
          throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`);
        }
        bytes22.set(newHeader, 0);
        return bytes22;
      }
    };
    CarWriterOut = class {
      /**
       * @param {AsyncIterator<Uint8Array>} iterator
       */
      constructor(iterator) {
        this._iterator = iterator;
      }
      [Symbol.asyncIterator]() {
        if (this._iterating) {
          throw new Error("Multiple iterator not supported");
        }
        this._iterating = true;
        return this._iterator;
      }
    };
    import_varint7 = __toESM2(require_varint(), 1);
    code17 = 514;
    NO_ROOTS_HEADER_LENGTH = 18;
    BlockStream = class extends ReadableStream {
      /** @param {import('./types.js').BlobLike} car */
      constructor(car) {
        let blocksPromise = null;
        const getBlocksIterable = () => {
          if (blocksPromise)
            return blocksPromise;
          blocksPromise = CarBlockIterator.fromIterable(toIterable(car.stream()));
          return blocksPromise;
        };
        let iterator = null;
        super({
          async start() {
            const blocks = await getBlocksIterable();
            iterator = /** @type {AsyncIterator<Block>} */
            blocks[Symbol.asyncIterator]();
          },
          async pull(controller) {
            if (!iterator)
              throw new Error("missing blocks iterator");
            const { value, done } = await iterator.next();
            if (done)
              return controller.close();
            controller.enqueue(value);
          }
        });
        this.getRoots = async () => {
          const blocks = await getBlocksIterable();
          return await blocks.getRoots();
        };
      }
    };
    base10_exports = {};
    __export2(base10_exports, {
      base10: () => base10
    });
    base10 = baseX({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
    base16_exports = {};
    __export2(base16_exports, {
      base16: () => base16,
      base16upper: () => base16upper
    });
    base16 = rfc4648({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    base16upper = rfc4648({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
    base2_exports = {};
    __export2(base2_exports, {
      base2: () => base22
    });
    base22 = rfc4648({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
    base256emoji_exports = {};
    __export2(base256emoji_exports, {
      base256emoji: () => base256emoji
    });
    alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    alphabetBytesToChars = alphabet.reduce((p, c, i) => {
      p[i] = c;
      return p;
    }, []);
    alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
      p[c.codePointAt(0)] = i;
      return p;
    }, []);
    base256emoji = from2({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: encode31,
      decode: decode39
    });
    base36_exports = {};
    __export2(base36_exports, {
      base36: () => base36,
      base36upper: () => base36upper
    });
    base36 = baseX({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    base36upper = baseX({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
    base8_exports = {};
    __export2(base8_exports, {
      base8: () => base8
    });
    base8 = rfc4648({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
    identity_exports = {};
    __export2(identity_exports, {
      identity: () => identity2
    });
    identity2 = from2({
      prefix: "\0",
      name: "identity",
      encode: (buf22) => toString2(buf22),
      decode: (str) => fromString2(str)
    });
    textEncoder4 = new TextEncoder();
    textDecoder3 = new TextDecoder();
    identity_exports2 = {};
    __export2(identity_exports2, {
      identity: () => identity3
    });
    code18 = 0;
    name13 = "identity";
    encode32 = coerce2;
    identity3 = { code: code18, name: name13, encode: encode32, digest: digest4 };
    sha2_browser_exports = {};
    __export2(sha2_browser_exports, {
      sha256: () => sha2564,
      sha512: () => sha5123
    });
    sha2564 = from6({
      name: "sha2-256",
      code: 18,
      encode: sha3("SHA-256")
    });
    sha5123 = from6({
      name: "sha2-512",
      code: 19,
      encode: sha3("SHA-512")
    });
    bases = { ...identity_exports, ...base2_exports, ...base8_exports, ...base10_exports, ...base16_exports, ...base32_exports, ...base36_exports, ...base58_exports, ...base64_exports, ...base256emoji_exports };
    hashes = { ...sha2_browser_exports, ...identity_exports2 };
    string2 = createCodec("utf8", "u", (buf22) => {
      const decoder32 = new TextDecoder("utf8");
      return "u" + decoder32.decode(buf22);
    }, (str) => {
      const encoder32 = new TextEncoder();
      return encoder32.encode(str.substring(1));
    });
    ascii = createCodec("ascii", "a", (buf22) => {
      let string32 = "a";
      for (let i = 0; i < buf22.length; i++) {
        string32 += String.fromCharCode(buf22[i]);
      }
      return string32;
    }, (str) => {
      str = str.substring(1);
      const buf22 = allocUnsafe(str.length);
      for (let i = 0; i < str.length; i++) {
        buf22[i] = str.charCodeAt(i);
      }
      return buf22;
    });
    BASES = {
      utf8: string2,
      "utf-8": string2,
      hex: bases.base16,
      latin1: ascii,
      ascii,
      binary: ascii,
      ...bases
    };
    DAG_PB_CODE5 = 112;
    cache4 = /* @__PURE__ */ new WeakMap();
    toBase58String = (digest52) => {
      let str = cache4.get(digest52.bytes);
      if (!str) {
        str = base58btc.encode(digest52.bytes);
        cache4.set(digest52.bytes, str);
      }
      return str;
    };
    DigestMap = class {
      /**
       * @param {Array<[Key, Value]>} [entries]
       */
      constructor(entries3) {
        __privateAdd(this, _data);
        __privateSet(this, _data, /* @__PURE__ */ new Map());
        for (const [k, v] of entries3 ?? []) {
          this.set(k, v);
        }
      }
      get [Symbol.toStringTag]() {
        return "DigestMap";
      }
      clear() {
        __privateGet(this, _data).clear();
      }
      /**
       * @param {Key} key
       * @returns {boolean}
       */
      delete(key) {
        const mhstr = toBase58String(key);
        return __privateGet(this, _data).delete(mhstr);
      }
      /**
       * @param {(value: Value, key: Key, map: Map<Key, Value>) => void} callbackfn
       * @param {any} [thisArg]
       */
      forEach(callbackfn, thisArg) {
        for (const [k, v] of __privateGet(this, _data).values()) {
          callbackfn.call(thisArg, v, k, this);
        }
      }
      /**
       * @param {Key} key
       * @returns {Value|undefined}
       */
      get(key) {
        const data = __privateGet(this, _data).get(toBase58String(key));
        if (data)
          return data[1];
      }
      /**
       * @param {Key} key
       * @returns {boolean}
       */
      has(key) {
        return __privateGet(this, _data).has(toBase58String(key));
      }
      /**
       * @param {Key} key
       * @param {Value} value
       */
      set(key, value) {
        __privateGet(this, _data).set(toBase58String(key), [key, value]);
        return this;
      }
      /** @returns {number} */
      get size() {
        return __privateGet(this, _data).size;
      }
      /** @returns */
      [Symbol.iterator]() {
        return this.entries();
      }
      /** @returns {IterableIterator<[Key, Value]>} */
      *entries() {
        yield* __privateGet(this, _data).values();
      }
      /** @returns {IterableIterator<Key>} */
      *keys() {
        for (const [k] of __privateGet(this, _data).values()) {
          yield k;
        }
      }
      /** @returns {IterableIterator<Value>} */
      *values() {
        for (const [, v] of __privateGet(this, _data).values()) {
          yield v;
        }
      }
    };
    _data = /* @__PURE__ */ new WeakMap();
    version = "index/sharded/dag@0.1";
    ShardedDAGIndexSchema = schema_exports3.variant({
      [version]: schema_exports3.struct({
        /** DAG root. */
        content: schema_exports3.link(),
        /** Shards the DAG can be found in. */
        shards: schema_exports3.array(schema_exports3.link())
      })
    });
    MultihashSchema = schema_exports3.bytes();
    BlobIndexSchema = schema_exports3.tuple([
      MultihashSchema,
      schema_exports3.array(
        /** multihash bytes, offset, length. */
        schema_exports3.tuple([
          MultihashSchema,
          schema_exports3.tuple([schema_exports3.number(), schema_exports3.number()])
        ])
      )
    ]);
    ShardedDAGIndex = class {
      /** @param {API.UnknownLink} content */
      constructor(content2) {
        __privateAdd(this, _content);
        __privateAdd(this, _shards);
        __privateSet(this, _content, content2);
        __privateSet(this, _shards, new DigestMap());
      }
      get content() {
        return __privateGet(this, _content);
      }
      get shards() {
        return __privateGet(this, _shards);
      }
      /**
       * @param {API.ShardDigest} shard
       * @param {API.SliceDigest} slice
       * @param {API.Position} pos
       */
      setSlice(shard, slice32, pos) {
        let index2 = __privateGet(this, _shards).get(shard);
        if (!index2) {
          index2 = new DigestMap();
          __privateGet(this, _shards).set(shard, index2);
        }
        index2.set(slice32, pos);
      }
      archive() {
        return archive2(this);
      }
    };
    _content = /* @__PURE__ */ new WeakMap();
    _shards = /* @__PURE__ */ new WeakMap();
    create18 = (content2) => new ShardedDAGIndex(content2);
    archive2 = async (model) => {
      const blocks = /* @__PURE__ */ new Map();
      const shards = [...model.shards.entries()].sort((a, b) => compare2(a[0].digest, b[0].digest));
      const index2 = {
        content: model.content,
        shards: (
          /** @type {API.Link[]} */
          []
        )
      };
      for (const s2 of shards) {
        const slices = [...s2[1].entries()].sort((a, b) => compare2(a[0].digest, b[0].digest)).map((e) => [e[0].bytes, e[1]]);
        const bytes3 = encode4([s2[0].bytes, slices]);
        const digest62 = await sha2564.digest(bytes3);
        const cid2 = create17(code3, digest62);
        blocks.set(cid2.toString(), { cid: cid2, bytes: bytes3 });
        index2.shards.push(cid2);
      }
      const bytes22 = encode4({ [version]: index2 });
      const digest52 = await sha2564.digest(bytes22);
      const cid = create17(code3, digest52);
      return ok(car_exports.encode({ roots: [{ cid, bytes: bytes22 }], blocks }));
    };
    symbol = Symbol.for("@achingbrain/uint8arraylist");
    Uint8ArrayList = class _Uint8ArrayList {
      constructor(...data) {
        __publicField(this, "bufs");
        __publicField(this, "length");
        __publicField(this, _a2, true);
        this.bufs = [];
        this.length = 0;
        if (data.length > 0) {
          this.appendAll(data);
        }
      }
      *[(_a2 = symbol, Symbol.iterator)]() {
        yield* this.bufs;
      }
      get byteLength() {
        return this.length;
      }
      /**
       * Add one or more `bufs` to the end of this Uint8ArrayList
       */
      append(...bufs) {
        this.appendAll(bufs);
      }
      /**
       * Add all `bufs` to the end of this Uint8ArrayList
       */
      appendAll(bufs) {
        let length42 = 0;
        for (const buf22 of bufs) {
          if (buf22 instanceof Uint8Array) {
            length42 += buf22.byteLength;
            this.bufs.push(buf22);
          } else if (isUint8ArrayList(buf22)) {
            length42 += buf22.byteLength;
            this.bufs.push(...buf22.bufs);
          } else {
            throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
          }
        }
        this.length += length42;
      }
      /**
       * Add one or more `bufs` to the start of this Uint8ArrayList
       */
      prepend(...bufs) {
        this.prependAll(bufs);
      }
      /**
       * Add all `bufs` to the start of this Uint8ArrayList
       */
      prependAll(bufs) {
        let length42 = 0;
        for (const buf22 of bufs.reverse()) {
          if (buf22 instanceof Uint8Array) {
            length42 += buf22.byteLength;
            this.bufs.unshift(buf22);
          } else if (isUint8ArrayList(buf22)) {
            length42 += buf22.byteLength;
            this.bufs.unshift(...buf22.bufs);
          } else {
            throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
          }
        }
        this.length += length42;
      }
      /**
       * Read the value at `index`
       */
      get(index2) {
        const res = findBufAndOffset(this.bufs, index2);
        return res.buf[res.index];
      }
      /**
       * Set the value at `index` to `value`
       */
      set(index2, value) {
        const res = findBufAndOffset(this.bufs, index2);
        res.buf[res.index] = value;
      }
      /**
       * Copy bytes from `buf` to the index specified by `offset`
       */
      write(buf22, offset22 = 0) {
        if (buf22 instanceof Uint8Array) {
          for (let i = 0; i < buf22.length; i++) {
            this.set(offset22 + i, buf22[i]);
          }
        } else if (isUint8ArrayList(buf22)) {
          for (let i = 0; i < buf22.length; i++) {
            this.set(offset22 + i, buf22.get(i));
          }
        } else {
          throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
        }
      }
      /**
       * Remove bytes from the front of the pool
       */
      consume(bytes22) {
        bytes22 = Math.trunc(bytes22);
        if (Number.isNaN(bytes22) || bytes22 <= 0) {
          return;
        }
        if (bytes22 === this.byteLength) {
          this.bufs = [];
          this.length = 0;
          return;
        }
        while (this.bufs.length > 0) {
          if (bytes22 >= this.bufs[0].byteLength) {
            bytes22 -= this.bufs[0].byteLength;
            this.length -= this.bufs[0].byteLength;
            this.bufs.shift();
          } else {
            this.bufs[0] = this.bufs[0].subarray(bytes22);
            this.length -= bytes22;
            break;
          }
        }
      }
      /**
       * Extracts a section of an array and returns a new array.
       *
       * This is a copy operation as it is with Uint8Arrays and Arrays
       * - note this is different to the behaviour of Node Buffers.
       */
      slice(beginInclusive, endExclusive) {
        const { bufs, length: length42 } = this._subList(beginInclusive, endExclusive);
        return concat2(bufs, length42);
      }
      /**
       * Returns a alloc from the given start and end element index.
       *
       * In the best case where the data extracted comes from a single Uint8Array
       * internally this is a no-copy operation otherwise it is a copy operation.
       */
      subarray(beginInclusive, endExclusive) {
        const { bufs, length: length42 } = this._subList(beginInclusive, endExclusive);
        if (bufs.length === 1) {
          return bufs[0];
        }
        return concat2(bufs, length42);
      }
      /**
       * Returns a allocList from the given start and end element index.
       *
       * This is a no-copy operation.
       */
      sublist(beginInclusive, endExclusive) {
        const { bufs, length: length42 } = this._subList(beginInclusive, endExclusive);
        const list7 = new _Uint8ArrayList();
        list7.length = length42;
        list7.bufs = [...bufs];
        return list7;
      }
      _subList(beginInclusive, endExclusive) {
        beginInclusive = beginInclusive ?? 0;
        endExclusive = endExclusive ?? this.length;
        if (beginInclusive < 0) {
          beginInclusive = this.length + beginInclusive;
        }
        if (endExclusive < 0) {
          endExclusive = this.length + endExclusive;
        }
        if (beginInclusive < 0 || endExclusive > this.length) {
          throw new RangeError("index is out of bounds");
        }
        if (beginInclusive === endExclusive) {
          return { bufs: [], length: 0 };
        }
        if (beginInclusive === 0 && endExclusive === this.length) {
          return { bufs: this.bufs, length: this.length };
        }
        const bufs = [];
        let offset22 = 0;
        for (let i = 0; i < this.bufs.length; i++) {
          const buf22 = this.bufs[i];
          const bufStart = offset22;
          const bufEnd = bufStart + buf22.byteLength;
          offset22 = bufEnd;
          if (beginInclusive >= bufEnd) {
            continue;
          }
          const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
          const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
          if (sliceStartInBuf && sliceEndsInBuf) {
            if (beginInclusive === bufStart && endExclusive === bufEnd) {
              bufs.push(buf22);
              break;
            }
            const start = beginInclusive - bufStart;
            bufs.push(buf22.subarray(start, start + (endExclusive - beginInclusive)));
            break;
          }
          if (sliceStartInBuf) {
            if (beginInclusive === 0) {
              bufs.push(buf22);
              continue;
            }
            bufs.push(buf22.subarray(beginInclusive - bufStart));
            continue;
          }
          if (sliceEndsInBuf) {
            if (endExclusive === bufEnd) {
              bufs.push(buf22);
              break;
            }
            bufs.push(buf22.subarray(0, endExclusive - bufStart));
            break;
          }
          bufs.push(buf22);
        }
        return { bufs, length: endExclusive - beginInclusive };
      }
      indexOf(search, offset22 = 0) {
        if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {
          throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
        }
        const needle = search instanceof Uint8Array ? search : search.subarray();
        offset22 = Number(offset22 ?? 0);
        if (isNaN(offset22)) {
          offset22 = 0;
        }
        if (offset22 < 0) {
          offset22 = this.length + offset22;
        }
        if (offset22 < 0) {
          offset22 = 0;
        }
        if (search.length === 0) {
          return offset22 > this.length ? this.length : offset22;
        }
        const M = needle.byteLength;
        if (M === 0) {
          throw new TypeError("search must be at least 1 byte long");
        }
        const radix = 256;
        const rightmostPositions = new Int32Array(radix);
        for (let c = 0; c < radix; c++) {
          rightmostPositions[c] = -1;
        }
        for (let j = 0; j < M; j++) {
          rightmostPositions[needle[j]] = j;
        }
        const right = rightmostPositions;
        const lastIndex = this.byteLength - needle.byteLength;
        const lastPatIndex = needle.byteLength - 1;
        let skip2;
        for (let i = offset22; i <= lastIndex; i += skip2) {
          skip2 = 0;
          for (let j = lastPatIndex; j >= 0; j--) {
            const char = this.get(i + j);
            if (needle[j] !== char) {
              skip2 = Math.max(1, j - right[char]);
              break;
            }
          }
          if (skip2 === 0) {
            return i;
          }
        }
        return -1;
      }
      getInt8(byteOffset) {
        const buf22 = this.subarray(byteOffset, byteOffset + 1);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        return view6.getInt8(0);
      }
      setInt8(byteOffset, value) {
        const buf22 = allocUnsafe(1);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        view6.setInt8(0, value);
        this.write(buf22, byteOffset);
      }
      getInt16(byteOffset, littleEndian) {
        const buf22 = this.subarray(byteOffset, byteOffset + 2);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        return view6.getInt16(0, littleEndian);
      }
      setInt16(byteOffset, value, littleEndian) {
        const buf22 = alloc2(2);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        view6.setInt16(0, value, littleEndian);
        this.write(buf22, byteOffset);
      }
      getInt32(byteOffset, littleEndian) {
        const buf22 = this.subarray(byteOffset, byteOffset + 4);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        return view6.getInt32(0, littleEndian);
      }
      setInt32(byteOffset, value, littleEndian) {
        const buf22 = alloc2(4);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        view6.setInt32(0, value, littleEndian);
        this.write(buf22, byteOffset);
      }
      getBigInt64(byteOffset, littleEndian) {
        const buf22 = this.subarray(byteOffset, byteOffset + 8);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        return view6.getBigInt64(0, littleEndian);
      }
      setBigInt64(byteOffset, value, littleEndian) {
        const buf22 = alloc2(8);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        view6.setBigInt64(0, value, littleEndian);
        this.write(buf22, byteOffset);
      }
      getUint8(byteOffset) {
        const buf22 = this.subarray(byteOffset, byteOffset + 1);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        return view6.getUint8(0);
      }
      setUint8(byteOffset, value) {
        const buf22 = allocUnsafe(1);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        view6.setUint8(0, value);
        this.write(buf22, byteOffset);
      }
      getUint16(byteOffset, littleEndian) {
        const buf22 = this.subarray(byteOffset, byteOffset + 2);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        return view6.getUint16(0, littleEndian);
      }
      setUint16(byteOffset, value, littleEndian) {
        const buf22 = alloc2(2);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        view6.setUint16(0, value, littleEndian);
        this.write(buf22, byteOffset);
      }
      getUint32(byteOffset, littleEndian) {
        const buf22 = this.subarray(byteOffset, byteOffset + 4);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        return view6.getUint32(0, littleEndian);
      }
      setUint32(byteOffset, value, littleEndian) {
        const buf22 = alloc2(4);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        view6.setUint32(0, value, littleEndian);
        this.write(buf22, byteOffset);
      }
      getBigUint64(byteOffset, littleEndian) {
        const buf22 = this.subarray(byteOffset, byteOffset + 8);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        return view6.getBigUint64(0, littleEndian);
      }
      setBigUint64(byteOffset, value, littleEndian) {
        const buf22 = alloc2(8);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        view6.setBigUint64(0, value, littleEndian);
        this.write(buf22, byteOffset);
      }
      getFloat32(byteOffset, littleEndian) {
        const buf22 = this.subarray(byteOffset, byteOffset + 4);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        return view6.getFloat32(0, littleEndian);
      }
      setFloat32(byteOffset, value, littleEndian) {
        const buf22 = alloc2(4);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        view6.setFloat32(0, value, littleEndian);
        this.write(buf22, byteOffset);
      }
      getFloat64(byteOffset, littleEndian) {
        const buf22 = this.subarray(byteOffset, byteOffset + 8);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        return view6.getFloat64(0, littleEndian);
      }
      setFloat64(byteOffset, value, littleEndian) {
        const buf22 = alloc2(8);
        const view6 = new DataView(buf22.buffer, buf22.byteOffset, buf22.byteLength);
        view6.setFloat64(0, value, littleEndian);
        this.write(buf22, byteOffset);
      }
      equals(other) {
        if (other == null) {
          return false;
        }
        if (!(other instanceof _Uint8ArrayList)) {
          return false;
        }
        if (other.bufs.length !== this.bufs.length) {
          return false;
        }
        for (let i = 0; i < this.bufs.length; i++) {
          if (!equals5(this.bufs[i], other.bufs[i])) {
            return false;
          }
        }
        return true;
      }
      /**
       * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this
       * method if you know the total size of all the Uint8Arrays ahead of time.
       */
      static fromUint8Arrays(bufs, length42) {
        const list7 = new _Uint8ArrayList();
        list7.bufs = bufs;
        if (length42 == null) {
          length42 = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);
        }
        list7.length = length42;
        return list7;
      }
    };
    MSB4 = 128;
    REST4 = 127;
    MSBALL4 = ~REST4;
    INT4 = Math.pow(2, 31);
    encode33 = (num) => {
      const out = [];
      let offset22 = 0;
      while (num >= INT4) {
        out[offset22++] = num & 255 | MSB4;
        num /= 128;
      }
      while (num & MSBALL4) {
        out[offset22++] = num & 255 | MSB4;
        num >>>= 7;
      }
      out[offset22] = num | 0;
      return out;
    };
    decode40 = (buf22, offset22) => {
      let res = 0;
      offset22 = offset22 || 0;
      let shift = 0;
      let counter = offset22;
      let b;
      const l2 = buf22.length;
      do {
        if (counter >= l2 || shift > 49) throw new RangeError("Could not decode varint");
        b = buf22.get(counter++);
        res += shift < 28 ? (b & REST4) << shift : (b & REST4) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB4);
      return [res, counter - offset22];
    };
    State = {
      ReadHeaderLength: 0,
      ReadHeader: 1,
      ReadBlockLength: 2,
      ReadBlock: 3
    };
    CIDV0_BYTES2 = {
      SHA2_256: 18,
      LENGTH: 32,
      DAG_PB: 112
    };
    CARReaderStream = class extends TransformStream {
      /**
       * @param {QueuingStrategy<Uint8Array>} [writableStrategy]
       * An object that optionally defines a queuing strategy for the stream.
       * @param {QueuingStrategy<import('./api.js').Block & import('./api.js').Position>} [readableStrategy]
       * An object that optionally defines a queuing strategy for the stream.
       * Defaults to a CountQueuingStrategy with highWaterMark of `1` to allow
       * `getHeader` to be called before the stream is consumed.
       */
      constructor(writableStrategy, readableStrategy) {
        const buffer22 = new Uint8ArrayList();
        let offset22 = 0;
        let prevOffset = offset22;
        let wanted = 8;
        let state = State.ReadHeaderLength;
        let resolveHeader;
        const headerPromise = new Promise((resolve2) => {
          resolveHeader = resolve2;
        });
        super({
          transform(chunk, controller) {
            buffer22.append(chunk);
            while (true) {
              if (buffer22.length < wanted) break;
              if (state === State.ReadHeaderLength) {
                const [length42, bytes22] = decode40(buffer22);
                buffer22.consume(bytes22);
                prevOffset = offset22;
                offset22 += bytes22;
                state = State.ReadHeader;
                wanted = length42;
              } else if (state === State.ReadHeader) {
                const header = decode6(buffer22.slice(0, wanted));
                resolveHeader && resolveHeader(header);
                buffer22.consume(wanted);
                prevOffset = offset22;
                offset22 += wanted;
                state = State.ReadBlockLength;
                wanted = 8;
              } else if (state === State.ReadBlockLength) {
                const [length42, bytes22] = decode40(buffer22);
                buffer22.consume(bytes22);
                prevOffset = offset22;
                offset22 += bytes22;
                state = State.ReadBlock;
                wanted = length42;
              } else if (state === State.ReadBlock) {
                const _offset = prevOffset;
                const length42 = offset22 - prevOffset + wanted;
                prevOffset = offset22;
                let cid;
                if (buffer22.get(0) === CIDV0_BYTES2.SHA2_256 && buffer22.get(1) === CIDV0_BYTES2.LENGTH) {
                  const bytes3 = buffer22.subarray(0, 34);
                  const multihash = decode5(bytes3);
                  cid = createLegacy2(multihash);
                  buffer22.consume(34);
                  offset22 += 34;
                } else {
                  const [version22, versionBytes] = decode40(buffer22);
                  if (version22 !== 1) throw new Error(`unexpected CID version (${version22})`);
                  buffer22.consume(versionBytes);
                  offset22 += versionBytes;
                  const [codec, codecBytes] = decode40(buffer22);
                  buffer22.consume(codecBytes);
                  offset22 += codecBytes;
                  const multihashBytes = getMultihashLength2(buffer22);
                  const multihash = decode5(buffer22.subarray(0, multihashBytes));
                  cid = create17(codec, multihash);
                  buffer22.consume(multihashBytes);
                  offset22 += multihashBytes;
                }
                const blockBytes = wanted - (offset22 - prevOffset);
                const bytes22 = buffer22.subarray(0, blockBytes);
                controller.enqueue({ cid, bytes: bytes22, offset: _offset, length: length42, blockOffset: offset22, blockLength: blockBytes });
                buffer22.consume(blockBytes);
                prevOffset = offset22;
                offset22 += blockBytes;
                state = State.ReadBlockLength;
                wanted = 8;
              }
            }
          },
          flush(controller) {
            if (state !== State.ReadBlockLength) {
              controller.error(new Error("unexpected end of data"));
            }
          }
        }, writableStrategy, readableStrategy ?? new CountQueuingStrategy({ highWaterMark: 1 }));
        __privateAdd(this, _headerPromise);
        __privateSet(this, _headerPromise, headerPromise);
      }
      /**
       * Get the decoded CAR header.
       */
      getHeader() {
        return __privateGet(this, _headerPromise);
      }
    };
    _headerPromise = /* @__PURE__ */ new WeakMap();
    getMultihashLength2 = (bytes22) => {
      const [, codeBytes] = decode40(bytes22);
      const [length42, lengthBytes] = decode40(bytes22, codeBytes);
      return codeBytes + lengthBytes + length42;
    };
    encodeHeader2 = (roots) => {
      const headerBytes = encode4({ version: 1, roots });
      const varintBytes = encode33(headerBytes.length);
      const header = new Uint8Array(varintBytes.length + headerBytes.length);
      header.set(varintBytes, 0);
      header.set(headerBytes, varintBytes.length);
      return header;
    };
    encodeBlock = (block) => {
      const varintBytes = encode33(block.cid.bytes.length + block.bytes.length);
      const bytes22 = new Uint8Array(varintBytes.length + block.cid.bytes.length + block.bytes.length);
      bytes22.set(varintBytes);
      bytes22.set(block.cid.bytes, varintBytes.length);
      bytes22.set(block.bytes, varintBytes.length + block.cid.bytes.length);
      return bytes22;
    };
    CARWriterStream = class extends TransformStream {
      /**
       * @param {import('multiformats').UnknownLink[]} [roots]
       * @param {QueuingStrategy<import('./api.js').Block>} [writableStrategy]
       * @param {QueuingStrategy<Uint8Array>} [readableStrategy]
       */
      constructor(roots = [], writableStrategy, readableStrategy) {
        super({
          start: (controller) => controller.enqueue(encodeHeader2(roots)),
          transform: (block, controller) => controller.enqueue(encodeBlock(block))
        }, writableStrategy, readableStrategy);
      }
    };
    SHARD_SIZE = 133169152;
    ShardingStream = class extends TransformStream {
      /**
       * @param {import('./types.js').ShardingOptions} [options]
       */
      constructor(options = {}) {
        const shardSize2 = options.shardSize ?? SHARD_SIZE;
        const maxBlockLength = shardSize2 - headerEncodingLength();
        let blocks = [];
        let readyBlocks = null;
        let slices = new DigestMap();
        let readySlices = null;
        let currentLength = 0;
        super({
          async transform(block, controller) {
            if (readyBlocks != null && readySlices != null) {
              controller.enqueue(await encodeCAR(readyBlocks, readySlices));
              readyBlocks = null;
              readySlices = null;
            }
            const blockHeaderLength = blockHeaderEncodingLength(block);
            const blockLength2 = blockHeaderLength + block.bytes.length;
            if (blockLength2 > maxBlockLength) {
              throw new Error(`block will cause CAR to exceed shard size: ${block.cid}`);
            }
            if (blocks.length && currentLength + blockLength2 > maxBlockLength) {
              readyBlocks = blocks;
              readySlices = slices;
              blocks = [];
              slices = new DigestMap();
              currentLength = 0;
            }
            blocks.push(block);
            slices.set(block.cid.multihash, [
              headerEncodingLength() + currentLength + blockHeaderLength,
              block.bytes.length
            ]);
            currentLength += blockLength2;
          },
          async flush(controller) {
            if (readyBlocks != null && readySlices != null) {
              controller.enqueue(await encodeCAR(readyBlocks, readySlices));
            }
            const rootBlock = blocks.at(-1);
            if (rootBlock == null)
              return;
            const rootCID = options.rootCID ?? rootBlock.cid;
            const headerLength2 = headerEncodingLength(rootCID);
            if (headerLength2 + currentLength > shardSize2) {
              const overage = headerLength2 + currentLength - shardSize2;
              const overflowBlocks = [];
              let overflowCurrentLength = 0;
              while (overflowCurrentLength < overage) {
                const block = blocks[blocks.length - 1];
                blocks.pop();
                slices.delete(block.cid.multihash);
                overflowBlocks.unshift(block);
                overflowCurrentLength += blockEncodingLength(block);
                if (blocks.length < 1)
                  throw new Error(`block will cause CAR to exceed shard size: ${block.cid}`);
              }
              controller.enqueue(await encodeCAR(blocks, slices));
              overflowCurrentLength = 0;
              const overflowSlices = new DigestMap();
              for (const block of blocks) {
                const overflowBlockHeaderLength = blockHeaderEncodingLength(block);
                overflowSlices.set(block.cid.multihash, [
                  headerLength2 + overflowCurrentLength + overflowBlockHeaderLength,
                  block.bytes.length
                ]);
                overflowCurrentLength += overflowBlockHeaderLength + block.bytes.length;
              }
              controller.enqueue(await encodeCAR(overflowBlocks, overflowSlices, rootCID));
            } else {
              const diff = headerLength2 - headerEncodingLength();
              for (const slice32 of slices.values()) {
                slice32[0] += diff;
              }
              controller.enqueue(await encodeCAR(blocks, slices, rootCID));
            }
          }
        });
      }
    };
    defaultFileComparator = (a, b, getComparedValue = (file) => file.name) => {
      return ascending(a, b, getComparedValue);
    };
    encodeCAR = async (blocks, slices, root2) => Object.assign(await encode30(blocks, root2), { slices });
  }
});

// node_modules/web-streams-polyfill/dist/ponyfill.js
var require_ponyfill = __commonJS({
  "node_modules/web-streams-polyfill/dist/ponyfill.js"(exports2, module2) {
    init_process_shim();
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
    })(exports2, function(exports3) {
      "use strict";
      var SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : function(description) {
        return "Symbol(".concat(description, ")");
      };
      function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1) throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n2) {
          return function(v) {
            return step2([n2, v]);
          };
        }
        function step2(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
          if (op[0] & 5) throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      }
      function __values(o) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
          next: function() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }
      function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      }
      function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n2) {
          if (g[n2]) i[n2] = function(v) {
            return new Promise(function(a, b) {
              q.push([n2, v, a, b]) > 1 || resume2(n2, v);
            });
          };
        }
        function resume2(n2, v) {
          try {
            step2(g[n2](v));
          } catch (e) {
            settle2(q[0][3], e);
          }
        }
        function step2(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle2(q[0][2], r);
        }
        function fulfill(value) {
          resume2("next", value);
        }
        function reject(value) {
          resume2("throw", value);
        }
        function settle2(f, v) {
          if (f(v), q.shift(), q.length) resume2(q[0][0], q[0][1]);
        }
      }
      function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n2, f) {
          i[n2] = o[n2] ? function(v) {
            return (p = !p) ? { value: __await(o[n2](v)), done: false } : f ? f(v) : v;
          } : f;
        }
      }
      function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n2) {
          i[n2] = o[n2] && function(v) {
            return new Promise(function(resolve2, reject) {
              v = o[n2](v), settle2(resolve2, reject, v.done, v.value);
            });
          };
        }
        function settle2(resolve2, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve2({ value: v2, done: d });
          }, reject);
        }
      }
      typeof SuppressedError === "function" ? SuppressedError : function(error3, suppressed, message2) {
        var e = new Error(message2);
        return e.name = "SuppressedError", e.error = error3, e.suppressed = suppressed, e;
      };
      function noop3() {
        return void 0;
      }
      function typeIsObject(x) {
        return typeof x === "object" && x !== null || typeof x === "function";
      }
      var rethrowAssertionErrorRejection = noop3;
      function setFunctionName(fn, name15) {
        try {
          Object.defineProperty(fn, "name", {
            value: name15,
            configurable: true
          });
        } catch (_a4) {
        }
      }
      var originalPromise = Promise;
      var originalPromiseThen = Promise.prototype.then;
      var originalPromiseReject = Promise.reject.bind(originalPromise);
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      function promiseResolvedWith(value) {
        return newPromise(function(resolve2) {
          return resolve2(value);
        });
      }
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, void 0, onRejected);
      }
      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
      }
      var _queueMicrotask = function(callback) {
        if (typeof queueMicrotask === "function") {
          _queueMicrotask = queueMicrotask;
        } else {
          var resolvedPromise_1 = promiseResolvedWith(void 0);
          _queueMicrotask = function(cb) {
            return PerformPromiseThen(resolvedPromise_1, cb);
          };
        }
        return _queueMicrotask(callback);
      };
      function reflectCall(F, V, args) {
        if (typeof F !== "function") {
          throw new TypeError("Argument is not a function");
        }
        return Function.prototype.apply.call(F, V, args);
      }
      function promiseCall(F, V, args) {
        try {
          return promiseResolvedWith(reflectCall(F, V, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }
      var QUEUE_MAX_ARRAY_SIZE = 16384;
      var SimpleQueue = (
        /** @class */
        function() {
          function SimpleQueue2() {
            this._cursor = 0;
            this._size = 0;
            this._front = {
              _elements: [],
              _next: void 0
            };
            this._back = this._front;
            this._cursor = 0;
            this._size = 0;
          }
          Object.defineProperty(SimpleQueue2.prototype, "length", {
            get: function() {
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          SimpleQueue2.prototype.push = function(element) {
            var oldBack = this._back;
            var newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
              newBack = {
                _elements: [],
                _next: void 0
              };
            }
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
              this._back = newBack;
              oldBack._next = newBack;
            }
            ++this._size;
          };
          SimpleQueue2.prototype.shift = function() {
            var oldFront = this._front;
            var newFront = oldFront;
            var oldCursor = this._cursor;
            var newCursor = oldCursor + 1;
            var elements = oldFront._elements;
            var element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
              newFront = oldFront._next;
              newCursor = 0;
            }
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
              this._front = newFront;
            }
            elements[oldCursor] = void 0;
            return element;
          };
          SimpleQueue2.prototype.forEach = function(callback) {
            var i = this._cursor;
            var node = this._front;
            var elements = node._elements;
            while (i !== elements.length || node._next !== void 0) {
              if (i === elements.length) {
                node = node._next;
                elements = node._elements;
                i = 0;
                if (elements.length === 0) {
                  break;
                }
              }
              callback(elements[i]);
              ++i;
            }
          };
          SimpleQueue2.prototype.peek = function() {
            var front = this._front;
            var cursor = this._cursor;
            return front._elements[cursor];
          };
          return SimpleQueue2;
        }()
      );
      var AbortSteps = SymbolPolyfill("[[AbortSteps]]");
      var ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
      var CancelSteps = SymbolPolyfill("[[CancelSteps]]");
      var PullSteps = SymbolPolyfill("[[PullSteps]]");
      var ReleaseSteps = SymbolPolyfill("[[ReleaseSteps]]");
      function ReadableStreamReaderGenericInitialize(reader, stream4) {
        reader._ownerReadableStream = stream4;
        stream4._reader = reader;
        if (stream4._state === "readable") {
          defaultReaderClosedPromiseInitialize(reader);
        } else if (stream4._state === "closed") {
          defaultReaderClosedPromiseInitializeAsResolved(reader);
        } else {
          defaultReaderClosedPromiseInitializeAsRejected(reader, stream4._storedError);
        }
      }
      function ReadableStreamReaderGenericCancel(reader, reason) {
        var stream4 = reader._ownerReadableStream;
        return ReadableStreamCancel(stream4, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        var stream4 = reader._ownerReadableStream;
        if (stream4._state === "readable") {
          defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
        } else {
          defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
        }
        stream4._readableStreamController[ReleaseSteps]();
        stream4._reader = void 0;
        reader._ownerReadableStream = void 0;
      }
      function readerLockException(name15) {
        return new TypeError("Cannot " + name15 + " a stream using a released reader");
      }
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise(function(resolve2, reject) {
          reader._closedPromise_resolve = resolve2;
          reader._closedPromise_reject = reject;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === void 0) {
          return;
        }
        reader._closedPromise_resolve(void 0);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      var NumberIsFinite = Number.isFinite || function(x) {
        return typeof x === "number" && isFinite(x);
      };
      var MathTrunc = Math.trunc || function(v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
      };
      function isDictionary(x) {
        return typeof x === "object" || typeof x === "function";
      }
      function assertDictionary(obj, context2) {
        if (obj !== void 0 && !isDictionary(obj)) {
          throw new TypeError("".concat(context2, " is not an object."));
        }
      }
      function assertFunction(x, context2) {
        if (typeof x !== "function") {
          throw new TypeError("".concat(context2, " is not a function."));
        }
      }
      function isObject3(x) {
        return typeof x === "object" && x !== null || typeof x === "function";
      }
      function assertObject(x, context2) {
        if (!isObject3(x)) {
          throw new TypeError("".concat(context2, " is not an object."));
        }
      }
      function assertRequiredArgument(x, position, context2) {
        if (x === void 0) {
          throw new TypeError("Parameter ".concat(position, " is required in '").concat(context2, "'."));
        }
      }
      function assertRequiredField(x, field, context2) {
        if (x === void 0) {
          throw new TypeError("".concat(field, " is required in '").concat(context2, "'."));
        }
      }
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x) {
        return x === 0 ? 0 : x;
      }
      function integerPart(x) {
        return censorNegativeZero(MathTrunc(x));
      }
      function convertUnsignedLongLongWithEnforceRange(value, context2) {
        var lowerBound = 0;
        var upperBound = Number.MAX_SAFE_INTEGER;
        var x = Number(value);
        x = censorNegativeZero(x);
        if (!NumberIsFinite(x)) {
          throw new TypeError("".concat(context2, " is not a finite number"));
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw new TypeError("".concat(context2, " is outside the accepted range of ").concat(lowerBound, " to ").concat(upperBound, ", inclusive"));
        }
        if (!NumberIsFinite(x) || x === 0) {
          return 0;
        }
        return x;
      }
      function assertReadableStream(x, context2) {
        if (!IsReadableStream(x)) {
          throw new TypeError("".concat(context2, " is not a ReadableStream."));
        }
      }
      function AcquireReadableStreamDefaultReader(stream4) {
        return new ReadableStreamDefaultReader2(stream4);
      }
      function ReadableStreamAddReadRequest(stream4, readRequest) {
        stream4._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream4, chunk, done) {
        var reader = stream4._reader;
        var readRequest = reader._readRequests.shift();
        if (done) {
          readRequest._closeSteps();
        } else {
          readRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadRequests(stream4) {
        return stream4._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream4) {
        var reader = stream4._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
          return false;
        }
        return true;
      }
      var ReadableStreamDefaultReader2 = (
        /** @class */
        function() {
          function ReadableStreamDefaultReader3(stream4) {
            assertRequiredArgument(stream4, 1, "ReadableStreamDefaultReader");
            assertReadableStream(stream4, "First parameter");
            if (IsReadableStreamLocked(stream4)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            ReadableStreamReaderGenericInitialize(this, stream4);
            this._readRequests = new SimpleQueue();
          }
          Object.defineProperty(ReadableStreamDefaultReader3.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed,
             * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
             */
            get: function() {
              if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
              }
              return this._closedPromise;
            },
            enumerable: false,
            configurable: true
          });
          ReadableStreamDefaultReader3.prototype.cancel = function(reason) {
            if (reason === void 0) {
              reason = void 0;
            }
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          };
          ReadableStreamDefaultReader3.prototype.read = function() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            var resolvePromise;
            var rejectPromise;
            var promise = newPromise(function(resolve2, reject) {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            var readRequest = {
              _chunkSteps: function(chunk) {
                return resolvePromise({ value: chunk, done: false });
              },
              _closeSteps: function() {
                return resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: function(e) {
                return rejectPromise(e);
              }
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
          };
          ReadableStreamDefaultReader3.prototype.releaseLock = function() {
            if (!IsReadableStreamDefaultReader(this)) {
              throw defaultReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            ReadableStreamDefaultReaderRelease(this);
          };
          return ReadableStreamDefaultReader3;
        }()
      );
      Object.defineProperties(ReadableStreamDefaultReader2.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      setFunctionName(ReadableStreamDefaultReader2.prototype.cancel, "cancel");
      setFunctionName(ReadableStreamDefaultReader2.prototype.read, "read");
      setFunctionName(ReadableStreamDefaultReader2.prototype.releaseLock, "releaseLock");
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultReader2.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamDefaultReader",
          configurable: true
        });
      }
      function IsReadableStreamDefaultReader(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
          return false;
        }
        return x instanceof ReadableStreamDefaultReader2;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        var stream4 = reader._ownerReadableStream;
        stream4._disturbed = true;
        if (stream4._state === "closed") {
          readRequest._closeSteps();
        } else if (stream4._state === "errored") {
          readRequest._errorSteps(stream4._storedError);
        } else {
          stream4._readableStreamController[PullSteps](readRequest);
        }
      }
      function ReadableStreamDefaultReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        var e = new TypeError("Reader was released");
        ReadableStreamDefaultReaderErrorReadRequests(reader, e);
      }
      function ReadableStreamDefaultReaderErrorReadRequests(reader, e) {
        var readRequests = reader._readRequests;
        reader._readRequests = new SimpleQueue();
        readRequests.forEach(function(readRequest) {
          readRequest._errorSteps(e);
        });
      }
      function defaultReaderBrandCheckException(name15) {
        return new TypeError("ReadableStreamDefaultReader.prototype.".concat(name15, " can only be used on a ReadableStreamDefaultReader"));
      }
      var _a$1, _b, _c;
      function CreateArrayFromList(elements) {
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src5, srcOffset, n2) {
        new Uint8Array(dest).set(new Uint8Array(src5, srcOffset, n2), destOffset);
      }
      var TransferArrayBuffer = function(O) {
        if (typeof O.transfer === "function") {
          TransferArrayBuffer = function(buffer3) {
            return buffer3.transfer();
          };
        } else if (typeof structuredClone === "function") {
          TransferArrayBuffer = function(buffer3) {
            return structuredClone(buffer3, { transfer: [buffer3] });
          };
        } else {
          TransferArrayBuffer = function(buffer3) {
            return buffer3;
          };
        }
        return TransferArrayBuffer(O);
      };
      var IsDetachedBuffer = function(O) {
        if (typeof O.detached === "boolean") {
          IsDetachedBuffer = function(buffer3) {
            return buffer3.detached;
          };
        } else {
          IsDetachedBuffer = function(buffer3) {
            return buffer3.byteLength === 0;
          };
        }
        return IsDetachedBuffer(O);
      };
      function ArrayBufferSlice(buffer3, begin, end) {
        if (buffer3.slice) {
          return buffer3.slice(begin, end);
        }
        var length5 = end - begin;
        var slice4 = new ArrayBuffer(length5);
        CopyDataBlockBytes(slice4, 0, buffer3, begin, length5);
        return slice4;
      }
      function GetMethod(receiver, prop) {
        var func = receiver[prop];
        if (func === void 0 || func === null) {
          return void 0;
        }
        if (typeof func !== "function") {
          throw new TypeError("".concat(String(prop), " is not a function"));
        }
        return func;
      }
      function CreateAsyncFromSyncIterator(syncIteratorRecord) {
        var _a4;
        var syncIterable = (_a4 = {}, _a4[SymbolPolyfill.iterator] = function() {
          return syncIteratorRecord.iterator;
        }, _a4);
        var asyncIterator2 = function() {
          return __asyncGenerator(this, arguments, function() {
            return __generator(this, function(_a5) {
              switch (_a5.label) {
                case 0:
                  return [5, __values(__asyncDelegator(__asyncValues(syncIterable)))];
                case 1:
                  return [4, __await.apply(void 0, [_a5.sent()])];
                case 2:
                  return [4, __await.apply(void 0, [_a5.sent()])];
                case 3:
                  return [2, _a5.sent()];
              }
            });
          });
        }();
        var nextMethod = asyncIterator2.next;
        return { iterator: asyncIterator2, nextMethod, done: false };
      }
      var SymbolAsyncIterator = (_c = (_a$1 = SymbolPolyfill.asyncIterator) !== null && _a$1 !== void 0 ? _a$1 : (_b = SymbolPolyfill.for) === null || _b === void 0 ? void 0 : _b.call(SymbolPolyfill, "Symbol.asyncIterator")) !== null && _c !== void 0 ? _c : "@@asyncIterator";
      function GetIterator(obj, hint, method) {
        if (hint === void 0) {
          hint = "sync";
        }
        if (method === void 0) {
          if (hint === "async") {
            method = GetMethod(obj, SymbolAsyncIterator);
            if (method === void 0) {
              var syncMethod = GetMethod(obj, SymbolPolyfill.iterator);
              var syncIteratorRecord = GetIterator(obj, "sync", syncMethod);
              return CreateAsyncFromSyncIterator(syncIteratorRecord);
            }
          } else {
            method = GetMethod(obj, SymbolPolyfill.iterator);
          }
        }
        if (method === void 0) {
          throw new TypeError("The object is not iterable");
        }
        var iterator = reflectCall(method, obj, []);
        if (!typeIsObject(iterator)) {
          throw new TypeError("The iterator method must return an object");
        }
        var nextMethod = iterator.next;
        return { iterator, nextMethod, done: false };
      }
      function IteratorNext(iteratorRecord) {
        var result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);
        if (!typeIsObject(result)) {
          throw new TypeError("The iterator.next() method must return an object");
        }
        return result;
      }
      function IteratorComplete(iterResult) {
        return Boolean(iterResult.done);
      }
      function IteratorValue(iterResult) {
        return iterResult.value;
      }
      var _a3;
      var AsyncIteratorPrototype = (_a3 = {}, // 25.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )
      // https://tc39.github.io/ecma262/#sec-asynciteratorprototype-asynciterator
      _a3[SymbolAsyncIterator] = function() {
        return this;
      }, _a3);
      Object.defineProperty(AsyncIteratorPrototype, SymbolAsyncIterator, { enumerable: false });
      var ReadableStreamAsyncIteratorImpl = (
        /** @class */
        function() {
          function ReadableStreamAsyncIteratorImpl2(reader, preventCancel) {
            this._ongoingPromise = void 0;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
          }
          ReadableStreamAsyncIteratorImpl2.prototype.next = function() {
            var _this = this;
            var nextSteps = function() {
              return _this._nextSteps();
            };
            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
            return this._ongoingPromise;
          };
          ReadableStreamAsyncIteratorImpl2.prototype.return = function(value) {
            var _this = this;
            var returnSteps = function() {
              return _this._returnSteps(value);
            };
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          };
          ReadableStreamAsyncIteratorImpl2.prototype._nextSteps = function() {
            var _this = this;
            if (this._isFinished) {
              return Promise.resolve({ value: void 0, done: true });
            }
            var reader = this._reader;
            var resolvePromise;
            var rejectPromise;
            var promise = newPromise(function(resolve2, reject) {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            var readRequest = {
              _chunkSteps: function(chunk) {
                _this._ongoingPromise = void 0;
                _queueMicrotask(function() {
                  return resolvePromise({ value: chunk, done: false });
                });
              },
              _closeSteps: function() {
                _this._ongoingPromise = void 0;
                _this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: function(reason) {
                _this._ongoingPromise = void 0;
                _this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                rejectPromise(reason);
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
          };
          ReadableStreamAsyncIteratorImpl2.prototype._returnSteps = function(value) {
            if (this._isFinished) {
              return Promise.resolve({ value, done: true });
            }
            this._isFinished = true;
            var reader = this._reader;
            if (!this._preventCancel) {
              var result = ReadableStreamReaderGenericCancel(reader, value);
              ReadableStreamReaderGenericRelease(reader);
              return transformPromiseWith(result, function() {
                return { value, done: true };
              });
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value, done: true });
          };
          return ReadableStreamAsyncIteratorImpl2;
        }()
      );
      var ReadableStreamAsyncIteratorPrototype = {
        next: function() {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
          }
          return this._asyncIteratorImpl.next();
        },
        return: function(value) {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
          }
          return this._asyncIteratorImpl.return(value);
        }
      };
      Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
      function AcquireReadableStreamAsyncIterator(stream4, preventCancel) {
        var reader = AcquireReadableStreamDefaultReader(stream4);
        var impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
      }
      function IsReadableStreamAsyncIterator(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) {
          return false;
        }
        try {
          return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
        } catch (_a4) {
          return false;
        }
      }
      function streamAsyncIteratorBrandCheckException(name15) {
        return new TypeError("ReadableStreamAsyncIterator.".concat(name15, " can only be used on a ReadableSteamAsyncIterator"));
      }
      var NumberIsNaN = Number.isNaN || function(x) {
        return x !== x;
      };
      function IsNonNegativeNumber(v) {
        if (typeof v !== "number") {
          return false;
        }
        if (NumberIsNaN(v)) {
          return false;
        }
        if (v < 0) {
          return false;
        }
        return true;
      }
      function CloneAsUint8Array(O) {
        var buffer3 = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer3);
      }
      function DequeueValue(container) {
        var pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
          container._queueTotalSize = 0;
        }
        return pair.value;
      }
      function EnqueueValueWithSize(container, value, size5) {
        if (!IsNonNegativeNumber(size5) || size5 === Infinity) {
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        }
        container._queue.push({ value, size: size5 });
        container._queueTotalSize += size5;
      }
      function PeekQueueValue(container) {
        var pair = container._queue.peek();
        return pair.value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
      }
      function isDataViewConstructor(ctor) {
        return ctor === DataView;
      }
      function isDataView(view6) {
        return isDataViewConstructor(view6.constructor);
      }
      function arrayBufferViewElementSize(ctor) {
        if (isDataViewConstructor(ctor)) {
          return 1;
        }
        return ctor.BYTES_PER_ELEMENT;
      }
      var ReadableStreamBYOBRequest2 = (
        /** @class */
        function() {
          function ReadableStreamBYOBRequest3() {
            throw new TypeError("Illegal constructor");
          }
          Object.defineProperty(ReadableStreamBYOBRequest3.prototype, "view", {
            /**
             * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
             */
            get: function() {
              if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException("view");
              }
              return this._view;
            },
            enumerable: false,
            configurable: true
          });
          ReadableStreamBYOBRequest3.prototype.respond = function(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respond");
            }
            assertRequiredArgument(bytesWritten, 1, "respond");
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(this._view.buffer)) {
              throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");
            }
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          };
          ReadableStreamBYOBRequest3.prototype.respondWithNewView = function(view6) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respondWithNewView");
            }
            assertRequiredArgument(view6, 1, "respondWithNewView");
            if (!ArrayBuffer.isView(view6)) {
              throw new TypeError("You can only respond with array buffer views");
            }
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(view6.buffer)) {
              throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
            }
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view6);
          };
          return ReadableStreamBYOBRequest3;
        }()
      );
      Object.defineProperties(ReadableStreamBYOBRequest2.prototype, {
        respond: { enumerable: true },
        respondWithNewView: { enumerable: true },
        view: { enumerable: true }
      });
      setFunctionName(ReadableStreamBYOBRequest2.prototype.respond, "respond");
      setFunctionName(ReadableStreamBYOBRequest2.prototype.respondWithNewView, "respondWithNewView");
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBRequest2.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamBYOBRequest",
          configurable: true
        });
      }
      var ReadableByteStreamController2 = (
        /** @class */
        function() {
          function ReadableByteStreamController3() {
            throw new TypeError("Illegal constructor");
          }
          Object.defineProperty(ReadableByteStreamController3.prototype, "byobRequest", {
            /**
             * Returns the current BYOB pull request, or `null` if there isn't one.
             */
            get: function() {
              if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException("byobRequest");
              }
              return ReadableByteStreamControllerGetBYOBRequest(this);
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(ReadableByteStreamController3.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
             * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
             */
            get: function() {
              if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException("desiredSize");
              }
              return ReadableByteStreamControllerGetDesiredSize(this);
            },
            enumerable: false,
            configurable: true
          });
          ReadableByteStreamController3.prototype.close = function() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("close");
            }
            if (this._closeRequested) {
              throw new TypeError("The stream has already been closed; do not close it again!");
            }
            var state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError("The stream (in ".concat(state, " state) is not in the readable state and cannot be closed"));
            }
            ReadableByteStreamControllerClose(this);
          };
          ReadableByteStreamController3.prototype.enqueue = function(chunk) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("enqueue");
            }
            assertRequiredArgument(chunk, 1, "enqueue");
            if (!ArrayBuffer.isView(chunk)) {
              throw new TypeError("chunk must be an array buffer view");
            }
            if (chunk.byteLength === 0) {
              throw new TypeError("chunk must have non-zero byteLength");
            }
            if (chunk.buffer.byteLength === 0) {
              throw new TypeError("chunk's buffer must have non-zero byteLength");
            }
            if (this._closeRequested) {
              throw new TypeError("stream is closed or draining");
            }
            var state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError("The stream (in ".concat(state, " state) is not in the readable state and cannot be enqueued to"));
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
          };
          ReadableByteStreamController3.prototype.error = function(e) {
            if (e === void 0) {
              e = void 0;
            }
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("error");
            }
            ReadableByteStreamControllerError(this, e);
          };
          ReadableByteStreamController3.prototype[CancelSteps] = function(reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            var result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
          };
          ReadableByteStreamController3.prototype[PullSteps] = function(readRequest) {
            var stream4 = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);
              return;
            }
            var autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              var buffer3 = void 0;
              try {
                buffer3 = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              var pullIntoDescriptor = {
                buffer: buffer3,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                minimumFill: 1,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream4, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
          };
          ReadableByteStreamController3.prototype[ReleaseSteps] = function() {
            if (this._pendingPullIntos.length > 0) {
              var firstPullInto = this._pendingPullIntos.peek();
              firstPullInto.readerType = "none";
              this._pendingPullIntos = new SimpleQueue();
              this._pendingPullIntos.push(firstPullInto);
            }
          };
          return ReadableByteStreamController3;
        }()
      );
      Object.defineProperties(ReadableByteStreamController2.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        byobRequest: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(ReadableByteStreamController2.prototype.close, "close");
      setFunctionName(ReadableByteStreamController2.prototype.enqueue, "enqueue");
      setFunctionName(ReadableByteStreamController2.prototype.error, "error");
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableByteStreamController2.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableByteStreamController",
          configurable: true
        });
      }
      function IsReadableByteStreamController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream")) {
          return false;
        }
        return x instanceof ReadableByteStreamController2;
      }
      function IsReadableStreamBYOBRequest(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
          return false;
        }
        return x instanceof ReadableStreamBYOBRequest2;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        var pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, function() {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
          return null;
        }, function(e) {
          ReadableByteStreamControllerError(controller, e);
          return null;
        });
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream4, pullIntoDescriptor) {
        var done = false;
        if (stream4._state === "closed") {
          done = true;
        }
        var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "default") {
          ReadableStreamFulfillReadRequest(stream4, filledView, done);
        } else {
          ReadableStreamFulfillReadIntoRequest(stream4, filledView, done);
        }
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        var bytesFilled = pullIntoDescriptor.bytesFilled;
        var elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer3, byteOffset, byteLength) {
        controller._queue.push({ buffer: buffer3, byteOffset, byteLength });
        controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, buffer3, byteOffset, byteLength) {
        var clonedChunk;
        try {
          clonedChunk = ArrayBufferSlice(buffer3, byteOffset, byteOffset + byteLength);
        } catch (cloneE) {
          ReadableByteStreamControllerError(controller, cloneE);
          throw cloneE;
        }
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength);
      }
      function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {
        if (firstDescriptor.bytesFilled > 0) {
          ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
        var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        var totalBytesToCopyRemaining = maxBytesToCopy;
        var ready = false;
        var remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;
        var maxAlignedBytes = maxBytesFilled - remainderBytes;
        if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {
          totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
          ready = true;
        }
        var queue = controller._queue;
        while (totalBytesToCopyRemaining > 0) {
          var headOfQueue = queue.peek();
          var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
          var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
          if (headOfQueue.byteLength === bytesToCopy) {
            queue.shift();
          } else {
            headOfQueue.byteOffset += bytesToCopy;
            headOfQueue.byteLength -= bytesToCopy;
          }
          controller._queueTotalSize -= bytesToCopy;
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
          totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size5, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size5;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(controller._controlledReadableByteStream);
        } else {
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
          return;
        }
        controller._byobRequest._associatedReadableByteStreamController = void 0;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        while (controller._pendingPullIntos.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          var pullIntoDescriptor = controller._pendingPullIntos.peek();
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {
        var reader = controller._controlledReadableByteStream._reader;
        while (reader._readRequests.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          var readRequest = reader._readRequests.shift();
          ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);
        }
      }
      function ReadableByteStreamControllerPullInto(controller, view6, min, readIntoRequest) {
        var stream4 = controller._controlledReadableByteStream;
        var ctor = view6.constructor;
        var elementSize = arrayBufferViewElementSize(ctor);
        var byteOffset = view6.byteOffset, byteLength = view6.byteLength;
        var minimumFill = min * elementSize;
        var buffer3;
        try {
          buffer3 = TransferArrayBuffer(view6.buffer);
        } catch (e2) {
          readIntoRequest._errorSteps(e2);
          return;
        }
        var pullIntoDescriptor = {
          buffer: buffer3,
          bufferByteLength: buffer3.byteLength,
          byteOffset,
          byteLength,
          bytesFilled: 0,
          minimumFill,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream4, readIntoRequest);
          return;
        }
        if (stream4._state === "closed") {
          var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            ReadableByteStreamControllerHandleQueueDrain(controller);
            readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e);
            readIntoRequest._errorSteps(e);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream4, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        if (firstDescriptor.readerType === "none") {
          ReadableByteStreamControllerShiftPendingPullInto(controller);
        }
        var stream4 = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream4)) {
          while (ReadableStreamGetNumReadIntoRequests(stream4) > 0) {
            var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(stream4, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "none") {
          ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          return;
        }
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {
          return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
          var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, pullIntoDescriptor.buffer, end - remainderSize, remainderSize);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      }
      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        var state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
        } else {
          ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        var descriptor = controller._pendingPullIntos.shift();
        return descriptor;
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        var stream4 = controller._controlledReadableByteStream;
        if (stream4._state !== "readable") {
          return false;
        }
        if (controller._closeRequested) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (ReadableStreamHasDefaultReader(stream4) && ReadableStreamGetNumReadRequests(stream4) > 0) {
          return true;
        }
        if (ReadableStreamHasBYOBReader(stream4) && ReadableStreamGetNumReadIntoRequests(stream4) > 0) {
          return true;
        }
        var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function ReadableByteStreamControllerClose(controller) {
        var stream4 = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream4._state !== "readable") {
          return;
        }
        if (controller._queueTotalSize > 0) {
          controller._closeRequested = true;
          return;
        }
        if (controller._pendingPullIntos.length > 0) {
          var firstPendingPullInto = controller._pendingPullIntos.peek();
          if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize !== 0) {
            var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e);
            throw e;
          }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream4);
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        var stream4 = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream4._state !== "readable") {
          return;
        }
        var buffer3 = chunk.buffer, byteOffset = chunk.byteOffset, byteLength = chunk.byteLength;
        if (IsDetachedBuffer(buffer3)) {
          throw new TypeError("chunk's buffer is detached and so cannot be enqueued");
        }
        var transferredBuffer = TransferArrayBuffer(buffer3);
        if (controller._pendingPullIntos.length > 0) {
          var firstPendingPullInto = controller._pendingPullIntos.peek();
          if (IsDetachedBuffer(firstPendingPullInto.buffer)) {
            throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          if (firstPendingPullInto.readerType === "none") {
            ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);
          }
        }
        if (ReadableStreamHasDefaultReader(stream4)) {
          ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);
          if (ReadableStreamGetNumReadRequests(stream4) === 0) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          } else {
            if (controller._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
            }
            var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
            ReadableStreamFulfillReadRequest(stream4, transferredView, false);
          }
        } else if (ReadableStreamHasBYOBReader(stream4)) {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        } else {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerError(controller, e) {
        var stream4 = controller._controlledReadableByteStream;
        if (stream4._state !== "readable") {
          return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream4, e);
      }
      function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {
        var entry = controller._queue.shift();
        controller._queueTotalSize -= entry.byteLength;
        ReadableByteStreamControllerHandleQueueDrain(controller);
        var view6 = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
        readRequest._chunkSteps(view6);
      }
      function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
          var firstDescriptor = controller._pendingPullIntos.peek();
          var view6 = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
          var byobRequest = Object.create(ReadableStreamBYOBRequest2.prototype);
          SetUpReadableStreamBYOBRequest(byobRequest, controller, view6);
          controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        var state = controller._controlledReadableByteStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        var state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (bytesWritten !== 0) {
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
          }
        } else {
          if (bytesWritten === 0) {
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          }
          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
            throw new RangeError("bytesWritten out of range");
          }
        }
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(controller, view6) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        var state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (view6.byteLength !== 0) {
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
          }
        } else {
          if (view6.byteLength === 0) {
            throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
          }
        }
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view6.byteOffset) {
          throw new RangeError("The region specified by view does not match byobRequest");
        }
        if (firstDescriptor.bufferByteLength !== view6.buffer.byteLength) {
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        }
        if (firstDescriptor.bytesFilled + view6.byteLength > firstDescriptor.byteLength) {
          throw new RangeError("The region specified by view is larger than byobRequest");
        }
        var viewByteLength = view6.byteLength;
        firstDescriptor.buffer = TransferArrayBuffer(view6.buffer);
        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
      }
      function SetUpReadableByteStreamController(stream4, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream4;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        controller._queue = controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream4._readableStreamController = controller;
        var startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), function() {
          controller._started = true;
          ReadableByteStreamControllerCallPullIfNeeded(controller);
          return null;
        }, function(r) {
          ReadableByteStreamControllerError(controller, r);
          return null;
        });
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream4, underlyingByteSource, highWaterMark) {
        var controller = Object.create(ReadableByteStreamController2.prototype);
        var startAlgorithm;
        var pullAlgorithm;
        var cancelAlgorithm;
        if (underlyingByteSource.start !== void 0) {
          startAlgorithm = function() {
            return underlyingByteSource.start(controller);
          };
        } else {
          startAlgorithm = function() {
            return void 0;
          };
        }
        if (underlyingByteSource.pull !== void 0) {
          pullAlgorithm = function() {
            return underlyingByteSource.pull(controller);
          };
        } else {
          pullAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
        }
        if (underlyingByteSource.cancel !== void 0) {
          cancelAlgorithm = function(reason) {
            return underlyingByteSource.cancel(reason);
          };
        } else {
          cancelAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
        }
        var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        }
        SetUpReadableByteStreamController(stream4, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
      }
      function SetUpReadableStreamBYOBRequest(request, controller, view6) {
        request._associatedReadableByteStreamController = controller;
        request._view = view6;
      }
      function byobRequestBrandCheckException(name15) {
        return new TypeError("ReadableStreamBYOBRequest.prototype.".concat(name15, " can only be used on a ReadableStreamBYOBRequest"));
      }
      function byteStreamControllerBrandCheckException(name15) {
        return new TypeError("ReadableByteStreamController.prototype.".concat(name15, " can only be used on a ReadableByteStreamController"));
      }
      function convertReaderOptions(options, context2) {
        assertDictionary(options, context2);
        var mode = options === null || options === void 0 ? void 0 : options.mode;
        return {
          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, "".concat(context2, " has member 'mode' that"))
        };
      }
      function convertReadableStreamReaderMode(mode, context2) {
        mode = "".concat(mode);
        if (mode !== "byob") {
          throw new TypeError("".concat(context2, " '").concat(mode, "' is not a valid enumeration value for ReadableStreamReaderMode"));
        }
        return mode;
      }
      function convertByobReadOptions(options, context2) {
        var _a4;
        assertDictionary(options, context2);
        var min = (_a4 = options === null || options === void 0 ? void 0 : options.min) !== null && _a4 !== void 0 ? _a4 : 1;
        return {
          min: convertUnsignedLongLongWithEnforceRange(min, "".concat(context2, " has member 'min' that"))
        };
      }
      function AcquireReadableStreamBYOBReader(stream4) {
        return new ReadableStreamBYOBReader2(stream4);
      }
      function ReadableStreamAddReadIntoRequest(stream4, readIntoRequest) {
        stream4._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream4, chunk, done) {
        var reader = stream4._reader;
        var readIntoRequest = reader._readIntoRequests.shift();
        if (done) {
          readIntoRequest._closeSteps(chunk);
        } else {
          readIntoRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadIntoRequests(stream4) {
        return stream4._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream4) {
        var reader = stream4._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
          return false;
        }
        return true;
      }
      var ReadableStreamBYOBReader2 = (
        /** @class */
        function() {
          function ReadableStreamBYOBReader3(stream4) {
            assertRequiredArgument(stream4, 1, "ReadableStreamBYOBReader");
            assertReadableStream(stream4, "First parameter");
            if (IsReadableStreamLocked(stream4)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            if (!IsReadableByteStreamController(stream4._readableStreamController)) {
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            }
            ReadableStreamReaderGenericInitialize(this, stream4);
            this._readIntoRequests = new SimpleQueue();
          }
          Object.defineProperty(ReadableStreamBYOBReader3.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
             * the reader's lock is released before the stream finishes closing.
             */
            get: function() {
              if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException("closed"));
              }
              return this._closedPromise;
            },
            enumerable: false,
            configurable: true
          });
          ReadableStreamBYOBReader3.prototype.cancel = function(reason) {
            if (reason === void 0) {
              reason = void 0;
            }
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          };
          ReadableStreamBYOBReader3.prototype.read = function(view6, rawOptions) {
            if (rawOptions === void 0) {
              rawOptions = {};
            }
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            }
            if (!ArrayBuffer.isView(view6)) {
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            }
            if (view6.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            }
            if (view6.buffer.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
            }
            if (IsDetachedBuffer(view6.buffer)) {
              return promiseRejectedWith(new TypeError("view's buffer has been detached"));
            }
            var options;
            try {
              options = convertByobReadOptions(rawOptions, "options");
            } catch (e) {
              return promiseRejectedWith(e);
            }
            var min = options.min;
            if (min === 0) {
              return promiseRejectedWith(new TypeError("options.min must be greater than 0"));
            }
            if (!isDataView(view6)) {
              if (min > view6.length) {
                return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's length"));
              }
            } else if (min > view6.byteLength) {
              return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's byteLength"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            var resolvePromise;
            var rejectPromise;
            var promise = newPromise(function(resolve2, reject) {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            var readIntoRequest = {
              _chunkSteps: function(chunk) {
                return resolvePromise({ value: chunk, done: false });
              },
              _closeSteps: function(chunk) {
                return resolvePromise({ value: chunk, done: true });
              },
              _errorSteps: function(e) {
                return rejectPromise(e);
              }
            };
            ReadableStreamBYOBReaderRead(this, view6, min, readIntoRequest);
            return promise;
          };
          ReadableStreamBYOBReader3.prototype.releaseLock = function() {
            if (!IsReadableStreamBYOBReader(this)) {
              throw byobReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            ReadableStreamBYOBReaderRelease(this);
          };
          return ReadableStreamBYOBReader3;
        }()
      );
      Object.defineProperties(ReadableStreamBYOBReader2.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      setFunctionName(ReadableStreamBYOBReader2.prototype.cancel, "cancel");
      setFunctionName(ReadableStreamBYOBReader2.prototype.read, "read");
      setFunctionName(ReadableStreamBYOBReader2.prototype.releaseLock, "releaseLock");
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBReader2.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamBYOBReader",
          configurable: true
        });
      }
      function IsReadableStreamBYOBReader(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
          return false;
        }
        return x instanceof ReadableStreamBYOBReader2;
      }
      function ReadableStreamBYOBReaderRead(reader, view6, min, readIntoRequest) {
        var stream4 = reader._ownerReadableStream;
        stream4._disturbed = true;
        if (stream4._state === "errored") {
          readIntoRequest._errorSteps(stream4._storedError);
        } else {
          ReadableByteStreamControllerPullInto(stream4._readableStreamController, view6, min, readIntoRequest);
        }
      }
      function ReadableStreamBYOBReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        var e = new TypeError("Reader was released");
        ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);
      }
      function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e) {
        var readIntoRequests = reader._readIntoRequests;
        reader._readIntoRequests = new SimpleQueue();
        readIntoRequests.forEach(function(readIntoRequest) {
          readIntoRequest._errorSteps(e);
        });
      }
      function byobReaderBrandCheckException(name15) {
        return new TypeError("ReadableStreamBYOBReader.prototype.".concat(name15, " can only be used on a ReadableStreamBYOBReader"));
      }
      function ExtractHighWaterMark(strategy, defaultHWM) {
        var highWaterMark = strategy.highWaterMark;
        if (highWaterMark === void 0) {
          return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
          throw new RangeError("Invalid highWaterMark");
        }
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        var size5 = strategy.size;
        if (!size5) {
          return function() {
            return 1;
          };
        }
        return size5;
      }
      function convertQueuingStrategy(init2, context2) {
        assertDictionary(init2, context2);
        var highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
        var size5 = init2 === null || init2 === void 0 ? void 0 : init2.size;
        return {
          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
          size: size5 === void 0 ? void 0 : convertQueuingStrategySize(size5, "".concat(context2, " has member 'size' that"))
        };
      }
      function convertQueuingStrategySize(fn, context2) {
        assertFunction(fn, context2);
        return function(chunk) {
          return convertUnrestrictedDouble(fn(chunk));
        };
      }
      function convertUnderlyingSink(original, context2) {
        assertDictionary(original, context2);
        var abort2 = original === null || original === void 0 ? void 0 : original.abort;
        var close9 = original === null || original === void 0 ? void 0 : original.close;
        var start = original === null || original === void 0 ? void 0 : original.start;
        var type2 = original === null || original === void 0 ? void 0 : original.type;
        var write8 = original === null || original === void 0 ? void 0 : original.write;
        return {
          abort: abort2 === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort2, original, "".concat(context2, " has member 'abort' that")),
          close: close9 === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close9, original, "".concat(context2, " has member 'close' that")),
          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, "".concat(context2, " has member 'start' that")),
          write: write8 === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write8, original, "".concat(context2, " has member 'write' that")),
          type: type2
        };
      }
      function convertUnderlyingSinkAbortCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return function(reason) {
          return promiseCall(fn, original, [reason]);
        };
      }
      function convertUnderlyingSinkCloseCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return function() {
          return promiseCall(fn, original, []);
        };
      }
      function convertUnderlyingSinkStartCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return function(controller) {
          return reflectCall(fn, original, [controller]);
        };
      }
      function convertUnderlyingSinkWriteCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return function(chunk, controller) {
          return promiseCall(fn, original, [chunk, controller]);
        };
      }
      function assertWritableStream(x, context2) {
        if (!IsWritableStream(x)) {
          throw new TypeError("".concat(context2, " is not a WritableStream."));
        }
      }
      function isAbortSignal(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        try {
          return typeof value.aborted === "boolean";
        } catch (_a4) {
          return false;
        }
      }
      var supportsAbortController = typeof AbortController === "function";
      function createAbortController() {
        if (supportsAbortController) {
          return new AbortController();
        }
        return void 0;
      }
      var WritableStream3 = (
        /** @class */
        function() {
          function WritableStream4(rawUnderlyingSink, rawStrategy) {
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = {};
            }
            if (rawStrategy === void 0) {
              rawStrategy = {};
            }
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = null;
            } else {
              assertObject(rawUnderlyingSink, "First parameter");
            }
            var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            var underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            var type2 = underlyingSink.type;
            if (type2 !== void 0) {
              throw new RangeError("Invalid type is specified");
            }
            var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            var highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          Object.defineProperty(WritableStream4.prototype, "locked", {
            /**
             * Returns whether or not the writable stream is locked to a writer.
             */
            get: function() {
              if (!IsWritableStream(this)) {
                throw streamBrandCheckException$2("locked");
              }
              return IsWritableStreamLocked(this);
            },
            enumerable: false,
            configurable: true
          });
          WritableStream4.prototype.abort = function(reason) {
            if (reason === void 0) {
              reason = void 0;
            }
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("abort"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
            }
            return WritableStreamAbort(this, reason);
          };
          WritableStream4.prototype.close = function() {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("close"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamClose(this);
          };
          WritableStream4.prototype.getWriter = function() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("getWriter");
            }
            return AcquireWritableStreamDefaultWriter(this);
          };
          return WritableStream4;
        }()
      );
      Object.defineProperties(WritableStream3.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        getWriter: { enumerable: true },
        locked: { enumerable: true }
      });
      setFunctionName(WritableStream3.prototype.abort, "abort");
      setFunctionName(WritableStream3.prototype.close, "close");
      setFunctionName(WritableStream3.prototype.getWriter, "getWriter");
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStream3.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStream",
          configurable: true
        });
      }
      function AcquireWritableStreamDefaultWriter(stream4) {
        return new WritableStreamDefaultWriter2(stream4);
      }
      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        if (highWaterMark === void 0) {
          highWaterMark = 1;
        }
        if (sizeAlgorithm === void 0) {
          sizeAlgorithm = function() {
            return 1;
          };
        }
        var stream4 = Object.create(WritableStream3.prototype);
        InitializeWritableStream(stream4);
        var controller = Object.create(WritableStreamDefaultController2.prototype);
        SetUpWritableStreamDefaultController(stream4, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        return stream4;
      }
      function InitializeWritableStream(stream4) {
        stream4._state = "writable";
        stream4._storedError = void 0;
        stream4._writer = void 0;
        stream4._writableStreamController = void 0;
        stream4._writeRequests = new SimpleQueue();
        stream4._inFlightWriteRequest = void 0;
        stream4._closeRequest = void 0;
        stream4._inFlightCloseRequest = void 0;
        stream4._pendingAbortRequest = void 0;
        stream4._backpressure = false;
      }
      function IsWritableStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
          return false;
        }
        return x instanceof WritableStream3;
      }
      function IsWritableStreamLocked(stream4) {
        if (stream4._writer === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamAbort(stream4, reason) {
        var _a4;
        if (stream4._state === "closed" || stream4._state === "errored") {
          return promiseResolvedWith(void 0);
        }
        stream4._writableStreamController._abortReason = reason;
        (_a4 = stream4._writableStreamController._abortController) === null || _a4 === void 0 ? void 0 : _a4.abort(reason);
        var state = stream4._state;
        if (state === "closed" || state === "errored") {
          return promiseResolvedWith(void 0);
        }
        if (stream4._pendingAbortRequest !== void 0) {
          return stream4._pendingAbortRequest._promise;
        }
        var wasAlreadyErroring = false;
        if (state === "erroring") {
          wasAlreadyErroring = true;
          reason = void 0;
        }
        var promise = newPromise(function(resolve2, reject) {
          stream4._pendingAbortRequest = {
            _promise: void 0,
            _resolve: resolve2,
            _reject: reject,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring
          };
        });
        stream4._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
          WritableStreamStartErroring(stream4, reason);
        }
        return promise;
      }
      function WritableStreamClose(stream4) {
        var state = stream4._state;
        if (state === "closed" || state === "errored") {
          return promiseRejectedWith(new TypeError("The stream (in ".concat(state, " state) is not in the writable state and cannot be closed")));
        }
        var promise = newPromise(function(resolve2, reject) {
          var closeRequest = {
            _resolve: resolve2,
            _reject: reject
          };
          stream4._closeRequest = closeRequest;
        });
        var writer = stream4._writer;
        if (writer !== void 0 && stream4._backpressure && state === "writable") {
          defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream4._writableStreamController);
        return promise;
      }
      function WritableStreamAddWriteRequest(stream4) {
        var promise = newPromise(function(resolve2, reject) {
          var writeRequest = {
            _resolve: resolve2,
            _reject: reject
          };
          stream4._writeRequests.push(writeRequest);
        });
        return promise;
      }
      function WritableStreamDealWithRejection(stream4, error3) {
        var state = stream4._state;
        if (state === "writable") {
          WritableStreamStartErroring(stream4, error3);
          return;
        }
        WritableStreamFinishErroring(stream4);
      }
      function WritableStreamStartErroring(stream4, reason) {
        var controller = stream4._writableStreamController;
        stream4._state = "erroring";
        stream4._storedError = reason;
        var writer = stream4._writer;
        if (writer !== void 0) {
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (!WritableStreamHasOperationMarkedInFlight(stream4) && controller._started) {
          WritableStreamFinishErroring(stream4);
        }
      }
      function WritableStreamFinishErroring(stream4) {
        stream4._state = "errored";
        stream4._writableStreamController[ErrorSteps]();
        var storedError = stream4._storedError;
        stream4._writeRequests.forEach(function(writeRequest) {
          writeRequest._reject(storedError);
        });
        stream4._writeRequests = new SimpleQueue();
        if (stream4._pendingAbortRequest === void 0) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream4);
          return;
        }
        var abortRequest = stream4._pendingAbortRequest;
        stream4._pendingAbortRequest = void 0;
        if (abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream4);
          return;
        }
        var promise = stream4._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, function() {
          abortRequest._resolve();
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream4);
          return null;
        }, function(reason) {
          abortRequest._reject(reason);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream4);
          return null;
        });
      }
      function WritableStreamFinishInFlightWrite(stream4) {
        stream4._inFlightWriteRequest._resolve(void 0);
        stream4._inFlightWriteRequest = void 0;
      }
      function WritableStreamFinishInFlightWriteWithError(stream4, error3) {
        stream4._inFlightWriteRequest._reject(error3);
        stream4._inFlightWriteRequest = void 0;
        WritableStreamDealWithRejection(stream4, error3);
      }
      function WritableStreamFinishInFlightClose(stream4) {
        stream4._inFlightCloseRequest._resolve(void 0);
        stream4._inFlightCloseRequest = void 0;
        var state = stream4._state;
        if (state === "erroring") {
          stream4._storedError = void 0;
          if (stream4._pendingAbortRequest !== void 0) {
            stream4._pendingAbortRequest._resolve();
            stream4._pendingAbortRequest = void 0;
          }
        }
        stream4._state = "closed";
        var writer = stream4._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseResolve(writer);
        }
      }
      function WritableStreamFinishInFlightCloseWithError(stream4, error3) {
        stream4._inFlightCloseRequest._reject(error3);
        stream4._inFlightCloseRequest = void 0;
        if (stream4._pendingAbortRequest !== void 0) {
          stream4._pendingAbortRequest._reject(error3);
          stream4._pendingAbortRequest = void 0;
        }
        WritableStreamDealWithRejection(stream4, error3);
      }
      function WritableStreamCloseQueuedOrInFlight(stream4) {
        if (stream4._closeRequest === void 0 && stream4._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamHasOperationMarkedInFlight(stream4) {
        if (stream4._inFlightWriteRequest === void 0 && stream4._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamMarkCloseRequestInFlight(stream4) {
        stream4._inFlightCloseRequest = stream4._closeRequest;
        stream4._closeRequest = void 0;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream4) {
        stream4._inFlightWriteRequest = stream4._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream4) {
        if (stream4._closeRequest !== void 0) {
          stream4._closeRequest._reject(stream4._storedError);
          stream4._closeRequest = void 0;
        }
        var writer = stream4._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseReject(writer, stream4._storedError);
        }
      }
      function WritableStreamUpdateBackpressure(stream4, backpressure) {
        var writer = stream4._writer;
        if (writer !== void 0 && backpressure !== stream4._backpressure) {
          if (backpressure) {
            defaultWriterReadyPromiseReset(writer);
          } else {
            defaultWriterReadyPromiseResolve(writer);
          }
        }
        stream4._backpressure = backpressure;
      }
      var WritableStreamDefaultWriter2 = (
        /** @class */
        function() {
          function WritableStreamDefaultWriter3(stream4) {
            assertRequiredArgument(stream4, 1, "WritableStreamDefaultWriter");
            assertWritableStream(stream4, "First parameter");
            if (IsWritableStreamLocked(stream4)) {
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            }
            this._ownerWritableStream = stream4;
            stream4._writer = this;
            var state = stream4._state;
            if (state === "writable") {
              if (!WritableStreamCloseQueuedOrInFlight(stream4) && stream4._backpressure) {
                defaultWriterReadyPromiseInitialize(this);
              } else {
                defaultWriterReadyPromiseInitializeAsResolved(this);
              }
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "erroring") {
              defaultWriterReadyPromiseInitializeAsRejected(this, stream4._storedError);
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "closed") {
              defaultWriterReadyPromiseInitializeAsResolved(this);
              defaultWriterClosedPromiseInitializeAsResolved(this);
            } else {
              var storedError = stream4._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
              defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          Object.defineProperty(WritableStreamDefaultWriter3.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
             * the writer’s lock is released before the stream finishes closing.
             */
            get: function() {
              if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
              }
              return this._closedPromise;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(WritableStreamDefaultWriter3.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.
             * A producer can use this information to determine the right amount of data to write.
             *
             * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
             * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
             * the writer’s lock is released.
             */
            get: function() {
              if (!IsWritableStreamDefaultWriter(this)) {
                throw defaultWriterBrandCheckException("desiredSize");
              }
              if (this._ownerWritableStream === void 0) {
                throw defaultWriterLockException("desiredSize");
              }
              return WritableStreamDefaultWriterGetDesiredSize(this);
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(WritableStreamDefaultWriter3.prototype, "ready", {
            /**
             * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions
             * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
             * back to zero or below, the getter will return a new promise that stays pending until the next transition.
             *
             * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become
             * rejected.
             */
            get: function() {
              if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
              }
              return this._readyPromise;
            },
            enumerable: false,
            configurable: true
          });
          WritableStreamDefaultWriter3.prototype.abort = function(reason) {
            if (reason === void 0) {
              reason = void 0;
            }
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("abort"));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
          };
          WritableStreamDefaultWriter3.prototype.close = function() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            }
            var stream4 = this._ownerWritableStream;
            if (stream4 === void 0) {
              return promiseRejectedWith(defaultWriterLockException("close"));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream4)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamDefaultWriterClose(this);
          };
          WritableStreamDefaultWriter3.prototype.releaseLock = function() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("releaseLock");
            }
            var stream4 = this._ownerWritableStream;
            if (stream4 === void 0) {
              return;
            }
            WritableStreamDefaultWriterRelease(this);
          };
          WritableStreamDefaultWriter3.prototype.write = function(chunk) {
            if (chunk === void 0) {
              chunk = void 0;
            }
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("write"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("write to"));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
          };
          return WritableStreamDefaultWriter3;
        }()
      );
      Object.defineProperties(WritableStreamDefaultWriter2.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        releaseLock: { enumerable: true },
        write: { enumerable: true },
        closed: { enumerable: true },
        desiredSize: { enumerable: true },
        ready: { enumerable: true }
      });
      setFunctionName(WritableStreamDefaultWriter2.prototype.abort, "abort");
      setFunctionName(WritableStreamDefaultWriter2.prototype.close, "close");
      setFunctionName(WritableStreamDefaultWriter2.prototype.releaseLock, "releaseLock");
      setFunctionName(WritableStreamDefaultWriter2.prototype.write, "write");
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultWriter2.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStreamDefaultWriter",
          configurable: true
        });
      }
      function IsWritableStreamDefaultWriter(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
          return false;
        }
        return x instanceof WritableStreamDefaultWriter2;
      }
      function WritableStreamDefaultWriterAbort(writer, reason) {
        var stream4 = writer._ownerWritableStream;
        return WritableStreamAbort(stream4, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        var stream4 = writer._ownerWritableStream;
        return WritableStreamClose(stream4);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        var stream4 = writer._ownerWritableStream;
        var state = stream4._state;
        if (WritableStreamCloseQueuedOrInFlight(stream4) || state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (state === "errored") {
          return promiseRejectedWith(stream4._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error3) {
        if (writer._closedPromiseState === "pending") {
          defaultWriterClosedPromiseReject(writer, error3);
        } else {
          defaultWriterClosedPromiseResetToRejected(writer, error3);
        }
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error3) {
        if (writer._readyPromiseState === "pending") {
          defaultWriterReadyPromiseReject(writer, error3);
        } else {
          defaultWriterReadyPromiseResetToRejected(writer, error3);
        }
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        var stream4 = writer._ownerWritableStream;
        var state = stream4._state;
        if (state === "errored" || state === "erroring") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(stream4._writableStreamController);
      }
      function WritableStreamDefaultWriterRelease(writer) {
        var stream4 = writer._ownerWritableStream;
        var releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
        stream4._writer = void 0;
        writer._ownerWritableStream = void 0;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        var stream4 = writer._ownerWritableStream;
        var controller = stream4._writableStreamController;
        var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream4 !== writer._ownerWritableStream) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        var state = stream4._state;
        if (state === "errored") {
          return promiseRejectedWith(stream4._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream4) || state === "closed") {
          return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        }
        if (state === "erroring") {
          return promiseRejectedWith(stream4._storedError);
        }
        var promise = WritableStreamAddWriteRequest(stream4);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
        return promise;
      }
      var closeSentinel = {};
      var WritableStreamDefaultController2 = (
        /** @class */
        function() {
          function WritableStreamDefaultController3() {
            throw new TypeError("Illegal constructor");
          }
          Object.defineProperty(WritableStreamDefaultController3.prototype, "abortReason", {
            /**
             * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
             *
             * @deprecated
             *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
             *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
             */
            get: function() {
              if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2("abortReason");
              }
              return this._abortReason;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(WritableStreamDefaultController3.prototype, "signal", {
            /**
             * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
             */
            get: function() {
              if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2("signal");
              }
              if (this._abortController === void 0) {
                throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
              }
              return this._abortController.signal;
            },
            enumerable: false,
            configurable: true
          });
          WritableStreamDefaultController3.prototype.error = function(e) {
            if (e === void 0) {
              e = void 0;
            }
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("error");
            }
            var state = this._controlledWritableStream._state;
            if (state !== "writable") {
              return;
            }
            WritableStreamDefaultControllerError(this, e);
          };
          WritableStreamDefaultController3.prototype[AbortSteps] = function(reason) {
            var result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
          };
          WritableStreamDefaultController3.prototype[ErrorSteps] = function() {
            ResetQueue(this);
          };
          return WritableStreamDefaultController3;
        }()
      );
      Object.defineProperties(WritableStreamDefaultController2.prototype, {
        abortReason: { enumerable: true },
        signal: { enumerable: true },
        error: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultController2.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStreamDefaultController",
          configurable: true
        });
      }
      function IsWritableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")) {
          return false;
        }
        return x instanceof WritableStreamDefaultController2;
      }
      function SetUpWritableStreamDefaultController(stream4, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream4;
        stream4._writableStreamController = controller;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._abortReason = void 0;
        controller._abortController = createAbortController();
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream4, backpressure);
        var startResult = startAlgorithm();
        var startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, function() {
          controller._started = true;
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          return null;
        }, function(r) {
          controller._started = true;
          WritableStreamDealWithRejection(stream4, r);
          return null;
        });
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream4, underlyingSink, highWaterMark, sizeAlgorithm) {
        var controller = Object.create(WritableStreamDefaultController2.prototype);
        var startAlgorithm;
        var writeAlgorithm;
        var closeAlgorithm;
        var abortAlgorithm;
        if (underlyingSink.start !== void 0) {
          startAlgorithm = function() {
            return underlyingSink.start(controller);
          };
        } else {
          startAlgorithm = function() {
            return void 0;
          };
        }
        if (underlyingSink.write !== void 0) {
          writeAlgorithm = function(chunk) {
            return underlyingSink.write(chunk, controller);
          };
        } else {
          writeAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
        }
        if (underlyingSink.close !== void 0) {
          closeAlgorithm = function() {
            return underlyingSink.close();
          };
        } else {
          closeAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
        }
        if (underlyingSink.abort !== void 0) {
          abortAlgorithm = function(reason) {
            return underlyingSink.abort(reason);
          };
        } else {
          abortAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
        }
        SetUpWritableStreamDefaultController(stream4, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = void 0;
        controller._closeAlgorithm = void 0;
        controller._abortAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
          return 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        var stream4 = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream4) && stream4._state === "writable") {
          var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream4, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        var stream4 = controller._controlledWritableStream;
        if (!controller._started) {
          return;
        }
        if (stream4._inFlightWriteRequest !== void 0) {
          return;
        }
        var state = stream4._state;
        if (state === "erroring") {
          WritableStreamFinishErroring(stream4);
          return;
        }
        if (controller._queue.length === 0) {
          return;
        }
        var value = PeekQueueValue(controller);
        if (value === closeSentinel) {
          WritableStreamDefaultControllerProcessClose(controller);
        } else {
          WritableStreamDefaultControllerProcessWrite(controller, value);
        }
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error3) {
        if (controller._controlledWritableStream._state === "writable") {
          WritableStreamDefaultControllerError(controller, error3);
        }
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        var stream4 = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream4);
        DequeueValue(controller);
        var sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(sinkClosePromise, function() {
          WritableStreamFinishInFlightClose(stream4);
          return null;
        }, function(reason) {
          WritableStreamFinishInFlightCloseWithError(stream4, reason);
          return null;
        });
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        var stream4 = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream4);
        var sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, function() {
          WritableStreamFinishInFlightWrite(stream4);
          var state = stream4._state;
          DequeueValue(controller);
          if (!WritableStreamCloseQueuedOrInFlight(stream4) && state === "writable") {
            var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream4, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          return null;
        }, function(reason) {
          if (stream4._state === "writable") {
            WritableStreamDefaultControllerClearAlgorithms(controller);
          }
          WritableStreamFinishInFlightWriteWithError(stream4, reason);
          return null;
        });
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
      }
      function WritableStreamDefaultControllerError(controller, error3) {
        var stream4 = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream4, error3);
      }
      function streamBrandCheckException$2(name15) {
        return new TypeError("WritableStream.prototype.".concat(name15, " can only be used on a WritableStream"));
      }
      function defaultControllerBrandCheckException$2(name15) {
        return new TypeError("WritableStreamDefaultController.prototype.".concat(name15, " can only be used on a WritableStreamDefaultController"));
      }
      function defaultWriterBrandCheckException(name15) {
        return new TypeError("WritableStreamDefaultWriter.prototype.".concat(name15, " can only be used on a WritableStreamDefaultWriter"));
      }
      function defaultWriterLockException(name15) {
        return new TypeError("Cannot " + name15 + " a stream using a released writer");
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise(function(resolve2, reject) {
          writer._closedPromise_resolve = resolve2;
          writer._closedPromise_reject = reject;
          writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "rejected";
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === void 0) {
          return;
        }
        writer._closedPromise_resolve(void 0);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "resolved";
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise(function(resolve2, reject) {
          writer._readyPromise_resolve = resolve2;
          writer._readyPromise_reject = reject;
        });
        writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "rejected";
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === void 0) {
          return;
        }
        writer._readyPromise_resolve(void 0);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "fulfilled";
      }
      function getGlobals() {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        } else if (typeof self !== "undefined") {
          return self;
        } else if (typeof global !== "undefined") {
          return global;
        }
        return void 0;
      }
      var globals = getGlobals();
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === "function" || typeof ctor === "object")) {
          return false;
        }
        if (ctor.name !== "DOMException") {
          return false;
        }
        try {
          new ctor();
          return true;
        } catch (_a4) {
          return false;
        }
      }
      function getFromGlobal() {
        var ctor = globals === null || globals === void 0 ? void 0 : globals.DOMException;
        return isDOMExceptionConstructor(ctor) ? ctor : void 0;
      }
      function createPolyfill() {
        var ctor = function DOMException3(message2, name15) {
          this.message = message2 || "";
          this.name = name15 || "Error";
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        };
        setFunctionName(ctor, "DOMException");
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
        return ctor;
      }
      var DOMException2 = getFromGlobal() || createPolyfill();
      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        var reader = AcquireReadableStreamDefaultReader(source);
        var writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        var shuttingDown = false;
        var currentWrite = promiseResolvedWith(void 0);
        return newPromise(function(resolve2, reject) {
          var abortAlgorithm;
          if (signal !== void 0) {
            abortAlgorithm = function() {
              var error3 = signal.reason !== void 0 ? signal.reason : new DOMException2("Aborted", "AbortError");
              var actions = [];
              if (!preventAbort) {
                actions.push(function() {
                  if (dest._state === "writable") {
                    return WritableStreamAbort(dest, error3);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              if (!preventCancel) {
                actions.push(function() {
                  if (source._state === "readable") {
                    return ReadableStreamCancel(source, error3);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              shutdownWithAction(function() {
                return Promise.all(actions.map(function(action) {
                  return action();
                }));
              }, true, error3);
            };
            if (signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          function pipeLoop() {
            return newPromise(function(resolveLoop, rejectLoop) {
              function next(done) {
                if (done) {
                  resolveLoop();
                } else {
                  PerformPromiseThen(pipeStep(), next, rejectLoop);
                }
              }
              next(false);
            });
          }
          function pipeStep() {
            if (shuttingDown) {
              return promiseResolvedWith(true);
            }
            return PerformPromiseThen(writer._readyPromise, function() {
              return newPromise(function(resolveRead, rejectRead) {
                ReadableStreamDefaultReaderRead(reader, {
                  _chunkSteps: function(chunk) {
                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop3);
                    resolveRead(false);
                  },
                  _closeSteps: function() {
                    return resolveRead(true);
                  },
                  _errorSteps: rejectRead
                });
              });
            });
          }
          isOrBecomesErrored(source, reader._closedPromise, function(storedError) {
            if (!preventAbort) {
              shutdownWithAction(function() {
                return WritableStreamAbort(dest, storedError);
              }, true, storedError);
            } else {
              shutdown(true, storedError);
            }
            return null;
          });
          isOrBecomesErrored(dest, writer._closedPromise, function(storedError) {
            if (!preventCancel) {
              shutdownWithAction(function() {
                return ReadableStreamCancel(source, storedError);
              }, true, storedError);
            } else {
              shutdown(true, storedError);
            }
            return null;
          });
          isOrBecomesClosed(source, reader._closedPromise, function() {
            if (!preventClose) {
              shutdownWithAction(function() {
                return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
              });
            } else {
              shutdown();
            }
            return null;
          });
          if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
            var destClosed_1 = new TypeError("the destination writable stream closed before all data could be piped to it");
            if (!preventCancel) {
              shutdownWithAction(function() {
                return ReadableStreamCancel(source, destClosed_1);
              }, true, destClosed_1);
            } else {
              shutdown(true, destClosed_1);
            }
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            var oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, function() {
              return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0;
            });
          }
          function isOrBecomesErrored(stream4, promise, action) {
            if (stream4._state === "errored") {
              action(stream4._storedError);
            } else {
              uponRejection(promise, action);
            }
          }
          function isOrBecomesClosed(stream4, promise, action) {
            if (stream4._state === "closed") {
              action();
            } else {
              uponFulfillment(promise, action);
            }
          }
          function shutdownWithAction(action, originalIsError, originalError) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), doTheRest);
            } else {
              doTheRest();
            }
            function doTheRest() {
              uponPromise(action(), function() {
                return finalize(originalIsError, originalError);
              }, function(newError) {
                return finalize(true, newError);
              });
              return null;
            }
          }
          function shutdown(isError, error3) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), function() {
                return finalize(isError, error3);
              });
            } else {
              finalize(isError, error3);
            }
          }
          function finalize(isError, error3) {
            WritableStreamDefaultWriterRelease(writer);
            ReadableStreamReaderGenericRelease(reader);
            if (signal !== void 0) {
              signal.removeEventListener("abort", abortAlgorithm);
            }
            if (isError) {
              reject(error3);
            } else {
              resolve2(void 0);
            }
            return null;
          }
        });
      }
      var ReadableStreamDefaultController2 = (
        /** @class */
        function() {
          function ReadableStreamDefaultController3() {
            throw new TypeError("Illegal constructor");
          }
          Object.defineProperty(ReadableStreamDefaultController3.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
             * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
             */
            get: function() {
              if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1("desiredSize");
              }
              return ReadableStreamDefaultControllerGetDesiredSize(this);
            },
            enumerable: false,
            configurable: true
          });
          ReadableStreamDefaultController3.prototype.close = function() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("close");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits close");
            }
            ReadableStreamDefaultControllerClose(this);
          };
          ReadableStreamDefaultController3.prototype.enqueue = function(chunk) {
            if (chunk === void 0) {
              chunk = void 0;
            }
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("enqueue");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits enqueue");
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          };
          ReadableStreamDefaultController3.prototype.error = function(e) {
            if (e === void 0) {
              e = void 0;
            }
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("error");
            }
            ReadableStreamDefaultControllerError(this, e);
          };
          ReadableStreamDefaultController3.prototype[CancelSteps] = function(reason) {
            ResetQueue(this);
            var result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
          };
          ReadableStreamDefaultController3.prototype[PullSteps] = function(readRequest) {
            var stream4 = this._controlledReadableStream;
            if (this._queue.length > 0) {
              var chunk = DequeueValue(this);
              if (this._closeRequested && this._queue.length === 0) {
                ReadableStreamDefaultControllerClearAlgorithms(this);
                ReadableStreamClose(stream4);
              } else {
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
              }
              readRequest._chunkSteps(chunk);
            } else {
              ReadableStreamAddReadRequest(stream4, readRequest);
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
          };
          ReadableStreamDefaultController3.prototype[ReleaseSteps] = function() {
          };
          return ReadableStreamDefaultController3;
        }()
      );
      Object.defineProperties(ReadableStreamDefaultController2.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(ReadableStreamDefaultController2.prototype.close, "close");
      setFunctionName(ReadableStreamDefaultController2.prototype.enqueue, "enqueue");
      setFunctionName(ReadableStreamDefaultController2.prototype.error, "error");
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultController2.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamDefaultController",
          configurable: true
        });
      }
      function IsReadableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
          return false;
        }
        return x instanceof ReadableStreamDefaultController2;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        var pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, function() {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }
          return null;
        }, function(e) {
          ReadableStreamDefaultControllerError(controller, e);
          return null;
        });
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        var stream4 = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (IsReadableStreamLocked(stream4) && ReadableStreamGetNumReadRequests(stream4) > 0) {
          return true;
        }
        var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        var stream4 = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamClose(stream4);
        }
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        var stream4 = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream4) && ReadableStreamGetNumReadRequests(stream4) > 0) {
          ReadableStreamFulfillReadRequest(stream4, chunk, false);
        } else {
          var chunkSize = void 0;
          try {
            chunkSize = controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            ReadableStreamDefaultControllerError(controller, chunkSizeE);
            throw chunkSizeE;
          }
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            ReadableStreamDefaultControllerError(controller, enqueueE);
            throw enqueueE;
          }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
      function ReadableStreamDefaultControllerError(controller, e) {
        var stream4 = controller._controlledReadableStream;
        if (stream4._state !== "readable") {
          return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream4, e);
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        var state = controller._controlledReadableStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
          return false;
        }
        return true;
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        var state = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state === "readable") {
          return true;
        }
        return false;
      }
      function SetUpReadableStreamDefaultController(stream4, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream4;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream4._readableStreamController = controller;
        var startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), function() {
          controller._started = true;
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          return null;
        }, function(r) {
          ReadableStreamDefaultControllerError(controller, r);
          return null;
        });
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream4, underlyingSource, highWaterMark, sizeAlgorithm) {
        var controller = Object.create(ReadableStreamDefaultController2.prototype);
        var startAlgorithm;
        var pullAlgorithm;
        var cancelAlgorithm;
        if (underlyingSource.start !== void 0) {
          startAlgorithm = function() {
            return underlyingSource.start(controller);
          };
        } else {
          startAlgorithm = function() {
            return void 0;
          };
        }
        if (underlyingSource.pull !== void 0) {
          pullAlgorithm = function() {
            return underlyingSource.pull(controller);
          };
        } else {
          pullAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
        }
        if (underlyingSource.cancel !== void 0) {
          cancelAlgorithm = function(reason) {
            return underlyingSource.cancel(reason);
          };
        } else {
          cancelAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
        }
        SetUpReadableStreamDefaultController(stream4, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function defaultControllerBrandCheckException$1(name15) {
        return new TypeError("ReadableStreamDefaultController.prototype.".concat(name15, " can only be used on a ReadableStreamDefaultController"));
      }
      function ReadableStreamTee(stream4, cloneForBranch2) {
        if (IsReadableByteStreamController(stream4._readableStreamController)) {
          return ReadableByteStreamTee(stream4);
        }
        return ReadableStreamDefaultTee(stream4);
      }
      function ReadableStreamDefaultTee(stream4, cloneForBranch2) {
        var reader = AcquireReadableStreamDefaultReader(stream4);
        var reading = false;
        var readAgain = false;
        var canceled1 = false;
        var canceled2 = false;
        var reason1;
        var reason2;
        var branch1;
        var branch2;
        var resolveCancelPromise;
        var cancelPromise = newPromise(function(resolve2) {
          resolveCancelPromise = resolve2;
        });
        function pullAlgorithm() {
          if (reading) {
            readAgain = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          var readRequest = {
            _chunkSteps: function(chunk) {
              _queueMicrotask(function() {
                readAgain = false;
                var chunk1 = chunk;
                var chunk2 = chunk;
                if (!canceled1) {
                  ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgain) {
                  pullAlgorithm();
                }
              });
            },
            _closeSteps: function() {
              reading = false;
              if (!canceled1) {
                ReadableStreamDefaultControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableStreamDefaultControllerClose(branch2._readableStreamController);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: function() {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            var compositeReason = CreateArrayFromList([reason1, reason2]);
            var cancelResult = ReadableStreamCancel(stream4, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            var compositeReason = CreateArrayFromList([reason1, reason2]);
            var cancelResult = ReadableStreamCancel(stream4, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
        uponRejection(reader._closedPromise, function(r) {
          ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
          ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(void 0);
          }
          return null;
        });
        return [branch1, branch2];
      }
      function ReadableByteStreamTee(stream4) {
        var reader = AcquireReadableStreamDefaultReader(stream4);
        var reading = false;
        var readAgainForBranch1 = false;
        var readAgainForBranch2 = false;
        var canceled1 = false;
        var canceled2 = false;
        var reason1;
        var reason2;
        var branch1;
        var branch2;
        var resolveCancelPromise;
        var cancelPromise = newPromise(function(resolve2) {
          resolveCancelPromise = resolve2;
        });
        function forwardReaderError(thisReader) {
          uponRejection(thisReader._closedPromise, function(r) {
            if (thisReader !== reader) {
              return null;
            }
            ReadableByteStreamControllerError(branch1._readableStreamController, r);
            ReadableByteStreamControllerError(branch2._readableStreamController, r);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
            return null;
          });
        }
        function pullWithDefaultReader() {
          if (IsReadableStreamBYOBReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamDefaultReader(stream4);
            forwardReaderError(reader);
          }
          var readRequest = {
            _chunkSteps: function(chunk) {
              _queueMicrotask(function() {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                var chunk1 = chunk;
                var chunk2 = chunk;
                if (!canceled1 && !canceled2) {
                  try {
                    chunk2 = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream4, cloneE));
                    return;
                  }
                }
                if (!canceled1) {
                  ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: function() {
              reading = false;
              if (!canceled1) {
                ReadableByteStreamControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableByteStreamControllerClose(branch2._readableStreamController);
              }
              if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
              }
              if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: function() {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view6, forBranch2) {
          if (IsReadableStreamDefaultReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamBYOBReader(stream4);
            forwardReaderError(reader);
          }
          var byobBranch = forBranch2 ? branch2 : branch1;
          var otherBranch = forBranch2 ? branch1 : branch2;
          var readIntoRequest = {
            _chunkSteps: function(chunk) {
              _queueMicrotask(function() {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                var byobCanceled = forBranch2 ? canceled2 : canceled1;
                var otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!otherCanceled) {
                  var clonedChunk = void 0;
                  try {
                    clonedChunk = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream4, cloneE));
                    return;
                  }
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                } else if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: function(chunk) {
              reading = false;
              var byobCanceled = forBranch2 ? canceled2 : canceled1;
              var otherCanceled = forBranch2 ? canceled1 : canceled2;
              if (!byobCanceled) {
                ReadableByteStreamControllerClose(byobBranch._readableStreamController);
              }
              if (!otherCanceled) {
                ReadableByteStreamControllerClose(otherBranch._readableStreamController);
              }
              if (chunk !== void 0) {
                if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                }
              }
              if (!byobCanceled || !otherCanceled) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: function() {
              reading = false;
            }
          };
          ReadableStreamBYOBReaderRead(reader, view6, 1, readIntoRequest);
        }
        function pull1Algorithm() {
          if (reading) {
            readAgainForBranch1 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, false);
          }
          return promiseResolvedWith(void 0);
        }
        function pull2Algorithm() {
          if (reading) {
            readAgainForBranch2 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, true);
          }
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            var compositeReason = CreateArrayFromList([reason1, reason2]);
            var cancelResult = ReadableStreamCancel(stream4, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            var compositeReason = CreateArrayFromList([reason1, reason2]);
            var cancelResult = ReadableStreamCancel(stream4, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
          return;
        }
        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
        forwardReaderError(reader);
        return [branch1, branch2];
      }
      function isReadableStreamLike(stream4) {
        return typeIsObject(stream4) && typeof stream4.getReader !== "undefined";
      }
      function ReadableStreamFrom(source) {
        if (isReadableStreamLike(source)) {
          return ReadableStreamFromDefaultReader(source.getReader());
        }
        return ReadableStreamFromIterable(source);
      }
      function ReadableStreamFromIterable(asyncIterable) {
        var stream4;
        var iteratorRecord = GetIterator(asyncIterable, "async");
        var startAlgorithm = noop3;
        function pullAlgorithm() {
          var nextResult;
          try {
            nextResult = IteratorNext(iteratorRecord);
          } catch (e) {
            return promiseRejectedWith(e);
          }
          var nextPromise = promiseResolvedWith(nextResult);
          return transformPromiseWith(nextPromise, function(iterResult) {
            if (!typeIsObject(iterResult)) {
              throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");
            }
            var done = IteratorComplete(iterResult);
            if (done) {
              ReadableStreamDefaultControllerClose(stream4._readableStreamController);
            } else {
              var value = IteratorValue(iterResult);
              ReadableStreamDefaultControllerEnqueue(stream4._readableStreamController, value);
            }
          });
        }
        function cancelAlgorithm(reason) {
          var iterator = iteratorRecord.iterator;
          var returnMethod;
          try {
            returnMethod = GetMethod(iterator, "return");
          } catch (e) {
            return promiseRejectedWith(e);
          }
          if (returnMethod === void 0) {
            return promiseResolvedWith(void 0);
          }
          var returnResult;
          try {
            returnResult = reflectCall(returnMethod, iterator, [reason]);
          } catch (e) {
            return promiseRejectedWith(e);
          }
          var returnPromise = promiseResolvedWith(returnResult);
          return transformPromiseWith(returnPromise, function(iterResult) {
            if (!typeIsObject(iterResult)) {
              throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
            }
            return void 0;
          });
        }
        stream4 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
        return stream4;
      }
      function ReadableStreamFromDefaultReader(reader) {
        var stream4;
        var startAlgorithm = noop3;
        function pullAlgorithm() {
          var readPromise;
          try {
            readPromise = reader.read();
          } catch (e) {
            return promiseRejectedWith(e);
          }
          return transformPromiseWith(readPromise, function(readResult) {
            if (!typeIsObject(readResult)) {
              throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
            }
            if (readResult.done) {
              ReadableStreamDefaultControllerClose(stream4._readableStreamController);
            } else {
              var value = readResult.value;
              ReadableStreamDefaultControllerEnqueue(stream4._readableStreamController, value);
            }
          });
        }
        function cancelAlgorithm(reason) {
          try {
            return promiseResolvedWith(reader.cancel(reason));
          } catch (e) {
            return promiseRejectedWith(e);
          }
        }
        stream4 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
        return stream4;
      }
      function convertUnderlyingDefaultOrByteSource(source, context2) {
        assertDictionary(source, context2);
        var original = source;
        var autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
        var cancel = original === null || original === void 0 ? void 0 : original.cancel;
        var pull = original === null || original === void 0 ? void 0 : original.pull;
        var start = original === null || original === void 0 ? void 0 : original.start;
        var type2 = original === null || original === void 0 ? void 0 : original.type;
        return {
          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, "".concat(context2, " has member 'autoAllocateChunkSize' that")),
          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, "".concat(context2, " has member 'cancel' that")),
          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, "".concat(context2, " has member 'pull' that")),
          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, "".concat(context2, " has member 'start' that")),
          type: type2 === void 0 ? void 0 : convertReadableStreamType(type2, "".concat(context2, " has member 'type' that"))
        };
      }
      function convertUnderlyingSourceCancelCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return function(reason) {
          return promiseCall(fn, original, [reason]);
        };
      }
      function convertUnderlyingSourcePullCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return function(controller) {
          return promiseCall(fn, original, [controller]);
        };
      }
      function convertUnderlyingSourceStartCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return function(controller) {
          return reflectCall(fn, original, [controller]);
        };
      }
      function convertReadableStreamType(type2, context2) {
        type2 = "".concat(type2);
        if (type2 !== "bytes") {
          throw new TypeError("".concat(context2, " '").concat(type2, "' is not a valid enumeration value for ReadableStreamType"));
        }
        return type2;
      }
      function convertIteratorOptions(options, context2) {
        assertDictionary(options, context2);
        var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }
      function convertPipeOptions(options, context2) {
        assertDictionary(options, context2);
        var preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
        var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        var preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
        var signal = options === null || options === void 0 ? void 0 : options.signal;
        if (signal !== void 0) {
          assertAbortSignal(signal, "".concat(context2, " has member 'signal' that"));
        }
        return {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal
        };
      }
      function assertAbortSignal(signal, context2) {
        if (!isAbortSignal(signal)) {
          throw new TypeError("".concat(context2, " is not an AbortSignal."));
        }
      }
      function convertReadableWritablePair(pair, context2) {
        assertDictionary(pair, context2);
        var readable = pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair");
        assertReadableStream(readable, "".concat(context2, " has member 'readable' that"));
        var writable = pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, "writable", "ReadableWritablePair");
        assertWritableStream(writable, "".concat(context2, " has member 'writable' that"));
        return { readable, writable };
      }
      var ReadableStream3 = (
        /** @class */
        function() {
          function ReadableStream4(rawUnderlyingSource, rawStrategy) {
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = {};
            }
            if (rawStrategy === void 0) {
              rawStrategy = {};
            }
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = null;
            } else {
              assertObject(rawUnderlyingSource, "First parameter");
            }
            var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            var underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            InitializeReadableStream(this);
            if (underlyingSource.type === "bytes") {
              if (strategy.size !== void 0) {
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              }
              var highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
              var highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          Object.defineProperty(ReadableStream4.prototype, "locked", {
            /**
             * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
             */
            get: function() {
              if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1("locked");
              }
              return IsReadableStreamLocked(this);
            },
            enumerable: false,
            configurable: true
          });
          ReadableStream4.prototype.cancel = function(reason) {
            if (reason === void 0) {
              reason = void 0;
            }
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("cancel"));
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
            }
            return ReadableStreamCancel(this, reason);
          };
          ReadableStream4.prototype.getReader = function(rawOptions) {
            if (rawOptions === void 0) {
              rawOptions = void 0;
            }
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("getReader");
            }
            var options = convertReaderOptions(rawOptions, "First parameter");
            if (options.mode === void 0) {
              return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
          };
          ReadableStream4.prototype.pipeThrough = function(rawTransform, rawOptions) {
            if (rawOptions === void 0) {
              rawOptions = {};
            }
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("pipeThrough");
            }
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            var transform = convertReadableWritablePair(rawTransform, "First parameter");
            var options = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            }
            if (IsWritableStreamLocked(transform.writable)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            }
            var promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
          };
          ReadableStream4.prototype.pipeTo = function(destination, rawOptions) {
            if (rawOptions === void 0) {
              rawOptions = {};
            }
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            }
            if (destination === void 0) {
              return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
            }
            if (!IsWritableStream(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
            }
            var options;
            try {
              options = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e) {
              return promiseRejectedWith(e);
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
            }
            if (IsWritableStreamLocked(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
            }
            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          };
          ReadableStream4.prototype.tee = function() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("tee");
            }
            var branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          };
          ReadableStream4.prototype.values = function(rawOptions) {
            if (rawOptions === void 0) {
              rawOptions = void 0;
            }
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("values");
            }
            var options = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
          };
          ReadableStream4.prototype[SymbolAsyncIterator] = function(options) {
            return this.values(options);
          };
          ReadableStream4.from = function(asyncIterable) {
            return ReadableStreamFrom(asyncIterable);
          };
          return ReadableStream4;
        }()
      );
      Object.defineProperties(ReadableStream3, {
        from: { enumerable: true }
      });
      Object.defineProperties(ReadableStream3.prototype, {
        cancel: { enumerable: true },
        getReader: { enumerable: true },
        pipeThrough: { enumerable: true },
        pipeTo: { enumerable: true },
        tee: { enumerable: true },
        values: { enumerable: true },
        locked: { enumerable: true }
      });
      setFunctionName(ReadableStream3.from, "from");
      setFunctionName(ReadableStream3.prototype.cancel, "cancel");
      setFunctionName(ReadableStream3.prototype.getReader, "getReader");
      setFunctionName(ReadableStream3.prototype.pipeThrough, "pipeThrough");
      setFunctionName(ReadableStream3.prototype.pipeTo, "pipeTo");
      setFunctionName(ReadableStream3.prototype.tee, "tee");
      setFunctionName(ReadableStream3.prototype.values, "values");
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStream3.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStream",
          configurable: true
        });
      }
      Object.defineProperty(ReadableStream3.prototype, SymbolAsyncIterator, {
        value: ReadableStream3.prototype.values,
        writable: true,
        configurable: true
      });
      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        if (highWaterMark === void 0) {
          highWaterMark = 1;
        }
        if (sizeAlgorithm === void 0) {
          sizeAlgorithm = function() {
            return 1;
          };
        }
        var stream4 = Object.create(ReadableStream3.prototype);
        InitializeReadableStream(stream4);
        var controller = Object.create(ReadableStreamDefaultController2.prototype);
        SetUpReadableStreamDefaultController(stream4, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        return stream4;
      }
      function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        var stream4 = Object.create(ReadableStream3.prototype);
        InitializeReadableStream(stream4);
        var controller = Object.create(ReadableByteStreamController2.prototype);
        SetUpReadableByteStreamController(stream4, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
        return stream4;
      }
      function InitializeReadableStream(stream4) {
        stream4._state = "readable";
        stream4._reader = void 0;
        stream4._storedError = void 0;
        stream4._disturbed = false;
      }
      function IsReadableStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
          return false;
        }
        return x instanceof ReadableStream3;
      }
      function IsReadableStreamLocked(stream4) {
        if (stream4._reader === void 0) {
          return false;
        }
        return true;
      }
      function ReadableStreamCancel(stream4, reason) {
        stream4._disturbed = true;
        if (stream4._state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (stream4._state === "errored") {
          return promiseRejectedWith(stream4._storedError);
        }
        ReadableStreamClose(stream4);
        var reader = stream4._reader;
        if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
          var readIntoRequests = reader._readIntoRequests;
          reader._readIntoRequests = new SimpleQueue();
          readIntoRequests.forEach(function(readIntoRequest) {
            readIntoRequest._closeSteps(void 0);
          });
        }
        var sourceCancelPromise = stream4._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop3);
      }
      function ReadableStreamClose(stream4) {
        stream4._state = "closed";
        var reader = stream4._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
          var readRequests = reader._readRequests;
          reader._readRequests = new SimpleQueue();
          readRequests.forEach(function(readRequest) {
            readRequest._closeSteps();
          });
        }
      }
      function ReadableStreamError(stream4, e) {
        stream4._state = "errored";
        stream4._storedError = e;
        var reader = stream4._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseReject(reader, e);
        if (IsReadableStreamDefaultReader(reader)) {
          ReadableStreamDefaultReaderErrorReadRequests(reader, e);
        } else {
          ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);
        }
      }
      function streamBrandCheckException$1(name15) {
        return new TypeError("ReadableStream.prototype.".concat(name15, " can only be used on a ReadableStream"));
      }
      function convertQueuingStrategyInit(init2, context2) {
        assertDictionary(init2, context2);
        var highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
        assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
        return {
          highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
      }
      var byteLengthSizeFunction = function(chunk) {
        return chunk.byteLength;
      };
      setFunctionName(byteLengthSizeFunction, "size");
      var ByteLengthQueuingStrategy2 = (
        /** @class */
        function() {
          function ByteLengthQueuingStrategy3(options) {
            assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
            options = convertQueuingStrategyInit(options, "First parameter");
            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          Object.defineProperty(ByteLengthQueuingStrategy3.prototype, "highWaterMark", {
            /**
             * Returns the high water mark provided to the constructor.
             */
            get: function() {
              if (!IsByteLengthQueuingStrategy(this)) {
                throw byteLengthBrandCheckException("highWaterMark");
              }
              return this._byteLengthQueuingStrategyHighWaterMark;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(ByteLengthQueuingStrategy3.prototype, "size", {
            /**
             * Measures the size of `chunk` by returning the value of its `byteLength` property.
             */
            get: function() {
              if (!IsByteLengthQueuingStrategy(this)) {
                throw byteLengthBrandCheckException("size");
              }
              return byteLengthSizeFunction;
            },
            enumerable: false,
            configurable: true
          });
          return ByteLengthQueuingStrategy3;
        }()
      );
      Object.defineProperties(ByteLengthQueuingStrategy2.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ByteLengthQueuingStrategy2.prototype, SymbolPolyfill.toStringTag, {
          value: "ByteLengthQueuingStrategy",
          configurable: true
        });
      }
      function byteLengthBrandCheckException(name15) {
        return new TypeError("ByteLengthQueuingStrategy.prototype.".concat(name15, " can only be used on a ByteLengthQueuingStrategy"));
      }
      function IsByteLengthQueuingStrategy(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x instanceof ByteLengthQueuingStrategy2;
      }
      var countSizeFunction = function() {
        return 1;
      };
      setFunctionName(countSizeFunction, "size");
      var CountQueuingStrategy3 = (
        /** @class */
        function() {
          function CountQueuingStrategy4(options) {
            assertRequiredArgument(options, 1, "CountQueuingStrategy");
            options = convertQueuingStrategyInit(options, "First parameter");
            this._countQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          Object.defineProperty(CountQueuingStrategy4.prototype, "highWaterMark", {
            /**
             * Returns the high water mark provided to the constructor.
             */
            get: function() {
              if (!IsCountQueuingStrategy(this)) {
                throw countBrandCheckException("highWaterMark");
              }
              return this._countQueuingStrategyHighWaterMark;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(CountQueuingStrategy4.prototype, "size", {
            /**
             * Measures the size of `chunk` by always returning 1.
             * This ensures that the total queue size is a count of the number of chunks in the queue.
             */
            get: function() {
              if (!IsCountQueuingStrategy(this)) {
                throw countBrandCheckException("size");
              }
              return countSizeFunction;
            },
            enumerable: false,
            configurable: true
          });
          return CountQueuingStrategy4;
        }()
      );
      Object.defineProperties(CountQueuingStrategy3.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(CountQueuingStrategy3.prototype, SymbolPolyfill.toStringTag, {
          value: "CountQueuingStrategy",
          configurable: true
        });
      }
      function countBrandCheckException(name15) {
        return new TypeError("CountQueuingStrategy.prototype.".concat(name15, " can only be used on a CountQueuingStrategy"));
      }
      function IsCountQueuingStrategy(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x instanceof CountQueuingStrategy3;
      }
      function convertTransformer(original, context2) {
        assertDictionary(original, context2);
        var cancel = original === null || original === void 0 ? void 0 : original.cancel;
        var flush3 = original === null || original === void 0 ? void 0 : original.flush;
        var readableType = original === null || original === void 0 ? void 0 : original.readableType;
        var start = original === null || original === void 0 ? void 0 : original.start;
        var transform = original === null || original === void 0 ? void 0 : original.transform;
        var writableType = original === null || original === void 0 ? void 0 : original.writableType;
        return {
          cancel: cancel === void 0 ? void 0 : convertTransformerCancelCallback(cancel, original, "".concat(context2, " has member 'cancel' that")),
          flush: flush3 === void 0 ? void 0 : convertTransformerFlushCallback(flush3, original, "".concat(context2, " has member 'flush' that")),
          readableType,
          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, "".concat(context2, " has member 'start' that")),
          transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, "".concat(context2, " has member 'transform' that")),
          writableType
        };
      }
      function convertTransformerFlushCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return function(controller) {
          return promiseCall(fn, original, [controller]);
        };
      }
      function convertTransformerStartCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return function(controller) {
          return reflectCall(fn, original, [controller]);
        };
      }
      function convertTransformerTransformCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return function(chunk, controller) {
          return promiseCall(fn, original, [chunk, controller]);
        };
      }
      function convertTransformerCancelCallback(fn, original, context2) {
        assertFunction(fn, context2);
        return function(reason) {
          return promiseCall(fn, original, [reason]);
        };
      }
      var TransformStream3 = (
        /** @class */
        function() {
          function TransformStream4(rawTransformer, rawWritableStrategy, rawReadableStrategy) {
            if (rawTransformer === void 0) {
              rawTransformer = {};
            }
            if (rawWritableStrategy === void 0) {
              rawWritableStrategy = {};
            }
            if (rawReadableStrategy === void 0) {
              rawReadableStrategy = {};
            }
            if (rawTransformer === void 0) {
              rawTransformer = null;
            }
            var writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
            var readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
            var transformer = convertTransformer(rawTransformer, "First parameter");
            if (transformer.readableType !== void 0) {
              throw new RangeError("Invalid readableType specified");
            }
            if (transformer.writableType !== void 0) {
              throw new RangeError("Invalid writableType specified");
            }
            var readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            var readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            var writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            var writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            var startPromise_resolve;
            var startPromise = newPromise(function(resolve2) {
              startPromise_resolve = resolve2;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
            if (transformer.start !== void 0) {
              startPromise_resolve(transformer.start(this._transformStreamController));
            } else {
              startPromise_resolve(void 0);
            }
          }
          Object.defineProperty(TransformStream4.prototype, "readable", {
            /**
             * The readable side of the transform stream.
             */
            get: function() {
              if (!IsTransformStream(this)) {
                throw streamBrandCheckException("readable");
              }
              return this._readable;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(TransformStream4.prototype, "writable", {
            /**
             * The writable side of the transform stream.
             */
            get: function() {
              if (!IsTransformStream(this)) {
                throw streamBrandCheckException("writable");
              }
              return this._writable;
            },
            enumerable: false,
            configurable: true
          });
          return TransformStream4;
        }()
      );
      Object.defineProperties(TransformStream3.prototype, {
        readable: { enumerable: true },
        writable: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStream3.prototype, SymbolPolyfill.toStringTag, {
          value: "TransformStream",
          configurable: true
        });
      }
      function InitializeTransformStream(stream4, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream4, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream4, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream4);
        }
        stream4._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream4);
        }
        function cancelAlgorithm(reason) {
          return TransformStreamDefaultSourceCancelAlgorithm(stream4, reason);
        }
        stream4._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        stream4._backpressure = void 0;
        stream4._backpressureChangePromise = void 0;
        stream4._backpressureChangePromise_resolve = void 0;
        TransformStreamSetBackpressure(stream4, true);
        stream4._transformStreamController = void 0;
      }
      function IsTransformStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
          return false;
        }
        return x instanceof TransformStream3;
      }
      function TransformStreamError(stream4, e) {
        ReadableStreamDefaultControllerError(stream4._readable._readableStreamController, e);
        TransformStreamErrorWritableAndUnblockWrite(stream4, e);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream4, e) {
        TransformStreamDefaultControllerClearAlgorithms(stream4._transformStreamController);
        WritableStreamDefaultControllerErrorIfNeeded(stream4._writable._writableStreamController, e);
        TransformStreamUnblockWrite(stream4);
      }
      function TransformStreamUnblockWrite(stream4) {
        if (stream4._backpressure) {
          TransformStreamSetBackpressure(stream4, false);
        }
      }
      function TransformStreamSetBackpressure(stream4, backpressure) {
        if (stream4._backpressureChangePromise !== void 0) {
          stream4._backpressureChangePromise_resolve();
        }
        stream4._backpressureChangePromise = newPromise(function(resolve2) {
          stream4._backpressureChangePromise_resolve = resolve2;
        });
        stream4._backpressure = backpressure;
      }
      var TransformStreamDefaultController2 = (
        /** @class */
        function() {
          function TransformStreamDefaultController3() {
            throw new TypeError("Illegal constructor");
          }
          Object.defineProperty(TransformStreamDefaultController3.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.
             */
            get: function() {
              if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException("desiredSize");
              }
              var readableController = this._controlledTransformStream._readable._readableStreamController;
              return ReadableStreamDefaultControllerGetDesiredSize(readableController);
            },
            enumerable: false,
            configurable: true
          });
          TransformStreamDefaultController3.prototype.enqueue = function(chunk) {
            if (chunk === void 0) {
              chunk = void 0;
            }
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("enqueue");
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
          };
          TransformStreamDefaultController3.prototype.error = function(reason) {
            if (reason === void 0) {
              reason = void 0;
            }
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("error");
            }
            TransformStreamDefaultControllerError(this, reason);
          };
          TransformStreamDefaultController3.prototype.terminate = function() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("terminate");
            }
            TransformStreamDefaultControllerTerminate(this);
          };
          return TransformStreamDefaultController3;
        }()
      );
      Object.defineProperties(TransformStreamDefaultController2.prototype, {
        enqueue: { enumerable: true },
        error: { enumerable: true },
        terminate: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      setFunctionName(TransformStreamDefaultController2.prototype.enqueue, "enqueue");
      setFunctionName(TransformStreamDefaultController2.prototype.error, "error");
      setFunctionName(TransformStreamDefaultController2.prototype.terminate, "terminate");
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStreamDefaultController2.prototype, SymbolPolyfill.toStringTag, {
          value: "TransformStreamDefaultController",
          configurable: true
        });
      }
      function IsTransformStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
          return false;
        }
        return x instanceof TransformStreamDefaultController2;
      }
      function SetUpTransformStreamDefaultController(stream4, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm) {
        controller._controlledTransformStream = stream4;
        stream4._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._finishPromise = void 0;
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(stream4, transformer) {
        var controller = Object.create(TransformStreamDefaultController2.prototype);
        var transformAlgorithm;
        var flushAlgorithm;
        var cancelAlgorithm;
        if (transformer.transform !== void 0) {
          transformAlgorithm = function(chunk) {
            return transformer.transform(chunk, controller);
          };
        } else {
          transformAlgorithm = function(chunk) {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
        }
        if (transformer.flush !== void 0) {
          flushAlgorithm = function() {
            return transformer.flush(controller);
          };
        } else {
          flushAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
        }
        if (transformer.cancel !== void 0) {
          cancelAlgorithm = function(reason) {
            return transformer.cancel(reason);
          };
        } else {
          cancelAlgorithm = function() {
            return promiseResolvedWith(void 0);
          };
        }
        SetUpTransformStreamDefaultController(stream4, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = void 0;
        controller._flushAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        var stream4 = controller._controlledTransformStream;
        var readableController = stream4._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
          throw new TypeError("Readable side is not in a state that permits enqueue");
        }
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e) {
          TransformStreamErrorWritableAndUnblockWrite(stream4, e);
          throw stream4._readable._storedError;
        }
        var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream4._backpressure) {
          TransformStreamSetBackpressure(stream4, true);
        }
      }
      function TransformStreamDefaultControllerError(controller, e) {
        TransformStreamError(controller._controlledTransformStream, e);
      }
      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        var transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, void 0, function(r) {
          TransformStreamError(controller._controlledTransformStream, r);
          throw r;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        var stream4 = controller._controlledTransformStream;
        var readableController = stream4._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        var error3 = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream4, error3);
      }
      function TransformStreamDefaultSinkWriteAlgorithm(stream4, chunk) {
        var controller = stream4._transformStreamController;
        if (stream4._backpressure) {
          var backpressureChangePromise = stream4._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, function() {
            var writable = stream4._writable;
            var state = writable._state;
            if (state === "erroring") {
              throw writable._storedError;
            }
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream4, reason) {
        var controller = stream4._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        var readable = stream4._readable;
        controller._finishPromise = newPromise(function(resolve2, reject) {
          controller._finishPromise_resolve = resolve2;
          controller._finishPromise_reject = reject;
        });
        var cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(cancelPromise, function() {
          if (readable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, readable._storedError);
          } else {
            ReadableStreamDefaultControllerError(readable._readableStreamController, reason);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, function(r) {
          ReadableStreamDefaultControllerError(readable._readableStreamController, r);
          defaultControllerFinishPromiseReject(controller, r);
          return null;
        });
        return controller._finishPromise;
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream4) {
        var controller = stream4._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        var readable = stream4._readable;
        controller._finishPromise = newPromise(function(resolve2, reject) {
          controller._finishPromise_resolve = resolve2;
          controller._finishPromise_reject = reject;
        });
        var flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(flushPromise, function() {
          if (readable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, readable._storedError);
          } else {
            ReadableStreamDefaultControllerClose(readable._readableStreamController);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, function(r) {
          ReadableStreamDefaultControllerError(readable._readableStreamController, r);
          defaultControllerFinishPromiseReject(controller, r);
          return null;
        });
        return controller._finishPromise;
      }
      function TransformStreamDefaultSourcePullAlgorithm(stream4) {
        TransformStreamSetBackpressure(stream4, false);
        return stream4._backpressureChangePromise;
      }
      function TransformStreamDefaultSourceCancelAlgorithm(stream4, reason) {
        var controller = stream4._transformStreamController;
        if (controller._finishPromise !== void 0) {
          return controller._finishPromise;
        }
        var writable = stream4._writable;
        controller._finishPromise = newPromise(function(resolve2, reject) {
          controller._finishPromise_resolve = resolve2;
          controller._finishPromise_reject = reject;
        });
        var cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(cancelPromise, function() {
          if (writable._state === "errored") {
            defaultControllerFinishPromiseReject(controller, writable._storedError);
          } else {
            WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason);
            TransformStreamUnblockWrite(stream4);
            defaultControllerFinishPromiseResolve(controller);
          }
          return null;
        }, function(r) {
          WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r);
          TransformStreamUnblockWrite(stream4);
          defaultControllerFinishPromiseReject(controller, r);
          return null;
        });
        return controller._finishPromise;
      }
      function defaultControllerBrandCheckException(name15) {
        return new TypeError("TransformStreamDefaultController.prototype.".concat(name15, " can only be used on a TransformStreamDefaultController"));
      }
      function defaultControllerFinishPromiseResolve(controller) {
        if (controller._finishPromise_resolve === void 0) {
          return;
        }
        controller._finishPromise_resolve();
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function defaultControllerFinishPromiseReject(controller, reason) {
        if (controller._finishPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(controller._finishPromise);
        controller._finishPromise_reject(reason);
        controller._finishPromise_resolve = void 0;
        controller._finishPromise_reject = void 0;
      }
      function streamBrandCheckException(name15) {
        return new TypeError("TransformStream.prototype.".concat(name15, " can only be used on a TransformStream"));
      }
      exports3.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy2;
      exports3.CountQueuingStrategy = CountQueuingStrategy3;
      exports3.ReadableByteStreamController = ReadableByteStreamController2;
      exports3.ReadableStream = ReadableStream3;
      exports3.ReadableStreamBYOBReader = ReadableStreamBYOBReader2;
      exports3.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest2;
      exports3.ReadableStreamDefaultController = ReadableStreamDefaultController2;
      exports3.ReadableStreamDefaultReader = ReadableStreamDefaultReader2;
      exports3.TransformStream = TransformStream3;
      exports3.TransformStreamDefaultController = TransformStreamDefaultController2;
      exports3.WritableStream = WritableStream3;
      exports3.WritableStreamDefaultController = WritableStreamDefaultController2;
      exports3.WritableStreamDefaultWriter = WritableStreamDefaultWriter2;
    });
  }
});

// node_modules/@web-std/stream/src/stream.cjs
var require_stream = __commonJS({
  "node_modules/@web-std/stream/src/stream.cjs"(exports2, module2) {
    init_process_shim();
    try {
      module2.exports = __require("stream/web");
    } catch (error3) {
      module2.exports = require_ponyfill();
    }
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    init_process_shim();
    var Stream = __require("stream").Stream;
    var util2 = __require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util2.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message2 = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message2));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    init_process_shim();
    var util2 = __require("util");
    var Stream = __require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util2.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream4) {
      return typeof stream4 !== "function" && typeof stream4 !== "string" && typeof stream4 !== "boolean" && typeof stream4 !== "number" && !Buffer.isBuffer(stream4);
    };
    CombinedStream.prototype.append = function(stream4) {
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        if (!(stream4 instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream4, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream4.on("data", this._checkDataSize.bind(this));
          stream4 = newStream;
        }
        this._handleErrors(stream4);
        if (this.pauseStreams) {
          stream4.pause();
        }
      }
      this._streams.push(stream4);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream4 = this._streams.shift();
      if (typeof stream4 == "undefined") {
        this.end();
        return;
      }
      if (typeof stream4 !== "function") {
        this._pipeNext(stream4);
        return;
      }
      var getStream = stream4;
      getStream(function(stream5) {
        var isStreamLike = CombinedStream.isStreamLike(stream5);
        if (isStreamLike) {
          stream5.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream5);
        }
        this._pipeNext(stream5);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream4) {
      this._currentStream = stream4;
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        stream4.on("end", this._getNext.bind(this));
        stream4.pipe(this, { end: false });
        return;
      }
      var value = stream4;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream4) {
      var self2 = this;
      stream4.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message2 = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message2));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream4) {
        if (!stream4.dataSize) {
          return;
        }
        self2.dataSize += stream4.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports2, module2) {
    init_process_shim();
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports2) {
    "use strict";
    init_process_shim();
    var db = require_mime_db();
    var extname = __require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType9;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup2;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match6 = EXTRACT_TYPE_REGEXP.exec(type2);
      var mime = match6 && db[match6[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match6 && TEXT_TYPE_REGEXP.test(match6[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType9(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match6 = EXTRACT_TYPE_REGEXP.exec(type2);
      var exts = match6 && exports2.extensions[match6[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup2(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types2) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type2) {
        var mime = db[type2];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type2] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types2[extension2]) {
            var from19 = preference.indexOf(db[types2[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types2[extension2] !== "application/octet-stream" && (from19 > to || from19 === to && types2[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types2[extension2] = type2;
        }
      });
    }
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports2, module2) {
    init_process_shim();
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports2, module2) {
    init_process_shim();
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync2 = false;
      defer(function() {
        isAsync2 = true;
      });
      return function async_callback(err, result) {
        if (isAsync2) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports2, module2) {
    init_process_shim();
    module2.exports = abort2;
    function abort2(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    init_process_shim();
    var async = require_async();
    var abort2 = require_abort();
    module2.exports = iterate4;
    function iterate4(list7, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list7[key], function(error3, output2) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error3) {
          abort2(state);
        } else {
          state.results[key] = output2;
        }
        callback(error3, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports2, module2) {
    init_process_shim();
    module2.exports = state;
    function state(list7, sortMethod) {
      var isNamedList = !Array.isArray(list7), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list7) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list7).length : list7.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list7[a], list7[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    init_process_shim();
    var abort2 = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort2(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/asynckit/parallel.js"(exports2, module2) {
    init_process_shim();
    var iterate4 = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list7, iterator, callback) {
      var state = initState(list7);
      while (state.index < (state["keyedList"] || list7).length) {
        iterate4(list7, iterator, state, function(error3, result) {
          if (error3) {
            callback(error3, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    init_process_shim();
    var iterate4 = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending2;
    module2.exports.descending = descending;
    function serialOrdered(list7, iterator, sortMethod, callback) {
      var state = initState(list7, sortMethod);
      iterate4(list7, iterator, state, function iteratorHandler(error3, result) {
        if (error3) {
          callback(error3, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list7).length) {
          iterate4(list7, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending2(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending2(a, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports2, module2) {
    init_process_shim();
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list7, iterator, callback) {
      return serialOrdered(list7, iterator, null, callback);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports2, module2) {
    init_process_shim();
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports2, module2) {
    init_process_shim();
    module2.exports = function(dst, src5) {
      Object.keys(src5).forEach(function(prop) {
        dst[prop] = dst[prop] || src5[prop];
      });
      return dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports2, module2) {
    init_process_shim();
    var CombinedStream = require_combined_stream();
    var util2 = __require("util");
    var path = __require("path");
    var http2 = __require("http");
    var https2 = __require("https");
    var parseUrl = __require("url").parse;
    var fs = __require("fs");
    var Stream = __require("stream").Stream;
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module2.exports = FormData5;
    util2.inherits(FormData5, CombinedStream);
    function FormData5(options) {
      if (!(this instanceof FormData5)) {
        return new FormData5(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData5.LINE_BREAK = "\r\n";
    FormData5.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData5.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append3 = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (Array.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append3(header);
      append3(value);
      append3(footer);
      this._trackLength(header, value, options);
    };
    FormData5.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData5.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData5.prototype._lengthRetriever = function(value, callback) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs.stat(value.path, function(err, stat) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback(null, +value.headers["content-length"]);
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData5.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType9 = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType9 || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop)) continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData5.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData5.LINE_BREAK + contents + FormData5.LINE_BREAK;
    };
    FormData5.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path.basename(options.filename || value.name || value.path);
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData5.prototype._getContentType = function(value, options) {
      var contentType9 = options.contentType;
      if (!contentType9 && value.name) {
        contentType9 = mime.lookup(value.name);
      }
      if (!contentType9 && value.path) {
        contentType9 = mime.lookup(value.path);
      }
      if (!contentType9 && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType9 = value.headers["content-type"];
      }
      if (!contentType9 && (options.filepath || options.filename)) {
        contentType9 = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType9 && typeof value == "object") {
        contentType9 = FormData5.DEFAULT_CONTENT_TYPE;
      }
      return contentType9;
    };
    FormData5.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData5.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData5.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData5.LINE_BREAK;
    };
    FormData5.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData5.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData5.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData5.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData5.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData5.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData5.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData5.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData5.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values2) {
        if (err) {
          cb(err);
          return;
        }
        values2.forEach(function(length5) {
          knownLength += length5;
        });
        cb(null, knownLength);
      });
    };
    FormData5.prototype.submit = function(params, cb) {
      var request, options, defaults6 = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults6);
      } else {
        options = populate(params, defaults6);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request = https2.request(options);
      } else {
        request = http2.request(options);
      }
      this.getLength(function(err, length5) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length5) {
          request.setHeader("Content-Length", length5);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error3, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error3, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData5.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData5.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "node_modules/proxy-from-env/index.js"(exports2) {
    "use strict";
    init_process_shim();
    var parseUrl = __require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s2) {
      return s2.length <= this.length && this.indexOf(s2, this.length - s2.length) !== -1;
    };
    function getProxyForUrl2(url2) {
      var parsedUrl = typeof url2 === "string" ? parseUrl(url2) : url2 || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports2.getProxyForUrl = getProxyForUrl2;
  }
});

// node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports2, module2) {
    init_process_shim();
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = __require("debug")("follow-redirects");
        } catch (error3) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports2, module2) {
    init_process_shim();
    var url2 = __require("url");
    var URL2 = url2.URL;
    var http2 = __require("http");
    var https2 = __require("https");
    var Writable = __require("stream").Writable;
    var assert = __require("assert");
    var debug = require_debug();
    (function detectUnsupportedEnvironment() {
      var looksLikeNode = typeof process !== "undefined";
      var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
      var looksLikeV8 = isFunction2(Error.captureStackTrace);
      if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn("The follow-redirects package should be excluded from browser builds.");
      }
    })();
    var useNativeURL = false;
    try {
      assert(new URL2(""));
    } catch (error3) {
      useNativeURL = error3.code === "ERR_INVALID_URL";
    }
    var preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    var destroy = Writable.prototype.destroy || noop3;
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        try {
          self2._processResponse(response);
        } catch (cause) {
          self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
        }
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error3) {
      destroyRequest(this._currentRequest, error3);
      destroy.call(this, error3);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString3(data) && !isBuffer5(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction2(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction2(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction2(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name15, value) {
      this._options.headers[name15] = value;
      this._currentRequest.setHeader(name15, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name15) {
      delete this._options.headers[name15];
      this._currentRequest.removeHeader(name15);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        self2.removeListener("close", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url2.format(this._options) : (
        // When making a request to a proxy, […]
        // a client MUST send the target URI in absolute-form […].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error3) {
          if (request === self2._currentRequest) {
            if (error3) {
              self2.emit("error", error3);
            } else if (i < buffers.length) {
              var buffer3 = buffers[i++];
              if (!request.finished) {
                request.write(buffer3.data, buffer3.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location2 = response.headers.location;
      if (!location2 || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource […]
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) […]
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location2) ? this._currentUrl : url2.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location2, currentUrl);
      debug("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction2(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    function wrap3(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input10, options, callback) {
          if (isURL(input10)) {
            input10 = spreadUrlObject(input10);
          } else if (isString3(input10)) {
            input10 = spreadUrlObject(parseUrl(input10));
          } else {
            callback = options;
            options = validateUrl(input10);
            input10 = { protocol };
          }
          if (isFunction2(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input10, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString3(options.host) && !isString3(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get15(input10, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input10, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get15, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop3() {
    }
    function parseUrl(input10) {
      var parsed;
      if (useNativeURL) {
        parsed = new URL2(input10);
      } else {
        parsed = validateUrl(url2.parse(input10));
        if (!isString3(parsed.protocol)) {
          throw new InvalidUrlError({ input: input10 });
        }
      }
      return parsed;
    }
    function resolveUrl(relative, base5) {
      return useNativeURL ? new URL2(relative, base5) : parseUrl(url2.resolve(base5, relative));
    }
    function validateUrl(input10) {
      if (/^\[/.test(input10.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input10.hostname)) {
        throw new InvalidUrlError({ input: input10.href || input10 });
      }
      if (/^\[/.test(input10.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input10.host)) {
        throw new InvalidUrlError({ input: input10.href || input10 });
      }
      return input10;
    }
    function spreadUrlObject(urlObject, target) {
      var spread3 = target || {};
      for (var key of preservedUrlFields) {
        spread3[key] = urlObject[key];
      }
      if (spread3.hostname.startsWith("[")) {
        spread3.hostname = spread3.hostname.slice(1, -1);
      }
      if (spread3.port !== "") {
        spread3.port = Number(spread3.port);
      }
      spread3.path = spread3.search ? spread3.pathname + spread3.search : spread3.pathname;
      return spread3;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code20, message2, baseClass) {
      function CustomError(properties) {
        if (isFunction2(Error.captureStackTrace)) {
          Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code20;
        this.message = this.cause ? message2 + ": " + this.cause.message : message2;
      }
      CustomError.prototype = new (baseClass || Error)();
      Object.defineProperties(CustomError.prototype, {
        constructor: {
          value: CustomError,
          enumerable: false
        },
        name: {
          value: "Error [" + code20 + "]",
          enumerable: false
        }
      });
      return CustomError;
    }
    function destroyRequest(request, error3) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop3);
      request.destroy(error3);
    }
    function isSubdomain(subdomain, domain) {
      assert(isString3(subdomain) && isString3(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString3(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction2(value) {
      return typeof value === "function";
    }
    function isBuffer5(value) {
      return typeof value === "object" && "length" in value;
    }
    function isURL(value) {
      return URL2 && value instanceof URL2;
    }
    module2.exports = wrap3({ http: http2, https: https2 });
    module2.exports.wrap = wrap3;
  }
});

// node_modules/object-traversal/dist/object-traversal.cjs.production.min.js
var require_object_traversal_cjs_production_min = __commonJS({
  "node_modules/object-traversal/dist/object-traversal.cjs.production.min.js"(exports2) {
    "use strict";
    init_process_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var t = { traversalType: "depth-first", maxNodes: Number.POSITIVE_INFINITY, cycleHandling: true, maxDepth: Number.POSITIVE_INFINITY, haltOnTruthy: false, pathSeparator: "." };
    var e = function() {
      function t2() {
        this.head = void 0, this.tail = void 0;
      }
      var e2 = t2.prototype;
      return e2.enqueue = function(t3) {
        this.tail ? this.tail = this.tail.next = { value: t3 } : this.head = this.tail = { value: t3 };
      }, e2.dequeue = function() {
        var t3 = this.head.value;
        return this.head = this.head.next, this.head || (this.tail = this.head), t3;
      }, e2.isEmpty = function() {
        return !this.head;
      }, e2.reset = function() {
        this.head = this.tail = void 0;
      }, t2;
    }();
    var i = function() {
      function t2(t3) {
        this.queue = void 0, this.queue = t3;
      }
      var e2 = t2.prototype;
      return e2.push = function(t3) {
        this.queue.enqueue(t3);
      }, e2.pop = function() {
        return this.queue.dequeue();
      }, e2.isEmpty = function() {
        return this.queue.isEmpty();
      }, e2.reset = function() {
        return this.queue.reset();
      }, t2;
    }();
    var a = function() {
      function t2() {
        this.tail = void 0;
      }
      var e2 = t2.prototype;
      return e2.push = function(t3) {
        this.tail = { value: t3, prev: this.tail };
      }, e2.pop = function() {
        var t3 = this.tail;
        return this.tail = this.tail.prev, t3.value;
      }, e2.isEmpty = function() {
        return !this.tail;
      }, e2.reset = function() {
        this.tail = void 0;
      }, t2;
    }();
    exports2._Queue = e, exports2._QueueToStackAdapter = i, exports2._Stack = a, exports2.getNodeByPath = function(t2, e2, i2) {
      void 0 === i2 && (i2 = ".");
      for (var a2 = t2, r = e2.split(i2), n2 = 0, s2 = r[n2]; a2 && s2; ) a2 = a2[s2], s2 = r[++n2];
      return a2;
    }, exports2.traverse = function(r, n2, s2) {
      if (!(r instanceof Object)) throw new Error("First argument must be an object");
      var u, o = Object.assign({}, t, s2);
      o.disablePathTracking = "string" != typeof o.pathSeparator, u = "depth-first" === o.traversalType ? new a() : new i(new e());
      var h = { visitedNodes: /* @__PURE__ */ new WeakSet(), depth: 0 };
      o.disablePathTracking || (h.nodePath = null), u.push({ parent: null, key: null, value: r, meta: h }), function(t2, r2, n3) {
        var s3;
        s3 = "depth-first" === n3.traversalType ? new a() : new i(new e());
        for (var u2 = n3.maxNodes, o2 = n3.cycleHandling, h2 = n3.maxDepth, p = n3.haltOnTruthy, d = n3.pathSeparator, l2 = 0; !r2.isEmpty() && u2 > l2; ) {
          var c = r2.pop(), v = c.value, f = c.meta, y = f.visitedNodes, m = v instanceof Object;
          if (!(o2 && m && y.has(v))) {
            if (t2(c) && p) break;
            if (l2++, m) {
              y.add(v);
              var b = f.nodePath, T = f.depth + 1;
              if (T > h2) continue;
              s3.reset();
              for (var x = Object.keys(v), N = 0; N < x.length; N++) {
                var g = x[N], k = { visitedNodes: y, depth: T };
                n3.disablePathTracking || (k.nodePath = b ? "" + b + d + g : g), s3.push({ value: v[g], meta: k, key: g, parent: v });
              }
              for (; !s3.isEmpty(); ) r2.push(s3.pop());
            }
          }
        }
      }(n2, u, o);
    };
  }
});

// node_modules/object-traversal/dist/object-traversal.cjs.development.js
var require_object_traversal_cjs_development = __commonJS({
  "node_modules/object-traversal/dist/object-traversal.cjs.development.js"(exports2) {
    "use strict";
    init_process_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var DEFAULT_SEPARATOR = ".";
    var DEFAULT_TRAVERSAL_OPTS = {
      traversalType: "depth-first",
      maxNodes: Number.POSITIVE_INFINITY,
      cycleHandling: true,
      maxDepth: Number.POSITIVE_INFINITY,
      haltOnTruthy: false,
      pathSeparator: DEFAULT_SEPARATOR
    };
    var _Queue = /* @__PURE__ */ function() {
      function _Queue2() {
        this.head = void 0;
        this.tail = void 0;
      }
      var _proto = _Queue2.prototype;
      _proto.enqueue = function enqueue2(v) {
        if (this.tail) {
          this.tail = this.tail.next = {
            value: v
          };
        } else {
          this.head = this.tail = {
            value: v
          };
        }
      };
      _proto.dequeue = function dequeue() {
        var previousHeadValue = this.head.value;
        this.head = this.head.next;
        if (!this.head) {
          this.tail = this.head;
        }
        return previousHeadValue;
      };
      _proto.isEmpty = function isEmpty2() {
        return !this.head;
      };
      _proto.reset = function reset() {
        this.head = this.tail = void 0;
      };
      return _Queue2;
    }();
    var _QueueToStackAdapter = /* @__PURE__ */ function() {
      function _QueueToStackAdapter2(queue) {
        this.queue = void 0;
        this.queue = queue;
      }
      var _proto2 = _QueueToStackAdapter2.prototype;
      _proto2.push = function push2(v) {
        this.queue.enqueue(v);
      };
      _proto2.pop = function pop() {
        return this.queue.dequeue();
      };
      _proto2.isEmpty = function isEmpty2() {
        return this.queue.isEmpty();
      };
      _proto2.reset = function reset() {
        return this.queue.reset();
      };
      return _QueueToStackAdapter2;
    }();
    var _Stack = /* @__PURE__ */ function() {
      function _Stack2() {
        this.tail = void 0;
      }
      var _proto = _Stack2.prototype;
      _proto.push = function push2(v) {
        this.tail = {
          value: v,
          prev: this.tail
        };
      };
      _proto.pop = function pop() {
        var node = this.tail;
        this.tail = this.tail.prev;
        return node.value;
      };
      _proto.isEmpty = function isEmpty2() {
        return !this.tail;
      };
      _proto.reset = function reset() {
        this.tail = void 0;
      };
      return _Stack2;
    }();
    var traverse2 = function traverse3(root2, callback, opts) {
      if (!(root2 instanceof Object)) {
        throw new Error("First argument must be an object");
      }
      var fullOpts = Object.assign({}, DEFAULT_TRAVERSAL_OPTS, opts);
      fullOpts.disablePathTracking = typeof fullOpts.pathSeparator !== "string";
      var stackOrQueue;
      if (fullOpts.traversalType === "depth-first") {
        stackOrQueue = new _Stack();
      } else {
        stackOrQueue = new _QueueToStackAdapter(new _Queue());
      }
      var traversalMeta = {
        visitedNodes: /* @__PURE__ */ new WeakSet(),
        depth: 0
      };
      if (!fullOpts.disablePathTracking) {
        traversalMeta.nodePath = null;
      }
      stackOrQueue.push({
        parent: null,
        key: null,
        value: root2,
        meta: traversalMeta
      });
      _traverse(callback, stackOrQueue, fullOpts);
    };
    var _traverse = function _traverse2(callback, stackOrQueue, opts) {
      var newNodesToVisit;
      if (opts.traversalType === "depth-first") {
        newNodesToVisit = new _Stack();
      } else {
        newNodesToVisit = new _QueueToStackAdapter(new _Queue());
      }
      var maxNodes = opts.maxNodes, cycleHandling = opts.cycleHandling, maxDepth = opts.maxDepth, haltOnTruthy = opts.haltOnTruthy, pathSeparator = opts.pathSeparator;
      var visitedNodeCount = 0;
      while (!stackOrQueue.isEmpty() && maxNodes > visitedNodeCount) {
        var callbackContext = stackOrQueue.pop();
        var value = callbackContext.value, meta = callbackContext.meta;
        var visitedNodes = meta.visitedNodes;
        var nodeIsObject = value instanceof Object;
        var skipNode = cycleHandling && nodeIsObject && visitedNodes.has(value);
        if (skipNode) {
          continue;
        }
        if (callback(callbackContext) && haltOnTruthy) {
          break;
        }
        visitedNodeCount++;
        if (nodeIsObject) {
          visitedNodes.add(value);
          var depth = meta.depth, nodePath = meta.nodePath;
          var newDepth = depth + 1;
          if (newDepth > maxDepth) {
            continue;
          }
          newNodesToVisit.reset();
          var keys2 = Object.keys(value);
          for (var i = 0; i < keys2.length; i++) {
            var property = keys2[i];
            var traversalMeta = {
              visitedNodes,
              depth: newDepth
            };
            var newPath = void 0;
            if (!opts.disablePathTracking) {
              if (!nodePath) {
                newPath = property;
              } else {
                newPath = "" + nodePath + pathSeparator + property;
              }
              traversalMeta.nodePath = newPath;
            }
            newNodesToVisit.push({
              value: value[property],
              meta: traversalMeta,
              key: property,
              parent: value
            });
          }
          while (!newNodesToVisit.isEmpty()) {
            stackOrQueue.push(newNodesToVisit.pop());
          }
        }
      }
    };
    function getNodeByPath(root2, path, separator) {
      if (separator === void 0) {
        separator = DEFAULT_SEPARATOR;
      }
      var node = root2;
      var segments = path.split(separator);
      var index2 = 0;
      var segment = segments[index2];
      while (node && segment) {
        node = node[segment];
        segment = segments[++index2];
      }
      return node;
    }
    exports2._Queue = _Queue;
    exports2._QueueToStackAdapter = _QueueToStackAdapter;
    exports2._Stack = _Stack;
    exports2.getNodeByPath = getNodeByPath;
    exports2.traverse = traverse2;
  }
});

// node_modules/object-traversal/dist/index.js
var require_dist = __commonJS({
  "node_modules/object-traversal/dist/index.js"(exports2, module2) {
    "use strict";
    init_process_shim();
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_object_traversal_cjs_production_min();
    } else {
      module2.exports = require_object_traversal_cjs_development();
    }
  }
});

// node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS({
  "node_modules/webidl-conversions/lib/index.js"(exports2, module2) {
    "use strict";
    init_process_shim();
    var conversions = {};
    module2.exports = conversions;
    function sign3(x) {
      return x < 0 ? -1 : 1;
    }
    function evenRound(x) {
      if (x % 1 === 0.5 && (x & 1) === 0) {
        return Math.floor(x);
      } else {
        return Math.round(x);
      }
    }
    function createNumberConversion(bitLength3, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength3;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength3);
      const upperBound = Math.pow(2, bitLength3) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength3);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength3 - 1);
      return function(V, opts) {
        if (!opts) opts = {};
        let x = +V;
        if (opts.enforceRange) {
          if (!Number.isFinite(x)) {
            throw new TypeError("Argument is not a finite number");
          }
          x = sign3(x) * Math.floor(Math.abs(x));
          if (x < lowerBound || x > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x;
        }
        if (!isNaN(x) && opts.clamp) {
          x = evenRound(x);
          if (x < lowerBound) x = lowerBound;
          if (x > upperBound) x = upperBound;
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        x = sign3(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;
        if (!typeOpts.unsigned && x >= moduloBound) {
          return x - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x < 0) {
            x += moduloVal;
          } else if (x === -0) {
            return 0;
          }
        }
        return x;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V) {
      const x = +V;
      if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x;
    };
    conversions["unrestricted double"] = function(V) {
      const x = +V;
      if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
      }
      return x;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V, opts) {
      if (!opts) opts = {};
      if (opts.treatNullAsEmptyString && V === null) {
        return "";
      }
      return String(V);
    };
    conversions["ByteString"] = function(V, opts) {
      const x = String(V);
      let c = void 0;
      for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x;
    };
    conversions["USVString"] = function(V) {
      const S = String(V);
      const n2 = S.length;
      const U = [];
      for (let i = 0; i < n2; ++i) {
        const c = S.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else {
          if (i === n2 - 1) {
            U.push(String.fromCodePoint(65533));
          } else {
            const d = S.charCodeAt(i + 1);
            if (56320 <= d && d <= 57343) {
              const a = c & 1023;
              const b = d & 1023;
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
              ++i;
            } else {
              U.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U.join("");
    };
    conversions["Date"] = function(V, opts) {
      if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V)) {
        return void 0;
      }
      return V;
    };
    conversions["RegExp"] = function(V, opts) {
      if (!(V instanceof RegExp)) {
        V = new RegExp(V);
      }
      return V;
    };
  }
});

// node_modules/whatwg-url/lib/utils.js
var require_utils = __commonJS({
  "node_modules/whatwg-url/lib/utils.js"(exports2, module2) {
    "use strict";
    init_process_shim();
    module2.exports.mixin = function mixin(target, source) {
      const keys2 = Object.getOwnPropertyNames(source);
      for (let i = 0; i < keys2.length; ++i) {
        Object.defineProperty(target, keys2[i], Object.getOwnPropertyDescriptor(source, keys2[i]));
      }
    };
    module2.exports.wrapperSymbol = Symbol("wrapper");
    module2.exports.implSymbol = Symbol("impl");
    module2.exports.wrapperForImpl = function(impl) {
      return impl[module2.exports.wrapperSymbol];
    };
    module2.exports.implForWrapper = function(wrapper) {
      return wrapper[module2.exports.implSymbol];
    };
  }
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/tr46/lib/mappingTable.json"(exports2, module2) {
    module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/tr46/index.js"(exports2, module2) {
    "use strict";
    init_process_shim();
    var punycode = __require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s2) {
        return s2.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string4) {
      return string4.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i = 0; i < len; ++i) {
        var codePoint = domain_name.codePointAt(i);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error3 = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error3 = true;
      }
      var len = countSymbols(label);
      for (var i = 0; i < len; ++i) {
        var status = findStatus(label.codePointAt(i));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error3 = true;
          break;
        }
      }
      return {
        label,
        error: error3
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i = 0; i < labels.length; ++i) {
        try {
          var validation = validateLabel(labels[i]);
          labels[i] = validation.label;
          result.error = result.error || validation.error;
        } catch (e) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l2) {
        try {
          return punycode.toASCII(l2);
        } catch (e) {
          result.error = true;
          return l2;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i = 0; i < labels.length; ++i) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error) return null;
      return labels.join(".");
    };
    module2.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/whatwg-url/lib/url-state-machine.js"(exports2, module2) {
    "use strict";
    init_process_shim();
    var punycode = __require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at2(input10, idx) {
      const c = input10[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    function isSingleDot(buffer3) {
      return buffer3 === "." || buffer3.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer3) {
      buffer3 = buffer3.toLowerCase();
      return buffer3 === ".." || buffer3 === "%2e." || buffer3 === ".%2e" || buffer3 === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string4) {
      return string4.length === 2 && isASCIIAlpha(string4.codePointAt(0)) && (string4[1] === ":" || string4[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string4) {
      return string4.length === 2 && isASCIIAlpha(string4.codePointAt(0)) && string4[1] === ":";
    }
    function containsForbiddenHostCodePoint(string4) {
      return string4.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string4) {
      return string4.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url2) {
      return isSpecialScheme(url2.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c) {
      const buf3 = new Buffer(c);
      let str = "";
      for (let i = 0; i < buf3.length; ++i) {
        str += percentEncode(buf3[i]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input10 = new Buffer(str);
      const output2 = [];
      for (let i = 0; i < input10.length; ++i) {
        if (input10[i] !== 37) {
          output2.push(input10[i]);
        } else if (input10[i] === 37 && isASCIIHex(input10[i + 1]) && isASCIIHex(input10[i + 2])) {
          output2.push(parseInt(input10.slice(i + 1, i + 3).toString(), 16));
          i += 2;
        } else {
          output2.push(input10[i]);
        }
      }
      return new Buffer(output2).toString();
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    function percentEncodeChar(c, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c);
      if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input10) {
      let R = 10;
      if (input10.length >= 2 && input10.charAt(0) === "0" && input10.charAt(1).toLowerCase() === "x") {
        input10 = input10.substring(2);
        R = 16;
      } else if (input10.length >= 2 && input10.charAt(0) === "0") {
        input10 = input10.substring(1);
        R = 8;
      }
      if (input10 === "") {
        return 0;
      }
      const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input10)) {
        return failure;
      }
      return parseInt(input10, R);
    }
    function parseIPv4(input10) {
      const parts = input10.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input10;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input10;
        }
        const n2 = parseIPv4Number(part);
        if (n2 === failure) {
          return input10;
        }
        numbers.push(n2);
      }
      for (let i = 0; i < numbers.length - 1; ++i) {
        if (numbers[i] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n2 of numbers) {
        ipv4 += n2 * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output2 = "";
      let n2 = address;
      for (let i = 1; i <= 4; ++i) {
        output2 = String(n2 % 256) + output2;
        if (i !== 4) {
          output2 = "." + output2;
        }
        n2 = Math.floor(n2 / 256);
      }
      return output2;
    }
    function parseIPv6(input10) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress2 = null;
      let pointer = 0;
      input10 = punycode.ucs2.decode(input10);
      if (input10[pointer] === 58) {
        if (input10[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress2 = pieceIndex;
      }
      while (pointer < input10.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input10[pointer] === 58) {
          if (compress2 !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress2 = pieceIndex;
          continue;
        }
        let value = 0;
        let length5 = 0;
        while (length5 < 4 && isASCIIHex(input10[pointer])) {
          value = value * 16 + parseInt(at2(input10, pointer), 16);
          ++pointer;
          ++length5;
        }
        if (input10[pointer] === 46) {
          if (length5 === 0) {
            return failure;
          }
          pointer -= length5;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input10[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input10[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input10[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input10[pointer])) {
              const number3 = parseInt(at2(input10, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number3;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number3;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input10[pointer] === 58) {
          ++pointer;
          if (input10[pointer] === void 0) {
            return failure;
          }
        } else if (input10[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress2 !== null) {
        let swaps = pieceIndex - compress2;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress2 + swaps - 1];
          address[compress2 + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress2 === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output2 = "";
      const seqResult = findLongestZeroSequence(address);
      const compress2 = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress2 === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output2 += separator;
          ignore0 = true;
          continue;
        }
        output2 += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output2 += ":";
        }
      }
      return output2;
    }
    function parseHost(input10, isSpecialArg) {
      if (input10[0] === "[") {
        if (input10[input10.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input10.substring(1, input10.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input10);
      }
      const domain = utf8PercentDecode(input10);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input10) {
      if (containsForbiddenHostCodePointExcludingPercent(input10)) {
        return failure;
      }
      let output2 = "";
      const decoded = punycode.ucs2.decode(input10);
      for (let i = 0; i < decoded.length; ++i) {
        output2 += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
      }
      return output2;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i = 0; i < arr.length; ++i) {
        if (arr[i] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url2) {
      return url2.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url2) {
      return url2.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url2) {
      const path = url2.path;
      if (path.length === 0) {
        return;
      }
      if (url2.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
        return;
      }
      path.pop();
    }
    function includesCredentials(url2) {
      return url2.username !== "" || url2.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url2) {
      return url2.host === null || url2.host === "" || url2.cannotBeABaseURL || url2.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string4) {
      return /^[A-Za-z]:$/.test(string4);
    }
    function URLStateMachine(input10, base5, encodingOverride, url2, stateOverride) {
      this.pointer = 0;
      this.input = input10;
      this.base = base5 || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url2;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 47) {
        this.state = "relative slash";
      } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === 91) {
          this.arrFlag = true;
        } else if (c === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
          !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c) && c !== 37) {
          this.parseError = true;
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer3 = new Buffer(this.buffer);
        for (let i = 0; i < buffer3.length; ++i) {
          if (buffer3[i] < 33 || buffer3[i] > 126 || buffer3[i] === 34 || buffer3[i] === 35 || buffer3[i] === 60 || buffer3[i] === 62) {
            this.url.query += percentEncode(buffer3[i]);
          } else {
            this.url.query += String.fromCodePoint(buffer3[i]);
          }
        }
        this.buffer = "";
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (isNaN(c)) {
      } else if (c === 0) {
        this.parseError = true;
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url2, excludeFragment) {
      let output2 = url2.scheme + ":";
      if (url2.host !== null) {
        output2 += "//";
        if (url2.username !== "" || url2.password !== "") {
          output2 += url2.username;
          if (url2.password !== "") {
            output2 += ":" + url2.password;
          }
          output2 += "@";
        }
        output2 += serializeHost(url2.host);
        if (url2.port !== null) {
          output2 += ":" + url2.port;
        }
      } else if (url2.host === null && url2.scheme === "file") {
        output2 += "//";
      }
      if (url2.cannotBeABaseURL) {
        output2 += url2.path[0];
      } else {
        for (const string4 of url2.path) {
          output2 += "/" + string4;
        }
      }
      if (url2.query !== null) {
        output2 += "?" + url2.query;
      }
      if (!excludeFragment && url2.fragment !== null) {
        output2 += "#" + url2.fragment;
      }
      return output2;
    }
    function serializeOrigin(tuple2) {
      let result = tuple2.scheme + "://";
      result += serializeHost(tuple2.host);
      if (tuple2.port !== null) {
        result += ":" + tuple2.port;
      }
      return result;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializeURLOrigin = function(url2) {
      switch (url2.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(url2.path[0]));
          } catch (e) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url2.scheme,
            host: url2.host,
            port: url2.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input10, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input10, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url2, username) {
      url2.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i = 0; i < decoded.length; ++i) {
        url2.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.setThePassword = function(url2, password) {
      url2.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i = 0; i < decoded.length; ++i) {
        url2.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.serializeInteger = function(integer2) {
      return String(integer2);
    };
    module2.exports.parseURL = function(input10, options) {
      if (options === void 0) {
        options = {};
      }
      return module2.exports.basicURLParse(input10, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/whatwg-url/lib/URL-impl.js"(exports2) {
    "use strict";
    init_process_shim();
    var usm = require_url_state_machine();
    exports2.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url2 = constructorArgs[0];
        const base5 = constructorArgs[1];
        let parsedBase = null;
        if (base5 !== void 0) {
          parsedBase = usm.basicURLParse(base5);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url2, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v) {
        usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url2 = this._url;
        if (url2.host === null) {
          return "";
        }
        if (url2.port === null) {
          return usm.serializeHost(url2.host);
        }
        return usm.serializeHost(url2.host) + ":" + usm.serializeInteger(url2.port);
      }
      set host(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v) {
        const url2 = this._url;
        if (v === "") {
          url2.query = null;
          return;
        }
        const input10 = v[0] === "?" ? v.substring(1) : v;
        url2.query = "";
        usm.basicURLParse(input10, { url: url2, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input10 = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input10, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/whatwg-url/lib/URL.js"(exports2, module2) {
    "use strict";
    init_process_shim();
    var conversions = require_lib();
    var utils2 = require_utils();
    var Impl = require_URL_impl();
    var impl = utils2.implSymbol;
    function URL2(url2) {
      if (!this || this[impl] || !(this instanceof URL2)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 2; ++i) {
        args[i] = arguments[i];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module2.exports.setup(this, args);
    }
    URL2.prototype.toJSON = function toJSON4() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 0; ++i) {
        args[i] = arguments[i];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL2.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
      },
      enumerable: true,
      configurable: true
    });
    URL2.prototype.toString = function() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL2.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL2.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData) privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils2.wrapperSymbol] = obj;
      },
      interface: URL2,
      expose: {
        Window: { URL: URL2 },
        Worker: { URL: URL2 }
      }
    };
  }
});

// node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "node_modules/whatwg-url/lib/public-api.js"(exports2) {
    "use strict";
    init_process_shim();
    exports2.URL = require_URL().interface;
    exports2.serializeURL = require_url_state_machine().serializeURL;
    exports2.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports2.basicURLParse = require_url_state_machine().basicURLParse;
    exports2.setTheUsername = require_url_state_machine().setTheUsername;
    exports2.setThePassword = require_url_state_machine().setThePassword;
    exports2.serializeHost = require_url_state_machine().serializeHost;
    exports2.serializeInteger = require_url_state_machine().serializeInteger;
    exports2.parseURL = require_url_state_machine().parseURL;
  }
});

// node_modules/node-fetch/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/node-fetch/lib/index.js"(exports2, module2) {
    "use strict";
    init_process_shim();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream = _interopDefault(__require("stream"));
    var http2 = _interopDefault(__require("http"));
    var Url = _interopDefault(__require("url"));
    var whatwgUrl = _interopDefault(require_public_api());
    var https2 = _interopDefault(__require("https"));
    var zlib2 = _interopDefault(__require("zlib"));
    var Readable3 = Stream.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob5 = class _Blob {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size5 = 0;
        if (blobParts) {
          const a = blobParts;
          const length5 = Number(a.length);
          for (let i = 0; i < length5; i++) {
            const element = a[i];
            let buffer3;
            if (element instanceof Buffer) {
              buffer3 = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer3 = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer3 = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer3 = element[BUFFER];
            } else {
              buffer3 = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size5 += buffer3.length;
            buffers.push(buffer3);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type2 = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type2 && !/[^\u0020-\u007E]/.test(type2)) {
          this[TYPE] = type2;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf3 = this[BUFFER];
        const ab = buf3.buffer.slice(buf3.byteOffset, buf3.byteOffset + buf3.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable3();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size5 = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size5 + start, 0);
        } else {
          relativeStart = Math.min(start, size5);
        }
        if (end === void 0) {
          relativeEnd = size5;
        } else if (end < 0) {
          relativeEnd = Math.max(size5 + end, 0);
        } else {
          relativeEnd = Math.min(end, size5);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer3 = this[BUFFER];
        const slicedBuffer = buffer3.slice(relativeStart, relativeStart + span);
        const blob3 = new _Blob([], { type: arguments[2] });
        blob3[BUFFER] = slicedBuffer;
        return blob3;
      }
    };
    Object.defineProperties(Blob5.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob5.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError(message2, type2, systemError) {
      Error.call(this, message2);
      this.message = message2;
      this.type = type2;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = __require("encoding").convert;
    } catch (e) {
    }
    var INTERNALS = Symbol("Body internals");
    var PassThrough = Stream.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size5 = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams2(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob4(body)) ;
      else if (Buffer.isBuffer(body)) ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream) ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size5;
      this.timeout = timeout;
      if (body instanceof Stream) {
        body.on("error", function(err) {
          const error3 = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS].error = error3;
        });
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf3) {
          return buf3.buffer.slice(buf3.byteOffset, buf3.byteOffset + buf3.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf3) {
          return Object.assign(
            // Prevent copying
            new Blob5([], {
              type: ct.toLowerCase()
            }),
            {
              [BUFFER]: buf3
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer3) {
          try {
            return JSON.parse(buffer3.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer3) {
          return buffer3.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer3) {
          return convertBody(buffer3, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name15 of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name15 in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name15);
          Object.defineProperty(proto, name15, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
      }
      let body = this.body;
      if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob4(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
      }
      if (!(body instanceof Stream)) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort2 = false;
      return new Body.Promise(function(resolve2, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort2 = true;
            reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort2 = true;
            reject(err);
          } else {
            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk) {
          if (abort2 || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort2 = true;
            reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort2) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve2(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer3, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
      }
      str = buffer3.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer3, "UTF-8", charset).toString();
    }
    function isURLSearchParams2(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob4(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone4(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream && typeof body.getBoundary !== "function") {
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams2(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob4(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob4(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob4(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name15) {
      name15 = `${name15}`;
      if (invalidTokenRegex.test(name15) || name15 === "") {
        throw new TypeError(`${name15} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map, name15) {
      name15 = name15.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name15) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers2 = class _Headers {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init2 instanceof _Headers) {
          const rawHeaders = init2.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init2 == null) ;
        else if (typeof init2 === "object") {
          const method = init2[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init2) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init2)) {
              const value = init2[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name15) {
        name15 = `${name15}`;
        validateName(name15);
        const key = find(this[MAP], name15);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i = 0;
        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          const name15 = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name15, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name15, value) {
        name15 = `${name15}`;
        value = `${value}`;
        validateName(name15);
        validateValue(value);
        const key = find(this[MAP], name15);
        this[MAP][key !== void 0 ? key : name15] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name15, value) {
        name15 = `${name15}`;
        value = `${value}`;
        validateName(name15);
        validateValue(value);
        const key = find(this[MAP], name15);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name15] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name15) {
        name15 = `${name15}`;
        validateName(name15);
        return find(this[MAP], name15) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name15) {
        name15 = `${name15}`;
        validateName(name15);
        const key = find(this[MAP], name15);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers2.prototype.entries = Headers2.prototype[Symbol.iterator];
    Object.defineProperty(Headers2.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers2.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys2 = Object.keys(headers[MAP]).sort();
      return keys2.map(kind === "key" ? function(k) {
        return k.toLowerCase();
      } : kind === "value" ? function(k) {
        return headers[MAP][k].join(", ");
      } : function(k) {
        return [k.toLowerCase(), headers[MAP][k].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index2 = _INTERNAL.index;
        const values2 = getHeaders(target, kind);
        const len = values2.length;
        if (index2 >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index2 + 1;
        return {
          value: values2[index2],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers2();
      for (const name15 of Object.keys(obj)) {
        if (invalidTokenRegex.test(name15)) {
          continue;
        }
        if (Array.isArray(obj[name15])) {
          for (const val of obj[name15]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name15] === void 0) {
              headers[MAP][name15] = [val];
            } else {
              headers[MAP][name15].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name15])) {
          headers[MAP][name15] = [obj[name15]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = http2.STATUS_CODES;
    var Response2 = class _Response {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers2(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType9 = extractContentType(body);
          if (contentType9) {
            headers.append("Content-Type", contentType9);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone4(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response2.prototype);
    Object.defineProperties(Response2.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response2.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var URL2 = Url.URL || whatwgUrl.URL;
    var parse_url = Url.parse;
    var format_url = Url.format;
    function parseURL2(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL2(urlStr).toString();
      }
      return parse_url(urlStr);
    }
    var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
    function isRequest2(input10) {
      return typeof input10 === "object" && typeof input10[INTERNALS$2] === "object";
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request2 = class _Request {
      constructor(input10) {
        let init2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest2(input10)) {
          if (input10 && input10.href) {
            parsedURL = parseURL2(input10.href);
          } else {
            parsedURL = parseURL2(`${input10}`);
          }
          input10 = {};
        } else {
          parsedURL = parseURL2(input10.url);
        }
        let method = init2.method || input10.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest2(input10) && input10.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init2.body != null ? init2.body : isRequest2(input10) && input10.body !== null ? clone4(input10) : null;
        Body.call(this, inputBody, {
          timeout: init2.timeout || input10.timeout || 0,
          size: init2.size || input10.size || 0
        });
        const headers = new Headers2(init2.headers || input10.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType9 = extractContentType(inputBody);
          if (contentType9) {
            headers.append("Content-Type", contentType9);
          }
        }
        let signal = isRequest2(input10) ? input10.signal : null;
        if ("signal" in init2) signal = init2.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init2.redirect || input10.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init2.follow !== void 0 ? init2.follow : input10.follow !== void 0 ? input10.follow : 20;
        this.compress = init2.compress !== void 0 ? init2.compress : input10.compress !== void 0 ? input10.compress : true;
        this.counter = init2.counter || input10.counter || 0;
        this.agent = init2.agent || input10.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
    };
    Body.mixIn(Request2.prototype);
    Object.defineProperty(Request2.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request2.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers2(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError2(message2) {
      Error.call(this, message2);
      this.type = "aborted";
      this.message = message2;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError2.prototype = Object.create(Error.prototype);
    AbortError2.prototype.constructor = AbortError2;
    AbortError2.prototype.name = "AbortError";
    var URL$1 = Url.URL || whatwgUrl.URL;
    var PassThrough$1 = Stream.PassThrough;
    var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    var isSameProtocol = function isSameProtocol2(destination, original) {
      const orig = new URL$1(original).protocol;
      const dest = new URL$1(destination).protocol;
      return orig === dest;
    };
    function fetch3(url2, opts) {
      if (!fetch3.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body.Promise = fetch3.Promise;
      return new fetch3.Promise(function(resolve2, reject) {
        const request = new Request2(url2, opts);
        const options = getNodeRequestOptions(request);
        const send2 = (options.protocol === "https:" ? https2 : http2).request;
        const signal = request.signal;
        let response = null;
        const abort2 = function abort3() {
          let error3 = new AbortError2("The user aborted a request.");
          reject(error3);
          if (request.body && request.body instanceof Stream.Readable) {
            destroyStream(request.body, error3);
          }
          if (!response || !response.body) return;
          response.body.emit("error", error3);
        };
        if (signal && signal.aborted) {
          abort2();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort2();
          finalize();
        };
        const req = send2(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal) signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          if (response && response.body) {
            destroyStream(response.body, err);
          }
          finalize();
        });
        fixResponseChunkedTransferBadEnding(req, function(err) {
          if (signal && signal.aborted) {
            return;
          }
          if (response && response.body) {
            destroyStream(response.body, err);
          }
        });
        if (parseInt(process.version.substring(1)) < 14) {
          req.on("socket", function(s2) {
            s2.addListener("close", function(hadError) {
              const hasDataListener = s2.listenerCount("data") > 0;
              if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                const err = new Error("Premature close");
                err.code = "ERR_STREAM_PREMATURE_CLOSE";
                response.body.emit("error", err);
              }
            });
          });
        }
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch3.isRedirect(res.statusCode)) {
            const location2 = headers.get("Location");
            let locationURL = null;
            try {
              locationURL = location2 === null ? null : new URL$1(location2, request.url).toString();
            } catch (err) {
              if (request.redirect !== "manual") {
                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location2}`, "invalid-redirect"));
                finalize();
                return;
              }
            }
            switch (request.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers2(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                  for (const name15 of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                    requestOpts.headers.delete(name15);
                  }
                }
                if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve2(fetch3(new Request2(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal) signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response2(body, response_options);
            resolve2(response);
            return;
          }
          const zlibOptions2 = {
            flush: zlib2.Z_SYNC_FLUSH,
            finishFlush: zlib2.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib2.createGunzip(zlibOptions2));
            response = new Response2(body, response_options);
            resolve2(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib2.createInflate());
              } else {
                body = body.pipe(zlib2.createInflateRaw());
              }
              response = new Response2(body, response_options);
              resolve2(response);
            });
            raw.on("end", function() {
              if (!response) {
                response = new Response2(body, response_options);
                resolve2(response);
              }
            });
            return;
          }
          if (codings == "br" && typeof zlib2.createBrotliDecompress === "function") {
            body = body.pipe(zlib2.createBrotliDecompress());
            response = new Response2(body, response_options);
            resolve2(response);
            return;
          }
          response = new Response2(body, response_options);
          resolve2(response);
        });
        writeToStream(req, request);
      });
    }
    function fixResponseChunkedTransferBadEnding(request, errorCallback) {
      let socket;
      request.on("socket", function(s2) {
        socket = s2;
      });
      request.on("response", function(response) {
        const headers = response.headers;
        if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
          response.once("close", function(hadError) {
            const hasDataListener = socket && socket.listenerCount("data") > 0;
            if (hasDataListener && !hadError) {
              const err = new Error("Premature close");
              err.code = "ERR_STREAM_PREMATURE_CLOSE";
              errorCallback(err);
            }
          });
        }
      });
    }
    function destroyStream(stream4, err) {
      if (stream4.destroy) {
        stream4.destroy(err);
      } else {
        stream4.emit("error", err);
        stream4.end();
      }
    }
    fetch3.isRedirect = function(code20) {
      return code20 === 301 || code20 === 302 || code20 === 303 || code20 === 307 || code20 === 308;
    };
    fetch3.Promise = global.Promise;
    module2.exports = exports2 = fetch3;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = exports2;
    exports2.Headers = Headers2;
    exports2.Request = Request2;
    exports2.Response = Response2;
    exports2.FetchError = FetchError;
    exports2.AbortError = AbortError2;
  }
});

// node_modules/cross-fetch/dist/node-ponyfill.js
var require_node_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/node-ponyfill.js"(exports2, module2) {
    init_process_shim();
    var nodeFetch = require_lib2();
    var realFetch = nodeFetch.default || nodeFetch;
    var fetch3 = function(url2, options) {
      if (/^\/\//.test(url2)) {
        url2 = "https:" + url2;
      }
      return realFetch.call(this, url2, options);
    };
    fetch3.ponyfill = true;
    module2.exports = exports2 = fetch3;
    exports2.fetch = fetch3;
    exports2.Headers = nodeFetch.Headers;
    exports2.Request = nodeFetch.Request;
    exports2.Response = nodeFetch.Response;
    exports2.default = fetch3;
  }
});

// node_modules/@fleek-platform/sdk/dist/browser/empty-DDVBHZPM.js
var empty_DDVBHZPM_exports = {};
__export(empty_DDVBHZPM_exports, {
  Readable: () => Readable,
  default: () => empty_default
});
var init_empty_DDVBHZPM = __esm({
  "node_modules/@fleek-platform/sdk/dist/browser/empty-DDVBHZPM.js"() {
    init_process_shim();
    init_chunk_UHP4SR3D();
    init_chunk_DNE4QC7K();
    init_empty();
  }
});

// node_modules/@fleek-platform/sdk/dist/browser/src-VT7VWDLR.js
var src_VT7VWDLR_exports = {};
__export(src_VT7VWDLR_exports, {
  CID: () => CID4,
  create: () => create22,
  globSource: () => globSource,
  multiaddr: () => export_multiaddr,
  urlSource: () => export_urlSource
});
function encode36(num, out, offset3) {
  out = out || [];
  offset3 = offset3 || 0;
  var oldOffset = offset3;
  while (num >= INT5) {
    out[offset3++] = num & 255 | MSB5;
    num /= 128;
  }
  while (num & MSBALL5) {
    out[offset3++] = num & 255 | MSB5;
    num >>>= 7;
  }
  out[offset3] = num | 0;
  encode36.bytes = offset3 - oldOffset + 1;
  return out;
}
function read9(buf22, offset3) {
  var res = 0, offset3 = offset3 || 0, shift = 0, counter = offset3, b, l2 = buf22.length;
  do {
    if (counter >= l2) {
      read9.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf22[counter++];
    res += shift < 28 ? (b & REST$14) << shift : (b & REST$14) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$14);
  read9.bytes = counter - offset3;
  return res;
}
function base4(ALPHABET2, name82) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET2.length; i++) {
    var x = ALPHABET2.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode132(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length22 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size5 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size5);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size5 - 1; (carry !== 0 || i2 < length22) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length22 = i2;
      pbegin++;
    }
    var it2 = size5 - length22;
    while (it2 !== size5 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size5; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length22 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size5 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size5);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size5 - 1; (carry !== 0 || i2 < length22) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length22 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size5 - length22;
    while (it4 !== size5 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size5 - it4));
    var j2 = zeroes;
    while (it4 !== size5) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode142(string22) {
    var buffer22 = decodeUnsafe(string22);
    if (buffer22) {
      return buffer22;
    }
    throw new Error(`Non-${name82} character`);
  }
  return {
    encode: encode132,
    decodeUnsafe,
    decode: decode142
  };
}
function is2(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf2 = typeof value;
  if (typeofs2.includes(typeOf2)) {
    return typeOf2;
  }
  if (typeOf2 === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer4(value)) {
    return "Buffer";
  }
  const objectType = getObjectType2(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer4(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType2(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames2.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
function isBuffer22(buf22) {
  return useBuffer2 && globalThis.Buffer.isBuffer(buf22);
}
function asU8A2(buf22) {
  if (!(buf22 instanceof Uint8Array)) {
    return Uint8Array.from(buf22);
  }
  return isBuffer22(buf22) ? new Uint8Array(buf22.buffer, buf22.byteOffset, buf22.byteLength) : buf22;
}
function compare3(b1, b2) {
  if (isBuffer22(b1) && isBuffer22(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes3(string22, units = Infinity) {
  let codePoint;
  const length22 = string22.length;
  let leadSurrogate = null;
  const bytes3 = [];
  for (let i = 0; i < length22; ++i) {
    codePoint = string22.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes3.push(239, 191, 189);
          continue;
        } else if (i + 1 === length22) {
          if ((units -= 3) > -1)
            bytes3.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes3.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes3.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes3.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes3.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes3.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes3.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes3;
}
function utf8Slice2(buf22, offset3, end) {
  const res = [];
  while (offset3 < end) {
    const firstByte = buf22[offset3];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset3 + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf22[offset3 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf22[offset3 + 1];
          thirdByte = buf22[offset3 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf22[offset3 + 1];
          thirdByte = buf22[offset3 + 2];
          fourthByte = buf22[offset3 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset3 += bytesPerSequence;
  }
  return decodeCodePointsArray2(res);
}
function decodeCodePointsArray2(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH2) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2));
  }
  return res;
}
function assertEnoughData2(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix2} not enough data for type`);
  }
}
function readUint82(data, offset3, options) {
  assertEnoughData2(data, offset3, 1);
  const value = data[offset3];
  if (options.strict === true && value < uintBoundaries2[0]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint162(data, offset3, options) {
  assertEnoughData2(data, offset3, 2);
  const value = data[offset3] << 8 | data[offset3 + 1];
  if (options.strict === true && value < uintBoundaries2[1]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint322(data, offset3, options) {
  assertEnoughData2(data, offset3, 4);
  const value = data[offset3] * 16777216 + (data[offset3 + 1] << 16) + (data[offset3 + 2] << 8) + data[offset3 + 3];
  if (options.strict === true && value < uintBoundaries2[2]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint642(data, offset3, options) {
  assertEnoughData2(data, offset3, 8);
  const hi = data[offset3] * 16777216 + (data[offset3 + 1] << 16) + (data[offset3 + 2] << 8) + data[offset3 + 3];
  const lo = data[offset3 + 4] * 16777216 + (data[offset3 + 5] << 16) + (data[offset3 + 6] << 8) + data[offset3 + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries2[3]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix2} integers outside of the safe integer range are not supported`);
}
function decodeUint82(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint82(data, pos + 1, options), 2);
}
function decodeUint162(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint162(data, pos + 1, options), 3);
}
function decodeUint322(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint322(data, pos + 1, options), 5);
}
function decodeUint642(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint642(data, pos + 1, options), 9);
}
function encodeUint2(buf22, token) {
  return encodeUintValue2(buf22, 0, token.value);
}
function encodeUintValue2(buf22, major, uint) {
  if (uint < uintBoundaries2[0]) {
    const nuint = Number(uint);
    buf22.push([major | nuint]);
  } else if (uint < uintBoundaries2[1]) {
    const nuint = Number(uint);
    buf22.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries2[2]) {
    const nuint = Number(uint);
    buf22.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries2[3]) {
    const nuint = Number(uint);
    buf22.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries2[4]) {
      const set5 = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set5[8] = lo & 255;
      lo = lo >> 8;
      set5[7] = lo & 255;
      lo = lo >> 8;
      set5[6] = lo & 255;
      lo = lo >> 8;
      set5[5] = lo & 255;
      set5[4] = hi & 255;
      hi = hi >> 8;
      set5[3] = hi & 255;
      hi = hi >> 8;
      set5[2] = hi & 255;
      hi = hi >> 8;
      set5[1] = hi & 255;
      buf22.push(set5);
    } else {
      throw new Error(`${decodeErrPrefix2} encountered BigInt larger than allowable range`);
    }
  }
}
function decodeNegint82(data, pos, _minor, options) {
  return new Token2(Type2.negint, -1 - readUint82(data, pos + 1, options), 2);
}
function decodeNegint162(data, pos, _minor, options) {
  return new Token2(Type2.negint, -1 - readUint162(data, pos + 1, options), 3);
}
function decodeNegint322(data, pos, _minor, options) {
  return new Token2(Type2.negint, -1 - readUint322(data, pos + 1, options), 5);
}
function decodeNegint642(data, pos, _minor, options) {
  const int2 = readUint642(data, pos + 1, options);
  if (typeof int2 !== "bigint") {
    const value = -1 - int2;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token2(Type2.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix2} integers outside of the safe integer range are not supported`);
  }
  return new Token2(Type2.negint, neg1b2 - BigInt(int2), 9);
}
function encodeNegint2(buf22, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b2 - pos1b2 : negint * -1 - 1;
  encodeUintValue2(buf22, token.type.majorEncoded, unsigned);
}
function toToken5(data, pos, prefix2, length22) {
  assertEnoughData2(data, pos, prefix2 + length22);
  const buf22 = slice3(data, pos + prefix2, pos + prefix2 + length22);
  return new Token2(Type2.bytes, buf22, prefix2 + length22);
}
function decodeBytesCompact2(data, pos, minor, _options2) {
  return toToken5(data, pos, 1, minor);
}
function decodeBytes82(data, pos, _minor, options) {
  return toToken5(data, pos, 2, readUint82(data, pos + 1, options));
}
function decodeBytes162(data, pos, _minor, options) {
  return toToken5(data, pos, 3, readUint162(data, pos + 1, options));
}
function decodeBytes322(data, pos, _minor, options) {
  return toToken5(data, pos, 5, readUint322(data, pos + 1, options));
}
function decodeBytes642(data, pos, _minor, options) {
  const l2 = readUint642(data, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer bytes lengths not supported`);
  }
  return toToken5(data, pos, 9, l2);
}
function tokenBytes2(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type2.string ? fromString22(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes2(buf22, token) {
  const bytes3 = tokenBytes2(token);
  encodeUintValue2(buf22, token.type.majorEncoded, bytes3.length);
  buf22.push(bytes3);
}
function compareBytes2(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare3(b1, b2);
}
function toToken22(data, pos, prefix2, length22, options) {
  const totLength = prefix2 + length22;
  assertEnoughData2(data, pos, totLength);
  const tok = new Token2(Type2.string, toString22(data, pos + prefix2, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice3(data, pos + prefix2, pos + totLength);
  }
  return tok;
}
function decodeStringCompact2(data, pos, minor, options) {
  return toToken22(data, pos, 1, minor, options);
}
function decodeString82(data, pos, _minor, options) {
  return toToken22(data, pos, 2, readUint82(data, pos + 1, options), options);
}
function decodeString162(data, pos, _minor, options) {
  return toToken22(data, pos, 3, readUint162(data, pos + 1, options), options);
}
function decodeString322(data, pos, _minor, options) {
  return toToken22(data, pos, 5, readUint322(data, pos + 1, options), options);
}
function decodeString642(data, pos, _minor, options) {
  const l2 = readUint642(data, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer string lengths not supported`);
  }
  return toToken22(data, pos, 9, l2, options);
}
function toToken32(_data2, _pos, prefix2, length22) {
  return new Token2(Type2.array, length22, prefix2);
}
function decodeArrayCompact2(data, pos, minor, _options2) {
  return toToken32(data, pos, 1, minor);
}
function decodeArray82(data, pos, _minor, options) {
  return toToken32(data, pos, 2, readUint82(data, pos + 1, options));
}
function decodeArray162(data, pos, _minor, options) {
  return toToken32(data, pos, 3, readUint162(data, pos + 1, options));
}
function decodeArray322(data, pos, _minor, options) {
  return toToken32(data, pos, 5, readUint322(data, pos + 1, options));
}
function decodeArray642(data, pos, _minor, options) {
  const l2 = readUint642(data, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer array lengths not supported`);
  }
  return toToken32(data, pos, 9, l2);
}
function decodeArrayIndefinite2(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
  }
  return toToken32(data, pos, 1, Infinity);
}
function encodeArray2(buf22, token) {
  encodeUintValue2(buf22, Type2.array.majorEncoded, token.value);
}
function toToken42(_data2, _pos, prefix2, length22) {
  return new Token2(Type2.map, length22, prefix2);
}
function decodeMapCompact2(data, pos, minor, _options2) {
  return toToken42(data, pos, 1, minor);
}
function decodeMap82(data, pos, _minor, options) {
  return toToken42(data, pos, 2, readUint82(data, pos + 1, options));
}
function decodeMap162(data, pos, _minor, options) {
  return toToken42(data, pos, 3, readUint162(data, pos + 1, options));
}
function decodeMap322(data, pos, _minor, options) {
  return toToken42(data, pos, 5, readUint322(data, pos + 1, options));
}
function decodeMap642(data, pos, _minor, options) {
  const l2 = readUint642(data, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer map lengths not supported`);
  }
  return toToken42(data, pos, 9, l2);
}
function decodeMapIndefinite2(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
  }
  return toToken42(data, pos, 1, Infinity);
}
function encodeMap2(buf22, token) {
  encodeUintValue2(buf22, Type2.map.majorEncoded, token.value);
}
function decodeTagCompact2(_data2, _pos, minor, _options2) {
  return new Token2(Type2.tag, minor, 1);
}
function decodeTag82(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint82(data, pos + 1, options), 2);
}
function decodeTag162(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint162(data, pos + 1, options), 3);
}
function decodeTag322(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint322(data, pos + 1, options), 5);
}
function decodeTag642(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint642(data, pos + 1, options), 9);
}
function encodeTag2(buf22, token) {
  encodeUintValue2(buf22, Type2.tag.majorEncoded, token.value);
}
function decodeUndefined2(_data2, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix2} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token2(Type2.null, null, 1);
  }
  return new Token2(Type2.undefined, void 0, 1);
}
function decodeBreak2(_data2, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
  }
  return new Token2(Type2.break, void 0, 1);
}
function createToken2(value, bytes3, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix2} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix2} Infinity values are not supported`);
    }
  }
  return new Token2(Type2.float, value, bytes3);
}
function decodeFloat162(data, pos, _minor, options) {
  return createToken2(readFloat162(data, pos + 1), 3, options);
}
function decodeFloat322(data, pos, _minor, options) {
  return createToken2(readFloat322(data, pos + 1), 5, options);
}
function decodeFloat642(data, pos, _minor, options) {
  return createToken2(readFloat642(data, pos + 1), 9, options);
}
function encodeFloat2(buf22, token, options) {
  const float2 = token.value;
  if (float2 === false) {
    buf22.push([Type2.float.majorEncoded | MINOR_FALSE2]);
  } else if (float2 === true) {
    buf22.push([Type2.float.majorEncoded | MINOR_TRUE2]);
  } else if (float2 === null) {
    buf22.push([Type2.float.majorEncoded | MINOR_NULL2]);
  } else if (float2 === void 0) {
    buf22.push([Type2.float.majorEncoded | MINOR_UNDEFINED2]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat162(float2);
      decoded = readFloat162(ui8a2, 1);
      if (float2 === decoded || Number.isNaN(float2)) {
        ui8a2[0] = 249;
        buf22.push(ui8a2.slice(0, 3));
        success = true;
      } else {
        encodeFloat322(float2);
        decoded = readFloat322(ui8a2, 1);
        if (float2 === decoded) {
          ui8a2[0] = 250;
          buf22.push(ui8a2.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat642(float2);
      decoded = readFloat642(ui8a2, 1);
      ui8a2[0] = 251;
      buf22.push(ui8a2.slice(0, 9));
    }
  }
}
function encodeFloat162(inp) {
  if (inp === Infinity) {
    dataView2.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView2.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView2.setUint16(0, 32256, false);
  } else {
    dataView2.setFloat32(0, inp);
    const valu32 = dataView2.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView2.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView2.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView2.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView2.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView2.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat162(ui8a22, pos) {
  if (ui8a22.length - pos < 2) {
    throw new Error(`${decodeErrPrefix2} not enough data for float16`);
  }
  const half = (ui8a22[pos] << 8) + ui8a22[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat322(inp) {
  dataView2.setFloat32(0, inp, false);
}
function readFloat322(ui8a22, pos) {
  if (ui8a22.length - pos < 4) {
    throw new Error(`${decodeErrPrefix2} not enough data for float32`);
  }
  const offset3 = (ui8a22.byteOffset || 0) + pos;
  return new DataView(ui8a22.buffer, offset3, 4).getFloat32(0, false);
}
function encodeFloat642(inp) {
  dataView2.setFloat64(0, inp, false);
}
function readFloat642(ui8a22, pos) {
  if (ui8a22.length - pos < 8) {
    throw new Error(`${decodeErrPrefix2} not enough data for float64`);
  }
  const offset3 = (ui8a22.byteOffset || 0) + pos;
  return new DataView(ui8a22.buffer, offset3, 8).getFloat64(0, false);
}
function invalidMinor2(data, pos, minor) {
  throw new Error(`${decodeErrPrefix2} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer2(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix2} ${msg}`);
  };
}
function quickEncodeToken2(token) {
  switch (token.type) {
    case Type2.false:
      return fromArray2([244]);
    case Type2.true:
      return fromArray2([245]);
    case Type2.null:
      return fromArray2([246]);
    case Type2.bytes:
      if (!token.value.length) {
        return fromArray2([64]);
      }
      return;
    case Type2.string:
      if (token.value === "") {
        return fromArray2([96]);
      }
      return;
    case Type2.array:
      if (token.value === 0) {
        return fromArray2([128]);
      }
      return;
    case Type2.map:
      if (token.value === 0) {
        return fromArray2([160]);
      }
      return;
    case Type2.uint:
      if (token.value < 24) {
        return fromArray2([Number(token.value)]);
      }
      return;
    case Type2.negint:
      if (token.value >= -24) {
        return fromArray2([31 - Number(token.value)]);
      }
  }
}
function makeCborEncoders2() {
  const encoders = [];
  encoders[Type2.uint.major] = encodeUint2;
  encoders[Type2.negint.major] = encodeNegint2;
  encoders[Type2.bytes.major] = encodeBytes2;
  encoders[Type2.string.major] = encodeString2;
  encoders[Type2.array.major] = encodeArray2;
  encoders[Type2.map.major] = encodeMap2;
  encoders[Type2.tag.major] = encodeTag2;
  encoders[Type2.float.major] = encodeFloat2;
  return encoders;
}
function objectToTokens2(obj, options = {}, refStack) {
  const typ = is2(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders2[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders2[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix2} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries2(entries3, options) {
  if (options.mapSorter) {
    entries3.sort(options.mapSorter);
  }
}
function mapSorter3(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders3[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded2(buf22, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded2(buf22, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf22, tokens, options);
  }
}
function encodeCustom2(data, encoders, options) {
  const tokens = objectToTokens2(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder4 = encoders[tokens.type.major];
    if (encoder4.encodedSize) {
      const size5 = encoder4.encodedSize(tokens, options);
      const buf22 = new Bl2(size5);
      encoder4(buf22, tokens, options);
      if (buf22.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A2(buf22.chunks[0]);
    }
  }
  buf2.reset();
  tokensToEncoded2(buf2, tokens, encoders, options);
  return buf2.toBytes(true);
}
function encode42(data, options) {
  options = Object.assign({}, defaultEncodeOptions4, options);
  return encodeCustom2(data, cborEncoders3, options);
}
function tokenToArray2(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject2(tokeniser, options);
    if (value === BREAK2) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix2} got unexpected break to lengthed array`);
    }
    if (value === DONE2) {
      throw new Error(`${decodeErrPrefix2} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
function tokenToMap2(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject2(tokeniser, options);
    if (key === BREAK2) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix2} got unexpected break to lengthed map`);
    }
    if (key === DONE2) {
      throw new Error(`${decodeErrPrefix2} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix2} non-string keys not supported (got ${typeof key})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix2} found repeat map key "${key}"`);
      }
    }
    const value = tokensToObject2(tokeniser, options);
    if (value === DONE2) {
      throw new Error(`${decodeErrPrefix2} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject2(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE2;
  }
  const token = tokeniser.next();
  if (token.type === Type2.break) {
    return BREAK2;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type2.array) {
    return tokenToArray2(token, tokeniser, options);
  }
  if (token.type === Type2.map) {
    return tokenToMap2(token, tokeniser, options);
  }
  if (token.type === Type2.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject2(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix2} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decode62(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix2} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions2, options);
  const tokeniser = options.tokenizer || new Tokeniser2(data, options);
  const decoded = tokensToObject2(tokeniser, options);
  if (decoded === DONE2) {
    throw new Error(`${decodeErrPrefix2} did not find any content to decode`);
  }
  if (decoded === BREAK2) {
    throw new Error(`${decodeErrPrefix2} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix2} too many terminals, data makes no sense`);
  }
  return decoded;
}
function cidEncoder3(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID4.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes3 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes3.set(cid.bytes, 1);
  return [
    new Token2(Type2.tag, CID_CBOR_TAG2),
    new Token2(Type2.bytes, bytes3)
  ];
}
function undefinedEncoder3() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder3(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
function cidDecoder2(bytes3) {
  if (bytes3[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID4.decode(bytes3.subarray(1));
}
function encode102(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars2[c];
    return p;
  }, "");
}
function decode112(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes2[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
function asUint8Array3(buf22) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf22.buffer, buf22.byteOffset, buf22.byteLength);
  }
  return buf22;
}
function allocUnsafe2(size5 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array3(globalThis.Buffer.allocUnsafe(size5));
  }
  return new Uint8Array(size5);
}
function createCodec2(name82, prefix2, encode132, decode142) {
  return {
    name: name82,
    prefix: prefix2,
    encoder: {
      name: name82,
      prefix: prefix2,
      encode: encode132
    },
    decoder: { decode: decode142 }
  };
}
function toString32(array2, encoding = "utf8") {
  const base33 = bases_default[encoding];
  if (!base33) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array2.buffer, array2.byteOffset, array2.byteLength).toString("utf8");
  }
  return base33.encoder.encode(array2).substring(1);
}
function fromString32(string22, encoding = "utf8") {
  const base33 = bases_default[encoding];
  if (!base33) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array3(globalThis.Buffer.from(string22, "utf-8"));
  }
  return base33.decoder.decode(`${base33.prefix}${string22}`);
}
function concat22(arrays, length22) {
  if (!length22) {
    length22 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output2 = allocUnsafe2(length22);
  let offset3 = 0;
  for (const arr of arrays) {
    output2.set(arr, offset3);
    offset3 += arr.length;
  }
  return asUint8Array3(output2);
}
function equals32(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function decodeVarint3(bytes3, offset3) {
  let v = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset3 >= bytes3.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b = bytes3[offset3++];
    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
    if (b < 128) {
      break;
    }
  }
  return [
    v,
    offset3
  ];
}
function decodeBytes2(bytes3, offset3) {
  let byteLen;
  [byteLen, offset3] = decodeVarint3(bytes3, offset3);
  const postOffset = offset3 + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes3.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [
    bytes3.subarray(offset3, postOffset),
    postOffset
  ];
}
function decodeKey2(bytes3, index2) {
  let wire;
  [wire, index2] = decodeVarint3(bytes3, index2);
  return [
    wire & 7,
    wire >> 3,
    index2
  ];
}
function decodeLink2(bytes3) {
  const link5 = {};
  const l2 = bytes3.length;
  let index2 = 0;
  while (index2 < l2) {
    let wireType, fieldNum;
    [wireType, fieldNum, index2] = decodeKey2(bytes3, index2);
    if (fieldNum === 1) {
      if (link5.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link5.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link5.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      ;
      [link5.Hash, index2] = decodeBytes2(bytes3, index2);
    } else if (fieldNum === 2) {
      if (link5.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link5.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index2] = decodeBytes2(bytes3, index2);
      link5.Name = textDecoder4.decode(byts);
    } else if (fieldNum === 3) {
      if (link5.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      ;
      [link5.Tsize, index2] = decodeVarint3(bytes3, index2);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index2 > l2) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link5;
}
function decodeNode2(bytes3) {
  const l2 = bytes3.length;
  let index2 = 0;
  let links3;
  let linksBeforeData = false;
  let data;
  while (index2 < l2) {
    let wireType, fieldNum;
    [wireType, fieldNum, index2] = decodeKey2(bytes3, index2);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      ;
      [data, index2] = decodeBytes2(bytes3, index2);
      if (links3) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links3) {
        links3 = [];
      }
      let byts;
      [byts, index2] = decodeBytes2(bytes3, index2);
      links3.push(decodeLink2(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index2 > l2) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links3 || [];
  return node;
}
function encodeLink3(link5, bytes3) {
  let i = bytes3.length;
  if (typeof link5.Tsize === "number") {
    if (link5.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link5.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i = encodeVarint2(bytes3, i, link5.Tsize) - 1;
    bytes3[i] = 24;
  }
  if (typeof link5.Name === "string") {
    const nameBytes = textEncoder6.encode(link5.Name);
    i -= nameBytes.length;
    bytes3.set(nameBytes, i);
    i = encodeVarint2(bytes3, i, nameBytes.length) - 1;
    bytes3[i] = 18;
  }
  if (link5.Hash) {
    i -= link5.Hash.length;
    bytes3.set(link5.Hash, i);
    i = encodeVarint2(bytes3, i, link5.Hash.length) - 1;
    bytes3[i] = 10;
  }
  return bytes3.length - i;
}
function encodeNode2(node) {
  const size5 = sizeNode2(node);
  const bytes3 = new Uint8Array(size5);
  let i = size5;
  if (node.Data) {
    i -= node.Data.length;
    bytes3.set(node.Data, i);
    i = encodeVarint2(bytes3, i, node.Data.length) - 1;
    bytes3[i] = 10;
  }
  if (node.Links) {
    for (let index2 = node.Links.length - 1; index2 >= 0; index2--) {
      const size22 = encodeLink3(node.Links[index2], bytes3.subarray(0, i));
      i -= size22;
      i = encodeVarint2(bytes3, i, size22) - 1;
      bytes3[i] = 18;
    }
  }
  return bytes3;
}
function sizeLink2(link5) {
  let n2 = 0;
  if (link5.Hash) {
    const l2 = link5.Hash.length;
    n2 += 1 + l2 + sov2(l2);
  }
  if (typeof link5.Name === "string") {
    const l2 = textEncoder6.encode(link5.Name).length;
    n2 += 1 + l2 + sov2(l2);
  }
  if (typeof link5.Tsize === "number") {
    n2 += 1 + sov2(link5.Tsize);
  }
  return n2;
}
function sizeNode2(node) {
  let n2 = 0;
  if (node.Data) {
    const l2 = node.Data.length;
    n2 += 1 + l2 + sov2(l2);
  }
  if (node.Links) {
    for (const link5 of node.Links) {
      const l2 = sizeLink2(link5);
      n2 += 1 + l2 + sov2(l2);
    }
  }
  return n2;
}
function encodeVarint2(bytes3, offset3, v) {
  offset3 -= sov2(v);
  const base33 = offset3;
  while (v >= maxUInt322) {
    bytes3[offset3++] = v & 127 | 128;
    v /= 128;
  }
  while (v >= 128) {
    bytes3[offset3++] = v & 127 | 128;
    v >>>= 7;
  }
  bytes3[offset3] = v;
  return base33;
}
function sov2(x) {
  if (x % 2 === 0) {
    x++;
  }
  return Math.floor((len642(x) + 6) / 7);
}
function len642(x) {
  let n2 = 0;
  if (x >= maxInt322) {
    x = Math.floor(x / maxInt322);
    n2 = 32;
  }
  if (x >= 1 << 16) {
    x >>>= 16;
    n2 += 16;
  }
  if (x >= 1 << 8) {
    x >>>= 8;
    n2 += 8;
  }
  return n2 + len8tab2[x];
}
function linkComparator2(a, b) {
  if (a === b) {
    return 0;
  }
  const abuf = a.Name ? textEncoder22.encode(a.Name) : [];
  const bbuf = b.Name ? textEncoder22.encode(b.Name) : [];
  let x = abuf.length;
  let y = bbuf.length;
  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (abuf[i] !== bbuf[i]) {
      x = abuf[i];
      y = bbuf[i];
      break;
    }
  }
  return x < y ? -1 : y < x ? 1 : 0;
}
function hasOnlyProperties2(node, properties) {
  return !Object.keys(node).some((p) => !properties.includes(p));
}
function asLink2(link5) {
  if (typeof link5.asCID === "object") {
    const Hash2 = CID4.asCID(link5);
    if (!Hash2) {
      throw new TypeError("Invalid DAG-PB form");
    }
    return { Hash: Hash2 };
  }
  if (typeof link5 !== "object" || Array.isArray(link5)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbl = {};
  if (link5.Hash) {
    let cid = CID4.asCID(link5.Hash);
    try {
      if (!cid) {
        if (typeof link5.Hash === "string") {
          cid = CID4.parse(link5.Hash);
        } else if (link5.Hash instanceof Uint8Array) {
          cid = CID4.decode(link5.Hash);
        }
      }
    } catch (e) {
      throw new TypeError(`Invalid DAG-PB form: ${e.message}`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (typeof link5.Name === "string") {
    pbl.Name = link5.Name;
  }
  if (typeof link5.Tsize === "number") {
    pbl.Tsize = link5.Tsize;
  }
  return pbl;
}
function prepare3(node) {
  if (node instanceof Uint8Array || typeof node === "string") {
    node = { Data: node };
  }
  if (typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbn = {};
  if (node.Data !== void 0) {
    if (typeof node.Data === "string") {
      pbn.Data = textEncoder22.encode(node.Data);
    } else if (node.Data instanceof Uint8Array) {
      pbn.Data = node.Data;
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  }
  if (node.Links !== void 0) {
    if (Array.isArray(node.Links)) {
      pbn.Links = node.Links.map(asLink2);
      pbn.Links.sort(linkComparator2);
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate2(node) {
  if (!node || typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties2(node, pbNodeProperties2)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");
  }
  if (!Array.isArray(node.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be an array)");
  }
  for (let i = 0; i < node.Links.length; i++) {
    const link5 = node.Links[i];
    if (!link5 || typeof link5 !== "object" || Array.isArray(link5)) {
      throw new TypeError("Invalid DAG-PB form (bad link object)");
    }
    if (!hasOnlyProperties2(link5, pbLinkProperties2)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");
    }
    if (!link5.Hash) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link5.Hash.asCID !== link5.Hash) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link5.Name !== void 0 && typeof link5.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link5.Tsize !== void 0 && (typeof link5.Tsize !== "number" || link5.Tsize % 1 !== 0)) {
      throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
    }
    if (i > 0 && linkComparator2(link5, node.Links[i - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
function createNode(data, links3 = []) {
  return prepare3({
    Data: data,
    Links: links3
  });
}
function createLink(name82, size5, cid) {
  return asLink2({
    Hash: cid,
    Name: name82,
    Tsize: size5
  });
}
function encode37(node) {
  validate2(node);
  const pbn = {};
  if (node.Links) {
    pbn.Links = node.Links.map((l2) => {
      const link5 = {};
      if (l2.Hash) {
        link5.Hash = l2.Hash.bytes;
      }
      if (l2.Name !== void 0) {
        link5.Name = l2.Name;
      }
      if (l2.Tsize !== void 0) {
        link5.Tsize = l2.Tsize;
      }
      return link5;
    });
  }
  if (node.Data) {
    pbn.Data = node.Data;
  }
  return encodeNode2(pbn);
}
function decode52(bytes3) {
  const pbn = decodeNode2(bytes3);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l2) => {
      const link5 = {};
      try {
        link5.Hash = CID4.decode(l2.Hash);
      } catch (e) {
      }
      if (!link5.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l2.Name !== void 0) {
        link5.Name = l2.Name;
      }
      if (l2.Tsize !== void 0) {
        link5.Tsize = l2.Tsize;
      }
      return link5;
    });
  }
  return node;
}
function cidEncoder4(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID4.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes3 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes3.set(cid.bytes, 1);
  return [
    new Token2(Type2.tag, CID_CBOR_TAG3),
    new Token2(Type2.bytes, bytes3)
  ];
}
function undefinedEncoder4() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder4(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
function cidDecoder3(bytes3) {
  if (bytes3[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID4.decode(bytes3.subarray(1));
}
function mapSorter22(e1, e2) {
  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {
    throw new Error(`${encodeErrPrefix2} complex map keys are not supported`);
  }
  const keyToken1 = e1[0];
  const keyToken2 = e2[0];
  if (keyToken1.type !== Type2.string || keyToken2.type !== Type2.string) {
    throw new Error(`${encodeErrPrefix2} non-string map keys are not supported`);
  }
  if (keyToken1 < keyToken2) {
    return -1;
  }
  if (keyToken1 > keyToken2) {
    return 1;
  }
  throw new Error(`${encodeErrPrefix2} unexpected duplicate map keys, this is not supported`);
}
function encode62(data, options) {
  options = Object.assign({}, defaultEncodeOptions22, options);
  return encodeCustom2(data, new JSONEncoder2(), options);
}
function decode82(data, options) {
  options = Object.assign({ tokenizer: new Tokenizer2(data, options) }, options);
  return decode62(data, options);
}
function cidEncoder22(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID4.asCID(obj);
  if (!cid) {
    return null;
  }
  const cidString = cid.toString();
  return [
    new Token2(Type2.map, Infinity, 1),
    new Token2(Type2.string, "/", 1),
    new Token2(Type2.string, cidString, cidString.length),
    new Token2(Type2.break, void 0, 1)
  ];
}
function bytesEncoder2(bytes3) {
  const bytesString = base643.encode(bytes3).slice(1);
  return [
    new Token2(Type2.map, Infinity, 1),
    new Token2(Type2.string, "/", 1),
    new Token2(Type2.map, Infinity, 1),
    new Token2(Type2.string, "bytes", 5),
    new Token2(Type2.string, bytesString, bytesString.length),
    new Token2(Type2.break, void 0, 1),
    new Token2(Type2.break, void 0, 1)
  ];
}
function undefinedEncoder22() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder22(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
function parse8(str = "", format11 = "ms") {
  var result = null;
  str = (str + "").replace(/(\d)[,_](\d)/g, "$1$2");
  var isNegative = str[0] === "-";
  str.replace(durationRE, function(_, n2, units) {
    units = unitRatio(units);
    if (units) result = (result || 0) + Math.abs(parseFloat(n2, 10)) * units;
  });
  return result && result / (unitRatio(format11) || 1) * (isNegative ? -1 : 1);
}
function unitRatio(str) {
  return parse8[str] || parse8[str.toLowerCase().replace(/s$/, "")];
}
function toUrlString(url2) {
  try {
    url2 = (0, import_multiaddr_to_uri.default)(new import_multiaddr.Multiaddr(url2));
  } catch (err) {
  }
  url2 = url2.toString();
  return url2;
}
function modeToString(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}
function parseMtime(input10) {
  if (input10 == null) {
    return void 0;
  }
  let mtime;
  if (input10.secs != null) {
    mtime = {
      secs: input10.secs,
      nsecs: input10.nsecs
    };
  }
  if (input10.Seconds != null) {
    mtime = {
      secs: input10.Seconds,
      nsecs: input10.FractionalNanoseconds
    };
  }
  if (Array.isArray(input10)) {
    mtime = {
      secs: input10[0],
      nsecs: input10[1]
    };
  }
  if (input10 instanceof Date) {
    const ms = input10.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}
function toUrlSearchParams({ arg, searchParams, hashAlg, mtime, mode, ...options } = {}) {
  if (searchParams) {
    options = {
      ...options,
      ...searchParams
    };
  }
  if (hashAlg) {
    options.hash = hashAlg;
  }
  if (mtime != null) {
    mtime = parseMtime(mtime);
    options.mtime = mtime.secs;
    options.mtimeNsecs = mtime.nsecs;
  }
  if (mode != null) {
    options.mode = modeToString(mode);
  }
  if (options.timeout && !isNaN(options.timeout)) {
    options.timeout = `${options.timeout}ms`;
  }
  if (arg === void 0 || arg === null) {
    arg = [];
  } else if (!Array.isArray(arg)) {
    arg = [arg];
  }
  const urlSearchParams = new URLSearchParams(options);
  arg.forEach((arg2) => urlSearchParams.append("arg", arg2));
  return urlSearchParams;
}
function toCoreInterface(res) {
  return {
    provideBufLen: res.ProvideBufLen,
    wantlist: (res.Wantlist || []).map((k) => CID4.parse(k["/"])),
    peers: res.Peers || [],
    blocksReceived: BigInt(res.BlocksReceived),
    dataReceived: BigInt(res.DataReceived),
    blocksSent: BigInt(res.BlocksSent),
    dataSent: BigInt(res.DataSent),
    dupBlksReceived: BigInt(res.DupBlksReceived),
    dupDataReceived: BigInt(res.DupDataReceived)
  };
}
function createBitswap(config2) {
  return {
    wantlist: createWantlist(config2),
    wantlistForPeer: createWantlistForPeer(config2),
    unwant: createUnwant(config2),
    stat: createStat(config2)
  };
}
function isBytes2(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob3(obj) {
  return obj.constructor && (obj.constructor.name === "Blob" || obj.constructor.name === "File") && typeof obj.stream === "function";
}
function isFileObject(obj) {
  return typeof obj === "object" && (obj.path || obj.content);
}
async function normaliseContent(input10) {
  if (isBytes2(input10)) {
    return new Blob([input10]);
  }
  if (typeof input10 === "string" || input10 instanceof String) {
    return new Blob([input10.toString()]);
  }
  if (isBlob3(input10)) {
    return input10;
  }
  if (isReadableStream2(input10)) {
    input10 = (0, import_browser_readablestream_to_it.default)(input10);
  }
  if (Symbol.iterator in input10 || Symbol.asyncIterator in input10) {
    const peekable = (0, import_it_peekable.default)(input10);
    const { value, done } = await peekable.peek();
    if (done) {
      return itToBlob(peekable);
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      return new Blob([Uint8Array.from(await (0, import_it_all.default)(peekable))]);
    }
    if (isBytes2(value) || typeof value === "string" || value instanceof String) {
      return itToBlob(peekable);
    }
  }
  throw (0, import_err_code2.default)(new Error(`Unexpected input: ${input10}`), "ERR_UNEXPECTED_INPUT");
}
async function itToBlob(stream4) {
  const parts = [];
  for await (const chunk of stream4) {
    parts.push(chunk);
  }
  return new Blob(parts);
}
function parseMode(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "number") {
    return mode & 4095;
  }
  mode = mode.toString();
  if (mode.substring(0, 1) === "0") {
    return parseInt(mode, 8) & 4095;
  }
  return parseInt(mode, 10) & 4095;
}
function parseMtime2(input10) {
  if (input10 == null) {
    return void 0;
  }
  let mtime;
  if (input10.secs != null) {
    mtime = {
      secs: input10.secs,
      nsecs: input10.nsecs
    };
  }
  if (input10.Seconds != null) {
    mtime = {
      secs: input10.Seconds,
      nsecs: input10.FractionalNanoseconds
    };
  }
  if (Array.isArray(input10)) {
    mtime = {
      secs: input10[0],
      nsecs: input10[1]
    };
  }
  if (input10 instanceof Date) {
    const ms = input10.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code3.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}
async function* normaliseCandidateMultiple(input10, normaliseContent2) {
  if (typeof input10 === "string" || input10 instanceof String || isBytes2(input10) || isBlob3(input10) || input10._readableState) {
    throw (0, import_err_code4.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isReadableStream2(input10)) {
    input10 = (0, import_browser_readablestream_to_it2.default)(input10);
  }
  if (Symbol.iterator in input10 || Symbol.asyncIterator in input10) {
    const peekable = (0, import_it_peekable2.default)(input10);
    const { value, done } = await peekable.peek();
    if (done) {
      yield* [];
      return;
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      throw (0, import_err_code4.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
    }
    if (value._readableState) {
      yield* (0, import_it_map.default)(peekable, (value2) => toFileObject({ content: value2 }, normaliseContent2));
      return;
    }
    if (isBytes2(value)) {
      yield toFileObject({ content: peekable }, normaliseContent2);
      return;
    }
    if (isFileObject(value) || value[Symbol.iterator] || value[Symbol.asyncIterator] || isReadableStream2(value) || isBlob3(value)) {
      yield* (0, import_it_map.default)(peekable, (value2) => toFileObject(value2, normaliseContent2));
      return;
    }
  }
  if (isFileObject(input10)) {
    throw (0, import_err_code4.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  throw (0, import_err_code4.default)(new Error("Unexpected input: " + typeof input10), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject(input10, normaliseContent2) {
  const { path, mode, mtime, content: content2 } = input10;
  const file = {
    path: path || "",
    mode: parseMode(mode),
    mtime: parseMtime2(mtime)
  };
  if (content2) {
    file.content = await normaliseContent2(content2);
  } else if (!path) {
    file.content = await normaliseContent2(input10);
  }
  return file;
}
function normaliseInput(input10) {
  return normaliseCandidateMultiple(input10, normaliseContent, true);
}
function modeToString2(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}
async function multipartRequest(source, abortController, headers = {}) {
  const parts = [];
  const formData = new FormData();
  let index2 = 0;
  let total = 0;
  for await (const { content: content2, path, mode, mtime } of normaliseInput(source)) {
    let fileSuffix = "";
    const type2 = content2 ? "file" : "dir";
    if (index2 > 0) {
      fileSuffix = `-${index2}`;
    }
    let fieldName = type2 + fileSuffix;
    const qs = [];
    if (mode !== null && mode !== void 0) {
      qs.push(`mode=${modeToString2(mode)}`);
    }
    if (mtime != null) {
      const { secs, nsecs } = mtime;
      qs.push(`mtime=${secs}`);
      if (nsecs != null) {
        qs.push(`mtime-nsecs=${nsecs}`);
      }
    }
    if (qs.length) {
      fieldName = `${fieldName}?${qs.join("&")}`;
    }
    if (content2) {
      formData.set(fieldName, content2, path != null ? encodeURIComponent(path) : void 0);
      const end = total + content2.size;
      parts.push({
        name: path,
        start: total,
        end
      });
      total = end;
    } else if (path != null) {
      formData.set(fieldName, new File([""], encodeURIComponent(path), { type: "application/x-directory" }));
    } else {
      throw new Error("path or content or both must be set");
    }
    index2++;
  }
  return {
    total,
    parts,
    headers,
    body: formData
  };
}
function filter2(signals) {
  return signals.filter(Boolean);
}
function abortSignal(...signals) {
  return (0, import_any_signal.anySignal)(filter2(signals));
}
function toCoreInterface2(removed) {
  const out = { cid: CID4.parse(removed.Hash) };
  if (removed.Error) {
    out.error = new Error(removed.Error);
  }
  return out;
}
function createBlock(config2) {
  return {
    get: createGet(config2),
    put: createPut(config2),
    rm: createRm(config2),
    stat: createStat2(config2)
  };
}
function createBootstrap(config2) {
  return {
    add: createAdd(config2),
    clear: createClear(config2),
    list: createList(config2),
    reset: createReset(config2),
    rm: createRm2(config2)
  };
}
function objectToCamel(obj) {
  if (obj == null) {
    return obj;
  }
  const caps = /^[A-Z]+$/;
  const output2 = {};
  return Object.keys(obj).reduce((camelObj, k) => {
    if (caps.test(k)) {
      camelObj[k.toLowerCase()] = obj[k];
    } else if (caps.test(k[0])) {
      camelObj[k[0].toLowerCase() + k.slice(1)] = obj[k];
    } else {
      camelObj[k] = obj[k];
    }
    return camelObj;
  }, output2);
}
function createProfiles(config2) {
  return {
    apply: createApply(config2),
    list: createList2(config2)
  };
}
function createConfig(config2) {
  return {
    getAll: createGetAll(config2),
    get: createGet2(config2),
    set: createSet(config2),
    replace: createReplace(config2),
    profiles: createProfiles(config2)
  };
}
async function* resolve(cid, path, codecs2, getBlock, options) {
  const load = async (cid2) => {
    const codec = await codecs2.getCodec(cid2.code);
    const block = await getBlock(cid2, options);
    return codec.decode(block);
  };
  const parts = path.split("/").filter(Boolean);
  let value = await load(cid);
  let lastCid = cid;
  while (parts.length) {
    const key = parts.shift();
    if (!key) {
      throw (0, import_err_code5.default)(new Error(`Could not resolve path "${path}"`), "ERR_INVALID_PATH");
    }
    if (Object.prototype.hasOwnProperty.call(value, key)) {
      value = value[key];
      yield {
        value,
        remainderPath: parts.join("/")
      };
    } else {
      throw (0, import_err_code5.default)(new Error(`no link named "${key}" under ${lastCid}`), "ERR_NO_LINK");
    }
    const cid2 = CID4.asCID(value);
    if (cid2) {
      lastCid = cid2;
      value = await load(value);
    }
  }
  yield {
    value,
    remainderPath: ""
  };
}
function createDag(codecs2, config2) {
  return {
    export: createExport(config2),
    get: createGet3(codecs2, config2),
    import: createImport(config2),
    put: createPut2(codecs2, config2),
    resolve: createResolve(config2)
  };
}
function createDht(config2) {
  return {
    findPeer: createFindPeer(config2),
    findProvs: createFindProvs(config2),
    get: createGet4(config2),
    provide: createProvide(config2),
    put: createPut3(config2),
    query: createQuery(config2)
  };
}
function createDiag(config2) {
  return {
    cmds: createCmds(config2),
    net: createNet(config2),
    sys: createSys(config2)
  };
}
function objectToCamelWithMetadata(entry) {
  const file = objectToCamel(entry);
  if (Object.prototype.hasOwnProperty.call(file, "mode")) {
    file.mode = parseInt(file.mode, 8);
  }
  if (Object.prototype.hasOwnProperty.call(file, "mtime")) {
    file.mtime = {
      secs: file.mtime,
      nsecs: file.mtimeNsecs || 0
    };
    delete file.mtimeNsecs;
  }
  return file;
}
function toCoreInterface3(entry) {
  if (entry.hash) {
    entry.cid = CID4.parse(entry.hash);
  }
  delete entry.hash;
  entry.type = entry.type === 1 ? "directory" : "file";
  return entry;
}
function toCoreInterface4(entry) {
  entry.cid = CID4.parse(entry.hash);
  delete entry.hash;
  return entry;
}
function createFiles(config2) {
  return {
    chmod: createChmod(config2),
    cp: createCp(config2),
    flush: createFlush(config2),
    ls: createLs(config2),
    mkdir: createMkdir(config2),
    mv: createMv(config2),
    read: createRead(config2),
    rm: createRm3(config2),
    stat: createStat3(config2),
    touch: createTouch(config2),
    write: createWrite(config2)
  };
}
function createKey(config2) {
  return {
    export: createExport2(config2),
    gen: createGen(config2),
    import: createImport2(config2),
    info: createInfo(config2),
    list: createList3(config2),
    rename: createRename(config2),
    rm: createRm4(config2)
  };
}
function createLog(config2) {
  return {
    level: createLevel(config2),
    ls: createLs2(config2),
    tail: createTail(config2)
  };
}
function createPubsub(config2) {
  return {
    cancel: createCancel(config2),
    state: createState(config2),
    subs: createSubs(config2)
  };
}
function createName(config2) {
  return {
    publish: createPublish(config2),
    resolve: createResolve2(config2),
    pubsub: createPubsub(config2)
  };
}
function createPatch(config2) {
  return {
    addLink: createAddLink(config2),
    appendData: createAppendData(config2),
    rmLink: createRmLink(config2),
    setData: createSetData(config2)
  };
}
function createObject(codecs2, config2) {
  return {
    data: createData(config2),
    get: createGet5(config2),
    links: createLinks(config2),
    new: createNew(config2),
    put: createPut4(codecs2, config2),
    stat: createStat4(config2),
    patch: createPatch(config2)
  };
}
async function* normaliseInput2(input10) {
  if (input10 === null || input10 === void 0) {
    throw (0, import_err_code9.default)(new Error(`Unexpected input: ${input10}`), "ERR_UNEXPECTED_INPUT");
  }
  const cid = CID4.asCID(input10);
  if (cid) {
    yield toPin({ cid });
    return;
  }
  if (input10 instanceof String || typeof input10 === "string") {
    yield toPin({ path: input10 });
    return;
  }
  if (input10.cid != null || input10.path != null) {
    return yield toPin(input10);
  }
  if (Symbol.iterator in input10) {
    const iterator = input10[Symbol.iterator]();
    const first2 = iterator.next();
    if (first2.done)
      return iterator;
    if (CID4.asCID(first2.value) || first2.value instanceof String || typeof first2.value === "string") {
      yield toPin({ cid: first2.value });
      for (const cid2 of iterator) {
        yield toPin({ cid: cid2 });
      }
      return;
    }
    if (first2.value.cid != null || first2.value.path != null) {
      yield toPin(first2.value);
      for (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw (0, import_err_code9.default)(new Error("Unexpected input: " + typeof input10), "ERR_UNEXPECTED_INPUT");
  }
  if (Symbol.asyncIterator in input10) {
    const iterator = input10[Symbol.asyncIterator]();
    const first2 = await iterator.next();
    if (first2.done)
      return iterator;
    if (CID4.asCID(first2.value) || first2.value instanceof String || typeof first2.value === "string") {
      yield toPin({ cid: first2.value });
      for await (const cid2 of iterator) {
        yield toPin({ cid: cid2 });
      }
      return;
    }
    if (first2.value.cid != null || first2.value.path != null) {
      yield toPin(first2.value);
      for await (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw (0, import_err_code9.default)(new Error("Unexpected input: " + typeof input10), "ERR_UNEXPECTED_INPUT");
  }
  throw (0, import_err_code9.default)(new Error("Unexpected input: " + typeof input10), "ERR_UNEXPECTED_INPUT");
}
function toPin(input10) {
  const path = input10.cid || `${input10.path}`;
  if (!path) {
    throw (0, import_err_code9.default)(new Error("Unexpected input: Please path either a CID or an IPFS path"), "ERR_UNEXPECTED_INPUT");
  }
  const pin = {
    path,
    recursive: input10.recursive !== false
  };
  if (input10.metadata != null) {
    pin.metadata = input10.metadata;
  }
  return pin;
}
function createAdd2(config2) {
  const all22 = createAddAll(config2);
  return configure6(() => {
    async function add9(path, options = {}) {
      return (0, import_it_last2.default)(all22([{
        path,
        ...options
      }], options));
    }
    return add9;
  })(config2);
}
function toPin2(type2, cid, metadata) {
  const pin = {
    type: type2,
    cid: CID4.parse(cid)
  };
  if (metadata) {
    pin.metadata = metadata;
  }
  return pin;
}
function createAdd3(client) {
  async function add9(cid, { timeout, signal, headers, ...query }) {
    const response = await client.post("pin/remote/add", {
      timeout,
      signal,
      headers,
      searchParams: encodeAddParams({
        cid,
        ...query
      })
    });
    return decodePin(await response.json());
  }
  return add9;
}
function createLs4(client) {
  async function* ls({ timeout, signal, headers, ...query }) {
    const response = await client.post("pin/remote/ls", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery(query)
    });
    for await (const pin of response.ndjson()) {
      yield decodePin(pin);
    }
  }
  return ls;
}
function createRm6(client) {
  async function rm({ timeout, signal, headers, ...query }) {
    await client.post("pin/remote/rm", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: false
      })
    });
  }
  return rm;
}
function createRmAll2(client) {
  async function rmAll({ timeout, signal, headers, ...query }) {
    await client.post("pin/remote/rm", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: true
      })
    });
  }
  return rmAll;
}
function encodeEndpoint(url2) {
  const href = String(url2);
  if (href === "undefined") {
    throw Error("endpoint is required");
  }
  return href[href.length - 1] === "/" ? href.slice(0, -1) : href;
}
function decodeRemoteService(json) {
  return {
    service: json.Service,
    endpoint: new URL(json.ApiEndpoint),
    ...json.Stat && { stat: decodeStat(json.Stat) }
  };
}
function decodeStat(json) {
  switch (json.Status) {
    case "valid": {
      const { Pinning, Pinned, Queued, Failed } = json.PinCount;
      return {
        status: "valid",
        pinCount: {
          queued: Queued,
          pinning: Pinning,
          pinned: Pinned,
          failed: Failed
        }
      };
    }
    case "invalid": {
      return { status: "invalid" };
    }
    default: {
      return { status: json.Status };
    }
  }
}
function createAdd4(client) {
  async function add9(name82, options) {
    const { endpoint, key, headers, timeout, signal } = options;
    await client.post("pin/remote/service/add", {
      timeout,
      signal,
      searchParams: toUrlSearchParams({
        arg: [
          name82,
          encodeEndpoint(endpoint),
          key
        ]
      }),
      headers
    });
  }
  return add9;
}
function createLs5(client) {
  async function ls(options = {}) {
    const { stat, headers, timeout, signal } = options;
    const response = await client.post("pin/remote/service/ls", {
      timeout,
      signal,
      headers,
      searchParams: stat === true ? toUrlSearchParams({ stat }) : void 0
    });
    const { RemoteServices } = await response.json();
    return RemoteServices.map(decodeRemoteService);
  }
  return ls;
}
function createRm7(client) {
  async function rm(name82, options = {}) {
    await client.post("pin/remote/service/rm", {
      signal: options.signal,
      headers: options.headers,
      searchParams: toUrlSearchParams({ arg: name82 })
    });
  }
  return rm;
}
function createService(config2) {
  const client = new Client(config2);
  return {
    add: createAdd4(client),
    ls: createLs5(client),
    rm: createRm7(client)
  };
}
function createRemote(config2) {
  const client = new Client(config2);
  return {
    add: createAdd3(client),
    ls: createLs4(client),
    rm: createRm6(client),
    rmAll: createRmAll2(client),
    service: createService(config2)
  };
}
function createPin(config2) {
  return {
    addAll: createAddAll(config2),
    add: createAdd2(config2),
    ls: createLs3(config2),
    rmAll: createRmAll(config2),
    rm: createRm5(config2),
    remote: createRemote(config2)
  };
}
async function readMessages(response, { onMessage, onEnd, onError }) {
  onError = onError || log2;
  try {
    for await (const msg of response.ndjson()) {
      try {
        if (!msg.from) {
          continue;
        }
        onMessage({
          from: msg.from,
          data: rpcToBytes(msg.data),
          seqno: rpcToBytes(msg.seqno),
          topicIDs: rpcArrayToTextArray(msg.topicIDs)
        });
      } catch (err) {
        err.message = `Failed to parse pubsub message: ${err.message}`;
        onError(err, false, msg);
      }
    }
  } catch (err) {
    if (!isAbortError(err)) {
      onError(err, true);
    }
  } finally {
    onEnd();
  }
}
function createPubsub2(config2) {
  const subscriptionTracker = new SubscriptionTracker();
  return {
    ls: createLs6(config2),
    peers: createPeers(config2),
    publish: createPublish2(config2),
    subscribe: createSubscribe(config2, subscriptionTracker),
    unsubscribe: createUnsubscribe(config2, subscriptionTracker)
  };
}
function createRepo(config2) {
  return {
    gc: createGc(config2),
    stat: createStat5(config2),
    version: createVersion(config2)
  };
}
function createStats(config2) {
  return {
    bitswap: createStat(config2),
    repo: createStat5(config2),
    bw: createBw(config2)
  };
}
function createSwarm(config2) {
  return {
    addrs: createAddrs(config2),
    connect: createConnect(config2),
    disconnect: createDisconnect(config2),
    localAddrs: createLocalAddrs(config2),
    peers: createPeers2(config2)
  };
}
function toCoreInterface5({ name: name82, hash, size: size5, mode, mtime, mtimeNsecs }) {
  const output2 = {
    path: name82,
    cid: CID4.parse(hash),
    size: parseInt(size5)
  };
  if (mode != null) {
    output2.mode = parseInt(mode, 8);
  }
  if (mtime != null) {
    output2.mtime = {
      secs: mtime,
      nsecs: mtimeNsecs || 0
    };
  }
  return output2;
}
async function* normaliseCandidateSingle(input10, normaliseContent2) {
  if (input10 === null || input10 === void 0) {
    throw (0, import_err_code10.default)(new Error(`Unexpected input: ${input10}`), "ERR_UNEXPECTED_INPUT");
  }
  if (typeof input10 === "string" || input10 instanceof String) {
    yield toFileObject2(input10.toString(), normaliseContent2);
    return;
  }
  if (isBytes2(input10) || isBlob3(input10)) {
    yield toFileObject2(input10, normaliseContent2);
    return;
  }
  if (isReadableStream2(input10)) {
    input10 = (0, import_browser_readablestream_to_it3.default)(input10);
  }
  if (Symbol.iterator in input10 || Symbol.asyncIterator in input10) {
    const peekable = (0, import_it_peekable3.default)(input10);
    const { value, done } = await peekable.peek();
    if (done) {
      yield { content: [] };
      return;
    }
    peekable.push(value);
    if (Number.isInteger(value) || isBytes2(value) || typeof value === "string" || value instanceof String) {
      yield toFileObject2(peekable, normaliseContent2);
      return;
    }
    throw (0, import_err_code10.default)(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isFileObject(input10)) {
    yield toFileObject2(input10, normaliseContent2);
    return;
  }
  throw (0, import_err_code10.default)(new Error('Unexpected input: cannot convert "' + typeof input10 + '" into ImportCandidate'), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject2(input10, normaliseContent2) {
  const { path, mode, mtime, content: content2 } = input10;
  const file = {
    path: path || "",
    mode: parseMode(mode),
    mtime: parseMtime2(mtime)
  };
  if (content2) {
    file.content = await normaliseContent2(content2);
  } else if (!path) {
    file.content = await normaliseContent2(input10);
  }
  return file;
}
function normaliseInput3(input10) {
  return normaliseCandidateSingle(input10, normaliseContent);
}
function createAdd5(options) {
  const all22 = createAddAll2(options);
  return configure6(() => {
    async function add9(input10, options2 = {}) {
      return await (0, import_it_last4.default)(all22(normaliseInput3(input10), options2));
    }
    return add9;
  })(options);
}
function typeOf(link5) {
  switch (link5.Type) {
    case 1:
    case 5:
      return "dir";
    case 2:
      return "file";
    default:
      return "file";
  }
}
function create22(options = {}) {
  const id = {
    name: identity4.name,
    code: identity4.code,
    encode: (id2) => id2,
    decode: (id2) => id2
  };
  const multibaseCodecs = Object.values(bases2);
  (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach((base33) => multibaseCodecs.push(base33));
  const multibases = new Multibases({
    bases: multibaseCodecs,
    loadBase: options.ipld && options.ipld.loadBase
  });
  const blockCodecs = Object.values(codecs);
  [
    src_exports,
    esm_exports,
    esm_exports2,
    dagJOSE,
    id
  ].concat(options.ipld && options.ipld.codecs || []).forEach((codec) => blockCodecs.push(codec));
  const multicodecs = new Multicodecs({
    codecs: blockCodecs,
    loadCodec: options.ipld && options.ipld.loadCodec
  });
  const multihashHashers = Object.values(hashes2);
  (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach((hasher) => multihashHashers.push(hasher));
  const multihashes = new Multihashes({
    hashers: multihashHashers,
    loadHasher: options.ipld && options.ipld.loadHasher
  });
  const client = {
    add: createAdd5(options),
    addAll: createAddAll2(options),
    bitswap: createBitswap(options),
    block: createBlock(options),
    bootstrap: createBootstrap(options),
    cat: createCat(options),
    commands: createCommands(options),
    config: createConfig(options),
    dag: createDag(multicodecs, options),
    dht: createDht(options),
    diag: createDiag(options),
    dns: createDns(options),
    files: createFiles(options),
    get: createGet6(options),
    getEndpointConfig: createGetEndpointConfig(options),
    id: createId(options),
    isOnline: createIsOnline(options),
    key: createKey(options),
    log: createLog(options),
    ls: createLs7(options),
    mount: createMount(options),
    name: createName(options),
    object: createObject(multicodecs, options),
    pin: createPin(options),
    ping: createPing(options),
    pubsub: createPubsub2(options),
    refs: createRefs(options),
    repo: createRepo(options),
    resolve: createResolve3(options),
    start: createStart(options),
    stats: createStats(options),
    stop: createStop(options),
    swarm: createSwarm(options),
    version: createVersion2(options),
    bases: multibases,
    codecs: multicodecs,
    hashers: multihashes
  };
  return client;
}
var encode_14, MSB5, REST5, MSBALL5, INT5, decode21, MSB$14, REST$14, N14, N24, N34, N44, N54, N64, N74, N84, N94, length4, varint3, _brrp_varint4, varint_default4, init_varint, decode210, encodeTo5, encodingLength5, init_varint2, empty8, equals8, coerce4, fromString3, toString6, init_bytes, digest_exports, create8, decode310, equals22, Digest6, init_digest, src4, _brrp__multiformats_scope_baseX4, base_x_default4, init_base_x, Encoder5, Decoder5, ComposedDecoder4, or13, Codec4, from8, baseX4, decode42, encode210, rfc46484, init_base, base58_exports2, base58btc4, base58flickr4, init_base58, base32_exports2, base324, base32upper4, base32pad4, base32padupper4, base32hex4, base32hexupper4, base32hexpad4, base32hexpadupper4, base32z4, init_base32, cid_exports, CID4, parseCIDtoBytes4, toStringV04, toStringV14, DAG_PB_CODE6, SHA_256_CODE4, encodeCID4, cidSymbol4, readonly2, hidden, version2, deprecate, IS_CID_DEPRECATION, init_cid, typeofs2, objectTypeNames2, init_is, Type2, Token2, init_token, useBuffer2, textDecoder22, textEncoder32, toString22, fromString22, fromArray2, slice3, concat3, alloc3, MAX_ARGUMENTS_LENGTH2, init_byte_utils, defaultChunkSize2, Bl2, init_bl, decodeErrPrefix2, encodeErrPrefix2, uintMinorPrefixBytes2, init_common, uintBoundaries2, init_uint, neg1b2, pos1b2, init_negint, init_bytes2, encodeString2, init_string, init_array, init_map, init_tag, MINOR_FALSE2, MINOR_TRUE2, MINOR_NULL2, MINOR_UNDEFINED2, buffer2, dataView2, ui8a2, init_float, jump2, quick2, init_jump, defaultEncodeOptions4, cborEncoders3, buf2, Ref2, simpleTokens2, typeEncoders2, init_encode, defaultDecodeOptions2, Tokeniser2, DONE2, BREAK2, init_decode, init_cborg, from22, Hasher5, init_hasher, init_src, base64_exports2, base643, base64pad3, base64url3, base64urlpad3, init_base64, require_utils2, require_signing, require_encryption, esm_exports3, CID_CBOR_TAG2, encodeOptions3, decodeOptions3, name42, code42, encode82, decode102, init_esm, require_lib3, identity_exports3, code52, name52, encode92, digest5, identity4, init_identity, identity_exports22, identity22, init_identity2, base2_exports2, base23, init_base2, base8_exports2, base82, init_base8, base10_exports2, base102, init_base10, base16_exports2, base162, base16upper2, init_base16, base36_exports2, base362, base36upper2, init_base36, base256emoji_exports2, alphabet2, alphabetBytesToChars2, alphabetCharsToBytes2, base256emoji2, init_base256emoji, sha2_browser_exports2, sha4, sha2565, sha5124, init_sha2_browser, raw_exports, name62, code62, encode112, decode122, init_raw, json_exports2, textEncoder42, textDecoder32, name72, code72, encode122, decode132, init_json, bases2, hashes2, codecs, init_basics, require_ip_regex, require_is_ip, init_as_uint8array, init_alloc, string3, ascii3, BASES2, bases_default, init_bases, to_string_exports, init_to_string, require_ip, require_protocols_table, from_string_exports, init_from_string, concat_exports, init_concat, require_convert, require_codec, require_err_code, equals_exports, init_equals, require_src, require_is_electron, require_env, require_ms, require_common, require_browser, require_error, require_browser2, require_src2, require_fetch_browser, require_fetch_browser2, require_is_plain_obj, require_merge_options, require_url_browser, require_relative, require_iso_url, require_any_signal, require_browser_readablestream_to_it, require_it_all, require_http, require_multiaddr_to_uri, require_it_peekable, require_it_map, require_longbits2, require_minimal3, require_writer2, require_writer_buffer2, require_reader2, require_reader_buffer2, require_service2, require_rpc2, require_roots2, require_index_minimal2, require_minimal22, require_it_first, require_it_last, require_source, require_glob_source, require_url_source, LOAD_BASE, Multibases, LOAD_CODEC, Multicodecs, LOAD_HASHER, Multihashes, src_exports, textDecoder4, textEncoder6, maxInt322, maxUInt322, len8tab2, pbNodeProperties2, pbLinkProperties2, textEncoder22, name14, code19, esm_exports, CID_CBOR_TAG3, encodeOptions4, decodeOptions4, name22, code22, encode52, decode72, esm_exports2, JSONEncoder2, defaultEncodeOptions22, Tokenizer2, encodeOptions22, DagJsonTokenizer2, decodeOptions22, name32, code32, encode72, decode92, dagJOSE, import_multiaddr2, import_env, durationRE, parse_duration_default, import_debug, import_http3, import_index2, merge_options_default, import_multiaddr, import_multiaddr_to_uri, agent_browser_default, log, merge2, DEFAULT_PROTOCOL, DEFAULT_HOST, DEFAULT_PORT, normalizeOptions, errorHandler, KEBAB_REGEX, kebabCase, parseTimeout, Client, HTTPError2, configure6, import_err_code, createWantlist, createWantlistForPeer, createStat, createUnwant, createGet, import_err_code2, import_it_peekable, import_browser_readablestream_to_it, import_it_all, isReadableStream2, import_err_code4, import_browser_readablestream_to_it2, import_it_peekable2, import_it_map, import_err_code3, import_minimal2, $Reader2, $Writer2, $util2, $root2, Data2, UnixTime2, Metadata2, DEFAULT_FILE_MODE2, DEFAULT_DIRECTORY_MODE2, import_any_signal, createPut, createRm, createStat2, import_multiaddr3, createAdd, import_multiaddr4, createClear, import_multiaddr5, createList, import_multiaddr6, createReset, import_multiaddr7, createRm2, createApply, createList2, createGet2, createGetAll, createReplace, createSet, encodeParam, createExport, import_err_code5, import_it_first, import_it_last, import_err_code6, createGet3, createImport, createPut2, createResolve, SendingQuery, PeerResponse, FinalPeer, QueryError, Provider, Value, AddingPeer, DialingPeer, import_multiaddr8, mapEvent, createFindPeer, createFindProvs, createGet4, createProvide, createPut3, createQuery, createCmds, createNet, createSys, createChmod, createCp, createFlush, createLs, createMkdir, createMv, import_source, createRead, import_http22, createRm3, createStat3, createTouch, createWrite, import_err_code7, createExport2, createGen, createImport2, import_err_code8, createInfo, createList3, createRename, createRm4, createLevel, createLs2, createTail, createPublish, createResolve2, createCancel, createState, createSubs, createData, createGet5, createLinks, createNew, createPut4, createStat4, createAddLink, createAppendData, createRmLink, createSetData, import_err_code9, createAddAll, import_it_last2, createLs3, createRmAll, import_it_last3, createRm5, decodePin, encodeService, encodeCID22, encodeQuery, encodeAddParams, rpcArrayToTextArray, rpcToText, rpcToBytes, textToUrlSafeRpc, createLs6, createPeers, createPublish2, import_debug2, log2, createSubscribe, isAbortError, createUnsubscribe, SubscriptionTracker, createLocal, createRefs, createGc, createStat5, createVersion, createBw, import_multiaddr9, createAddrs, createConnect, createDisconnect, import_multiaddr10, createLocalAddrs, import_multiaddr11, createPeers2, createAddAll2, createProgressHandler, createOnUploadProgress, import_it_last4, import_err_code10, import_browser_readablestream_to_it3, import_it_peekable3, createCat, createCommands, createDns, createGetEndpointConfig, createGet6, import_multiaddr12, createId, createIsOnline, createLs7, createMount, createPing, createResolve3, import_err_code11, createStart, createStop, createVersion2, import_glob_source, import_multiaddr13, import_url_source, globSource, export_multiaddr, export_urlSource;
var init_src_VT7VWDLR = __esm({
  "node_modules/@fleek-platform/sdk/dist/browser/src-VT7VWDLR.js"() {
    init_process_shim();
    init_chunk_77WUQNS7();
    init_chunk_DNE4QC7K();
    init_varint = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/varint.js"() {
        encode_14 = encode36;
        MSB5 = 128;
        REST5 = 127;
        MSBALL5 = ~REST5;
        INT5 = Math.pow(2, 31);
        decode21 = read9;
        MSB$14 = 128;
        REST$14 = 127;
        N14 = Math.pow(2, 7);
        N24 = Math.pow(2, 14);
        N34 = Math.pow(2, 21);
        N44 = Math.pow(2, 28);
        N54 = Math.pow(2, 35);
        N64 = Math.pow(2, 42);
        N74 = Math.pow(2, 49);
        N84 = Math.pow(2, 56);
        N94 = Math.pow(2, 63);
        length4 = function(value) {
          return value < N14 ? 1 : value < N24 ? 2 : value < N34 ? 3 : value < N44 ? 4 : value < N54 ? 5 : value < N64 ? 6 : value < N74 ? 7 : value < N84 ? 8 : value < N94 ? 9 : 10;
        };
        varint3 = {
          encode: encode_14,
          decode: decode21,
          encodingLength: length4
        };
        _brrp_varint4 = varint3;
        varint_default4 = _brrp_varint4;
      }
    });
    init_varint2 = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/varint.js"() {
        init_varint();
        decode210 = (data, offset3 = 0) => {
          const code82 = varint_default4.decode(data, offset3);
          return [
            code82,
            varint_default4.decode.bytes
          ];
        };
        encodeTo5 = (int2, target, offset3 = 0) => {
          varint_default4.encode(int2, target, offset3);
          return target;
        };
        encodingLength5 = (int2) => {
          return varint_default4.encodingLength(int2);
        };
      }
    });
    init_bytes = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bytes.js"() {
        empty8 = new Uint8Array(0);
        equals8 = (aa, bb) => {
          if (aa === bb)
            return true;
          if (aa.byteLength !== bb.byteLength) {
            return false;
          }
          for (let ii = 0; ii < aa.byteLength; ii++) {
            if (aa[ii] !== bb[ii]) {
              return false;
            }
          }
          return true;
        };
        coerce4 = (o) => {
          if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
            return o;
          if (o instanceof ArrayBuffer)
            return new Uint8Array(o);
          if (ArrayBuffer.isView(o)) {
            return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
          }
          throw new Error("Unknown type, must be binary type");
        };
        fromString3 = (str) => new TextEncoder().encode(str);
        toString6 = (b) => new TextDecoder().decode(b);
      }
    });
    digest_exports = {};
    __export2(digest_exports, {
      Digest: () => Digest6,
      create: () => create8,
      decode: () => decode310,
      equals: () => equals22
    });
    init_digest = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/digest.js"() {
        init_bytes();
        init_varint2();
        create8 = (code82, digest22) => {
          const size5 = digest22.byteLength;
          const sizeOffset = encodingLength5(code82);
          const digestOffset = sizeOffset + encodingLength5(size5);
          const bytes3 = new Uint8Array(digestOffset + size5);
          encodeTo5(code82, bytes3, 0);
          encodeTo5(size5, bytes3, sizeOffset);
          bytes3.set(digest22, digestOffset);
          return new Digest6(code82, size5, digest22, bytes3);
        };
        decode310 = (multihash) => {
          const bytes3 = coerce4(multihash);
          const [code82, sizeOffset] = decode210(bytes3);
          const [size5, digestOffset] = decode210(bytes3.subarray(sizeOffset));
          const digest22 = bytes3.subarray(sizeOffset + digestOffset);
          if (digest22.byteLength !== size5) {
            throw new Error("Incorrect length");
          }
          return new Digest6(code82, size5, digest22, bytes3);
        };
        equals22 = (a, b) => {
          if (a === b) {
            return true;
          } else {
            return a.code === b.code && a.size === b.size && equals8(a.bytes, b.bytes);
          }
        };
        Digest6 = class {
          constructor(code82, size5, digest22, bytes3) {
            this.code = code82;
            this.size = size5;
            this.digest = digest22;
            this.bytes = bytes3;
          }
        };
      }
    });
    init_base_x = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/base-x.js"() {
        src4 = base4;
        _brrp__multiformats_scope_baseX4 = src4;
        base_x_default4 = _brrp__multiformats_scope_baseX4;
      }
    });
    init_base = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base.js"() {
        init_base_x();
        init_bytes();
        Encoder5 = class {
          constructor(name82, prefix2, baseEncode) {
            this.name = name82;
            this.prefix = prefix2;
            this.baseEncode = baseEncode;
          }
          encode(bytes3) {
            if (bytes3 instanceof Uint8Array) {
              return `${this.prefix}${this.baseEncode(bytes3)}`;
            } else {
              throw Error("Unknown type, must be binary type");
            }
          }
        };
        Decoder5 = class {
          constructor(name82, prefix2, baseDecode) {
            this.name = name82;
            this.prefix = prefix2;
            if (prefix2.codePointAt(0) === void 0) {
              throw new Error("Invalid prefix character");
            }
            this.prefixCodePoint = prefix2.codePointAt(0);
            this.baseDecode = baseDecode;
          }
          decode(text2) {
            if (typeof text2 === "string") {
              if (text2.codePointAt(0) !== this.prefixCodePoint) {
                throw Error(`Unable to decode multibase string ${JSON.stringify(text2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
              }
              return this.baseDecode(text2.slice(this.prefix.length));
            } else {
              throw Error("Can only multibase decode strings");
            }
          }
          or(decoder4) {
            return or13(this, decoder4);
          }
        };
        ComposedDecoder4 = class {
          constructor(decoders) {
            this.decoders = decoders;
          }
          or(decoder4) {
            return or13(this, decoder4);
          }
          decode(input10) {
            const prefix2 = input10[0];
            const decoder4 = this.decoders[prefix2];
            if (decoder4) {
              return decoder4.decode(input10);
            } else {
              throw RangeError(`Unable to decode multibase string ${JSON.stringify(input10)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
            }
          }
        };
        or13 = (left, right) => new ComposedDecoder4({
          ...left.decoders || { [left.prefix]: left },
          ...right.decoders || { [right.prefix]: right }
        });
        Codec4 = class {
          constructor(name82, prefix2, baseEncode, baseDecode) {
            this.name = name82;
            this.prefix = prefix2;
            this.baseEncode = baseEncode;
            this.baseDecode = baseDecode;
            this.encoder = new Encoder5(name82, prefix2, baseEncode);
            this.decoder = new Decoder5(name82, prefix2, baseDecode);
          }
          encode(input10) {
            return this.encoder.encode(input10);
          }
          decode(input10) {
            return this.decoder.decode(input10);
          }
        };
        from8 = ({ name: name82, prefix: prefix2, encode: encode132, decode: decode142 }) => new Codec4(name82, prefix2, encode132, decode142);
        baseX4 = ({ prefix: prefix2, name: name82, alphabet: alphabet22 }) => {
          const { encode: encode132, decode: decode142 } = base_x_default4(alphabet22, name82);
          return from8({
            prefix: prefix2,
            name: name82,
            encode: encode132,
            decode: (text2) => coerce4(decode142(text2))
          });
        };
        decode42 = (string22, alphabet22, bitsPerChar, name82) => {
          const codes = {};
          for (let i = 0; i < alphabet22.length; ++i) {
            codes[alphabet22[i]] = i;
          }
          let end = string22.length;
          while (string22[end - 1] === "=") {
            --end;
          }
          const out = new Uint8Array(end * bitsPerChar / 8 | 0);
          let bits = 0;
          let buffer22 = 0;
          let written = 0;
          for (let i = 0; i < end; ++i) {
            const value = codes[string22[i]];
            if (value === void 0) {
              throw new SyntaxError(`Non-${name82} character`);
            }
            buffer22 = buffer22 << bitsPerChar | value;
            bits += bitsPerChar;
            if (bits >= 8) {
              bits -= 8;
              out[written++] = 255 & buffer22 >> bits;
            }
          }
          if (bits >= bitsPerChar || 255 & buffer22 << 8 - bits) {
            throw new SyntaxError("Unexpected end of data");
          }
          return out;
        };
        encode210 = (data, alphabet22, bitsPerChar) => {
          const pad2 = alphabet22[alphabet22.length - 1] === "=";
          const mask2 = (1 << bitsPerChar) - 1;
          let out = "";
          let bits = 0;
          let buffer22 = 0;
          for (let i = 0; i < data.length; ++i) {
            buffer22 = buffer22 << 8 | data[i];
            bits += 8;
            while (bits > bitsPerChar) {
              bits -= bitsPerChar;
              out += alphabet22[mask2 & buffer22 >> bits];
            }
          }
          if (bits) {
            out += alphabet22[mask2 & buffer22 << bitsPerChar - bits];
          }
          if (pad2) {
            while (out.length * bitsPerChar & 7) {
              out += "=";
            }
          }
          return out;
        };
        rfc46484 = ({ name: name82, prefix: prefix2, bitsPerChar, alphabet: alphabet22 }) => {
          return from8({
            prefix: prefix2,
            name: name82,
            encode(input10) {
              return encode210(input10, alphabet22, bitsPerChar);
            },
            decode(input10) {
              return decode42(input10, alphabet22, bitsPerChar, name82);
            }
          });
        };
      }
    });
    base58_exports2 = {};
    __export2(base58_exports2, {
      base58btc: () => base58btc4,
      base58flickr: () => base58flickr4
    });
    init_base58 = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base58.js"() {
        init_base();
        base58btc4 = baseX4({
          name: "base58btc",
          prefix: "z",
          alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
        });
        base58flickr4 = baseX4({
          name: "base58flickr",
          prefix: "Z",
          alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        });
      }
    });
    base32_exports2 = {};
    __export2(base32_exports2, {
      base32: () => base324,
      base32hex: () => base32hex4,
      base32hexpad: () => base32hexpad4,
      base32hexpadupper: () => base32hexpadupper4,
      base32hexupper: () => base32hexupper4,
      base32pad: () => base32pad4,
      base32padupper: () => base32padupper4,
      base32upper: () => base32upper4,
      base32z: () => base32z4
    });
    init_base32 = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base32.js"() {
        init_base();
        base324 = rfc46484({
          prefix: "b",
          name: "base32",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567",
          bitsPerChar: 5
        });
        base32upper4 = rfc46484({
          prefix: "B",
          name: "base32upper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
          bitsPerChar: 5
        });
        base32pad4 = rfc46484({
          prefix: "c",
          name: "base32pad",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
          bitsPerChar: 5
        });
        base32padupper4 = rfc46484({
          prefix: "C",
          name: "base32padupper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
          bitsPerChar: 5
        });
        base32hex4 = rfc46484({
          prefix: "v",
          name: "base32hex",
          alphabet: "0123456789abcdefghijklmnopqrstuv",
          bitsPerChar: 5
        });
        base32hexupper4 = rfc46484({
          prefix: "V",
          name: "base32hexupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
          bitsPerChar: 5
        });
        base32hexpad4 = rfc46484({
          prefix: "t",
          name: "base32hexpad",
          alphabet: "0123456789abcdefghijklmnopqrstuv=",
          bitsPerChar: 5
        });
        base32hexpadupper4 = rfc46484({
          prefix: "T",
          name: "base32hexpadupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
          bitsPerChar: 5
        });
        base32z4 = rfc46484({
          prefix: "h",
          name: "base32z",
          alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
          bitsPerChar: 5
        });
      }
    });
    cid_exports = {};
    __export2(cid_exports, {
      CID: () => CID4
    });
    init_cid = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/cid.js"() {
        init_varint2();
        init_digest();
        init_base58();
        init_base32();
        init_bytes();
        CID4 = class _CID4 {
          constructor(version22, code82, multihash, bytes3) {
            this.code = code82;
            this.version = version22;
            this.multihash = multihash;
            this.bytes = bytes3;
            this.byteOffset = bytes3.byteOffset;
            this.byteLength = bytes3.byteLength;
            this.asCID = this;
            this._baseCache = /* @__PURE__ */ new Map();
            Object.defineProperties(this, {
              byteOffset: hidden,
              byteLength: hidden,
              code: readonly2,
              version: readonly2,
              multihash: readonly2,
              bytes: readonly2,
              _baseCache: hidden,
              asCID: hidden
            });
          }
          toV0() {
            switch (this.version) {
              case 0: {
                return this;
              }
              default: {
                const { code: code82, multihash } = this;
                if (code82 !== DAG_PB_CODE6) {
                  throw new Error("Cannot convert a non dag-pb CID to CIDv0");
                }
                if (multihash.code !== SHA_256_CODE4) {
                  throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
                }
                return _CID4.createV0(multihash);
              }
            }
          }
          toV1() {
            switch (this.version) {
              case 0: {
                const { code: code82, digest: digest22 } = this.multihash;
                const multihash = create8(code82, digest22);
                return _CID4.createV1(this.code, multihash);
              }
              case 1: {
                return this;
              }
              default: {
                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
              }
            }
          }
          equals(other) {
            return other && this.code === other.code && this.version === other.version && equals22(this.multihash, other.multihash);
          }
          toString(base33) {
            const { bytes: bytes3, version: version22, _baseCache } = this;
            switch (version22) {
              case 0:
                return toStringV04(bytes3, _baseCache, base33 || base58btc4.encoder);
              default:
                return toStringV14(bytes3, _baseCache, base33 || base324.encoder);
            }
          }
          toJSON() {
            return {
              code: this.code,
              version: this.version,
              hash: this.multihash.bytes
            };
          }
          get [Symbol.toStringTag]() {
            return "CID";
          }
          [Symbol.for("nodejs.util.inspect.custom")]() {
            return "CID(" + this.toString() + ")";
          }
          static isCID(value) {
            deprecate(/^0\.0/, IS_CID_DEPRECATION);
            return !!(value && (value[cidSymbol4] || value.asCID === value));
          }
          get toBaseEncodedString() {
            throw new Error("Deprecated, use .toString()");
          }
          get codec() {
            throw new Error('"codec" property is deprecated, use integer "code" property instead');
          }
          get buffer() {
            throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
          }
          get multibaseName() {
            throw new Error('"multibaseName" property is deprecated');
          }
          get prefix() {
            throw new Error('"prefix" property is deprecated');
          }
          static asCID(value) {
            if (value instanceof _CID4) {
              return value;
            } else if (value != null && value.asCID === value) {
              const { version: version22, code: code82, multihash, bytes: bytes3 } = value;
              return new _CID4(version22, code82, multihash, bytes3 || encodeCID4(version22, code82, multihash.bytes));
            } else if (value != null && value[cidSymbol4] === true) {
              const { version: version22, multihash, code: code82 } = value;
              const digest22 = decode310(multihash);
              return _CID4.create(version22, code82, digest22);
            } else {
              return null;
            }
          }
          static create(version22, code82, digest22) {
            if (typeof code82 !== "number") {
              throw new Error("String codecs are no longer supported");
            }
            switch (version22) {
              case 0: {
                if (code82 !== DAG_PB_CODE6) {
                  throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE6}) block encoding`);
                } else {
                  return new _CID4(version22, code82, digest22, digest22.bytes);
                }
              }
              case 1: {
                const bytes3 = encodeCID4(version22, code82, digest22.bytes);
                return new _CID4(version22, code82, digest22, bytes3);
              }
              default: {
                throw new Error("Invalid version");
              }
            }
          }
          static createV0(digest22) {
            return _CID4.create(0, DAG_PB_CODE6, digest22);
          }
          static createV1(code82, digest22) {
            return _CID4.create(1, code82, digest22);
          }
          static decode(bytes3) {
            const [cid, remainder] = _CID4.decodeFirst(bytes3);
            if (remainder.length) {
              throw new Error("Incorrect length");
            }
            return cid;
          }
          static decodeFirst(bytes3) {
            const specs = _CID4.inspectBytes(bytes3);
            const prefixSize = specs.size - specs.multihashSize;
            const multihashBytes = coerce4(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
            if (multihashBytes.byteLength !== specs.multihashSize) {
              throw new Error("Incorrect length");
            }
            const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
            const digest22 = new Digest6(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
            const cid = specs.version === 0 ? _CID4.createV0(digest22) : _CID4.createV1(specs.codec, digest22);
            return [
              cid,
              bytes3.subarray(specs.size)
            ];
          }
          static inspectBytes(initialBytes) {
            let offset3 = 0;
            const next = () => {
              const [i, length22] = decode210(initialBytes.subarray(offset3));
              offset3 += length22;
              return i;
            };
            let version22 = next();
            let codec = DAG_PB_CODE6;
            if (version22 === 18) {
              version22 = 0;
              offset3 = 0;
            } else if (version22 === 1) {
              codec = next();
            }
            if (version22 !== 0 && version22 !== 1) {
              throw new RangeError(`Invalid CID version ${version22}`);
            }
            const prefixSize = offset3;
            const multihashCode = next();
            const digestSize = next();
            const size5 = offset3 + digestSize;
            const multihashSize = size5 - prefixSize;
            return {
              version: version22,
              codec,
              multihashCode,
              digestSize,
              multihashSize,
              size: size5
            };
          }
          static parse(source, base33) {
            const [prefix2, bytes3] = parseCIDtoBytes4(source, base33);
            const cid = _CID4.decode(bytes3);
            cid._baseCache.set(prefix2, source);
            return cid;
          }
        };
        parseCIDtoBytes4 = (source, base33) => {
          switch (source[0]) {
            case "Q": {
              const decoder4 = base33 || base58btc4;
              return [
                base58btc4.prefix,
                decoder4.decode(`${base58btc4.prefix}${source}`)
              ];
            }
            case base58btc4.prefix: {
              const decoder4 = base33 || base58btc4;
              return [
                base58btc4.prefix,
                decoder4.decode(source)
              ];
            }
            case base324.prefix: {
              const decoder4 = base33 || base324;
              return [
                base324.prefix,
                decoder4.decode(source)
              ];
            }
            default: {
              if (base33 == null) {
                throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
              }
              return [
                source[0],
                base33.decode(source)
              ];
            }
          }
        };
        toStringV04 = (bytes3, cache5, base33) => {
          const { prefix: prefix2 } = base33;
          if (prefix2 !== base58btc4.prefix) {
            throw Error(`Cannot string encode V0 in ${base33.name} encoding`);
          }
          const cid = cache5.get(prefix2);
          if (cid == null) {
            const cid2 = base33.encode(bytes3).slice(1);
            cache5.set(prefix2, cid2);
            return cid2;
          } else {
            return cid;
          }
        };
        toStringV14 = (bytes3, cache5, base33) => {
          const { prefix: prefix2 } = base33;
          const cid = cache5.get(prefix2);
          if (cid == null) {
            const cid2 = base33.encode(bytes3);
            cache5.set(prefix2, cid2);
            return cid2;
          } else {
            return cid;
          }
        };
        DAG_PB_CODE6 = 112;
        SHA_256_CODE4 = 18;
        encodeCID4 = (version22, code82, multihash) => {
          const codeOffset = encodingLength5(version22);
          const hashOffset = codeOffset + encodingLength5(code82);
          const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
          encodeTo5(version22, bytes3, 0);
          encodeTo5(code82, bytes3, codeOffset);
          bytes3.set(multihash, hashOffset);
          return bytes3;
        };
        cidSymbol4 = Symbol.for("@ipld/js-cid/CID");
        readonly2 = {
          writable: false,
          configurable: false,
          enumerable: true
        };
        hidden = {
          writable: false,
          enumerable: false,
          configurable: false
        };
        version2 = "0.0.0-dev";
        deprecate = (range, message2) => {
          if (range.test(version2)) {
            console.warn(message2);
          } else {
            throw new Error(message2);
          }
        };
        IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
      }
    });
    init_is = __esm2({
      "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/is.js"() {
        typeofs2 = [
          "string",
          "number",
          "bigint",
          "symbol"
        ];
        objectTypeNames2 = [
          "Function",
          "Generator",
          "AsyncGenerator",
          "GeneratorFunction",
          "AsyncGeneratorFunction",
          "AsyncFunction",
          "Observable",
          "Array",
          "Buffer",
          "Object",
          "RegExp",
          "Date",
          "Error",
          "Map",
          "Set",
          "WeakMap",
          "WeakSet",
          "ArrayBuffer",
          "SharedArrayBuffer",
          "DataView",
          "Promise",
          "URL",
          "HTMLElement",
          "Int8Array",
          "Uint8Array",
          "Uint8ClampedArray",
          "Int16Array",
          "Uint16Array",
          "Int32Array",
          "Uint32Array",
          "Float32Array",
          "Float64Array",
          "BigInt64Array",
          "BigUint64Array"
        ];
      }
    });
    init_token = __esm2({
      "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/token.js"() {
        Type2 = class {
          constructor(major, name82, terminal) {
            this.major = major;
            this.majorEncoded = major << 5;
            this.name = name82;
            this.terminal = terminal;
          }
          toString() {
            return `Type[${this.major}].${this.name}`;
          }
          compare(typ) {
            return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
          }
        };
        Type2.uint = new Type2(0, "uint", true);
        Type2.negint = new Type2(1, "negint", true);
        Type2.bytes = new Type2(2, "bytes", true);
        Type2.string = new Type2(3, "string", true);
        Type2.array = new Type2(4, "array", false);
        Type2.map = new Type2(5, "map", false);
        Type2.tag = new Type2(6, "tag", false);
        Type2.float = new Type2(7, "float", true);
        Type2.false = new Type2(7, "false", true);
        Type2.true = new Type2(7, "true", true);
        Type2.null = new Type2(7, "null", true);
        Type2.undefined = new Type2(7, "undefined", true);
        Type2.break = new Type2(7, "break", true);
        Token2 = class {
          constructor(type2, value, encodedLength) {
            this.type = type2;
            this.value = value;
            this.encodedLength = encodedLength;
            this.encodedBytes = void 0;
            this.byteValue = void 0;
          }
          toString() {
            return `Token[${this.type}].${this.value}`;
          }
        };
      }
    });
    init_byte_utils = __esm2({
      "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/byte-utils.js"() {
        useBuffer2 = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
        textDecoder22 = new TextDecoder();
        textEncoder32 = new TextEncoder();
        toString22 = useBuffer2 ? (bytes3, start, end) => {
          return end - start > 64 ? globalThis.Buffer.from(bytes3.subarray(start, end)).toString("utf8") : utf8Slice2(bytes3, start, end);
        } : (bytes3, start, end) => {
          return end - start > 64 ? textDecoder22.decode(bytes3.subarray(start, end)) : utf8Slice2(bytes3, start, end);
        };
        fromString22 = useBuffer2 ? (string22) => {
          return string22.length > 64 ? globalThis.Buffer.from(string22) : utf8ToBytes3(string22);
        } : (string22) => {
          return string22.length > 64 ? textEncoder32.encode(string22) : utf8ToBytes3(string22);
        };
        fromArray2 = (arr) => {
          return Uint8Array.from(arr);
        };
        slice3 = useBuffer2 ? (bytes3, start, end) => {
          if (isBuffer22(bytes3)) {
            return new Uint8Array(bytes3.subarray(start, end));
          }
          return bytes3.slice(start, end);
        } : (bytes3, start, end) => {
          return bytes3.slice(start, end);
        };
        concat3 = useBuffer2 ? (chunks, length22) => {
          chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
          return asU8A2(globalThis.Buffer.concat(chunks, length22));
        } : (chunks, length22) => {
          const out = new Uint8Array(length22);
          let off = 0;
          for (let b of chunks) {
            if (off + b.length > out.length) {
              b = b.subarray(0, out.length - off);
            }
            out.set(b, off);
            off += b.length;
          }
          return out;
        };
        alloc3 = useBuffer2 ? (size5) => {
          return globalThis.Buffer.allocUnsafe(size5);
        } : (size5) => {
          return new Uint8Array(size5);
        };
        MAX_ARGUMENTS_LENGTH2 = 4096;
      }
    });
    init_bl = __esm2({
      "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/bl.js"() {
        init_byte_utils();
        defaultChunkSize2 = 256;
        Bl2 = class {
          constructor(chunkSize = defaultChunkSize2) {
            this.chunkSize = chunkSize;
            this.cursor = 0;
            this.maxCursor = -1;
            this.chunks = [];
            this._initReuseChunk = null;
          }
          reset() {
            this.cursor = 0;
            this.maxCursor = -1;
            if (this.chunks.length) {
              this.chunks = [];
            }
            if (this._initReuseChunk !== null) {
              this.chunks.push(this._initReuseChunk);
              this.maxCursor = this._initReuseChunk.length - 1;
            }
          }
          push(bytes3) {
            let topChunk = this.chunks[this.chunks.length - 1];
            const newMax = this.cursor + bytes3.length;
            if (newMax <= this.maxCursor + 1) {
              const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
              topChunk.set(bytes3, chunkPos);
            } else {
              if (topChunk) {
                const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
                if (chunkPos < topChunk.length) {
                  this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
                  this.maxCursor = this.cursor - 1;
                }
              }
              if (bytes3.length < 64 && bytes3.length < this.chunkSize) {
                topChunk = alloc3(this.chunkSize);
                this.chunks.push(topChunk);
                this.maxCursor += topChunk.length;
                if (this._initReuseChunk === null) {
                  this._initReuseChunk = topChunk;
                }
                topChunk.set(bytes3, 0);
              } else {
                this.chunks.push(bytes3);
                this.maxCursor += bytes3.length;
              }
            }
            this.cursor += bytes3.length;
          }
          toBytes(reset = false) {
            let byts;
            if (this.chunks.length === 1) {
              const chunk = this.chunks[0];
              if (reset && this.cursor > chunk.length / 2) {
                byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
                this._initReuseChunk = null;
                this.chunks = [];
              } else {
                byts = slice3(chunk, 0, this.cursor);
              }
            } else {
              byts = concat3(this.chunks, this.cursor);
            }
            if (reset) {
              this.reset();
            }
            return byts;
          }
        };
      }
    });
    init_common = __esm2({
      "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/common.js"() {
        decodeErrPrefix2 = "CBOR decode error:";
        encodeErrPrefix2 = "CBOR encode error:";
        uintMinorPrefixBytes2 = [];
        uintMinorPrefixBytes2[23] = 1;
        uintMinorPrefixBytes2[24] = 2;
        uintMinorPrefixBytes2[25] = 3;
        uintMinorPrefixBytes2[26] = 5;
        uintMinorPrefixBytes2[27] = 9;
      }
    });
    init_uint = __esm2({
      "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/0uint.js"() {
        init_token();
        init_common();
        uintBoundaries2 = [
          24,
          256,
          65536,
          4294967296,
          BigInt("18446744073709551616")
        ];
        encodeUint2.encodedSize = function encodedSize9(token) {
          return encodeUintValue2.encodedSize(token.value);
        };
        encodeUintValue2.encodedSize = function encodedSize22(uint) {
          if (uint < uintBoundaries2[0]) {
            return 1;
          }
          if (uint < uintBoundaries2[1]) {
            return 2;
          }
          if (uint < uintBoundaries2[2]) {
            return 3;
          }
          if (uint < uintBoundaries2[3]) {
            return 5;
          }
          return 9;
        };
        encodeUint2.compareTokens = function compareTokens4(tok1, tok2) {
          return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
        };
      }
    });
    init_negint = __esm2({
      "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/1negint.js"() {
        init_token();
        init_uint();
        init_common();
        neg1b2 = BigInt(-1);
        pos1b2 = BigInt(1);
        encodeNegint2.encodedSize = function encodedSize32(token) {
          const negint = token.value;
          const unsigned = typeof negint === "bigint" ? negint * neg1b2 - pos1b2 : negint * -1 - 1;
          if (unsigned < uintBoundaries2[0]) {
            return 1;
          }
          if (unsigned < uintBoundaries2[1]) {
            return 2;
          }
          if (unsigned < uintBoundaries2[2]) {
            return 3;
          }
          if (unsigned < uintBoundaries2[3]) {
            return 5;
          }
          return 9;
        };
        encodeNegint2.compareTokens = function compareTokens22(tok1, tok2) {
          return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
        };
      }
    });
    init_bytes2 = __esm2({
      "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/2bytes.js"() {
        init_token();
        init_common();
        init_uint();
        init_byte_utils();
        encodeBytes2.encodedSize = function encodedSize42(token) {
          const bytes3 = tokenBytes2(token);
          return encodeUintValue2.encodedSize(bytes3.length) + bytes3.length;
        };
        encodeBytes2.compareTokens = function compareTokens32(tok1, tok2) {
          return compareBytes2(tokenBytes2(tok1), tokenBytes2(tok2));
        };
      }
    });
    init_string = __esm2({
      "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/3string.js"() {
        init_token();
        init_common();
        init_uint();
        init_bytes2();
        init_byte_utils();
        encodeString2 = encodeBytes2;
      }
    });
    init_array = __esm2({
      "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/4array.js"() {
        init_token();
        init_uint();
        init_common();
        encodeArray2.compareTokens = encodeUint2.compareTokens;
        encodeArray2.encodedSize = function encodedSize52(token) {
          return encodeUintValue2.encodedSize(token.value);
        };
      }
    });
    init_map = __esm2({
      "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/5map.js"() {
        init_token();
        init_uint();
        init_common();
        encodeMap2.compareTokens = encodeUint2.compareTokens;
        encodeMap2.encodedSize = function encodedSize62(token) {
          return encodeUintValue2.encodedSize(token.value);
        };
      }
    });
    init_tag = __esm2({
      "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/6tag.js"() {
        init_token();
        init_uint();
        encodeTag2.compareTokens = encodeUint2.compareTokens;
        encodeTag2.encodedSize = function encodedSize72(token) {
          return encodeUintValue2.encodedSize(token.value);
        };
      }
    });
    init_float = __esm2({
      "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/7float.js"() {
        init_token();
        init_common();
        init_uint();
        MINOR_FALSE2 = 20;
        MINOR_TRUE2 = 21;
        MINOR_NULL2 = 22;
        MINOR_UNDEFINED2 = 23;
        encodeFloat2.encodedSize = function encodedSize82(token, options) {
          const float2 = token.value;
          if (float2 === false || float2 === true || float2 === null || float2 === void 0) {
            return 1;
          }
          if (!options || options.float64 !== true) {
            encodeFloat162(float2);
            let decoded = readFloat162(ui8a2, 1);
            if (float2 === decoded || Number.isNaN(float2)) {
              return 3;
            }
            encodeFloat322(float2);
            decoded = readFloat322(ui8a2, 1);
            if (float2 === decoded) {
              return 5;
            }
          }
          return 9;
        };
        buffer2 = new ArrayBuffer(9);
        dataView2 = new DataView(buffer2, 1);
        ui8a2 = new Uint8Array(buffer2, 0);
        encodeFloat2.compareTokens = encodeUint2.compareTokens;
      }
    });
    init_jump = __esm2({
      "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/jump.js"() {
        init_token();
        init_uint();
        init_negint();
        init_bytes2();
        init_string();
        init_array();
        init_map();
        init_tag();
        init_float();
        init_common();
        init_byte_utils();
        jump2 = [];
        for (let i = 0; i <= 23; i++) {
          jump2[i] = invalidMinor2;
        }
        jump2[24] = decodeUint82;
        jump2[25] = decodeUint162;
        jump2[26] = decodeUint322;
        jump2[27] = decodeUint642;
        jump2[28] = invalidMinor2;
        jump2[29] = invalidMinor2;
        jump2[30] = invalidMinor2;
        jump2[31] = invalidMinor2;
        for (let i = 32; i <= 55; i++) {
          jump2[i] = invalidMinor2;
        }
        jump2[56] = decodeNegint82;
        jump2[57] = decodeNegint162;
        jump2[58] = decodeNegint322;
        jump2[59] = decodeNegint642;
        jump2[60] = invalidMinor2;
        jump2[61] = invalidMinor2;
        jump2[62] = invalidMinor2;
        jump2[63] = invalidMinor2;
        for (let i = 64; i <= 87; i++) {
          jump2[i] = decodeBytesCompact2;
        }
        jump2[88] = decodeBytes82;
        jump2[89] = decodeBytes162;
        jump2[90] = decodeBytes322;
        jump2[91] = decodeBytes642;
        jump2[92] = invalidMinor2;
        jump2[93] = invalidMinor2;
        jump2[94] = invalidMinor2;
        jump2[95] = errorer2("indefinite length bytes/strings are not supported");
        for (let i = 96; i <= 119; i++) {
          jump2[i] = decodeStringCompact2;
        }
        jump2[120] = decodeString82;
        jump2[121] = decodeString162;
        jump2[122] = decodeString322;
        jump2[123] = decodeString642;
        jump2[124] = invalidMinor2;
        jump2[125] = invalidMinor2;
        jump2[126] = invalidMinor2;
        jump2[127] = errorer2("indefinite length bytes/strings are not supported");
        for (let i = 128; i <= 151; i++) {
          jump2[i] = decodeArrayCompact2;
        }
        jump2[152] = decodeArray82;
        jump2[153] = decodeArray162;
        jump2[154] = decodeArray322;
        jump2[155] = decodeArray642;
        jump2[156] = invalidMinor2;
        jump2[157] = invalidMinor2;
        jump2[158] = invalidMinor2;
        jump2[159] = decodeArrayIndefinite2;
        for (let i = 160; i <= 183; i++) {
          jump2[i] = decodeMapCompact2;
        }
        jump2[184] = decodeMap82;
        jump2[185] = decodeMap162;
        jump2[186] = decodeMap322;
        jump2[187] = decodeMap642;
        jump2[188] = invalidMinor2;
        jump2[189] = invalidMinor2;
        jump2[190] = invalidMinor2;
        jump2[191] = decodeMapIndefinite2;
        for (let i = 192; i <= 215; i++) {
          jump2[i] = decodeTagCompact2;
        }
        jump2[216] = decodeTag82;
        jump2[217] = decodeTag162;
        jump2[218] = decodeTag322;
        jump2[219] = decodeTag642;
        jump2[220] = invalidMinor2;
        jump2[221] = invalidMinor2;
        jump2[222] = invalidMinor2;
        jump2[223] = invalidMinor2;
        for (let i = 224; i <= 243; i++) {
          jump2[i] = errorer2("simple values are not supported");
        }
        jump2[244] = invalidMinor2;
        jump2[245] = invalidMinor2;
        jump2[246] = invalidMinor2;
        jump2[247] = decodeUndefined2;
        jump2[248] = errorer2("simple values are not supported");
        jump2[249] = decodeFloat162;
        jump2[250] = decodeFloat322;
        jump2[251] = decodeFloat642;
        jump2[252] = invalidMinor2;
        jump2[253] = invalidMinor2;
        jump2[254] = invalidMinor2;
        jump2[255] = decodeBreak2;
        quick2 = [];
        for (let i = 0; i < 24; i++) {
          quick2[i] = new Token2(Type2.uint, i, 1);
        }
        for (let i = -1; i >= -24; i--) {
          quick2[31 - i] = new Token2(Type2.negint, i, 1);
        }
        quick2[64] = new Token2(Type2.bytes, new Uint8Array(0), 1);
        quick2[96] = new Token2(Type2.string, "", 1);
        quick2[128] = new Token2(Type2.array, 0, 1);
        quick2[160] = new Token2(Type2.map, 0, 1);
        quick2[244] = new Token2(Type2.false, false, 1);
        quick2[245] = new Token2(Type2.true, true, 1);
        quick2[246] = new Token2(Type2.null, null, 1);
      }
    });
    init_encode = __esm2({
      "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/encode.js"() {
        init_is();
        init_token();
        init_bl();
        init_common();
        init_jump();
        init_byte_utils();
        init_uint();
        init_negint();
        init_bytes2();
        init_string();
        init_array();
        init_map();
        init_tag();
        init_float();
        defaultEncodeOptions4 = {
          float64: false,
          mapSorter: mapSorter3,
          quickEncodeToken: quickEncodeToken2
        };
        cborEncoders3 = makeCborEncoders2();
        buf2 = new Bl2();
        Ref2 = class _Ref2 {
          constructor(obj, parent) {
            this.obj = obj;
            this.parent = parent;
          }
          includes(obj) {
            let p = this;
            do {
              if (p.obj === obj) {
                return true;
              }
            } while (p = p.parent);
            return false;
          }
          static createCheck(stack, obj) {
            if (stack && stack.includes(obj)) {
              throw new Error(`${encodeErrPrefix2} object contains circular references`);
            }
            return new _Ref2(obj, stack);
          }
        };
        simpleTokens2 = {
          null: new Token2(Type2.null, null),
          undefined: new Token2(Type2.undefined, void 0),
          true: new Token2(Type2.true, true),
          false: new Token2(Type2.false, false),
          emptyArray: new Token2(Type2.array, 0),
          emptyMap: new Token2(Type2.map, 0)
        };
        typeEncoders2 = {
          number(obj, _typ, _options2, _refStack) {
            if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
              return new Token2(Type2.float, obj);
            } else if (obj >= 0) {
              return new Token2(Type2.uint, obj);
            } else {
              return new Token2(Type2.negint, obj);
            }
          },
          bigint(obj, _typ, _options2, _refStack) {
            if (obj >= BigInt(0)) {
              return new Token2(Type2.uint, obj);
            } else {
              return new Token2(Type2.negint, obj);
            }
          },
          Uint8Array(obj, _typ, _options2, _refStack) {
            return new Token2(Type2.bytes, obj);
          },
          string(obj, _typ, _options2, _refStack) {
            return new Token2(Type2.string, obj);
          },
          boolean(obj, _typ, _options2, _refStack) {
            return obj ? simpleTokens2.true : simpleTokens2.false;
          },
          null(_obj, _typ, _options2, _refStack) {
            return simpleTokens2.null;
          },
          undefined(_obj, _typ, _options2, _refStack) {
            return simpleTokens2.undefined;
          },
          ArrayBuffer(obj, _typ, _options2, _refStack) {
            return new Token2(Type2.bytes, new Uint8Array(obj));
          },
          DataView(obj, _typ, _options2, _refStack) {
            return new Token2(Type2.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
          },
          Array(obj, _typ, options, refStack) {
            if (!obj.length) {
              if (options.addBreakTokens === true) {
                return [
                  simpleTokens2.emptyArray,
                  new Token2(Type2.break)
                ];
              }
              return simpleTokens2.emptyArray;
            }
            refStack = Ref2.createCheck(refStack, obj);
            const entries3 = [];
            let i = 0;
            for (const e of obj) {
              entries3[i++] = objectToTokens2(e, options, refStack);
            }
            if (options.addBreakTokens) {
              return [
                new Token2(Type2.array, obj.length),
                entries3,
                new Token2(Type2.break)
              ];
            }
            return [
              new Token2(Type2.array, obj.length),
              entries3
            ];
          },
          Object(obj, typ, options, refStack) {
            const isMap = typ !== "Object";
            const keys2 = isMap ? obj.keys() : Object.keys(obj);
            const length22 = isMap ? obj.size : keys2.length;
            if (!length22) {
              if (options.addBreakTokens === true) {
                return [
                  simpleTokens2.emptyMap,
                  new Token2(Type2.break)
                ];
              }
              return simpleTokens2.emptyMap;
            }
            refStack = Ref2.createCheck(refStack, obj);
            const entries3 = [];
            let i = 0;
            for (const key of keys2) {
              entries3[i++] = [
                objectToTokens2(key, options, refStack),
                objectToTokens2(isMap ? obj.get(key) : obj[key], options, refStack)
              ];
            }
            sortMapEntries2(entries3, options);
            if (options.addBreakTokens) {
              return [
                new Token2(Type2.map, length22),
                entries3,
                new Token2(Type2.break)
              ];
            }
            return [
              new Token2(Type2.map, length22),
              entries3
            ];
          }
        };
        typeEncoders2.Map = typeEncoders2.Object;
        typeEncoders2.Buffer = typeEncoders2.Uint8Array;
        for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
          typeEncoders2[`${typ}Array`] = typeEncoders2.DataView;
        }
      }
    });
    init_decode = __esm2({
      "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/decode.js"() {
        init_common();
        init_token();
        init_jump();
        defaultDecodeOptions2 = {
          strict: false,
          allowIndefinite: true,
          allowUndefined: true,
          allowBigInt: true
        };
        Tokeniser2 = class {
          constructor(data, options = {}) {
            this.pos = 0;
            this.data = data;
            this.options = options;
          }
          done() {
            return this.pos >= this.data.length;
          }
          next() {
            const byt = this.data[this.pos];
            let token = quick2[byt];
            if (token === void 0) {
              const decoder4 = jump2[byt];
              if (!decoder4) {
                throw new Error(`${decodeErrPrefix2} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
              }
              const minor = byt & 31;
              token = decoder4(this.data, this.pos, minor, this.options);
            }
            this.pos += token.encodedLength;
            return token;
          }
        };
        DONE2 = Symbol.for("DONE");
        BREAK2 = Symbol.for("BREAK");
      }
    });
    init_cborg = __esm2({
      "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/cborg.js"() {
        init_encode();
        init_decode();
        init_token();
      }
    });
    init_hasher = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/hasher.js"() {
        init_digest();
        from22 = ({ name: name82, code: code82, encode: encode132 }) => new Hasher5(name82, code82, encode132);
        Hasher5 = class {
          constructor(name82, code82, encode132) {
            this.name = name82;
            this.code = code82;
            this.encode = encode132;
          }
          digest(input10) {
            if (input10 instanceof Uint8Array) {
              const result = this.encode(input10);
              return result instanceof Uint8Array ? create8(this.code, result) : result.then((digest22) => create8(this.code, digest22));
            } else {
              throw Error("Unknown type, must be binary type");
            }
          }
        };
      }
    });
    init_src = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/index.js"() {
        init_cid();
        init_varint2();
        init_bytes();
        init_hasher();
        init_digest();
      }
    });
    base64_exports2 = {};
    __export2(base64_exports2, {
      base64: () => base643,
      base64pad: () => base64pad3,
      base64url: () => base64url3,
      base64urlpad: () => base64urlpad3
    });
    init_base64 = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base64.js"() {
        init_base();
        base643 = rfc46484({
          prefix: "m",
          name: "base64",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          bitsPerChar: 6
        });
        base64pad3 = rfc46484({
          prefix: "M",
          name: "base64pad",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          bitsPerChar: 6
        });
        base64url3 = rfc46484({
          prefix: "u",
          name: "base64url",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
          bitsPerChar: 6
        });
        base64urlpad3 = rfc46484({
          prefix: "U",
          name: "base64urlpad",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
          bitsPerChar: 6
        });
      }
    });
    require_utils2 = __commonJS2({
      "../../node_modules/.pnpm/dag-jose@1.0.0/node_modules/dag-jose/lib/utils.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.fromBase64url = exports2.toBase64url = void 0;
        var base64_1 = (init_base64(), __toCommonJS(base64_exports2));
        function toBase64url(b) {
          return base64_1.base64url.encode(b).slice(1);
        }
        exports2.toBase64url = toBase64url;
        function fromBase64url(s2) {
          return base64_1.base64url.decode(`u${s2}`);
        }
        exports2.fromBase64url = fromBase64url;
      }
    });
    require_signing = __commonJS2({
      "../../node_modules/.pnpm/dag-jose@1.0.0/node_modules/dag-jose/lib/signing.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        var utils_1 = require_utils2();
        var cid_1 = (init_cid(), __toCommonJS(cid_exports));
        function fromSplit(split3) {
          const [protectedHeader, payload, signature] = split3;
          return {
            payload,
            signatures: [{ protected: protectedHeader, signature }],
            link: cid_1.CID.decode(utils_1.fromBase64url(payload))
          };
        }
        function encodeSignature2(signature) {
          const encoded = {
            signature: utils_1.fromBase64url(signature.signature)
          };
          if (signature.header)
            encoded.header = signature.header;
          if (signature.protected)
            encoded.protected = utils_1.fromBase64url(signature.protected);
          return encoded;
        }
        function encode132(jws) {
          const payload = utils_1.fromBase64url(jws.payload);
          try {
            cid_1.CID.decode(payload);
          } catch (e) {
            throw new Error("Not a valid DagJWS");
          }
          const encodedJws = {
            payload,
            signatures: jws.signatures.map(encodeSignature2)
          };
          return encodedJws;
        }
        function decodeSignature(encoded) {
          const sign3 = {
            signature: utils_1.toBase64url(encoded.signature)
          };
          if (encoded.header)
            sign3.header = encoded.header;
          if (encoded.protected)
            sign3.protected = utils_1.toBase64url(encoded.protected);
          return sign3;
        }
        function decode142(encoded) {
          const decoded = {
            payload: utils_1.toBase64url(encoded.payload),
            signatures: encoded.signatures.map(decodeSignature)
          };
          decoded.link = cid_1.CID.decode(new Uint8Array(encoded.payload));
          return decoded;
        }
        exports2.default = {
          fromSplit,
          encode: encode132,
          decode: decode142
        };
      }
    });
    require_encryption = __commonJS2({
      "../../node_modules/.pnpm/dag-jose@1.0.0/node_modules/dag-jose/lib/encryption.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        var utils_1 = require_utils2();
        function fromSplit(split3) {
          const [protectedHeader, encrypted_key, iv, ciphertext, tag2] = split3;
          const jwe = {
            ciphertext,
            iv,
            protected: protectedHeader,
            tag: tag2
          };
          if (encrypted_key)
            jwe.recipients = [{ encrypted_key }];
          return jwe;
        }
        function encodeRecipient(recipient) {
          const encRec = {};
          if (recipient.encrypted_key)
            encRec.encrypted_key = utils_1.fromBase64url(recipient.encrypted_key);
          if (recipient.header)
            encRec.header = recipient.header;
          return encRec;
        }
        function encode132(jwe) {
          const encJwe = {
            ciphertext: utils_1.fromBase64url(jwe.ciphertext),
            protected: utils_1.fromBase64url(jwe.protected),
            iv: utils_1.fromBase64url(jwe.iv),
            tag: utils_1.fromBase64url(jwe.tag)
          };
          if (jwe.aad)
            encJwe.aad = utils_1.fromBase64url(jwe.aad);
          if (jwe.recipients)
            encJwe.recipients = jwe.recipients.map(encodeRecipient);
          if (jwe.unprotected)
            encJwe.unprotected = jwe.unprotected;
          return encJwe;
        }
        function decodeRecipient(encoded) {
          const recipient = {};
          if (encoded.encrypted_key)
            recipient.encrypted_key = utils_1.toBase64url(encoded.encrypted_key);
          if (encoded.header)
            recipient.header = encoded.header;
          return recipient;
        }
        function decode142(encoded) {
          const jwe = {
            ciphertext: utils_1.toBase64url(encoded.ciphertext),
            protected: utils_1.toBase64url(encoded.protected),
            iv: utils_1.toBase64url(encoded.iv),
            tag: utils_1.toBase64url(encoded.tag)
          };
          if (encoded.aad)
            jwe.aad = utils_1.toBase64url(encoded.aad);
          if (encoded.recipients)
            jwe.recipients = encoded.recipients.map(decodeRecipient);
          if (encoded.unprotected)
            jwe.unprotected = encoded.unprotected;
          return jwe;
        }
        exports2.default = {
          fromSplit,
          decode: decode142,
          encode: encode132
        };
      }
    });
    esm_exports3 = {};
    __export2(esm_exports3, {
      code: () => code42,
      decode: () => decode102,
      encode: () => encode82,
      name: () => name42
    });
    init_esm = __esm2({
      "../../node_modules/.pnpm/@ipld+dag-cbor@6.0.15/node_modules/@ipld/dag-cbor/esm/index.js"() {
        init_cborg();
        init_cid();
        CID_CBOR_TAG2 = 42;
        encodeOptions3 = {
          float64: true,
          typeEncoders: {
            Object: cidEncoder3,
            undefined: undefinedEncoder3,
            number: numberEncoder3
          }
        };
        decodeOptions3 = {
          allowIndefinite: false,
          allowUndefined: false,
          allowNaN: false,
          allowInfinity: false,
          allowBigInt: true,
          strict: true,
          useMaps: false,
          tags: []
        };
        decodeOptions3.tags[CID_CBOR_TAG2] = cidDecoder2;
        name42 = "dag-cbor";
        code42 = 113;
        encode82 = (node) => encode42(node, encodeOptions3);
        decode102 = (data) => decode62(data, decodeOptions3);
      }
    });
    require_lib3 = __commonJS2({
      "../../node_modules/.pnpm/dag-jose@1.0.0/node_modules/dag-jose/lib/index.js"(exports2) {
        "use strict";
        var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
          if (k2 === void 0) k2 = k;
          Object.defineProperty(o, k2, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k2) {
          if (k2 === void 0) k2 = k;
          o[k2] = m[k];
        });
        var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        });
        var __importStar = exports2 && exports2.__importStar || function(mod3) {
          if (mod3 && mod3.__esModule) return mod3;
          var result = {};
          if (mod3 != null) {
            for (var k in mod3) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k)) __createBinding(result, mod3, k);
          }
          __setModuleDefault(result, mod3);
          return result;
        };
        var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
          return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.decode = exports2.encode = exports2.toGeneral = exports2.code = exports2.name = void 0;
        var signing_1 = __importDefault(require_signing());
        var encryption_1 = __importDefault(require_encryption());
        var cbor = __importStar((init_esm(), __toCommonJS(esm_exports3)));
        exports2.name = "dag-jose";
        exports2.code = 133;
        function isDagJWS(jose) {
          return "payload" in jose && typeof jose.payload === "string" && "signatures" in jose && Array.isArray(jose.signatures);
        }
        function isEncodedJWS(jose) {
          return "payload" in jose && jose.payload instanceof Uint8Array && "signatures" in jose && Array.isArray(jose.signatures);
        }
        function isEncodedJWE(jose) {
          return "ciphertext" in jose && jose.ciphertext instanceof Uint8Array && "iv" in jose && jose.iv instanceof Uint8Array && "protected" in jose && jose.protected instanceof Uint8Array && "tag" in jose && jose.tag instanceof Uint8Array;
        }
        function isDagJWE(jose) {
          return "ciphertext" in jose && typeof jose.ciphertext === "string" && "iv" in jose && typeof jose.iv === "string" && "protected" in jose && typeof jose.protected === "string" && "tag" in jose && typeof jose.tag === "string";
        }
        function toGeneral(jose) {
          if (typeof jose === "string") {
            const split3 = jose.split(".");
            if (split3.length === 3) {
              return signing_1.default.fromSplit(split3);
            } else if (split3.length === 5) {
              return encryption_1.default.fromSplit(split3);
            }
            throw new Error("Not a valid JOSE string");
          }
          if (isDagJWS(jose) || isDagJWE(jose)) {
            return jose;
          }
          throw new Error("Not a valid unencoded JOSE object");
        }
        exports2.toGeneral = toGeneral;
        function encode132(obj) {
          if (typeof obj === "string") {
            obj = toGeneral(obj);
          }
          let encodedJose;
          if (isDagJWS(obj)) {
            encodedJose = signing_1.default.encode(obj);
          } else if (isDagJWE(obj)) {
            encodedJose = encryption_1.default.encode(obj);
          } else {
            throw new Error("Not a valid JOSE object");
          }
          return new Uint8Array(cbor.encode(encodedJose));
        }
        exports2.encode = encode132;
        function decode142(data) {
          let encoded;
          try {
            encoded = cbor.decode(data);
          } catch (e) {
            throw new Error("Not a valid DAG-JOSE object");
          }
          if (isEncodedJWS(encoded)) {
            return signing_1.default.decode(encoded);
          } else if (isEncodedJWE(encoded)) {
            return encryption_1.default.decode(encoded);
          } else {
            throw new Error("Not a valid DAG-JOSE object");
          }
        }
        exports2.decode = decode142;
      }
    });
    identity_exports3 = {};
    __export2(identity_exports3, {
      identity: () => identity4
    });
    init_identity = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/identity.js"() {
        init_bytes();
        init_digest();
        code52 = 0;
        name52 = "identity";
        encode92 = coerce4;
        digest5 = (input10) => create8(code52, encode92(input10));
        identity4 = {
          code: code52,
          name: name52,
          encode: encode92,
          digest: digest5
        };
      }
    });
    identity_exports22 = {};
    __export2(identity_exports22, {
      identity: () => identity22
    });
    init_identity2 = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/identity.js"() {
        init_base();
        init_bytes();
        identity22 = from8({
          prefix: "\0",
          name: "identity",
          encode: (buf22) => toString6(buf22),
          decode: (str) => fromString3(str)
        });
      }
    });
    base2_exports2 = {};
    __export2(base2_exports2, {
      base2: () => base23
    });
    init_base2 = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base2.js"() {
        init_base();
        base23 = rfc46484({
          prefix: "0",
          name: "base2",
          alphabet: "01",
          bitsPerChar: 1
        });
      }
    });
    base8_exports2 = {};
    __export2(base8_exports2, {
      base8: () => base82
    });
    init_base8 = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base8.js"() {
        init_base();
        base82 = rfc46484({
          prefix: "7",
          name: "base8",
          alphabet: "01234567",
          bitsPerChar: 3
        });
      }
    });
    base10_exports2 = {};
    __export2(base10_exports2, {
      base10: () => base102
    });
    init_base10 = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base10.js"() {
        init_base();
        base102 = baseX4({
          prefix: "9",
          name: "base10",
          alphabet: "0123456789"
        });
      }
    });
    base16_exports2 = {};
    __export2(base16_exports2, {
      base16: () => base162,
      base16upper: () => base16upper2
    });
    init_base16 = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base16.js"() {
        init_base();
        base162 = rfc46484({
          prefix: "f",
          name: "base16",
          alphabet: "0123456789abcdef",
          bitsPerChar: 4
        });
        base16upper2 = rfc46484({
          prefix: "F",
          name: "base16upper",
          alphabet: "0123456789ABCDEF",
          bitsPerChar: 4
        });
      }
    });
    base36_exports2 = {};
    __export2(base36_exports2, {
      base36: () => base362,
      base36upper: () => base36upper2
    });
    init_base36 = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base36.js"() {
        init_base();
        base362 = baseX4({
          prefix: "k",
          name: "base36",
          alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
        });
        base36upper2 = baseX4({
          prefix: "K",
          name: "base36upper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        });
      }
    });
    base256emoji_exports2 = {};
    __export2(base256emoji_exports2, {
      base256emoji: () => base256emoji2
    });
    init_base256emoji = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base256emoji.js"() {
        init_base();
        alphabet2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
        alphabetBytesToChars2 = alphabet2.reduce((p, c, i) => {
          p[i] = c;
          return p;
        }, []);
        alphabetCharsToBytes2 = alphabet2.reduce((p, c, i) => {
          p[c.codePointAt(0)] = i;
          return p;
        }, []);
        base256emoji2 = from8({
          prefix: "\u{1F680}",
          name: "base256emoji",
          encode: encode102,
          decode: decode112
        });
      }
    });
    sha2_browser_exports2 = {};
    __export2(sha2_browser_exports2, {
      sha256: () => sha2565,
      sha512: () => sha5124
    });
    init_sha2_browser = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/sha2-browser.js"() {
        init_hasher();
        sha4 = (name82) => async (data) => new Uint8Array(await crypto.subtle.digest(name82, data));
        sha2565 = from22({
          name: "sha2-256",
          code: 18,
          encode: sha4("SHA-256")
        });
        sha5124 = from22({
          name: "sha2-512",
          code: 19,
          encode: sha4("SHA-512")
        });
      }
    });
    raw_exports = {};
    __export2(raw_exports, {
      code: () => code62,
      decode: () => decode122,
      encode: () => encode112,
      name: () => name62
    });
    init_raw = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/codecs/raw.js"() {
        init_bytes();
        name62 = "raw";
        code62 = 85;
        encode112 = (node) => coerce4(node);
        decode122 = (data) => coerce4(data);
      }
    });
    json_exports2 = {};
    __export2(json_exports2, {
      code: () => code72,
      decode: () => decode132,
      encode: () => encode122,
      name: () => name72
    });
    init_json = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/codecs/json.js"() {
        textEncoder42 = new TextEncoder();
        textDecoder32 = new TextDecoder();
        name72 = "json";
        code72 = 512;
        encode122 = (node) => textEncoder42.encode(JSON.stringify(node));
        decode132 = (data) => JSON.parse(textDecoder32.decode(data));
      }
    });
    init_basics = __esm2({
      "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/basics.js"() {
        init_identity2();
        init_base2();
        init_base8();
        init_base10();
        init_base16();
        init_base32();
        init_base36();
        init_base58();
        init_base64();
        init_base256emoji();
        init_sha2_browser();
        init_identity();
        init_raw();
        init_json();
        init_src();
        bases2 = {
          ...identity_exports22,
          ...base2_exports2,
          ...base8_exports2,
          ...base10_exports2,
          ...base16_exports2,
          ...base32_exports2,
          ...base36_exports2,
          ...base58_exports2,
          ...base64_exports2,
          ...base256emoji_exports2
        };
        hashes2 = {
          ...sha2_browser_exports2,
          ...identity_exports3
        };
        codecs = {
          raw: raw_exports,
          json: json_exports2
        };
      }
    });
    require_ip_regex = __commonJS2({
      "../../node_modules/.pnpm/ip-regex@4.3.0/node_modules/ip-regex/index.js"(exports2, module2) {
        "use strict";
        var word = "[a-fA-F\\d:]";
        var b = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
        var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
        var v6seg = "[a-fA-F\\d]{1,4}";
        var v6 = `
(?:
(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
        var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
        var v4exact = new RegExp(`^${v4}$`);
        var v6exact = new RegExp(`^${v6}$`);
        var ip = (options) => options && options.exact ? v46Exact : new RegExp(`(?:${b(options)}${v4}${b(options)})|(?:${b(options)}${v6}${b(options)})`, "g");
        ip.v4 = (options) => options && options.exact ? v4exact : new RegExp(`${b(options)}${v4}${b(options)}`, "g");
        ip.v6 = (options) => options && options.exact ? v6exact : new RegExp(`${b(options)}${v6}${b(options)}`, "g");
        module2.exports = ip;
      }
    });
    require_is_ip = __commonJS2({
      "../../node_modules/.pnpm/is-ip@3.1.0/node_modules/is-ip/index.js"(exports2, module2) {
        "use strict";
        var ipRegex = require_ip_regex();
        var isIp = (string22) => ipRegex({ exact: true }).test(string22);
        isIp.v4 = (string22) => ipRegex.v4({ exact: true }).test(string22);
        isIp.v6 = (string22) => ipRegex.v6({ exact: true }).test(string22);
        isIp.version = (string22) => isIp(string22) ? isIp.v4(string22) ? 4 : 6 : void 0;
        module2.exports = isIp;
      }
    });
    init_as_uint8array = __esm2({
      "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/util/as-uint8array.js"() {
      }
    });
    init_alloc = __esm2({
      "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/alloc.js"() {
        init_as_uint8array();
      }
    });
    init_bases = __esm2({
      "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/util/bases.js"() {
        init_basics();
        init_alloc();
        string3 = createCodec2("utf8", "u", (buf22) => {
          const decoder4 = new TextDecoder("utf8");
          return "u" + decoder4.decode(buf22);
        }, (str) => {
          const encoder4 = new TextEncoder();
          return encoder4.encode(str.substring(1));
        });
        ascii3 = createCodec2("ascii", "a", (buf22) => {
          let string22 = "a";
          for (let i = 0; i < buf22.length; i++) {
            string22 += String.fromCharCode(buf22[i]);
          }
          return string22;
        }, (str) => {
          str = str.substring(1);
          const buf22 = allocUnsafe2(str.length);
          for (let i = 0; i < str.length; i++) {
            buf22[i] = str.charCodeAt(i);
          }
          return buf22;
        });
        BASES2 = {
          utf8: string3,
          "utf-8": string3,
          hex: bases2.base16,
          latin1: ascii3,
          ascii: ascii3,
          binary: ascii3,
          ...bases2
        };
        bases_default = BASES2;
      }
    });
    to_string_exports = {};
    __export2(to_string_exports, {
      toString: () => toString32
    });
    init_to_string = __esm2({
      "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/to-string.js"() {
        init_bases();
      }
    });
    require_ip = __commonJS2({
      "../../node_modules/.pnpm/multiaddr@10.0.1/node_modules/multiaddr/src/ip.js"(exports2, module2) {
        "use strict";
        var isIp = require_is_ip();
        var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
        var isIP = isIp;
        var isV4 = isIp.v4;
        var isV6 = isIp.v6;
        var toBytes4 = function(ip, buff, offset3) {
          offset3 = ~~offset3;
          let result;
          if (isV4(ip)) {
            result = buff || new Uint8Array(offset3 + 4);
            ip.split(/\./g).map(function(byte) {
              result[offset3++] = parseInt(byte, 10) & 255;
            });
          } else if (isV6(ip)) {
            const sections = ip.split(":", 8);
            let i;
            for (i = 0; i < sections.length; i++) {
              const isv4 = isV4(sections[i]);
              let v4Buffer;
              if (isv4) {
                v4Buffer = toBytes4(sections[i]);
                sections[i] = uint8ArrayToString(v4Buffer.slice(0, 2), "base16");
              }
              if (v4Buffer && ++i < 8) {
                sections.splice(i, 0, uint8ArrayToString(v4Buffer.slice(2, 4), "base16"));
              }
            }
            if (sections[0] === "") {
              while (sections.length < 8) sections.unshift("0");
            } else if (sections[sections.length - 1] === "") {
              while (sections.length < 8) sections.push("0");
            } else if (sections.length < 8) {
              for (i = 0; i < sections.length && sections[i] !== ""; i++) ;
              const argv = [i, "1"];
              for (i = 9 - sections.length; i > 0; i--) {
                argv.push("0");
              }
              sections.splice.apply(sections, argv);
            }
            result = buff || new Uint8Array(offset3 + 16);
            for (i = 0; i < sections.length; i++) {
              const word = parseInt(sections[i], 16);
              result[offset3++] = word >> 8 & 255;
              result[offset3++] = word & 255;
            }
          }
          if (!result) {
            throw Error("Invalid ip address: " + ip);
          }
          return result;
        };
        var toString42 = function(buff, offset3, length22) {
          offset3 = ~~offset3;
          length22 = length22 || buff.length - offset3;
          const result = [];
          let string22;
          const view6 = new DataView(buff.buffer);
          if (length22 === 4) {
            for (let i = 0; i < length22; i++) {
              result.push(buff[offset3 + i]);
            }
            string22 = result.join(".");
          } else if (length22 === 16) {
            for (let i = 0; i < length22; i += 2) {
              result.push(view6.getUint16(offset3 + i).toString(16));
            }
            string22 = result.join(":");
            string22 = string22.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3");
            string22 = string22.replace(/:{3,4}/, "::");
          }
          return string22;
        };
        module2.exports = {
          isIP,
          isV4,
          isV6,
          toBytes: toBytes4,
          toString: toString42
        };
      }
    });
    require_protocols_table = __commonJS2({
      "../../node_modules/.pnpm/multiaddr@10.0.1/node_modules/multiaddr/src/protocols-table.js"(exports2, module2) {
        "use strict";
        function Protocols(proto) {
          if (typeof proto === "number") {
            if (Protocols.codes[proto]) {
              return Protocols.codes[proto];
            }
            throw new Error("no protocol with code: " + proto);
          } else if (typeof proto === "string") {
            if (Protocols.names[proto]) {
              return Protocols.names[proto];
            }
            throw new Error("no protocol with name: " + proto);
          }
          throw new Error("invalid protocol id type: " + proto);
        }
        var V = -1;
        Protocols.lengthPrefixedVarSize = V;
        Protocols.V = V;
        Protocols.table = [
          [4, 32, "ip4"],
          [6, 16, "tcp"],
          [33, 16, "dccp"],
          [41, 128, "ip6"],
          [42, V, "ip6zone"],
          [53, V, "dns", "resolvable"],
          [54, V, "dns4", "resolvable"],
          [55, V, "dns6", "resolvable"],
          [56, V, "dnsaddr", "resolvable"],
          [132, 16, "sctp"],
          [273, 16, "udp"],
          [275, 0, "p2p-webrtc-star"],
          [276, 0, "p2p-webrtc-direct"],
          [277, 0, "p2p-stardust"],
          [290, 0, "p2p-circuit"],
          [301, 0, "udt"],
          [302, 0, "utp"],
          [400, V, "unix", false, "path"],
          // `ipfs` is added before `p2p` for legacy support.
          // All text representations will default to `p2p`, but `ipfs` will
          // still be supported
          [421, V, "ipfs"],
          // `p2p` is the preferred name for 421, and is now the default
          [421, V, "p2p"],
          [443, 0, "https"],
          [444, 96, "onion"],
          [445, 296, "onion3"],
          [446, V, "garlic64"],
          [460, 0, "quic"],
          [477, 0, "ws"],
          [478, 0, "wss"],
          [479, 0, "p2p-websocket-star"],
          [480, 0, "http"],
          [777, V, "memory"]
        ];
        Protocols.names = {};
        Protocols.codes = {};
        Protocols.table.map((row) => {
          const proto = p.apply(null, row);
          Protocols.codes[proto.code] = proto;
          Protocols.names[proto.name] = proto;
          return null;
        });
        Protocols.object = p;
        function p(code82, size5, name82, resolvable, path) {
          return {
            code: code82,
            size: size5,
            name: name82,
            resolvable: Boolean(resolvable),
            path: Boolean(path)
          };
        }
        module2.exports = Protocols;
      }
    });
    from_string_exports = {};
    __export2(from_string_exports, {
      fromString: () => fromString32
    });
    init_from_string = __esm2({
      "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/from-string.js"() {
        init_bases();
        init_as_uint8array();
      }
    });
    concat_exports = {};
    __export2(concat_exports, {
      concat: () => concat22
    });
    init_concat = __esm2({
      "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/concat.js"() {
        init_alloc();
        init_as_uint8array();
      }
    });
    require_convert = __commonJS2({
      "../../node_modules/.pnpm/multiaddr@10.0.1/node_modules/multiaddr/src/convert.js"(exports2, module2) {
        "use strict";
        var ip = require_ip();
        var protocols = require_protocols_table();
        var { CID: CID22 } = (init_cid(), __toCommonJS(cid_exports));
        var { base32: base3222 } = (init_base32(), __toCommonJS(base32_exports2));
        var { base58btc: base58btc22 } = (init_base58(), __toCommonJS(base58_exports2));
        var Digest22 = (init_digest(), __toCommonJS(digest_exports));
        var varint22 = require_varint();
        var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
        var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
        var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
        module2.exports = Convert;
        function Convert(proto, a) {
          if (a instanceof Uint8Array) {
            return Convert.toString(proto, a);
          } else {
            return Convert.toBytes(proto, a);
          }
        }
        Convert.toString = function convertToString(proto, buf22) {
          const protocol = protocols(proto);
          switch (protocol.code) {
            case 4:
            case 41:
              return bytes2ip(buf22);
            case 6:
            case 273:
            case 33:
            case 132:
              return bytes2port(buf22).toString();
            case 53:
            case 54:
            case 55:
            case 56:
            case 400:
            case 777:
              return bytes2str(buf22);
            case 421:
              return bytes2mh(buf22);
            case 444:
              return bytes2onion(buf22);
            case 445:
              return bytes2onion(buf22);
            default:
              return uint8ArrayToString(buf22, "base16");
          }
        };
        Convert.toBytes = function convertToBytes(proto, str) {
          const protocol = protocols(proto);
          switch (protocol.code) {
            case 4:
              return ip2bytes(str);
            case 41:
              return ip2bytes(str);
            case 6:
            case 273:
            case 33:
            case 132:
              return port2bytes(parseInt(str, 10));
            case 53:
            case 54:
            case 55:
            case 56:
            case 400:
            case 777:
              return str2bytes(str);
            case 421:
              return mh2bytes(str);
            case 444:
              return onion2bytes(str);
            case 445:
              return onion32bytes(str);
            default:
              return uint8ArrayFromString(str, "base16");
          }
        };
        function ip2bytes(ipString) {
          if (!ip.isIP(ipString)) {
            throw new Error("invalid ip address");
          }
          return ip.toBytes(ipString);
        }
        function bytes2ip(ipBuff) {
          const ipString = ip.toString(ipBuff);
          if (!ipString || !ip.isIP(ipString)) {
            throw new Error("invalid ip address");
          }
          return ipString;
        }
        function port2bytes(port) {
          const buf22 = new ArrayBuffer(2);
          const view6 = new DataView(buf22);
          view6.setUint16(0, port);
          return new Uint8Array(buf22);
        }
        function bytes2port(buf22) {
          const view6 = new DataView(buf22.buffer);
          return view6.getUint16(buf22.byteOffset);
        }
        function str2bytes(str) {
          const buf22 = uint8ArrayFromString(str);
          const size5 = Uint8Array.from(varint22.encode(buf22.length));
          return uint8ArrayConcat([size5, buf22], size5.length + buf22.length);
        }
        function bytes2str(buf22) {
          const size5 = varint22.decode(buf22);
          buf22 = buf22.slice(varint22.decode.bytes);
          if (buf22.length !== size5) {
            throw new Error("inconsistent lengths");
          }
          return uint8ArrayToString(buf22);
        }
        function mh2bytes(hash) {
          let mh;
          if (hash[0] === "Q" || hash[0] === "1") {
            mh = Digest22.decode(base58btc22.decode(`z${hash}`)).bytes;
          } else {
            mh = CID22.parse(hash).multihash.bytes;
          }
          const size5 = Uint8Array.from(varint22.encode(mh.length));
          return uint8ArrayConcat([size5, mh], size5.length + mh.length);
        }
        function bytes2mh(buf22) {
          const size5 = varint22.decode(buf22);
          const address = buf22.slice(varint22.decode.bytes);
          if (address.length !== size5) {
            throw new Error("inconsistent lengths");
          }
          return uint8ArrayToString(address, "base58btc");
        }
        function onion2bytes(str) {
          const addr = str.split(":");
          if (addr.length !== 2) {
            throw new Error("failed to parse onion addr: " + addr + " does not contain a port number");
          }
          if (addr[0].length !== 16) {
            throw new Error("failed to parse onion addr: " + addr[0] + " not a Tor onion address.");
          }
          const buf22 = base3222.decode("b" + addr[0]);
          const port = parseInt(addr[1], 10);
          if (port < 1 || port > 65536) {
            throw new Error("Port number is not in range(1, 65536)");
          }
          const portBuf = port2bytes(port);
          return uint8ArrayConcat([buf22, portBuf], buf22.length + portBuf.length);
        }
        function onion32bytes(str) {
          const addr = str.split(":");
          if (addr.length !== 2) {
            throw new Error("failed to parse onion addr: " + addr + " does not contain a port number");
          }
          if (addr[0].length !== 56) {
            throw new Error("failed to parse onion addr: " + addr[0] + " not a Tor onion3 address.");
          }
          const buf22 = base3222.decode("b" + addr[0]);
          const port = parseInt(addr[1], 10);
          if (port < 1 || port > 65536) {
            throw new Error("Port number is not in range(1, 65536)");
          }
          const portBuf = port2bytes(port);
          return uint8ArrayConcat([buf22, portBuf], buf22.length + portBuf.length);
        }
        function bytes2onion(buf22) {
          const addrBytes = buf22.slice(0, buf22.length - 2);
          const portBytes = buf22.slice(buf22.length - 2);
          const addr = uint8ArrayToString(addrBytes, "base32");
          const port = bytes2port(portBytes);
          return addr + ":" + port;
        }
      }
    });
    require_codec = __commonJS2({
      "../../node_modules/.pnpm/multiaddr@10.0.1/node_modules/multiaddr/src/codec.js"(exports2, module2) {
        "use strict";
        var convert = require_convert();
        var protocols = require_protocols_table();
        var varint22 = require_varint();
        var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
        var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
        module2.exports = {
          stringToStringTuples,
          stringTuplesToString,
          tuplesToStringTuples,
          stringTuplesToTuples,
          bytesToTuples,
          tuplesToBytes,
          bytesToString,
          stringToBytes,
          fromString: fromString4,
          fromBytes: fromBytes6,
          validateBytes,
          isValidBytes,
          cleanPath,
          ParseError: ParseError2,
          protoFromTuple,
          sizeForAddr
        };
        function stringToStringTuples(str) {
          const tuples = [];
          const parts = str.split("/").slice(1);
          if (parts.length === 1 && parts[0] === "") {
            return [];
          }
          for (let p = 0; p < parts.length; p++) {
            const part = parts[p];
            const proto = protocols(part);
            if (proto.size === 0) {
              tuples.push([part]);
              continue;
            }
            p++;
            if (p >= parts.length) {
              throw ParseError2("invalid address: " + str);
            }
            if (proto.path) {
              tuples.push([
                part,
                // TODO: should we need to check each path part to see if it's a proto?
                // This would allow for other protocols to be added after a unix path,
                // however it would have issues if the path had a protocol name in the path
                cleanPath(parts.slice(p).join("/"))
              ]);
              break;
            }
            tuples.push([part, parts[p]]);
          }
          return tuples;
        }
        function stringTuplesToString(tuples) {
          const parts = [];
          tuples.map((tup) => {
            const proto = protoFromTuple(tup);
            parts.push(proto.name);
            if (tup.length > 1) {
              parts.push(tup[1]);
            }
            return null;
          });
          return cleanPath(parts.join("/"));
        }
        function stringTuplesToTuples(tuples) {
          return tuples.map((tup) => {
            if (!Array.isArray(tup)) {
              tup = [tup];
            }
            const proto = protoFromTuple(tup);
            if (tup.length > 1) {
              return [proto.code, convert.toBytes(proto.code, tup[1])];
            }
            return [proto.code];
          });
        }
        function tuplesToStringTuples(tuples) {
          return tuples.map((tup) => {
            const proto = protoFromTuple(tup);
            if (tup[1]) {
              return [proto.code, convert.toString(proto.code, tup[1])];
            }
            return [proto.code];
          });
        }
        function tuplesToBytes(tuples) {
          return fromBytes6(uint8ArrayConcat(tuples.map((tup) => {
            const proto = protoFromTuple(tup);
            let buf22 = Uint8Array.from(varint22.encode(proto.code));
            if (tup.length > 1) {
              buf22 = uint8ArrayConcat([buf22, tup[1]]);
            }
            return buf22;
          })));
        }
        function sizeForAddr(p, addr) {
          if (p.size > 0) {
            return p.size / 8;
          } else if (p.size === 0) {
            return 0;
          } else {
            const size5 = varint22.decode(addr);
            return size5 + varint22.decode.bytes;
          }
        }
        function bytesToTuples(buf22) {
          const tuples = [];
          let i = 0;
          while (i < buf22.length) {
            const code82 = varint22.decode(buf22, i);
            const n2 = varint22.decode.bytes;
            const p = protocols(code82);
            const size5 = sizeForAddr(p, buf22.slice(i + n2));
            if (size5 === 0) {
              tuples.push([code82]);
              i += n2;
              continue;
            }
            const addr = buf22.slice(i + n2, i + n2 + size5);
            i += size5 + n2;
            if (i > buf22.length) {
              throw ParseError2("Invalid address Uint8Array: " + uint8ArrayToString(buf22, "base16"));
            }
            tuples.push([code82, addr]);
          }
          return tuples;
        }
        function bytesToString(buf22) {
          const a = bytesToTuples(buf22);
          const b = tuplesToStringTuples(a);
          return stringTuplesToString(b);
        }
        function stringToBytes(str) {
          str = cleanPath(str);
          const a = stringToStringTuples(str);
          const b = stringTuplesToTuples(a);
          return tuplesToBytes(b);
        }
        function fromString4(str) {
          return stringToBytes(str);
        }
        function fromBytes6(buf22) {
          const err = validateBytes(buf22);
          if (err) throw err;
          return Uint8Array.from(buf22);
        }
        function validateBytes(buf22) {
          try {
            bytesToTuples(buf22);
          } catch (err) {
            return err;
          }
        }
        function isValidBytes(buf22) {
          return validateBytes(buf22) === void 0;
        }
        function cleanPath(str) {
          return "/" + str.trim().split("/").filter((a) => a).join("/");
        }
        function ParseError2(str) {
          return new Error("Error parsing address: " + str);
        }
        function protoFromTuple(tup) {
          const proto = protocols(tup[0]);
          return proto;
        }
      }
    });
    require_err_code = __commonJS2({
      "../../node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js"(exports2, module2) {
        "use strict";
        function assign2(obj, props) {
          for (const key in props) {
            Object.defineProperty(obj, key, {
              value: props[key],
              enumerable: true,
              configurable: true
            });
          }
          return obj;
        }
        function createError(err, code82, props) {
          if (!err || typeof err === "string") {
            throw new TypeError("Please pass an Error to err-code");
          }
          if (!props) {
            props = {};
          }
          if (typeof code82 === "object") {
            props = code82;
            code82 = "";
          }
          if (code82) {
            props.code = code82;
          }
          try {
            return assign2(err, props);
          } catch (_) {
            props.message = err.message;
            props.stack = err.stack;
            const ErrClass = function() {
            };
            ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
            const output2 = assign2(new ErrClass(), props);
            return output2;
          }
        }
        module2.exports = createError;
      }
    });
    equals_exports = {};
    __export2(equals_exports, {
      equals: () => equals32
    });
    init_equals = __esm2({
      "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/equals.js"() {
      }
    });
    require_src = __commonJS2({
      "../../node_modules/.pnpm/multiaddr@10.0.1/node_modules/multiaddr/src/index.js"(exports2, module2) {
        "use strict";
        var codec = require_codec();
        var protocols = require_protocols_table();
        var varint22 = require_varint();
        var { CID: CID22 } = (init_cid(), __toCommonJS(cid_exports));
        var { base58btc: base58btc22 } = (init_base58(), __toCommonJS(base58_exports2));
        var errCode11 = require_err_code();
        var inspect = Symbol.for("nodejs.util.inspect.custom");
        var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
        var { equals: uint8ArrayEquals } = (init_equals(), __toCommonJS(equals_exports));
        var resolvers2 = /* @__PURE__ */ new Map();
        var symbol2 = Symbol.for("@multiformats/js-multiaddr/multiaddr");
        var Multiaddr14 = class _Multiaddr {
          /**
           * @example
           * ```js
           * new Multiaddr('/ip4/127.0.0.1/tcp/4001')
           * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
           * ```
           *
           * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)
           */
          constructor(addr) {
            if (addr == null) {
              addr = "";
            }
            Object.defineProperty(this, symbol2, { value: true });
            if (addr instanceof Uint8Array) {
              this.bytes = codec.fromBytes(addr);
            } else if (typeof addr === "string") {
              if (addr.length > 0 && addr.charAt(0) !== "/") {
                throw new Error(`multiaddr "${addr}" must start with a "/"`);
              }
              this.bytes = codec.fromString(addr);
            } else if (_Multiaddr.isMultiaddr(addr)) {
              this.bytes = codec.fromBytes(addr.bytes);
            } else {
              throw new Error("addr must be a string, Buffer, or another Multiaddr");
            }
          }
          /**
           * Returns Multiaddr as a String
           *
           * @example
           * ```js
           * new Multiaddr('/ip4/127.0.0.1/tcp/4001').toString()
           * // '/ip4/127.0.0.1/tcp/4001'
           * ```
           */
          toString() {
            return codec.bytesToString(this.bytes);
          }
          /**
           * Returns Multiaddr as a JSON encoded object
           *
           * @example
           * ```js
           * JSON.stringify(new Multiaddr('/ip4/127.0.0.1/tcp/4001'))
           * // '/ip4/127.0.0.1/tcp/4001'
           * ```
           */
          toJSON() {
            return this.toString();
          }
          /**
           * Returns Multiaddr as a convinient options object to be used with net.createConnection
           *
           * @example
           * ```js
           * new Multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()
           * // { family: 4, host: '127.0.0.1', transport: 'tcp', port: 4001 }
           * ```
           */
          toOptions() {
            const opts = {};
            const parsed = this.toString().split("/");
            opts.family = parsed[1] === "ip4" ? 4 : 6;
            opts.host = parsed[2];
            opts.transport = parsed[3];
            opts.port = parseInt(parsed[4]);
            return opts;
          }
          /**
           * Returns the protocols the Multiaddr is defined with, as an array of objects, in
           * left-to-right order. Each object contains the protocol code, protocol name,
           * and the size of its address space in bits.
           * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)
           *
           * @example
           * ```js
           * new Multiaddr('/ip4/127.0.0.1/tcp/4001').protos()
           * // [ { code: 4, size: 32, name: 'ip4' },
           * //   { code: 6, size: 16, name: 'tcp' } ]
           * ```
           *
           * @returns {Protocol[]} protocols - All the protocols the address is composed of
           */
          protos() {
            return this.protoCodes().map((code82) => Object.assign({}, protocols(code82)));
          }
          /**
           * Returns the codes of the protocols in left-to-right order.
           * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)
           *
           * @example
           * ```js
           * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()
           * // [ 4, 6 ]
           * ```
           *
           * @returns {number[]} protocol codes
           */
          protoCodes() {
            const codes = [];
            const buf22 = this.bytes;
            let i = 0;
            while (i < buf22.length) {
              const code82 = varint22.decode(buf22, i);
              const n2 = varint22.decode.bytes;
              const p = protocols(code82);
              const size5 = codec.sizeForAddr(p, buf22.slice(i + n2));
              i += size5 + n2;
              codes.push(code82);
            }
            return codes;
          }
          /**
           * Returns the names of the protocols in left-to-right order.
           * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)
           *
           * @example
           * ```js
           * new Multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()
           * // [ 'ip4', 'tcp' ]
           * ```
           *
           * @returns {string[]} protocol names
           */
          protoNames() {
            return this.protos().map((proto) => proto.name);
          }
          /**
           * Returns a tuple of parts
           *
           * @example
           * ```js
           * new Multiaddr("/ip4/127.0.0.1/tcp/4001").tuples()
           * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]
           * ```
           */
          tuples() {
            return codec.bytesToTuples(this.bytes);
          }
          /**
           * Returns a tuple of string/number parts
           * - tuples[][0] = code of protocol
           * - tuples[][1] = contents of address
           *
           * @example
           * ```js
           * new Multiaddr("/ip4/127.0.0.1/tcp/4001").stringTuples()
           * // [ [ 4, '127.0.0.1' ], [ 6, '4001' ] ]
           * ```
           */
          stringTuples() {
            const t = codec.bytesToTuples(this.bytes);
            return codec.tuplesToStringTuples(t);
          }
          /**
           * Encapsulates a Multiaddr in another Multiaddr
           *
           * @example
           * ```js
           * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080')
           * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>
           *
           * const mh2 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')
           * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
           *
           * const mh3 = mh1.encapsulate(mh2)
           * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>
           *
           * mh3.toString()
           * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'
           * ```
           *
           * @param {MultiaddrInput} addr - Multiaddr to add into this Multiaddr
           */
          encapsulate(addr) {
            addr = new _Multiaddr(addr);
            return new _Multiaddr(this.toString() + addr.toString());
          }
          /**
           * Decapsulates a Multiaddr from another Multiaddr
           *
           * @example
           * ```js
           * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080')
           * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>
           *
           * const mh2 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')
           * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
           *
           * const mh3 = mh1.encapsulate(mh2)
           * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>
           *
           * mh3.decapsulate(mh2).toString()
           * // '/ip4/8.8.8.8/tcp/1080'
           * ```
           *
           * @param {Multiaddr | string} addr - Multiaddr to remove from this Multiaddr
           * @returns {Multiaddr}
           */
          decapsulate(addr) {
            const addrString = addr.toString();
            const s2 = this.toString();
            const i = s2.lastIndexOf(addrString);
            if (i < 0) {
              throw new Error("Address " + this + " does not contain subaddress: " + addr);
            }
            return new _Multiaddr(s2.slice(0, i));
          }
          /**
           * A more reliable version of `decapsulate` if you are targeting a
           * specific code, such as 421 (the `p2p` protocol code). The last index of the code
           * will be removed from the `Multiaddr`, and a new instance will be returned.
           * If the code is not present, the original `Multiaddr` is returned.
           *
           * @example
           * ```js
           * const addr = new Multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')
           * // <Multiaddr 0400... - /ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC>
           *
           * addr.decapsulateCode(421).toString()
           * // '/ip4/0.0.0.0/tcp/8080'
           *
           * new Multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()
           * // '/ip4/127.0.0.1/tcp/8080'
           * ```
           *
           * @param {number} code - The code of the protocol to decapsulate from this Multiaddr
           * @returns {Multiaddr}
           */
          decapsulateCode(code82) {
            const tuples = this.tuples();
            for (let i = tuples.length - 1; i >= 0; i--) {
              if (tuples[i][0] === code82) {
                return new _Multiaddr(codec.tuplesToBytes(tuples.slice(0, i)));
              }
            }
            return this;
          }
          /**
           * Extract the peerId if the multiaddr contains one
           *
           * @example
           * ```js
           * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')
           * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string>
           *
           * // should return QmValidBase58string or null if the id is missing or invalid
           * const peerId = mh1.getPeerId()
           * ```
           *
           * @returns {string | null} peerId - The id of the peer or null if invalid or missing from the ma
           */
          getPeerId() {
            try {
              const tuples = this.stringTuples().filter((tuple22) => {
                if (tuple22[0] === protocols.names.ipfs.code) {
                  return true;
                }
                return false;
              });
              const tuple2 = tuples.pop();
              if (tuple2 && tuple2[1]) {
                const peerIdStr = tuple2[1];
                if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
                  return uint8ArrayToString(base58btc22.decode(`z${peerIdStr}`), "base58btc");
                }
                return uint8ArrayToString(CID22.parse(peerIdStr).multihash.bytes, "base58btc");
              }
              return null;
            } catch (e) {
              return null;
            }
          }
          /**
           * Extract the path if the multiaddr contains one
           *
           * @example
           * ```js
           * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')
           * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock>
           *
           * // should return utf8 string or null if the id is missing or invalid
           * const path = mh1.getPath()
           * ```js
           *
           * @returns {string | null} path - The path of the multiaddr, or null if no path protocol is present
           */
          getPath() {
            let path = null;
            try {
              path = this.stringTuples().filter((tuple2) => {
                const proto = protocols(tuple2[0]);
                if (proto.path) {
                  return true;
                }
                return false;
              })[0][1];
              if (!path) {
                path = null;
              }
            } catch (e) {
              path = null;
            }
            return path;
          }
          /**
           * Checks if two Multiaddrs are the same
           *
           * @example
           * ```js
           * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080')
           * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>
           *
           * const mh2 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')
           * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
           *
           * mh1.equals(mh1)
           * // true
           *
           * mh1.equals(mh2)
           * // false
           * ```
           *
           * @param {Multiaddr} addr
           * @returns {boolean}
           */
          equals(addr) {
            return uint8ArrayEquals(this.bytes, addr.bytes);
          }
          /**
           * Resolve multiaddr if containing resolvable hostname.
           *
           * @example
           * ```js
           * Multiaddr.resolvers.set('dnsaddr', resolverFunction)
           * const mh1 = new Multiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb')
           * const resolvedMultiaddrs = await mh1.resolve()
           * // [
           * //   <Multiaddr 04934b5353060fa1a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/tcp/4001/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>,
           * //   <Multiaddr 04934b53530601bbde03a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/tcp/443/wss/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>,
           * //   <Multiaddr 04934b535391020fa1cc03a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/udp/4001/quic/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>
           * // ]
           * ```
           *
           * @returns {Promise<Array<Multiaddr>>}
           */
          async resolve() {
            const resolvableProto = this.protos().find((p) => p.resolvable);
            if (!resolvableProto) {
              return [this];
            }
            const resolver = resolvers2.get(resolvableProto.name);
            if (!resolver) {
              throw errCode11(new Error(`no available resolver for ${resolvableProto.name}`), "ERR_NO_AVAILABLE_RESOLVER");
            }
            const addresses = await resolver(this);
            return addresses.map((a) => new _Multiaddr(a));
          }
          /**
           * Gets a Multiaddrs node-friendly address object. Note that protocol information
           * is left out: in Node (and most network systems) the protocol is unknowable
           * given only the address.
           *
           * Has to be a ThinWaist Address, otherwise throws error
           *
           * @example
           * ```js
           * new Multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()
           * // {family: 4, address: '127.0.0.1', port: 4001}
           * ```
           *
           * @returns {{family: 4 | 6, address: string, port: number}}
           * @throws {Error} Throws error if Multiaddr is not a Thin Waist address
           */
          nodeAddress() {
            const codes = this.protoCodes();
            const names = this.protoNames();
            const parts = this.toString().split("/").slice(1);
            if (parts.length < 4) {
              throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".');
            } else if (codes[0] !== 4 && codes[0] !== 41 && codes[0] !== 54 && codes[0] !== 55) {
              throw new Error(`no protocol with name: "'${names[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`);
            } else if (parts[2] !== "tcp" && parts[2] !== "udp") {
              throw new Error(`no protocol with name: "'${names[1]}'". Must have a valid transport protocol: "{tcp, udp}".`);
            }
            return {
              family: codes[0] === 41 || codes[0] === 55 ? 6 : 4,
              address: parts[1],
              port: parseInt(parts[3])
              // tcp or udp port
            };
          }
          /**
           * Returns if a Multiaddr is a Thin Waist address or not.
           *
           * Thin Waist is if a Multiaddr adheres to the standard combination of:
           *
           * `{IPv4, IPv6}/{TCP, UDP}`
           *
           * @example
           * ```js
           * const mh1 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')
           * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
           * const mh2 = new Multiaddr('/ip4/192.168.2.1/tcp/5001')
           * // <Multiaddr 04c0a80201061389 - /ip4/192.168.2.1/tcp/5001>
           * const mh3 = mh1.encapsulate(mh2)
           * // <Multiaddr 047f000001060fa104c0a80201061389 - /ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001>
           * const mh4 = new Multiaddr('/ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a')
           * // <Multiaddr 047f0000010607d0de039302a503221220d52ebb89d85b02a284948203a62ff28389c57c9f42beec4ec20db76a64835843 - /ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a>
           * mh1.isThinWaistAddress()
           * // true
           * mh2.isThinWaistAddress()
           * // true
           * mh3.isThinWaistAddress()
           * // false
           * mh4.isThinWaistAddress()
           * // false
           * ```
           *
           * @param {Multiaddr} [addr] - Defaults to using `this` instance
           */
          isThinWaistAddress(addr) {
            const protos = (addr || this).protos();
            if (protos.length !== 2) {
              return false;
            }
            if (protos[0].code !== 4 && protos[0].code !== 41) {
              return false;
            }
            if (protos[1].code !== 6 && protos[1].code !== 273) {
              return false;
            }
            return true;
          }
          /**
           * Creates a Multiaddr from a node-friendly address object
           *
           * @example
           * ```js
           * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')
           * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
           * ```
           *
           * @param {{family: 4 | 6, address: string, port: number}} addr
           * @param {string} transport
           */
          static fromNodeAddress(addr, transport) {
            if (!addr) {
              throw new Error("requires node address object");
            }
            if (!transport) {
              throw new Error("requires transport protocol");
            }
            let ip;
            switch (addr.family) {
              case 4:
                ip = "ip4";
                break;
              case 6:
                ip = "ip6";
                break;
              default:
                throw Error(`Invalid addr family. Got '${addr.family}' instead of 4 or 6`);
            }
            return new _Multiaddr("/" + [ip, addr.address, transport, addr.port].join("/"));
          }
          /**
           * Returns if something is a Multiaddr that is a name
           *
           * @param {Multiaddr} addr
           * @returns {boolean} isName
           */
          static isName(addr) {
            if (!_Multiaddr.isMultiaddr(addr)) {
              return false;
            }
            return addr.protos().some((proto) => proto.resolvable);
          }
          /**
           * Check if object is a CID instance
           *
           * @param {any} value
           * @returns {value is Multiaddr}
           */
          static isMultiaddr(value) {
            return value instanceof _Multiaddr || Boolean(value && value[symbol2]);
          }
          /**
           * Returns Multiaddr as a human-readable string.
           * For post Node.js v10.0.0.
           * https://nodejs.org/api/deprecations.html#deprecations_dep0079_custom_inspection_function_on_objects_via_inspect
           *
           * @example
           * ```js
           * console.log(new Multiaddr('/ip4/127.0.0.1/tcp/4001'))
           * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'
           * ```
           *
           * @returns {string}
           */
          [inspect]() {
            return "<Multiaddr " + uint8ArrayToString(this.bytes, "base16") + " - " + codec.bytesToString(this.bytes) + ">";
          }
          /**
           * Returns Multiaddr as a human-readable string.
           * Fallback for pre Node.js v10.0.0.
           * https://nodejs.org/api/deprecations.html#deprecations_dep0079_custom_inspection_function_on_objects_via_inspect
           *
           * @example
           * ```js
           * new Multiaddr('/ip4/127.0.0.1/tcp/4001').inspect()
           * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'
           * ```
           *
           * @returns {string}
           */
          inspect() {
            return "<Multiaddr " + uint8ArrayToString(this.bytes, "base16") + " - " + codec.bytesToString(this.bytes) + ">";
          }
        };
        Multiaddr14.protocols = protocols;
        Multiaddr14.resolvers = resolvers2;
        function multiaddr(addr) {
          return new Multiaddr14(addr);
        }
        module2.exports = { Multiaddr: Multiaddr14, multiaddr, protocols, resolvers: resolvers2 };
      }
    });
    require_is_electron = __commonJS2({
      "../../node_modules/.pnpm/is-electron@2.2.2/node_modules/is-electron/index.js"(exports2, module2) {
        function isElectron() {
          if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
            return true;
          }
          if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
            return true;
          }
          if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
            return true;
          }
          return false;
        }
        module2.exports = isElectron;
      }
    });
    require_env = __commonJS2({
      "../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/env.js"(exports2, module2) {
        "use strict";
        var isElectron = require_is_electron();
        var IS_ENV_WITH_DOM = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
        var IS_ELECTRON = isElectron();
        var IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON;
        var IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM;
        var IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM;
        var IS_NODE = typeof __require2 === "function" && typeof process !== "undefined" && typeof process.release !== "undefined" && process.release.name === "node" && !IS_ELECTRON;
        var IS_WEBWORKER = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
        var IS_TEST = typeof process !== "undefined" && typeof process.env !== "undefined" && false;
        var IS_REACT_NATIVE = typeof navigator !== "undefined" && navigator.product === "ReactNative";
        module2.exports = {
          isTest: IS_TEST,
          isElectron: IS_ELECTRON,
          isElectronMain: IS_ELECTRON_MAIN,
          isElectronRenderer: IS_ELECTRON_RENDERER,
          isNode: IS_NODE,
          /**
           * Detects browser main thread  **NOT** web worker or service worker
           */
          isBrowser: IS_BROWSER,
          isWebWorker: IS_WEBWORKER,
          isEnvWithDom: IS_ENV_WITH_DOM,
          isReactNative: IS_REACT_NATIVE
        };
      }
    });
    require_ms = __commonJS2({
      "../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"(exports2, module2) {
        var s2 = 1e3;
        var m = s2 * 60;
        var h = m * 60;
        var d = h * 24;
        var w = d * 7;
        var y = d * 365.25;
        module2.exports = function(val, options) {
          options = options || {};
          var type2 = typeof val;
          if (type2 === "string" && val.length > 0) {
            return parse22(val);
          } else if (type2 === "number" && isFinite(val)) {
            return options.long ? fmtLong(val) : fmtShort(val);
          }
          throw new Error(
            "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
          );
        };
        function parse22(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match6 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
            str
          );
          if (!match6) {
            return;
          }
          var n2 = parseFloat(match6[1]);
          var type2 = (match6[2] || "ms").toLowerCase();
          switch (type2) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n2 * y;
            case "weeks":
            case "week":
            case "w":
              return n2 * w;
            case "days":
            case "day":
            case "d":
              return n2 * d;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n2 * h;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n2 * m;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n2 * s2;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n2;
            default:
              return void 0;
          }
        }
        function fmtShort(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return Math.round(ms / d) + "d";
          }
          if (msAbs >= h) {
            return Math.round(ms / h) + "h";
          }
          if (msAbs >= m) {
            return Math.round(ms / m) + "m";
          }
          if (msAbs >= s2) {
            return Math.round(ms / s2) + "s";
          }
          return ms + "ms";
        }
        function fmtLong(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return plural(ms, msAbs, d, "day");
          }
          if (msAbs >= h) {
            return plural(ms, msAbs, h, "hour");
          }
          if (msAbs >= m) {
            return plural(ms, msAbs, m, "minute");
          }
          if (msAbs >= s2) {
            return plural(ms, msAbs, s2, "second");
          }
          return ms + " ms";
        }
        function plural(ms, msAbs, n2, name82) {
          var isPlural = msAbs >= n2 * 1.5;
          return Math.round(ms / n2) + " " + name82 + (isPlural ? "s" : "");
        }
      }
    });
    require_common = __commonJS2({
      "../../node_modules/.pnpm/debug@4.3.6/node_modules/debug/src/common.js"(exports2, module2) {
        function setup(env) {
          createDebug.debug = createDebug;
          createDebug.default = createDebug;
          createDebug.coerce = coerce22;
          createDebug.disable = disable;
          createDebug.enable = enable;
          createDebug.enabled = enabled;
          createDebug.humanize = require_ms();
          createDebug.destroy = destroy;
          Object.keys(env).forEach((key) => {
            createDebug[key] = env[key];
          });
          createDebug.names = [];
          createDebug.skips = [];
          createDebug.formatters = {};
          function selectColor(namespace) {
            let hash = 0;
            for (let i = 0; i < namespace.length; i++) {
              hash = (hash << 5) - hash + namespace.charCodeAt(i);
              hash |= 0;
            }
            return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
          }
          createDebug.selectColor = selectColor;
          function createDebug(namespace) {
            let prevTime;
            let enableOverride = null;
            let namespacesCache;
            let enabledCache;
            function debug3(...args) {
              if (!debug3.enabled) {
                return;
              }
              const self2 = debug3;
              const curr = Number(/* @__PURE__ */ new Date());
              const ms = curr - (prevTime || curr);
              self2.diff = ms;
              self2.prev = prevTime;
              self2.curr = curr;
              prevTime = curr;
              args[0] = createDebug.coerce(args[0]);
              if (typeof args[0] !== "string") {
                args.unshift("%O");
              }
              let index2 = 0;
              args[0] = args[0].replace(/%([a-zA-Z%])/g, (match6, format11) => {
                if (match6 === "%%") {
                  return "%";
                }
                index2++;
                const formatter = createDebug.formatters[format11];
                if (typeof formatter === "function") {
                  const val = args[index2];
                  match6 = formatter.call(self2, val);
                  args.splice(index2, 1);
                  index2--;
                }
                return match6;
              });
              createDebug.formatArgs.call(self2, args);
              const logFn = self2.log || createDebug.log;
              logFn.apply(self2, args);
            }
            debug3.namespace = namespace;
            debug3.useColors = createDebug.useColors();
            debug3.color = createDebug.selectColor(namespace);
            debug3.extend = extend2;
            debug3.destroy = createDebug.destroy;
            Object.defineProperty(debug3, "enabled", {
              enumerable: true,
              configurable: false,
              get: () => {
                if (enableOverride !== null) {
                  return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                  namespacesCache = createDebug.namespaces;
                  enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
              },
              set: (v) => {
                enableOverride = v;
              }
            });
            if (typeof createDebug.init === "function") {
              createDebug.init(debug3);
            }
            return debug3;
          }
          function extend2(namespace, delimiter) {
            const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
            newDebug.log = this.log;
            return newDebug;
          }
          function enable(namespaces) {
            createDebug.save(namespaces);
            createDebug.namespaces = namespaces;
            createDebug.names = [];
            createDebug.skips = [];
            let i;
            const split3 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
            const len = split3.length;
            for (i = 0; i < len; i++) {
              if (!split3[i]) {
                continue;
              }
              namespaces = split3[i].replace(/\*/g, ".*?");
              if (namespaces[0] === "-") {
                createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
              } else {
                createDebug.names.push(new RegExp("^" + namespaces + "$"));
              }
            }
          }
          function disable() {
            const namespaces = [
              ...createDebug.names.map(toNamespace),
              ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
            ].join(",");
            createDebug.enable("");
            return namespaces;
          }
          function enabled(name82) {
            if (name82[name82.length - 1] === "*") {
              return true;
            }
            let i;
            let len;
            for (i = 0, len = createDebug.skips.length; i < len; i++) {
              if (createDebug.skips[i].test(name82)) {
                return false;
              }
            }
            for (i = 0, len = createDebug.names.length; i < len; i++) {
              if (createDebug.names[i].test(name82)) {
                return true;
              }
            }
            return false;
          }
          function toNamespace(regexp) {
            return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          function coerce22(val) {
            if (val instanceof Error) {
              return val.stack || val.message;
            }
            return val;
          }
          function destroy() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
          createDebug.enable(createDebug.load());
          return createDebug;
        }
        module2.exports = setup;
      }
    });
    require_browser = __commonJS2({
      "../../node_modules/.pnpm/debug@4.3.6/node_modules/debug/src/browser.js"(exports2, module2) {
        exports2.formatArgs = formatArgs;
        exports2.save = save;
        exports2.load = load;
        exports2.useColors = useColors;
        exports2.storage = localstorage();
        exports2.destroy = /* @__PURE__ */ (() => {
          let warned = false;
          return () => {
            if (!warned) {
              warned = true;
              console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
            }
          };
        })();
        exports2.colors = [
          "#0000CC",
          "#0000FF",
          "#0033CC",
          "#0033FF",
          "#0066CC",
          "#0066FF",
          "#0099CC",
          "#0099FF",
          "#00CC00",
          "#00CC33",
          "#00CC66",
          "#00CC99",
          "#00CCCC",
          "#00CCFF",
          "#3300CC",
          "#3300FF",
          "#3333CC",
          "#3333FF",
          "#3366CC",
          "#3366FF",
          "#3399CC",
          "#3399FF",
          "#33CC00",
          "#33CC33",
          "#33CC66",
          "#33CC99",
          "#33CCCC",
          "#33CCFF",
          "#6600CC",
          "#6600FF",
          "#6633CC",
          "#6633FF",
          "#66CC00",
          "#66CC33",
          "#9900CC",
          "#9900FF",
          "#9933CC",
          "#9933FF",
          "#99CC00",
          "#99CC33",
          "#CC0000",
          "#CC0033",
          "#CC0066",
          "#CC0099",
          "#CC00CC",
          "#CC00FF",
          "#CC3300",
          "#CC3333",
          "#CC3366",
          "#CC3399",
          "#CC33CC",
          "#CC33FF",
          "#CC6600",
          "#CC6633",
          "#CC9900",
          "#CC9933",
          "#CCCC00",
          "#CCCC33",
          "#FF0000",
          "#FF0033",
          "#FF0066",
          "#FF0099",
          "#FF00CC",
          "#FF00FF",
          "#FF3300",
          "#FF3333",
          "#FF3366",
          "#FF3399",
          "#FF33CC",
          "#FF33FF",
          "#FF6600",
          "#FF6633",
          "#FF9900",
          "#FF9933",
          "#FFCC00",
          "#FFCC33"
        ];
        function useColors() {
          if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
            return true;
          }
          if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
            return false;
          }
          let m;
          return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
          typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
          // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
          typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
          typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        function formatArgs(args) {
          args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
          if (!this.useColors) {
            return;
          }
          const c = "color: " + this.color;
          args.splice(1, 0, c, "color: inherit");
          let index2 = 0;
          let lastC = 0;
          args[0].replace(/%[a-zA-Z%]/g, (match6) => {
            if (match6 === "%%") {
              return;
            }
            index2++;
            if (match6 === "%c") {
              lastC = index2;
            }
          });
          args.splice(lastC, 0, c);
        }
        exports2.log = console.debug || console.log || (() => {
        });
        function save(namespaces) {
          try {
            if (namespaces) {
              exports2.storage.setItem("debug", namespaces);
            } else {
              exports2.storage.removeItem("debug");
            }
          } catch (error3) {
          }
        }
        function load() {
          let r;
          try {
            r = exports2.storage.getItem("debug");
          } catch (error3) {
          }
          if (!r && typeof process !== "undefined" && "env" in process) {
            r = process.env.DEBUG;
          }
          return r;
        }
        function localstorage() {
          try {
            return localStorage;
          } catch (error3) {
          }
        }
        module2.exports = require_common()(exports2);
        var { formatters } = module2.exports;
        formatters.j = function(v) {
          try {
            return JSON.stringify(v);
          } catch (error3) {
            return "[UnexpectedJSONParseError]: " + error3.message;
          }
        };
      }
    });
    require_error = __commonJS2({
      "../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/http/error.js"(exports2) {
        "use strict";
        var TimeoutError = class extends Error {
          constructor(message2 = "Request timed out") {
            super(message2);
            this.name = "TimeoutError";
          }
        };
        exports2.TimeoutError = TimeoutError;
        var AbortError2 = class extends Error {
          constructor(message2 = "The operation was aborted.") {
            super(message2);
            this.name = "AbortError";
          }
        };
        exports2.AbortError = AbortError2;
        var HTTPError22 = class extends Error {
          /**
           * @param {Response} response
           */
          constructor(response) {
            super(response.statusText);
            this.name = "HTTPError";
            this.response = response;
          }
        };
        exports2.HTTPError = HTTPError22;
      }
    });
    require_browser2 = __commonJS2({
      "../../node_modules/.pnpm/node-fetch@2.7.0/node_modules/node-fetch/browser.js"(exports2, module2) {
        "use strict";
        var getGlobal = function() {
          if (typeof self !== "undefined") {
            return self;
          }
          if (typeof window !== "undefined") {
            return window;
          }
          if (typeof global !== "undefined") {
            return global;
          }
          throw new Error("unable to locate global object");
        };
        var globalObject = getGlobal();
        module2.exports = exports2 = globalObject.fetch;
        if (globalObject.fetch) {
          exports2.default = globalObject.fetch.bind(globalObject);
        }
        exports2.Headers = globalObject.Headers;
        exports2.Request = globalObject.Request;
        exports2.Response = globalObject.Response;
      }
    });
    require_src2 = __commonJS2({
      "../../node_modules/.pnpm/native-fetch@3.0.0_node-fetch@2.7.0/node_modules/native-fetch/src/index.js"(exports2, module2) {
        "use strict";
        if (globalThis.fetch && globalThis.Headers && globalThis.Request && globalThis.Response) {
          module2.exports = {
            default: globalThis.fetch,
            Headers: globalThis.Headers,
            Request: globalThis.Request,
            Response: globalThis.Response
          };
        } else {
          module2.exports = {
            default: require_browser2().default,
            Headers: require_browser2().Headers,
            Request: require_browser2().Request,
            Response: require_browser2().Response
          };
        }
      }
    });
    require_fetch_browser = __commonJS2({
      "../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/fetch.browser.js"(exports2, module2) {
        "use strict";
        module2.exports = require_src2();
      }
    });
    require_fetch_browser2 = __commonJS2({
      "../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/http/fetch.browser.js"(exports2, module2) {
        "use strict";
        var { TimeoutError, AbortError: AbortError2 } = require_error();
        var { Response: Response2, Request: Request2, Headers: Headers2, default: fetch3 } = require_fetch_browser();
        var fetchWithProgress = (url2, options = {}) => {
          const request = new XMLHttpRequest();
          request.open(options.method || "GET", url2.toString(), true);
          const { timeout, headers } = options;
          if (timeout && timeout > 0 && timeout < Infinity) {
            request.timeout = timeout;
          }
          if (options.overrideMimeType != null) {
            request.overrideMimeType(options.overrideMimeType);
          }
          if (headers) {
            for (const [name82, value] of new Headers2(headers)) {
              request.setRequestHeader(name82, value);
            }
          }
          if (options.signal) {
            options.signal.onabort = () => request.abort();
          }
          if (options.onUploadProgress) {
            request.upload.onprogress = options.onUploadProgress;
          }
          request.responseType = "arraybuffer";
          return new Promise((resolve2, reject) => {
            const handleEvent = (event) => {
              switch (event.type) {
                case "error": {
                  resolve2(Response2.error());
                  break;
                }
                case "load": {
                  resolve2(
                    new ResponseWithURL(request.responseURL, request.response, {
                      status: request.status,
                      statusText: request.statusText,
                      headers: parseHeaders(request.getAllResponseHeaders())
                    })
                  );
                  break;
                }
                case "timeout": {
                  reject(new TimeoutError());
                  break;
                }
                case "abort": {
                  reject(new AbortError2());
                  break;
                }
                default: {
                  break;
                }
              }
            };
            request.onerror = handleEvent;
            request.onload = handleEvent;
            request.ontimeout = handleEvent;
            request.onabort = handleEvent;
            request.send(options.body);
          });
        };
        var fetchWithStreaming = fetch3;
        var fetchWith = (url2, options = {}) => options.onUploadProgress != null ? fetchWithProgress(url2, options) : fetchWithStreaming(url2, options);
        var parseHeaders = (input10) => {
          const headers = new Headers2();
          for (const line of input10.trim().split(/[\r\n]+/)) {
            const index2 = line.indexOf(": ");
            if (index2 > 0) {
              headers.set(line.slice(0, index2), line.slice(index2 + 1));
            }
          }
          return headers;
        };
        var ResponseWithURL = class extends Response2 {
          /**
           * @param {string} url
           * @param {BodyInit} body
           * @param {ResponseInit} options
           */
          constructor(url2, body, options) {
            super(body, options);
            Object.defineProperty(this, "url", { value: url2 });
          }
        };
        module2.exports = {
          fetch: fetchWith,
          Request: Request2,
          Headers: Headers2
        };
      }
    });
    require_is_plain_obj = __commonJS2({
      "../../node_modules/.pnpm/is-plain-obj@2.1.0/node_modules/is-plain-obj/index.js"(exports2, module2) {
        "use strict";
        module2.exports = (value) => {
          if (Object.prototype.toString.call(value) !== "[object Object]") {
            return false;
          }
          const prototype3 = Object.getPrototypeOf(value);
          return prototype3 === null || prototype3 === Object.prototype;
        };
      }
    });
    require_merge_options = __commonJS2({
      "../../node_modules/.pnpm/merge-options@3.0.4/node_modules/merge-options/index.js"(exports2, module2) {
        "use strict";
        var isOptionObject = require_is_plain_obj();
        var { hasOwnProperty: hasOwnProperty3 } = Object.prototype;
        var { propertyIsEnumerable } = Object;
        var defineProperty = (object, name82, value) => Object.defineProperty(object, name82, {
          value,
          writable: true,
          enumerable: true,
          configurable: true
        });
        var globalThis2 = exports2;
        var defaultMergeOptions = {
          concatArrays: false,
          ignoreUndefined: false
        };
        var getEnumerableOwnPropertyKeys = (value) => {
          const keys2 = [];
          for (const key in value) {
            if (hasOwnProperty3.call(value, key)) {
              keys2.push(key);
            }
          }
          if (Object.getOwnPropertySymbols) {
            const symbols = Object.getOwnPropertySymbols(value);
            for (const symbol2 of symbols) {
              if (propertyIsEnumerable.call(value, symbol2)) {
                keys2.push(symbol2);
              }
            }
          }
          return keys2;
        };
        function clone4(value) {
          if (Array.isArray(value)) {
            return cloneArray(value);
          }
          if (isOptionObject(value)) {
            return cloneOptionObject(value);
          }
          return value;
        }
        function cloneArray(array2) {
          const result = array2.slice(0, 0);
          getEnumerableOwnPropertyKeys(array2).forEach((key) => {
            defineProperty(result, key, clone4(array2[key]));
          });
          return result;
        }
        function cloneOptionObject(object) {
          const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
          getEnumerableOwnPropertyKeys(object).forEach((key) => {
            defineProperty(result, key, clone4(object[key]));
          });
          return result;
        }
        var mergeKeys = (merged, source, keys2, config2) => {
          keys2.forEach((key) => {
            if (typeof source[key] === "undefined" && config2.ignoreUndefined) {
              return;
            }
            if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
              defineProperty(merged, key, merge22(merged[key], source[key], config2));
            } else {
              defineProperty(merged, key, clone4(source[key]));
            }
          });
          return merged;
        };
        var concatArrays = (merged, source, config2) => {
          let result = merged.slice(0, 0);
          let resultIndex = 0;
          [merged, source].forEach((array2) => {
            const indices = [];
            for (let k = 0; k < array2.length; k++) {
              if (!hasOwnProperty3.call(array2, k)) {
                continue;
              }
              indices.push(String(k));
              if (array2 === merged) {
                defineProperty(result, resultIndex++, array2[k]);
              } else {
                defineProperty(result, resultIndex++, clone4(array2[k]));
              }
            }
            result = mergeKeys(result, array2, getEnumerableOwnPropertyKeys(array2).filter((key) => !indices.includes(key)), config2);
          });
          return result;
        };
        function merge22(merged, source, config2) {
          if (config2.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
            return concatArrays(merged, source, config2);
          }
          if (!isOptionObject(source) || !isOptionObject(merged)) {
            return clone4(source);
          }
          return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config2);
        }
        module2.exports = function(...options) {
          const config2 = merge22(clone4(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
          let merged = { _: {} };
          for (const option of options) {
            if (option === void 0) {
              continue;
            }
            if (!isOptionObject(option)) {
              throw new TypeError("`" + option + "` is not an Option Object");
            }
            merged = merge22(merged, { _: option }, config2);
          }
          return merged._;
        };
      }
    });
    require_url_browser = __commonJS2({
      "../../node_modules/.pnpm/iso-url@1.2.1/node_modules/iso-url/src/url-browser.js"(exports2, module2) {
        "use strict";
        var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
        function getDefaultBase() {
          if (isReactNative) {
            return "http://localhost";
          }
          if (!self.location) {
            return "";
          }
          return self.location.protocol + "//" + self.location.host;
        }
        var URL2 = self.URL;
        var defaultBase = getDefaultBase();
        var URLWithLegacySupport = class {
          constructor(url2 = "", base33 = defaultBase) {
            this.super = new URL2(url2, base33);
            this.path = this.pathname + this.search;
            this.auth = this.username && this.password ? this.username + ":" + this.password : null;
            this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
          }
          get hash() {
            return this.super.hash;
          }
          get host() {
            return this.super.host;
          }
          get hostname() {
            return this.super.hostname;
          }
          get href() {
            return this.super.href;
          }
          get origin() {
            return this.super.origin;
          }
          get password() {
            return this.super.password;
          }
          get pathname() {
            return this.super.pathname;
          }
          get port() {
            return this.super.port;
          }
          get protocol() {
            return this.super.protocol;
          }
          get search() {
            return this.super.search;
          }
          get searchParams() {
            return this.super.searchParams;
          }
          get username() {
            return this.super.username;
          }
          set hash(hash) {
            this.super.hash = hash;
          }
          set host(host) {
            this.super.host = host;
          }
          set hostname(hostname) {
            this.super.hostname = hostname;
          }
          set href(href) {
            this.super.href = href;
          }
          set password(password) {
            this.super.password = password;
          }
          set pathname(pathname) {
            this.super.pathname = pathname;
          }
          set port(port) {
            this.super.port = port;
          }
          set protocol(protocol) {
            this.super.protocol = protocol;
          }
          set search(search) {
            this.super.search = search;
          }
          set username(username) {
            this.super.username = username;
          }
          /**
           * @param {any} o
           */
          static createObjectURL(o) {
            return URL2.createObjectURL(o);
          }
          /**
           * @param {string} o
           */
          static revokeObjectURL(o) {
            URL2.revokeObjectURL(o);
          }
          toJSON() {
            return this.super.toJSON();
          }
          toString() {
            return this.super.toString();
          }
          format() {
            return this.toString();
          }
        };
        function format11(obj) {
          if (typeof obj === "string") {
            const url2 = new URL2(obj);
            return url2.toString();
          }
          if (!(obj instanceof URL2)) {
            const userPass = (
              // @ts-ignore its not supported in node but we normalise
              obj.username && obj.password ? `${obj.username}:${obj.password}@` : ""
            );
            const auth = obj.auth ? obj.auth + "@" : "";
            const port = obj.port ? ":" + obj.port : "";
            const protocol = obj.protocol ? obj.protocol + "//" : "";
            const host = obj.host || "";
            const hostname = obj.hostname || "";
            const search = obj.search || (obj.query ? "?" + obj.query : "");
            const hash = obj.hash || "";
            const pathname = obj.pathname || "";
            const path = obj.path || pathname + search;
            return `${protocol}${userPass || auth}${host || hostname + port}${path}${hash}`;
          }
        }
        module2.exports = {
          URLWithLegacySupport,
          URLSearchParams: self.URLSearchParams,
          defaultBase,
          format: format11
        };
      }
    });
    require_relative = __commonJS2({
      "../../node_modules/.pnpm/iso-url@1.2.1/node_modules/iso-url/src/relative.js"(exports2, module2) {
        "use strict";
        var { URLWithLegacySupport, format: format11 } = require_url_browser();
        module2.exports = (url2, location2 = {}, protocolMap = {}, defaultProtocol) => {
          let protocol = location2.protocol ? location2.protocol.replace(":", "") : "http";
          protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
          let urlParsed;
          try {
            urlParsed = new URLWithLegacySupport(url2);
          } catch (err) {
            urlParsed = {};
          }
          const base33 = Object.assign({}, location2, {
            protocol: protocol || urlParsed.protocol,
            host: location2.host || urlParsed.host
          });
          return new URLWithLegacySupport(url2, format11(base33)).toString();
        };
      }
    });
    require_iso_url = __commonJS2({
      "../../node_modules/.pnpm/iso-url@1.2.1/node_modules/iso-url/index.js"(exports2, module2) {
        "use strict";
        var {
          URLWithLegacySupport,
          format: format11,
          URLSearchParams: URLSearchParams2,
          defaultBase
        } = require_url_browser();
        var relative = require_relative();
        module2.exports = {
          URL: URLWithLegacySupport,
          URLSearchParams: URLSearchParams2,
          format: format11,
          relative,
          defaultBase
        };
      }
    });
    require_any_signal = __commonJS2({
      "../../node_modules/.pnpm/any-signal@3.0.1/node_modules/any-signal/index.js"(exports2, module2) {
        function anySignal2(signals) {
          const controller = new globalThis.AbortController();
          function onAbort() {
            controller.abort();
            for (const signal of signals) {
              if (!signal || !signal.removeEventListener) continue;
              signal.removeEventListener("abort", onAbort);
            }
          }
          for (const signal of signals) {
            if (!signal || !signal.addEventListener) continue;
            if (signal.aborted) {
              onAbort();
              break;
            }
            signal.addEventListener("abort", onAbort);
          }
          return controller.signal;
        }
        module2.exports = anySignal2;
        module2.exports.anySignal = anySignal2;
      }
    });
    require_browser_readablestream_to_it = __commonJS2({
      "../../node_modules/.pnpm/browser-readablestream-to-it@1.0.3/node_modules/browser-readablestream-to-it/index.js"(exports2, module2) {
        "use strict";
        async function* browserReadableStreamToIt(stream4, options = {}) {
          const reader = stream4.getReader();
          try {
            while (true) {
              const result = await reader.read();
              if (result.done) {
                return;
              }
              yield result.value;
            }
          } finally {
            if (options.preventCancel !== true) {
              reader.cancel();
            }
            reader.releaseLock();
          }
        }
        module2.exports = browserReadableStreamToIt;
      }
    });
    require_it_all = __commonJS2({
      "../../node_modules/.pnpm/it-all@1.0.6/node_modules/it-all/index.js"(exports2, module2) {
        "use strict";
        var all22 = async (source) => {
          const arr = [];
          for await (const entry of source) {
            arr.push(entry);
          }
          return arr;
        };
        module2.exports = all22;
      }
    });
    require_http = __commonJS2({
      "../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/http.js"(exports2, module2) {
        "use strict";
        var { fetch: fetch3, Request: Request2, Headers: Headers2 } = require_fetch_browser2();
        var { TimeoutError, HTTPError: HTTPError22 } = require_error();
        var merge22 = require_merge_options().bind({ ignoreUndefined: true });
        var { URL: URL2, URLSearchParams: URLSearchParams2 } = require_iso_url();
        var anySignal2 = require_any_signal();
        var browserReableStreamToIt = require_browser_readablestream_to_it();
        var { isBrowser: isBrowser2, isWebWorker: isWebWorker2 } = require_env();
        var all22 = require_it_all();
        var timeout = (promise, ms, abortController) => {
          if (ms === void 0) {
            return promise;
          }
          const start = Date.now();
          const timedOut = () => {
            const time = Date.now() - start;
            return time >= ms;
          };
          return new Promise((resolve2, reject) => {
            const timeoutID = setTimeout(() => {
              if (timedOut()) {
                reject(new TimeoutError());
                abortController.abort();
              }
            }, ms);
            const after = (next) => {
              const fn = (res) => {
                clearTimeout(timeoutID);
                if (timedOut()) {
                  reject(new TimeoutError());
                  return;
                }
                next(res);
              };
              return fn;
            };
            promise.then(after(resolve2), after(reject));
          });
        };
        var defaults6 = {
          throwHttpErrors: true,
          credentials: "same-origin"
        };
        var HTTP3 = class {
          /**
           *
           * @param {HTTPOptions} options
           */
          constructor(options = {}) {
            this.opts = merge22(defaults6, options);
          }
          /**
           * Fetch
           *
           * @param {string | Request} resource
           * @param {HTTPOptions} options
           * @returns {Promise<ExtendedResponse>}
           */
          async fetch(resource, options = {}) {
            const opts = merge22(this.opts, options);
            const headers = new Headers2(opts.headers);
            if (typeof resource !== "string" && !(resource instanceof URL2 || resource instanceof Request2)) {
              throw new TypeError("`resource` must be a string, URL, or Request");
            }
            const url2 = new URL2(resource.toString(), opts.base);
            const {
              searchParams,
              transformSearchParams,
              json
            } = opts;
            if (searchParams) {
              if (typeof transformSearchParams === "function") {
                url2.search = transformSearchParams(new URLSearchParams2(opts.searchParams));
              } else {
                url2.search = new URLSearchParams2(opts.searchParams);
              }
            }
            if (json) {
              opts.body = JSON.stringify(opts.json);
              headers.set("content-type", "application/json");
            }
            const abortController = new AbortController();
            const signal = anySignal2([abortController.signal, opts.signal]);
            if (globalThis.ReadableStream != null && opts.body instanceof globalThis.ReadableStream && (isBrowser2 || isWebWorker2)) {
              opts.body = new Blob(await all22(browserReableStreamToIt(opts.body)));
            }
            const response = await timeout(
              fetch3(
                url2.toString(),
                {
                  ...opts,
                  signal,
                  // @ts-expect-error non-browser fetch implementations may take extra options
                  timeout: void 0,
                  headers,
                  // https://fetch.spec.whatwg.org/#dom-requestinit-duplex
                  // https://github.com/whatwg/fetch/issues/1254
                  duplex: "half"
                }
              ),
              opts.timeout,
              abortController
            );
            if (!response.ok && opts.throwHttpErrors) {
              if (opts.handleError) {
                await opts.handleError(response);
              }
              throw new HTTPError22(response);
            }
            response.iterator = async function* () {
              yield* fromStream(response.body);
            };
            response.ndjson = async function* () {
              for await (const chunk of ndjson(response.iterator())) {
                if (options.transform) {
                  yield options.transform(chunk);
                } else {
                  yield chunk;
                }
              }
            };
            return response;
          }
          /**
           * @param {string | Request} resource
           * @param {HTTPOptions} options
           */
          post(resource, options = {}) {
            return this.fetch(resource, { ...options, method: "POST" });
          }
          /**
           * @param {string | Request} resource
           * @param {HTTPOptions} options
           */
          get(resource, options = {}) {
            return this.fetch(resource, { ...options, method: "GET" });
          }
          /**
           * @param {string | Request} resource
           * @param {HTTPOptions} options
           */
          put(resource, options = {}) {
            return this.fetch(resource, { ...options, method: "PUT" });
          }
          /**
           * @param {string | Request} resource
           * @param {HTTPOptions} options
           */
          delete(resource, options = {}) {
            return this.fetch(resource, { ...options, method: "DELETE" });
          }
          /**
           * @param {string | Request} resource
           * @param {HTTPOptions} options
           */
          options(resource, options = {}) {
            return this.fetch(resource, { ...options, method: "OPTIONS" });
          }
        };
        var ndjson = async function* (source) {
          const decoder4 = new TextDecoder();
          let buf22 = "";
          for await (const chunk of source) {
            buf22 += decoder4.decode(chunk, { stream: true });
            const lines = buf22.split(/\r?\n/);
            for (let i = 0; i < lines.length - 1; i++) {
              const l2 = lines[i].trim();
              if (l2.length > 0) {
                yield JSON.parse(l2);
              }
            }
            buf22 = lines[lines.length - 1];
          }
          buf22 += decoder4.decode();
          buf22 = buf22.trim();
          if (buf22.length !== 0) {
            yield JSON.parse(buf22);
          }
        };
        var fromStream = (source) => {
          if (isAsyncIterable(source)) {
            return source;
          }
          if (isNodeReadableStream(source)) {
            const iter = source[Symbol.asyncIterator]();
            return {
              [Symbol.asyncIterator]() {
                return {
                  next: iter.next.bind(iter),
                  return(value) {
                    source.destroy();
                    if (typeof iter.return === "function") {
                      return iter.return();
                    }
                    return Promise.resolve({ done: true, value });
                  }
                };
              }
            };
          }
          if (isWebReadableStream(source)) {
            const reader = source.getReader();
            return async function* () {
              try {
                while (true) {
                  const { done, value } = await reader.read();
                  if (done) return;
                  if (value) {
                    yield value;
                  }
                }
              } finally {
                reader.releaseLock();
              }
            }();
          }
          throw new TypeError("Body can't be converted to AsyncIterable");
        };
        var isAsyncIterable = (value) => {
          return typeof value === "object" && value !== null && typeof /** @type {any} */
          value[Symbol.asyncIterator] === "function";
        };
        var isWebReadableStream = (value) => {
          return value && typeof /** @type {any} */
          value.getReader === "function";
        };
        var isNodeReadableStream = (value) => Object.prototype.hasOwnProperty.call(value, "readable") && Object.prototype.hasOwnProperty.call(value, "writable");
        HTTP3.HTTPError = HTTPError22;
        HTTP3.TimeoutError = TimeoutError;
        HTTP3.streamToAsyncIterator = fromStream;
        HTTP3.post = (resource, options) => new HTTP3(options).post(resource, options);
        HTTP3.get = (resource, options) => new HTTP3(options).get(resource, options);
        HTTP3.put = (resource, options) => new HTTP3(options).put(resource, options);
        HTTP3.delete = (resource, options) => new HTTP3(options).delete(resource, options);
        HTTP3.options = (resource, options) => new HTTP3(options).options(resource, options);
        module2.exports = HTTP3;
      }
    });
    require_multiaddr_to_uri = __commonJS2({
      "../../node_modules/.pnpm/multiaddr-to-uri@8.0.0/node_modules/multiaddr-to-uri/index.js"(exports2, module2) {
        var { Multiaddr: Multiaddr14 } = require_src();
        var reduceValue = (_, v) => v;
        var tcpUri = (str, port, parts, opts) => {
          if (opts && opts.assumeHttp === false) return `tcp://${str}:${port}`;
          let protocol = "tcp";
          let explicitPort = `:${port}`;
          const last5 = parts[parts.length - 1];
          if (last5.protocol === "tcp") {
            protocol = port === "443" ? "https" : "http";
            explicitPort = port === "443" || port === "80" ? "" : explicitPort;
          }
          return `${protocol}://${str}${explicitPort}`;
        };
        var Reducers = {
          ip4: reduceValue,
          ip6: (str, content2, i, parts) => parts.length === 1 && parts[0].protocol === "ip6" ? content2 : `[${content2}]`,
          tcp: (str, content2, i, parts, opts) => parts.some((p) => ["http", "https", "ws", "wss"].includes(p.protocol)) ? `${str}:${content2}` : tcpUri(str, content2, parts, opts),
          udp: (str, content2) => `udp://${str}:${content2}`,
          dnsaddr: reduceValue,
          dns4: reduceValue,
          dns6: reduceValue,
          ipfs: (str, content2) => `${str}/ipfs/${content2}`,
          p2p: (str, content2) => `${str}/p2p/${content2}`,
          http: (str) => `http://${str}`,
          https: (str) => `https://${str}`,
          ws: (str) => `ws://${str}`,
          wss: (str) => `wss://${str}`,
          "p2p-websocket-star": (str) => `${str}/p2p-websocket-star`,
          "p2p-webrtc-star": (str) => `${str}/p2p-webrtc-star`,
          "p2p-webrtc-direct": (str) => `${str}/p2p-webrtc-direct`
        };
        module2.exports = (multiaddr, opts) => {
          const ma = new Multiaddr14(multiaddr);
          const parts = multiaddr.toString().split("/").slice(1);
          return ma.tuples().map((tuple2) => ({
            protocol: parts.shift(),
            content: tuple2[1] ? parts.shift() : null
          })).reduce((str, part, i, parts2) => {
            const reduce = Reducers[part.protocol];
            if (!reduce) throw new Error(`Unsupported protocol ${part.protocol}`);
            return reduce(str, part.content, i, parts2, opts);
          }, "");
        };
      }
    });
    require_it_peekable = __commonJS2({
      "../../node_modules/.pnpm/it-peekable@1.0.3/node_modules/it-peekable/index.js"(exports2, module2) {
        "use strict";
        function peekableIterator(iterable) {
          const [iterator, symbol2] = iterable[Symbol.asyncIterator] ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
          const queue = [];
          return {
            peek: () => {
              return iterator.next();
            },
            push: (value) => {
              queue.push(value);
            },
            next: () => {
              if (queue.length) {
                return {
                  done: false,
                  value: queue.shift()
                };
              }
              return iterator.next();
            },
            [symbol2]() {
              return this;
            }
          };
        }
        module2.exports = peekableIterator;
      }
    });
    require_it_map = __commonJS2({
      "../../node_modules/.pnpm/it-map@1.0.6/node_modules/it-map/index.js"(exports2, module2) {
        "use strict";
        var map2 = async function* (source, func) {
          for await (const val of source) {
            yield func(val);
          }
        };
        module2.exports = map2;
      }
    });
    require_longbits2 = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
        "use strict";
        module2.exports = LongBits;
        var util2 = require_minimal3();
        function LongBits(lo, hi) {
          this.lo = lo >>> 0;
          this.hi = hi >>> 0;
        }
        var zero = LongBits.zero = new LongBits(0, 0);
        zero.toNumber = function() {
          return 0;
        };
        zero.zzEncode = zero.zzDecode = function() {
          return this;
        };
        zero.length = function() {
          return 1;
        };
        var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
        LongBits.fromNumber = function fromNumber(value) {
          if (value === 0)
            return zero;
          var sign3 = value < 0;
          if (sign3)
            value = -value;
          var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
          if (sign3) {
            hi = ~hi >>> 0;
            lo = ~lo >>> 0;
            if (++lo > 4294967295) {
              lo = 0;
              if (++hi > 4294967295)
                hi = 0;
            }
          }
          return new LongBits(lo, hi);
        };
        LongBits.from = function from32(value) {
          if (typeof value === "number")
            return LongBits.fromNumber(value);
          if (util2.isString(value)) {
            if (util2.Long)
              value = util2.Long.fromString(value);
            else
              return LongBits.fromNumber(parseInt(value, 10));
          }
          return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
        };
        LongBits.prototype.toNumber = function toNumber(unsigned) {
          if (!unsigned && this.hi >>> 31) {
            var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
            if (!lo)
              hi = hi + 1 >>> 0;
            return -(lo + hi * 4294967296);
          }
          return this.lo + this.hi * 4294967296;
        };
        LongBits.prototype.toLong = function toLong(unsigned) {
          return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
        };
        var charCodeAt = String.prototype.charCodeAt;
        LongBits.fromHash = function fromHash(hash) {
          if (hash === zeroHash)
            return zero;
          return new LongBits(
            (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
            (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
          );
        };
        LongBits.prototype.toHash = function toHash() {
          return String.fromCharCode(
            this.lo & 255,
            this.lo >>> 8 & 255,
            this.lo >>> 16 & 255,
            this.lo >>> 24,
            this.hi & 255,
            this.hi >>> 8 & 255,
            this.hi >>> 16 & 255,
            this.hi >>> 24
          );
        };
        LongBits.prototype.zzEncode = function zzEncode() {
          var mask2 = this.hi >> 31;
          this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask2) >>> 0;
          this.lo = (this.lo << 1 ^ mask2) >>> 0;
          return this;
        };
        LongBits.prototype.zzDecode = function zzDecode() {
          var mask2 = -(this.lo & 1);
          this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask2) >>> 0;
          this.hi = (this.hi >>> 1 ^ mask2) >>> 0;
          return this;
        };
        LongBits.prototype.length = function length22() {
          var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
          return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
        };
      }
    });
    require_minimal3 = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/util/minimal.js"(exports2) {
        "use strict";
        var util2 = exports2;
        util2.asPromise = require_aspromise();
        util2.base64 = require_base64();
        util2.EventEmitter = require_eventemitter();
        util2.float = require_float();
        util2.inquire = require_inquire();
        util2.utf8 = require_utf8();
        util2.pool = require_pool();
        util2.LongBits = require_longbits2();
        util2.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
        util2.global = util2.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
        util2.emptyArray = Object.freeze ? Object.freeze([]) : (
          /* istanbul ignore next */
          []
        );
        util2.emptyObject = Object.freeze ? Object.freeze({}) : (
          /* istanbul ignore next */
          {}
        );
        util2.isInteger = Number.isInteger || /* istanbul ignore next */
        function isInteger2(value) {
          return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
        };
        util2.isString = function isString3(value) {
          return typeof value === "string" || value instanceof String;
        };
        util2.isObject = function isObject3(value) {
          return value && typeof value === "object";
        };
        util2.isset = /**
        * Checks if a property on a message is considered to be present.
        * @param {Object} obj Plain object or message instance
        * @param {string} prop Property name
        * @returns {boolean} `true` if considered to be present, otherwise `false`
        */
        util2.isSet = function isSet(obj, prop) {
          var value = obj[prop];
          if (value != null && obj.hasOwnProperty(prop))
            return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
          return false;
        };
        util2.Buffer = function() {
          try {
            var Buffer2 = util2.inquire("buffer").Buffer;
            return Buffer2.prototype.utf8Write ? Buffer2 : (
              /* istanbul ignore next */
              null
            );
          } catch (e) {
            return null;
          }
        }();
        util2._Buffer_from = null;
        util2._Buffer_allocUnsafe = null;
        util2.newBuffer = function newBuffer(sizeOrArray) {
          return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
        };
        util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        util2.Long = /* istanbul ignore next */
        util2.global.dcodeIO && /* istanbul ignore next */
        util2.global.dcodeIO.Long || /* istanbul ignore next */
        util2.global.Long || util2.inquire("long");
        util2.key2Re = /^true|false|0|1$/;
        util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
        util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
        util2.longToHash = function longToHash(value) {
          return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;
        };
        util2.longFromHash = function longFromHash(hash, unsigned) {
          var bits = util2.LongBits.fromHash(hash);
          if (util2.Long)
            return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
          return bits.toNumber(Boolean(unsigned));
        };
        function merge22(dst, src22, ifNotSet) {
          for (var keys2 = Object.keys(src22), i = 0; i < keys2.length; ++i)
            if (dst[keys2[i]] === void 0 || !ifNotSet)
              dst[keys2[i]] = src22[keys2[i]];
          return dst;
        }
        util2.merge = merge22;
        util2.lcFirst = function lcFirst(str) {
          return str.charAt(0).toLowerCase() + str.substring(1);
        };
        function newError(name82) {
          function CustomError(message2, properties) {
            if (!(this instanceof CustomError))
              return new CustomError(message2, properties);
            Object.defineProperty(this, "message", { get: function() {
              return message2;
            } });
            if (Error.captureStackTrace)
              Error.captureStackTrace(this, CustomError);
            else
              Object.defineProperty(this, "stack", { value: new Error().stack || "" });
            if (properties)
              merge22(this, properties);
          }
          (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
          Object.defineProperty(CustomError.prototype, "name", { get: function() {
            return name82;
          } });
          CustomError.prototype.toString = function toString42() {
            return this.name + ": " + this.message;
          };
          return CustomError;
        }
        util2.newError = newError;
        util2.ProtocolError = newError("ProtocolError");
        util2.oneOfGetter = function getOneOf(fieldNames) {
          var fieldMap = {};
          for (var i = 0; i < fieldNames.length; ++i)
            fieldMap[fieldNames[i]] = 1;
          return function() {
            for (var keys2 = Object.keys(this), i2 = keys2.length - 1; i2 > -1; --i2)
              if (fieldMap[keys2[i2]] === 1 && this[keys2[i2]] !== void 0 && this[keys2[i2]] !== null)
                return keys2[i2];
          };
        };
        util2.oneOfSetter = function setOneOf(fieldNames) {
          return function(name82) {
            for (var i = 0; i < fieldNames.length; ++i)
              if (fieldNames[i] !== name82)
                delete this[fieldNames[i]];
          };
        };
        util2.toJSONOptions = {
          longs: String,
          enums: String,
          bytes: String,
          json: true
        };
        util2._configure = function() {
          var Buffer2 = util2.Buffer;
          if (!Buffer2) {
            util2._Buffer_from = util2._Buffer_allocUnsafe = null;
            return;
          }
          util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
          function Buffer_from(value, encoding) {
            return new Buffer2(value, encoding);
          };
          util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
          function Buffer_allocUnsafe(size5) {
            return new Buffer2(size5);
          };
        };
      }
    });
    require_writer2 = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/writer.js"(exports2, module2) {
        "use strict";
        module2.exports = Writer2;
        var util2 = require_minimal3();
        var BufferWriter;
        var LongBits = util2.LongBits;
        var base6422 = util2.base64;
        var utf84 = util2.utf8;
        function Op(fn, len, val) {
          this.fn = fn;
          this.len = len;
          this.next = void 0;
          this.val = val;
        }
        function noop3() {
        }
        function State2(writer) {
          this.head = writer.head;
          this.tail = writer.tail;
          this.len = writer.len;
          this.next = writer.states;
        }
        function Writer2() {
          this.len = 0;
          this.head = new Op(noop3, 0, 0);
          this.tail = this.head;
          this.states = null;
        }
        var create32 = function create42() {
          return util2.Buffer ? function create_buffer_setup() {
            return (Writer2.create = function create_buffer() {
              return new BufferWriter();
            })();
          } : function create_array() {
            return new Writer2();
          };
        };
        Writer2.create = create32();
        Writer2.alloc = function alloc22(size5) {
          return new util2.Array(size5);
        };
        if (util2.Array !== Array)
          Writer2.alloc = util2.pool(Writer2.alloc, util2.Array.prototype.subarray);
        Writer2.prototype._push = function push2(fn, len, val) {
          this.tail = this.tail.next = new Op(fn, len, val);
          this.len += len;
          return this;
        };
        function writeByte(val, buf22, pos) {
          buf22[pos] = val & 255;
        }
        function writeVarint32(val, buf22, pos) {
          while (val > 127) {
            buf22[pos++] = val & 127 | 128;
            val >>>= 7;
          }
          buf22[pos] = val;
        }
        function VarintOp(len, val) {
          this.len = len;
          this.next = void 0;
          this.val = val;
        }
        VarintOp.prototype = Object.create(Op.prototype);
        VarintOp.prototype.fn = writeVarint32;
        Writer2.prototype.uint32 = function write_uint32(value) {
          this.len += (this.tail = this.tail.next = new VarintOp(
            (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
            value
          )).len;
          return this;
        };
        Writer2.prototype.int32 = function write_int32(value) {
          return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
        };
        Writer2.prototype.sint32 = function write_sint32(value) {
          return this.uint32((value << 1 ^ value >> 31) >>> 0);
        };
        function writeVarint64(val, buf22, pos) {
          while (val.hi) {
            buf22[pos++] = val.lo & 127 | 128;
            val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
            val.hi >>>= 7;
          }
          while (val.lo > 127) {
            buf22[pos++] = val.lo & 127 | 128;
            val.lo = val.lo >>> 7;
          }
          buf22[pos++] = val.lo;
        }
        Writer2.prototype.uint64 = function write_uint64(value) {
          var bits = LongBits.from(value);
          return this._push(writeVarint64, bits.length(), bits);
        };
        Writer2.prototype.int64 = Writer2.prototype.uint64;
        Writer2.prototype.sint64 = function write_sint64(value) {
          var bits = LongBits.from(value).zzEncode();
          return this._push(writeVarint64, bits.length(), bits);
        };
        Writer2.prototype.bool = function write_bool(value) {
          return this._push(writeByte, 1, value ? 1 : 0);
        };
        function writeFixed32(val, buf22, pos) {
          buf22[pos] = val & 255;
          buf22[pos + 1] = val >>> 8 & 255;
          buf22[pos + 2] = val >>> 16 & 255;
          buf22[pos + 3] = val >>> 24;
        }
        Writer2.prototype.fixed32 = function write_fixed32(value) {
          return this._push(writeFixed32, 4, value >>> 0);
        };
        Writer2.prototype.sfixed32 = Writer2.prototype.fixed32;
        Writer2.prototype.fixed64 = function write_fixed64(value) {
          var bits = LongBits.from(value);
          return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
        };
        Writer2.prototype.sfixed64 = Writer2.prototype.fixed64;
        Writer2.prototype.float = function write_float(value) {
          return this._push(util2.float.writeFloatLE, 4, value);
        };
        Writer2.prototype.double = function write_double(value) {
          return this._push(util2.float.writeDoubleLE, 8, value);
        };
        var writeBytes2 = util2.Array.prototype.set ? function writeBytes_set(val, buf22, pos) {
          buf22.set(val, pos);
        } : function writeBytes_for(val, buf22, pos) {
          for (var i = 0; i < val.length; ++i)
            buf22[pos + i] = val[i];
        };
        Writer2.prototype.bytes = function write_bytes(value) {
          var len = value.length >>> 0;
          if (!len)
            return this._push(writeByte, 1, 0);
          if (util2.isString(value)) {
            var buf22 = Writer2.alloc(len = base6422.length(value));
            base6422.decode(value, buf22, 0);
            value = buf22;
          }
          return this.uint32(len)._push(writeBytes2, len, value);
        };
        Writer2.prototype.string = function write_string(value) {
          var len = utf84.length(value);
          return len ? this.uint32(len)._push(utf84.write, len, value) : this._push(writeByte, 1, 0);
        };
        Writer2.prototype.fork = function fork5() {
          this.states = new State2(this);
          this.head = this.tail = new Op(noop3, 0, 0);
          this.len = 0;
          return this;
        };
        Writer2.prototype.reset = function reset() {
          if (this.states) {
            this.head = this.states.head;
            this.tail = this.states.tail;
            this.len = this.states.len;
            this.states = this.states.next;
          } else {
            this.head = this.tail = new Op(noop3, 0, 0);
            this.len = 0;
          }
          return this;
        };
        Writer2.prototype.ldelim = function ldelim() {
          var head = this.head, tail = this.tail, len = this.len;
          this.reset().uint32(len);
          if (len) {
            this.tail.next = head.next;
            this.tail = tail;
            this.len += len;
          }
          return this;
        };
        Writer2.prototype.finish = function finish() {
          var head = this.head.next, buf22 = this.constructor.alloc(this.len), pos = 0;
          while (head) {
            head.fn(head.val, buf22, pos);
            pos += head.len;
            head = head.next;
          }
          return buf22;
        };
        Writer2._configure = function(BufferWriter_) {
          BufferWriter = BufferWriter_;
          Writer2.create = create32();
          BufferWriter._configure();
        };
      }
    });
    require_writer_buffer2 = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
        "use strict";
        module2.exports = BufferWriter;
        var Writer2 = require_writer2();
        (BufferWriter.prototype = Object.create(Writer2.prototype)).constructor = BufferWriter;
        var util2 = require_minimal3();
        function BufferWriter() {
          Writer2.call(this);
        }
        BufferWriter._configure = function() {
          BufferWriter.alloc = util2._Buffer_allocUnsafe;
          BufferWriter.writeBytesBuffer = util2.Buffer && util2.Buffer.prototype instanceof Uint8Array && util2.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf22, pos) {
            buf22.set(val, pos);
          } : function writeBytesBuffer_copy(val, buf22, pos) {
            if (val.copy)
              val.copy(buf22, pos, 0, val.length);
            else for (var i = 0; i < val.length; )
              buf22[pos++] = val[i++];
          };
        };
        BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
          if (util2.isString(value))
            value = util2._Buffer_from(value, "base64");
          var len = value.length >>> 0;
          this.uint32(len);
          if (len)
            this._push(BufferWriter.writeBytesBuffer, len, value);
          return this;
        };
        function writeStringBuffer(val, buf22, pos) {
          if (val.length < 40)
            util2.utf8.write(val, buf22, pos);
          else if (buf22.utf8Write)
            buf22.utf8Write(val, pos);
          else
            buf22.write(val, pos);
        }
        BufferWriter.prototype.string = function write_string_buffer(value) {
          var len = util2.Buffer.byteLength(value);
          this.uint32(len);
          if (len)
            this._push(writeStringBuffer, len, value);
          return this;
        };
        BufferWriter._configure();
      }
    });
    require_reader2 = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/reader.js"(exports2, module2) {
        "use strict";
        module2.exports = Reader;
        var util2 = require_minimal3();
        var BufferReader;
        var LongBits = util2.LongBits;
        var utf84 = util2.utf8;
        function indexOutOfRange(reader, writeLength) {
          return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
        }
        function Reader(buffer22) {
          this.buf = buffer22;
          this.pos = 0;
          this.len = buffer22.length;
        }
        var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer22) {
          if (buffer22 instanceof Uint8Array || Array.isArray(buffer22))
            return new Reader(buffer22);
          throw Error("illegal buffer");
        } : function create_array2(buffer22) {
          if (Array.isArray(buffer22))
            return new Reader(buffer22);
          throw Error("illegal buffer");
        };
        var create32 = function create42() {
          return util2.Buffer ? function create_buffer_setup(buffer22) {
            return (Reader.create = function create_buffer(buffer3) {
              return util2.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
            })(buffer22);
          } : create_array;
        };
        Reader.create = create32();
        Reader.prototype._slice = util2.Array.prototype.subarray || /* istanbul ignore next */
        util2.Array.prototype.slice;
        Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
          var value = 4294967295;
          return function read_uint32() {
            value = (this.buf[this.pos] & 127) >>> 0;
            if (this.buf[this.pos++] < 128) return value;
            value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
            if (this.buf[this.pos++] < 128) return value;
            value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
            if (this.buf[this.pos++] < 128) return value;
            value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
            if (this.buf[this.pos++] < 128) return value;
            value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
            if (this.buf[this.pos++] < 128) return value;
            if ((this.pos += 5) > this.len) {
              this.pos = this.len;
              throw indexOutOfRange(this, 10);
            }
            return value;
          };
        }();
        Reader.prototype.int32 = function read_int32() {
          return this.uint32() | 0;
        };
        Reader.prototype.sint32 = function read_sint32() {
          var value = this.uint32();
          return value >>> 1 ^ -(value & 1) | 0;
        };
        function readLongVarint() {
          var bits = new LongBits(0, 0);
          var i = 0;
          if (this.len - this.pos > 4) {
            for (; i < 4; ++i) {
              bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
              if (this.buf[this.pos++] < 128)
                return bits;
            }
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
            i = 0;
          } else {
            for (; i < 3; ++i) {
              if (this.pos >= this.len)
                throw indexOutOfRange(this);
              bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
              if (this.buf[this.pos++] < 128)
                return bits;
            }
            bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
            return bits;
          }
          if (this.len - this.pos > 4) {
            for (; i < 5; ++i) {
              bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
              if (this.buf[this.pos++] < 128)
                return bits;
            }
          } else {
            for (; i < 5; ++i) {
              if (this.pos >= this.len)
                throw indexOutOfRange(this);
              bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
              if (this.buf[this.pos++] < 128)
                return bits;
            }
          }
          throw Error("invalid varint encoding");
        }
        Reader.prototype.bool = function read_bool() {
          return this.uint32() !== 0;
        };
        function readFixed32_end(buf22, end) {
          return (buf22[end - 4] | buf22[end - 3] << 8 | buf22[end - 2] << 16 | buf22[end - 1] << 24) >>> 0;
        }
        Reader.prototype.fixed32 = function read_fixed32() {
          if (this.pos + 4 > this.len)
            throw indexOutOfRange(this, 4);
          return readFixed32_end(this.buf, this.pos += 4);
        };
        Reader.prototype.sfixed32 = function read_sfixed32() {
          if (this.pos + 4 > this.len)
            throw indexOutOfRange(this, 4);
          return readFixed32_end(this.buf, this.pos += 4) | 0;
        };
        function readFixed64() {
          if (this.pos + 8 > this.len)
            throw indexOutOfRange(this, 8);
          return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
        }
        Reader.prototype.float = function read_float() {
          if (this.pos + 4 > this.len)
            throw indexOutOfRange(this, 4);
          var value = util2.float.readFloatLE(this.buf, this.pos);
          this.pos += 4;
          return value;
        };
        Reader.prototype.double = function read_double() {
          if (this.pos + 8 > this.len)
            throw indexOutOfRange(this, 4);
          var value = util2.float.readDoubleLE(this.buf, this.pos);
          this.pos += 8;
          return value;
        };
        Reader.prototype.bytes = function read_bytes() {
          var length22 = this.uint32(), start = this.pos, end = this.pos + length22;
          if (end > this.len)
            throw indexOutOfRange(this, length22);
          this.pos += length22;
          if (Array.isArray(this.buf))
            return this.buf.slice(start, end);
          return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
        };
        Reader.prototype.string = function read_string() {
          var bytes3 = this.bytes();
          return utf84.read(bytes3, 0, bytes3.length);
        };
        Reader.prototype.skip = function skip2(length22) {
          if (typeof length22 === "number") {
            if (this.pos + length22 > this.len)
              throw indexOutOfRange(this, length22);
            this.pos += length22;
          } else {
            do {
              if (this.pos >= this.len)
                throw indexOutOfRange(this);
            } while (this.buf[this.pos++] & 128);
          }
          return this;
        };
        Reader.prototype.skipType = function(wireType) {
          switch (wireType) {
            case 0:
              this.skip();
              break;
            case 1:
              this.skip(8);
              break;
            case 2:
              this.skip(this.uint32());
              break;
            case 3:
              while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
              }
              break;
            case 5:
              this.skip(4);
              break;
            default:
              throw Error("invalid wire type " + wireType + " at offset " + this.pos);
          }
          return this;
        };
        Reader._configure = function(BufferReader_) {
          BufferReader = BufferReader_;
          Reader.create = create32();
          BufferReader._configure();
          var fn = util2.Long ? "toLong" : (
            /* istanbul ignore next */
            "toNumber"
          );
          util2.merge(Reader.prototype, {
            int64: function read_int64() {
              return readLongVarint.call(this)[fn](false);
            },
            uint64: function read_uint64() {
              return readLongVarint.call(this)[fn](true);
            },
            sint64: function read_sint64() {
              return readLongVarint.call(this).zzDecode()[fn](false);
            },
            fixed64: function read_fixed64() {
              return readFixed64.call(this)[fn](true);
            },
            sfixed64: function read_sfixed64() {
              return readFixed64.call(this)[fn](false);
            }
          });
        };
      }
    });
    require_reader_buffer2 = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
        "use strict";
        module2.exports = BufferReader;
        var Reader = require_reader2();
        (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
        var util2 = require_minimal3();
        function BufferReader(buffer22) {
          Reader.call(this, buffer22);
        }
        BufferReader._configure = function() {
          if (util2.Buffer)
            BufferReader.prototype._slice = util2.Buffer.prototype.slice;
        };
        BufferReader.prototype.string = function read_string_buffer() {
          var len = this.uint32();
          return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
        };
        BufferReader._configure();
      }
    });
    require_service2 = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
        "use strict";
        module2.exports = Service;
        var util2 = require_minimal3();
        (Service.prototype = Object.create(util2.EventEmitter.prototype)).constructor = Service;
        function Service(rpcImpl, requestDelimited, responseDelimited) {
          if (typeof rpcImpl !== "function")
            throw TypeError("rpcImpl must be a function");
          util2.EventEmitter.call(this);
          this.rpcImpl = rpcImpl;
          this.requestDelimited = Boolean(requestDelimited);
          this.responseDelimited = Boolean(responseDelimited);
        }
        Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
          if (!request)
            throw TypeError("request must be specified");
          var self2 = this;
          if (!callback)
            return util2.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
          if (!self2.rpcImpl) {
            setTimeout(function() {
              callback(Error("already ended"));
            }, 0);
            return void 0;
          }
          try {
            return self2.rpcImpl(
              method,
              requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
              function rpcCallback(err, response) {
                if (err) {
                  self2.emit("error", err, method);
                  return callback(err);
                }
                if (response === null) {
                  self2.end(
                    /* endedByRPC */
                    true
                  );
                  return void 0;
                }
                if (!(response instanceof responseCtor)) {
                  try {
                    response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
                  } catch (err2) {
                    self2.emit("error", err2, method);
                    return callback(err2);
                  }
                }
                self2.emit("data", response, method);
                return callback(null, response);
              }
            );
          } catch (err) {
            self2.emit("error", err, method);
            setTimeout(function() {
              callback(err);
            }, 0);
            return void 0;
          }
        };
        Service.prototype.end = function end(endedByRPC) {
          if (this.rpcImpl) {
            if (!endedByRPC)
              this.rpcImpl(null, null, null);
            this.rpcImpl = null;
            this.emit("end").off();
          }
          return this;
        };
      }
    });
    require_rpc2 = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/rpc.js"(exports2) {
        "use strict";
        var rpc = exports2;
        rpc.Service = require_service2();
      }
    });
    require_roots2 = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/roots.js"(exports2, module2) {
        "use strict";
        module2.exports = {};
      }
    });
    require_index_minimal2 = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/index-minimal.js"(exports2) {
        "use strict";
        var protobuf = exports2;
        protobuf.build = "minimal";
        protobuf.Writer = require_writer2();
        protobuf.BufferWriter = require_writer_buffer2();
        protobuf.Reader = require_reader2();
        protobuf.BufferReader = require_reader_buffer2();
        protobuf.util = require_minimal3();
        protobuf.rpc = require_rpc2();
        protobuf.roots = require_roots2();
        protobuf.configure = configure22;
        function configure22() {
          protobuf.util._configure();
          protobuf.Writer._configure(protobuf.BufferWriter);
          protobuf.Reader._configure(protobuf.BufferReader);
        }
        configure22();
      }
    });
    require_minimal22 = __commonJS2({
      "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/minimal.js"(exports2, module2) {
        "use strict";
        module2.exports = require_index_minimal2();
      }
    });
    require_it_first = __commonJS2({
      "../../node_modules/.pnpm/it-first@1.0.7/node_modules/it-first/index.js"(exports2, module2) {
        "use strict";
        var first2 = async (source) => {
          for await (const entry of source) {
            return entry;
          }
          return void 0;
        };
        module2.exports = first2;
      }
    });
    require_it_last = __commonJS2({
      "../../node_modules/.pnpm/it-last@1.0.6/node_modules/it-last/index.js"(exports2, module2) {
        "use strict";
        var last5 = async (source) => {
          let res;
          for await (const entry of source) {
            res = entry;
          }
          return res;
        };
        module2.exports = last5;
      }
    });
    require_source = __commonJS2({
      "../../node_modules/.pnpm/stream-to-it@0.2.4/node_modules/stream-to-it/source.js"(exports2, module2) {
        module2.exports = (readable) => {
          if (readable[Symbol.asyncIterator]) return readable;
          if (readable.getReader) {
            return async function* () {
              const reader = readable.getReader();
              try {
                while (true) {
                  const { done, value } = await reader.read();
                  if (done) return;
                  yield value;
                }
              } finally {
                reader.releaseLock();
              }
            }();
          }
          throw new Error("unknown stream");
        };
      }
    });
    require_glob_source = __commonJS2({
      "(disabled):../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/files/glob-source.js"() {
      }
    });
    require_url_source = __commonJS2({
      "../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/files/url-source.js"(exports2, module2) {
        "use strict";
        var HTTP3 = require_http();
        var urlSource = (url2, options) => {
          return {
            path: decodeURIComponent(new URL(url2).pathname.split("/").pop() || ""),
            content: readURLContent(url2, options)
          };
        };
        async function* readURLContent(url2, options) {
          const http2 = new HTTP3();
          const response = await http2.get(url2, options);
          yield* response.iterator();
        }
        module2.exports = urlSource;
      }
    });
    LOAD_BASE = (name82) => Promise.reject(new Error(`No base found for "${name82}"`));
    Multibases = class {
      constructor(options) {
        this._basesByName = {};
        this._basesByPrefix = {};
        this._loadBase = options.loadBase || LOAD_BASE;
        for (const base33 of options.bases) {
          this.addBase(base33);
        }
      }
      addBase(base33) {
        if (this._basesByName[base33.name] || this._basesByPrefix[base33.prefix]) {
          throw new Error(`Codec already exists for codec "${base33.name}"`);
        }
        this._basesByName[base33.name] = base33;
        this._basesByPrefix[base33.prefix] = base33;
      }
      removeBase(base33) {
        delete this._basesByName[base33.name];
        delete this._basesByPrefix[base33.prefix];
      }
      async getBase(nameOrPrefix) {
        if (this._basesByName[nameOrPrefix]) {
          return this._basesByName[nameOrPrefix];
        }
        if (this._basesByPrefix[nameOrPrefix]) {
          return this._basesByPrefix[nameOrPrefix];
        }
        const base33 = await this._loadBase(nameOrPrefix);
        if (this._basesByName[base33.name] == null && this._basesByPrefix[base33.prefix] == null) {
          this.addBase(base33);
        }
        return base33;
      }
      listBases() {
        return Object.values(this._basesByName);
      }
    };
    LOAD_CODEC = (codeOrName) => Promise.reject(new Error(`No codec found for "${codeOrName}"`));
    Multicodecs = class {
      constructor(options) {
        this._codecsByName = {};
        this._codecsByCode = {};
        this._loadCodec = options.loadCodec || LOAD_CODEC;
        for (const codec of options.codecs) {
          this.addCodec(codec);
        }
      }
      addCodec(codec) {
        if (this._codecsByName[codec.name] || this._codecsByCode[codec.code]) {
          throw new Error(`Resolver already exists for codec "${codec.name}"`);
        }
        this._codecsByName[codec.name] = codec;
        this._codecsByCode[codec.code] = codec;
      }
      removeCodec(codec) {
        delete this._codecsByName[codec.name];
        delete this._codecsByCode[codec.code];
      }
      async getCodec(code82) {
        const table = typeof code82 === "string" ? this._codecsByName : this._codecsByCode;
        if (table[code82]) {
          return table[code82];
        }
        const codec = await this._loadCodec(code82);
        if (table[code82] == null) {
          this.addCodec(codec);
        }
        return codec;
      }
      listCodecs() {
        return Object.values(this._codecsByName);
      }
    };
    LOAD_HASHER = (codeOrName) => Promise.reject(new Error(`No hasher found for "${codeOrName}"`));
    Multihashes = class {
      constructor(options) {
        this._hashersByName = {};
        this._hashersByCode = {};
        this._loadHasher = options.loadHasher || LOAD_HASHER;
        for (const hasher of options.hashers) {
          this.addHasher(hasher);
        }
      }
      addHasher(hasher) {
        if (this._hashersByName[hasher.name] || this._hashersByCode[hasher.code]) {
          throw new Error(`Resolver already exists for codec "${hasher.name}"`);
        }
        this._hashersByName[hasher.name] = hasher;
        this._hashersByCode[hasher.code] = hasher;
      }
      removeHasher(hasher) {
        delete this._hashersByName[hasher.name];
        delete this._hashersByCode[hasher.code];
      }
      async getHasher(code82) {
        const table = typeof code82 === "string" ? this._hashersByName : this._hashersByCode;
        if (table[code82]) {
          return table[code82];
        }
        const hasher = await this._loadHasher(code82);
        if (table[code82] == null) {
          this.addHasher(hasher);
        }
        return hasher;
      }
      listHashers() {
        return Object.values(this._hashersByName);
      }
    };
    src_exports = {};
    __export2(src_exports, {
      code: () => code19,
      createLink: () => createLink,
      createNode: () => createNode,
      decode: () => decode52,
      encode: () => encode37,
      name: () => name14,
      prepare: () => prepare3,
      validate: () => validate2
    });
    init_cid();
    textDecoder4 = new TextDecoder();
    textEncoder6 = new TextEncoder();
    maxInt322 = 2 ** 32;
    maxUInt322 = 2 ** 31;
    len8tab2 = [
      0,
      1,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ];
    init_cid();
    pbNodeProperties2 = [
      "Data",
      "Links"
    ];
    pbLinkProperties2 = [
      "Hash",
      "Name",
      "Tsize"
    ];
    textEncoder22 = new TextEncoder();
    name14 = "dag-pb";
    code19 = 112;
    esm_exports = {};
    __export2(esm_exports, {
      code: () => code22,
      decode: () => decode72,
      encode: () => encode52,
      name: () => name22
    });
    init_cborg();
    init_cid();
    CID_CBOR_TAG3 = 42;
    encodeOptions4 = {
      float64: true,
      typeEncoders: {
        Object: cidEncoder4,
        undefined: undefinedEncoder4,
        number: numberEncoder4
      }
    };
    decodeOptions4 = {
      allowIndefinite: false,
      coerceUndefinedToNull: true,
      allowNaN: false,
      allowInfinity: false,
      allowBigInt: true,
      strict: true,
      useMaps: false,
      tags: []
    };
    decodeOptions4.tags[CID_CBOR_TAG3] = cidDecoder3;
    name22 = "dag-cbor";
    code22 = 113;
    encode52 = (node) => encode42(node, encodeOptions4);
    decode72 = (data) => decode62(data, decodeOptions4);
    esm_exports2 = {};
    __export2(esm_exports2, {
      code: () => code32,
      decode: () => decode92,
      encode: () => encode72,
      name: () => name32
    });
    init_src();
    init_base64();
    init_cborg();
    init_token();
    init_encode();
    init_common();
    init_byte_utils();
    JSONEncoder2 = class extends Array {
      constructor() {
        super();
        this.inRecursive = [];
      }
      prefix(buf22) {
        const recurs = this.inRecursive[this.inRecursive.length - 1];
        if (recurs) {
          if (recurs.type === Type2.array) {
            recurs.elements++;
            if (recurs.elements !== 1) {
              buf22.push([44]);
            }
          }
          if (recurs.type === Type2.map) {
            recurs.elements++;
            if (recurs.elements !== 1) {
              if (recurs.elements % 2 === 1) {
                buf22.push([44]);
              } else {
                buf22.push([58]);
              }
            }
          }
        }
      }
      [Type2.uint.major](buf22, token) {
        this.prefix(buf22);
        const is22 = String(token.value);
        const isa = [];
        for (let i = 0; i < is22.length; i++) {
          isa[i] = is22.charCodeAt(i);
        }
        buf22.push(isa);
      }
      [Type2.negint.major](buf22, token) {
        this[Type2.uint.major](buf22, token);
      }
      [Type2.bytes.major](_buf, _token) {
        throw new Error(`${encodeErrPrefix2} unsupported type: Uint8Array`);
      }
      [Type2.string.major](buf22, token) {
        this.prefix(buf22);
        const byts = fromString22(JSON.stringify(token.value));
        buf22.push(byts.length > 32 ? asU8A2(byts) : byts);
      }
      [Type2.array.major](buf22, _token) {
        this.prefix(buf22);
        this.inRecursive.push({
          type: Type2.array,
          elements: 0
        });
        buf22.push([91]);
      }
      [Type2.map.major](buf22, _token) {
        this.prefix(buf22);
        this.inRecursive.push({
          type: Type2.map,
          elements: 0
        });
        buf22.push([123]);
      }
      [Type2.tag.major](_buf, _token) {
      }
      [Type2.float.major](buf22, token) {
        if (token.type.name === "break") {
          const recurs = this.inRecursive.pop();
          if (recurs) {
            if (recurs.type === Type2.array) {
              buf22.push([93]);
            } else if (recurs.type === Type2.map) {
              buf22.push([125]);
            } else {
              throw new Error("Unexpected recursive type; this should not happen!");
            }
            return;
          }
          throw new Error("Unexpected break; this should not happen!");
        }
        if (token.value === void 0) {
          throw new Error(`${encodeErrPrefix2} unsupported type: undefined`);
        }
        this.prefix(buf22);
        if (token.type.name === "true") {
          buf22.push([
            116,
            114,
            117,
            101
          ]);
          return;
        } else if (token.type.name === "false") {
          buf22.push([
            102,
            97,
            108,
            115,
            101
          ]);
          return;
        } else if (token.type.name === "null") {
          buf22.push([
            110,
            117,
            108,
            108
          ]);
          return;
        }
        const is22 = String(token.value);
        const isa = [];
        let dp = false;
        for (let i = 0; i < is22.length; i++) {
          isa[i] = is22.charCodeAt(i);
          if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {
            dp = true;
          }
        }
        if (!dp) {
          isa.push(46);
          isa.push(48);
        }
        buf22.push(isa);
      }
    };
    defaultEncodeOptions22 = {
      addBreakTokens: true,
      mapSorter: mapSorter22
    };
    init_decode();
    init_token();
    init_byte_utils();
    init_common();
    Tokenizer2 = class {
      constructor(data, options = {}) {
        this.pos = 0;
        this.data = data;
        this.options = options;
        this.modeStack = ["value"];
        this.lastToken = "";
      }
      done() {
        return this.pos >= this.data.length;
      }
      ch() {
        return this.data[this.pos];
      }
      currentMode() {
        return this.modeStack[this.modeStack.length - 1];
      }
      skipWhitespace() {
        let c = this.ch();
        while (c === 32 || c === 9 || c === 13 || c === 10) {
          c = this.data[++this.pos];
        }
      }
      expect(str) {
        if (this.data.length - this.pos < str.length) {
          throw new Error(`${decodeErrPrefix2} unexpected end of input at position ${this.pos}`);
        }
        for (let i = 0; i < str.length; i++) {
          if (this.data[this.pos++] !== str[i]) {
            throw new Error(`${decodeErrPrefix2} unexpected token at position ${this.pos}, expected to find '${String.fromCharCode(...str)}'`);
          }
        }
      }
      parseNumber() {
        const startPos = this.pos;
        let negative = false;
        let float2 = false;
        const swallow = (chars) => {
          while (!this.done()) {
            const ch = this.ch();
            if (chars.includes(ch)) {
              this.pos++;
            } else {
              break;
            }
          }
        };
        if (this.ch() === 45) {
          negative = true;
          this.pos++;
        }
        if (this.ch() === 48) {
          this.pos++;
          if (this.ch() === 46) {
            this.pos++;
            float2 = true;
          } else {
            return new Token2(Type2.uint, 0, this.pos - startPos);
          }
        }
        swallow([
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57
        ]);
        if (negative && this.pos === startPos + 1) {
          throw new Error(`${decodeErrPrefix2} unexpected token at position ${this.pos}`);
        }
        if (!this.done() && this.ch() === 46) {
          if (float2) {
            throw new Error(`${decodeErrPrefix2} unexpected token at position ${this.pos}`);
          }
          float2 = true;
          this.pos++;
          swallow([
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57
          ]);
        }
        if (!this.done() && (this.ch() === 101 || this.ch() === 69)) {
          float2 = true;
          this.pos++;
          if (!this.done() && (this.ch() === 43 || this.ch() === 45)) {
            this.pos++;
          }
          swallow([
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57
          ]);
        }
        const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this.pos));
        const num = parseFloat(numStr);
        if (float2) {
          return new Token2(Type2.float, num, this.pos - startPos);
        }
        if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {
          return new Token2(num >= 0 ? Type2.uint : Type2.negint, num, this.pos - startPos);
        }
        return new Token2(num >= 0 ? Type2.uint : Type2.negint, BigInt(numStr), this.pos - startPos);
      }
      parseString() {
        if (this.ch() !== 34) {
          throw new Error(`${decodeErrPrefix2} unexpected character at position ${this.pos}; this shouldn't happen`);
        }
        this.pos++;
        for (let i = this.pos, l2 = 0; i < this.data.length && l2 < 65536; i++, l2++) {
          const ch = this.data[i];
          if (ch === 92 || ch < 32 || ch >= 128) {
            break;
          }
          if (ch === 34) {
            const str = String.fromCharCode.apply(null, this.data.subarray(this.pos, i));
            this.pos = i + 1;
            return new Token2(Type2.string, str, l2);
          }
        }
        const startPos = this.pos;
        const chars = [];
        const readu4 = () => {
          if (this.pos + 4 >= this.data.length) {
            throw new Error(`${decodeErrPrefix2} unexpected end of unicode escape sequence at position ${this.pos}`);
          }
          let u4 = 0;
          for (let i = 0; i < 4; i++) {
            let ch = this.ch();
            if (ch >= 48 && ch <= 57) {
              ch -= 48;
            } else if (ch >= 97 && ch <= 102) {
              ch = ch - 97 + 10;
            } else if (ch >= 65 && ch <= 70) {
              ch = ch - 65 + 10;
            } else {
              throw new Error(`${decodeErrPrefix2} unexpected unicode escape character at position ${this.pos}`);
            }
            u4 = u4 * 16 + ch;
            this.pos++;
          }
          return u4;
        };
        const readUtf8Char = () => {
          const firstByte = this.ch();
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (this.pos + bytesPerSequence > this.data.length) {
            throw new Error(`${decodeErrPrefix2} unexpected unicode sequence at position ${this.pos}`);
          }
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = this.data[this.pos + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = this.data[this.pos + 1];
              thirdByte = this.data[this.pos + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = this.data[this.pos + 1];
              thirdByte = this.data[this.pos + 2];
              fourthByte = this.data[this.pos + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            chars.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          chars.push(codePoint);
          this.pos += bytesPerSequence;
        };
        while (!this.done()) {
          const ch = this.ch();
          let ch1;
          switch (ch) {
            case 92:
              this.pos++;
              if (this.done()) {
                throw new Error(`${decodeErrPrefix2} unexpected string termination at position ${this.pos}`);
              }
              ch1 = this.ch();
              this.pos++;
              switch (ch1) {
                case 34:
                case 39:
                case 92:
                case 47:
                  chars.push(ch1);
                  break;
                case 98:
                  chars.push(8);
                  break;
                case 116:
                  chars.push(9);
                  break;
                case 110:
                  chars.push(10);
                  break;
                case 102:
                  chars.push(12);
                  break;
                case 114:
                  chars.push(13);
                  break;
                case 117:
                  chars.push(readu4());
                  break;
                default:
                  throw new Error(`${decodeErrPrefix2} unexpected string escape character at position ${this.pos}`);
              }
              break;
            case 34:
              this.pos++;
              return new Token2(Type2.string, decodeCodePointsArray2(chars), this.pos - startPos);
            default:
              if (ch < 32) {
                throw new Error(`${decodeErrPrefix2} invalid control character at position ${this.pos}`);
              } else if (ch < 128) {
                chars.push(ch);
                this.pos++;
              } else {
                readUtf8Char();
              }
          }
        }
        throw new Error(`${decodeErrPrefix2} unexpected end of string at position ${this.pos}`);
      }
      parseValue() {
        switch (this.ch()) {
          case 123:
            this.modeStack.push("obj-start");
            this.pos++;
            return new Token2(Type2.map, Infinity, 1);
          case 91:
            this.modeStack.push("array-start");
            this.pos++;
            return new Token2(Type2.array, Infinity, 1);
          case 34: {
            return this.parseString();
          }
          case 110:
            this.expect([
              110,
              117,
              108,
              108
            ]);
            return new Token2(Type2.null, null, 4);
          case 102:
            this.expect([
              102,
              97,
              108,
              115,
              101
            ]);
            return new Token2(Type2.false, false, 5);
          case 116:
            this.expect([
              116,
              114,
              117,
              101
            ]);
            return new Token2(Type2.true, true, 4);
          case 45:
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.parseNumber();
          default:
            throw new Error(`${decodeErrPrefix2} unexpected character at position ${this.pos}`);
        }
      }
      next() {
        this.skipWhitespace();
        switch (this.currentMode()) {
          case "value":
            this.modeStack.pop();
            return this.parseValue();
          case "array-value": {
            this.modeStack.pop();
            if (this.ch() === 93) {
              this.pos++;
              this.skipWhitespace();
              return new Token2(Type2.break, void 0, 1);
            }
            if (this.ch() !== 44) {
              throw new Error(`${decodeErrPrefix2} unexpected character at position ${this.pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
            }
            this.pos++;
            this.modeStack.push("array-value");
            this.skipWhitespace();
            return this.parseValue();
          }
          case "array-start": {
            this.modeStack.pop();
            if (this.ch() === 93) {
              this.pos++;
              this.skipWhitespace();
              return new Token2(Type2.break, void 0, 1);
            }
            this.modeStack.push("array-value");
            this.skipWhitespace();
            return this.parseValue();
          }
          case "obj-key":
            if (this.ch() === 125) {
              this.modeStack.pop();
              this.pos++;
              this.skipWhitespace();
              return new Token2(Type2.break, void 0, 1);
            }
            if (this.ch() !== 44) {
              throw new Error(`${decodeErrPrefix2} unexpected character at position ${this.pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
            }
            this.pos++;
            this.skipWhitespace();
          case "obj-start": {
            this.modeStack.pop();
            if (this.ch() === 125) {
              this.pos++;
              this.skipWhitespace();
              return new Token2(Type2.break, void 0, 1);
            }
            const token = this.parseString();
            this.skipWhitespace();
            if (this.ch() !== 58) {
              throw new Error(`${decodeErrPrefix2} unexpected character at position ${this.pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
            }
            this.pos++;
            this.modeStack.push("obj-value");
            return token;
          }
          case "obj-value": {
            this.modeStack.pop();
            this.modeStack.push("obj-key");
            this.skipWhitespace();
            return this.parseValue();
          }
          default:
            throw new Error(`${decodeErrPrefix2} unexpected parse state at position ${this.pos}; this shouldn't happen`);
        }
      }
    };
    encodeOptions22 = {
      typeEncoders: {
        Object: cidEncoder22,
        Uint8Array: bytesEncoder2,
        Buffer: bytesEncoder2,
        undefined: undefinedEncoder22,
        number: numberEncoder22
      }
    };
    DagJsonTokenizer2 = class extends Tokenizer2 {
      constructor(data, options) {
        super(data, options);
        this.tokenBuffer = [];
      }
      done() {
        return this.tokenBuffer.length === 0 && super.done();
      }
      _next() {
        if (this.tokenBuffer.length > 0) {
          return this.tokenBuffer.pop();
        }
        return super.next();
      }
      next() {
        const token = this._next();
        if (token.type === Type2.map) {
          const keyToken = this._next();
          if (keyToken.type === Type2.string && keyToken.value === "/") {
            const valueToken = this._next();
            if (valueToken.type === Type2.string) {
              const breakToken = this._next();
              if (breakToken.type !== Type2.break) {
                throw new Error("Invalid encoded CID form");
              }
              this.tokenBuffer.push(valueToken);
              return new Token2(Type2.tag, 42, 0);
            }
            if (valueToken.type === Type2.map) {
              const innerKeyToken = this._next();
              if (innerKeyToken.type === Type2.string && innerKeyToken.value === "bytes") {
                const innerValueToken = this._next();
                if (innerValueToken.type === Type2.string) {
                  for (let i = 0; i < 2; i++) {
                    const breakToken = this._next();
                    if (breakToken.type !== Type2.break) {
                      throw new Error("Invalid encoded Bytes form");
                    }
                  }
                  const bytes3 = base643.decode(`m${innerValueToken.value}`);
                  return new Token2(Type2.bytes, bytes3, innerValueToken.value.length);
                }
                this.tokenBuffer.push(innerValueToken);
              }
              this.tokenBuffer.push(innerKeyToken);
            }
            this.tokenBuffer.push(valueToken);
          }
          this.tokenBuffer.push(keyToken);
        }
        return token;
      }
    };
    decodeOptions22 = {
      allowIndefinite: false,
      allowUndefined: false,
      allowNaN: false,
      allowInfinity: false,
      allowBigInt: true,
      strict: true,
      useMaps: false,
      tags: []
    };
    decodeOptions22.tags[42] = CID4.parse;
    name32 = "dag-json";
    code32 = 297;
    encode72 = (node) => encode62(node, encodeOptions22);
    decode92 = (data) => {
      const options = Object.assign(decodeOptions22, { tokenizer: new DagJsonTokenizer2(data, decodeOptions22) });
      return decode82(data, options);
    };
    dagJOSE = __toESM2(require_lib3(), 1);
    init_identity();
    init_basics();
    init_cid();
    import_multiaddr2 = __toESM2(require_src(), 1);
    import_env = __toESM2(require_env(), 1);
    durationRE = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/uig;
    parse8.nanosecond = parse8.ns = 1 / 1e6;
    parse8["\xB5s"] = parse8["\u03BCs"] = parse8.us = parse8.microsecond = 1 / 1e3;
    parse8.millisecond = parse8.ms = parse8[""] = 1;
    parse8.second = parse8.sec = parse8.s = parse8.ms * 1e3;
    parse8.minute = parse8.min = parse8.m = parse8.s * 60;
    parse8.hour = parse8.hr = parse8.h = parse8.m * 60;
    parse8.day = parse8.d = parse8.h * 24;
    parse8.week = parse8.wk = parse8.w = parse8.d * 7;
    parse8.month = parse8.b = parse8.d * (365.25 / 12);
    parse8.year = parse8.yr = parse8.y = parse8.d * 365.25;
    parse_duration_default = parse8;
    import_debug = __toESM2(require_browser(), 1);
    import_http3 = __toESM2(require_http(), 1);
    import_index2 = __toESM2(require_merge_options(), 1);
    merge_options_default = import_index2.default;
    import_multiaddr = __toESM2(require_src(), 1);
    import_multiaddr_to_uri = __toESM2(require_multiaddr_to_uri(), 1);
    agent_browser_default = () => {
    };
    log = (0, import_debug.default)("ipfs-http-client:lib:error-handler");
    merge2 = merge_options_default.bind({ ignoreUndefined: true });
    DEFAULT_PROTOCOL = import_env.isBrowser || import_env.isWebWorker ? location.protocol : "http";
    DEFAULT_HOST = import_env.isBrowser || import_env.isWebWorker ? location.hostname : "localhost";
    DEFAULT_PORT = import_env.isBrowser || import_env.isWebWorker ? location.port : "5001";
    normalizeOptions = (options = {}) => {
      let url2;
      let opts = {};
      let agent;
      if (typeof options === "string" || import_multiaddr2.Multiaddr.isMultiaddr(options)) {
        url2 = new URL(toUrlString(options));
      } else if (options instanceof URL) {
        url2 = options;
      } else if (typeof options.url === "string" || import_multiaddr2.Multiaddr.isMultiaddr(options.url)) {
        url2 = new URL(toUrlString(options.url));
        opts = options;
      } else if (options.url instanceof URL) {
        url2 = options.url;
        opts = options;
      } else {
        opts = options || {};
        const protocol = (opts.protocol || DEFAULT_PROTOCOL).replace(":", "");
        const host = (opts.host || DEFAULT_HOST).split(":")[0];
        const port = opts.port || DEFAULT_PORT;
        url2 = new URL(`${protocol}://${host}:${port}`);
      }
      if (opts.apiPath) {
        url2.pathname = opts.apiPath;
      } else if (url2.pathname === "/" || url2.pathname === void 0) {
        url2.pathname = "api/v0";
      }
      if (import_env.isNode) {
        const Agent = agent_browser_default(url2);
        agent = opts.agent || new Agent({
          keepAlive: true,
          maxSockets: 6
        });
      }
      return {
        ...opts,
        host: url2.host,
        protocol: url2.protocol.replace(":", ""),
        port: Number(url2.port),
        apiPath: url2.pathname,
        url: url2,
        agent
      };
    };
    errorHandler = async (response) => {
      let msg;
      try {
        if ((response.headers.get("Content-Type") || "").startsWith("application/json")) {
          const data = await response.json();
          log(data);
          msg = data.Message || data.message;
        } else {
          msg = await response.text();
        }
      } catch (err) {
        log("Failed to parse error response", err);
        msg = err.message;
      }
      let error3 = new import_http3.default.HTTPError(response);
      if (msg) {
        if (msg.includes("deadline has elapsed")) {
          error3 = new import_http3.default.TimeoutError();
        }
        if (msg && msg.includes("context deadline exceeded")) {
          error3 = new import_http3.default.TimeoutError();
        }
      }
      if (msg && msg.includes("request timed out")) {
        error3 = new import_http3.default.TimeoutError();
      }
      if (msg) {
        error3.message = msg;
      }
      throw error3;
    };
    KEBAB_REGEX = /[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g;
    kebabCase = (str) => {
      return str.replace(KEBAB_REGEX, function(match6) {
        return "-" + match6.toLowerCase();
      });
    };
    parseTimeout = (value) => {
      return typeof value === "string" ? parse_duration_default(value) : value;
    };
    Client = class extends import_http3.default {
      constructor(options = {}) {
        const opts = normalizeOptions(options);
        super({
          timeout: parseTimeout(opts.timeout || 0) || void 0,
          headers: opts.headers,
          base: `${opts.url}`,
          handleError: errorHandler,
          transformSearchParams: (search) => {
            const out = new URLSearchParams();
            for (const [key, value] of search) {
              if (value !== "undefined" && value !== "null" && key !== "signal") {
                out.append(kebabCase(key), value);
              }
              if (key === "timeout" && !isNaN(value)) {
                out.append(kebabCase(key), value);
              }
            }
            return out;
          },
          agent: opts.agent
        });
        delete this.get;
        delete this.put;
        delete this.delete;
        delete this.options;
        const fetch3 = this.fetch;
        this.fetch = (resource, options2 = {}) => {
          if (typeof resource === "string" && !resource.startsWith("/")) {
            resource = `${opts.url}/${resource}`;
          }
          return fetch3.call(this, resource, merge2(options2, { method: "POST" }));
        };
      }
    };
    HTTPError2 = import_http3.default.HTTPError;
    configure6 = (fn) => {
      return (options) => {
        return fn(new Client(options), options);
      };
    };
    import_err_code = __toESM2(require_err_code(), 1);
    createWantlist = configure6((api) => {
      async function wantlist(options = {}) {
        const res = await (await api.post("bitswap/wantlist", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        })).json();
        return (res.Keys || []).map((k) => CID4.parse(k["/"]));
      }
      return wantlist;
    });
    init_cid();
    createWantlistForPeer = configure6((api) => {
      async function wantlistForPeer(peerId, options = {}) {
        const res = await (await api.post("bitswap/wantlist", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            ...options,
            peer: peerId.toString()
          }),
          headers: options.headers
        })).json();
        return (res.Keys || []).map((k) => CID4.parse(k["/"]));
      }
      return wantlistForPeer;
    });
    init_cid();
    createStat = configure6((api) => {
      async function stat(options = {}) {
        const res = await api.post("bitswap/stat", {
          searchParams: toUrlSearchParams(options),
          signal: options.signal,
          headers: options.headers
        });
        return toCoreInterface(await res.json());
      }
      return stat;
    });
    createUnwant = configure6((api) => {
      async function unwant(cid, options = {}) {
        const res = await api.post("bitswap/unwant", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: cid.toString(),
            ...options
          }),
          headers: options.headers
        });
        return res.json();
      }
      return unwant;
    });
    createGet = configure6((api) => {
      async function get15(cid, options = {}) {
        const res = await api.post("block/get", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: cid.toString(),
            ...options
          }),
          headers: options.headers
        });
        return new Uint8Array(await res.arrayBuffer());
      }
      return get15;
    });
    init_cid();
    import_err_code2 = __toESM2(require_err_code());
    import_it_peekable = __toESM2(require_it_peekable());
    import_browser_readablestream_to_it = __toESM2(require_browser_readablestream_to_it());
    import_it_all = __toESM2(require_it_all());
    isReadableStream2 = (value) => value && typeof value.getReader === "function";
    import_err_code4 = __toESM2(require_err_code(), 1);
    import_browser_readablestream_to_it2 = __toESM2(require_browser_readablestream_to_it(), 1);
    import_it_peekable2 = __toESM2(require_it_peekable(), 1);
    import_it_map = __toESM2(require_it_map(), 1);
    import_err_code3 = __toESM2(require_err_code(), 1);
    import_minimal2 = __toESM2(require_minimal22(), 1);
    $Reader2 = import_minimal2.default.Reader;
    $Writer2 = import_minimal2.default.Writer;
    $util2 = import_minimal2.default.util;
    $root2 = import_minimal2.default.roots["ipfs-unixfs"] || (import_minimal2.default.roots["ipfs-unixfs"] = {});
    Data2 = $root2.Data = (() => {
      function Data22(p) {
        this.blocksizes = [];
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Data22.prototype.Type = 0;
      Data22.prototype.Data = $util2.newBuffer([]);
      Data22.prototype.filesize = $util2.Long ? $util2.Long.fromBits(0, 0, true) : 0;
      Data22.prototype.blocksizes = $util2.emptyArray;
      Data22.prototype.hashType = $util2.Long ? $util2.Long.fromBits(0, 0, true) : 0;
      Data22.prototype.fanout = $util2.Long ? $util2.Long.fromBits(0, 0, true) : 0;
      Data22.prototype.mode = 0;
      Data22.prototype.mtime = null;
      Data22.encode = function encode132(m, w) {
        if (!w)
          w = $Writer2.create();
        w.uint32(8).int32(m.Type);
        if (m.Data != null && Object.hasOwnProperty.call(m, "Data"))
          w.uint32(18).bytes(m.Data);
        if (m.filesize != null && Object.hasOwnProperty.call(m, "filesize"))
          w.uint32(24).uint64(m.filesize);
        if (m.blocksizes != null && m.blocksizes.length) {
          for (var i = 0; i < m.blocksizes.length; ++i)
            w.uint32(32).uint64(m.blocksizes[i]);
        }
        if (m.hashType != null && Object.hasOwnProperty.call(m, "hashType"))
          w.uint32(40).uint64(m.hashType);
        if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
          w.uint32(48).uint64(m.fanout);
        if (m.mode != null && Object.hasOwnProperty.call(m, "mode"))
          w.uint32(56).uint32(m.mode);
        if (m.mtime != null && Object.hasOwnProperty.call(m, "mtime"))
          $root2.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
        return w;
      };
      Data22.decode = function decode142(r, l2) {
        if (!(r instanceof $Reader2))
          r = $Reader2.create(r);
        var c = l2 === void 0 ? r.len : r.pos + l2, m = new $root2.Data();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.Type = r.int32();
              break;
            case 2:
              m.Data = r.bytes();
              break;
            case 3:
              m.filesize = r.uint64();
              break;
            case 4:
              if (!(m.blocksizes && m.blocksizes.length))
                m.blocksizes = [];
              if ((t & 7) === 2) {
                var c2 = r.uint32() + r.pos;
                while (r.pos < c2)
                  m.blocksizes.push(r.uint64());
              } else
                m.blocksizes.push(r.uint64());
              break;
            case 5:
              m.hashType = r.uint64();
              break;
            case 6:
              m.fanout = r.uint64();
              break;
            case 7:
              m.mode = r.uint32();
              break;
            case 8:
              m.mtime = $root2.UnixTime.decode(r, r.uint32());
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        if (!m.hasOwnProperty("Type"))
          throw $util2.ProtocolError("missing required 'Type'", { instance: m });
        return m;
      };
      Data22.fromObject = function fromObject(d) {
        if (d instanceof $root2.Data)
          return d;
        var m = new $root2.Data();
        switch (d.Type) {
          case "Raw":
          case 0:
            m.Type = 0;
            break;
          case "Directory":
          case 1:
            m.Type = 1;
            break;
          case "File":
          case 2:
            m.Type = 2;
            break;
          case "Metadata":
          case 3:
            m.Type = 3;
            break;
          case "Symlink":
          case 4:
            m.Type = 4;
            break;
          case "HAMTShard":
          case 5:
            m.Type = 5;
            break;
        }
        if (d.Data != null) {
          if (typeof d.Data === "string")
            $util2.base64.decode(d.Data, m.Data = $util2.newBuffer($util2.base64.length(d.Data)), 0);
          else if (d.Data.length)
            m.Data = d.Data;
        }
        if (d.filesize != null) {
          if ($util2.Long)
            (m.filesize = $util2.Long.fromValue(d.filesize)).unsigned = true;
          else if (typeof d.filesize === "string")
            m.filesize = parseInt(d.filesize, 10);
          else if (typeof d.filesize === "number")
            m.filesize = d.filesize;
          else if (typeof d.filesize === "object")
            m.filesize = new $util2.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
        }
        if (d.blocksizes) {
          if (!Array.isArray(d.blocksizes))
            throw TypeError(".Data.blocksizes: array expected");
          m.blocksizes = [];
          for (var i = 0; i < d.blocksizes.length; ++i) {
            if ($util2.Long)
              (m.blocksizes[i] = $util2.Long.fromValue(d.blocksizes[i])).unsigned = true;
            else if (typeof d.blocksizes[i] === "string")
              m.blocksizes[i] = parseInt(d.blocksizes[i], 10);
            else if (typeof d.blocksizes[i] === "number")
              m.blocksizes[i] = d.blocksizes[i];
            else if (typeof d.blocksizes[i] === "object")
              m.blocksizes[i] = new $util2.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);
          }
        }
        if (d.hashType != null) {
          if ($util2.Long)
            (m.hashType = $util2.Long.fromValue(d.hashType)).unsigned = true;
          else if (typeof d.hashType === "string")
            m.hashType = parseInt(d.hashType, 10);
          else if (typeof d.hashType === "number")
            m.hashType = d.hashType;
          else if (typeof d.hashType === "object")
            m.hashType = new $util2.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
        }
        if (d.fanout != null) {
          if ($util2.Long)
            (m.fanout = $util2.Long.fromValue(d.fanout)).unsigned = true;
          else if (typeof d.fanout === "string")
            m.fanout = parseInt(d.fanout, 10);
          else if (typeof d.fanout === "number")
            m.fanout = d.fanout;
          else if (typeof d.fanout === "object")
            m.fanout = new $util2.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
        }
        if (d.mode != null) {
          m.mode = d.mode >>> 0;
        }
        if (d.mtime != null) {
          if (typeof d.mtime !== "object")
            throw TypeError(".Data.mtime: object expected");
          m.mtime = $root2.UnixTime.fromObject(d.mtime);
        }
        return m;
      };
      Data22.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.arrays || o.defaults) {
          d.blocksizes = [];
        }
        if (o.defaults) {
          d.Type = o.enums === String ? "Raw" : 0;
          if (o.bytes === String)
            d.Data = "";
          else {
            d.Data = [];
            if (o.bytes !== Array)
              d.Data = $util2.newBuffer(d.Data);
          }
          if ($util2.Long) {
            var n2 = new $util2.Long(0, 0, true);
            d.filesize = o.longs === String ? n2.toString() : o.longs === Number ? n2.toNumber() : n2;
          } else
            d.filesize = o.longs === String ? "0" : 0;
          if ($util2.Long) {
            var n2 = new $util2.Long(0, 0, true);
            d.hashType = o.longs === String ? n2.toString() : o.longs === Number ? n2.toNumber() : n2;
          } else
            d.hashType = o.longs === String ? "0" : 0;
          if ($util2.Long) {
            var n2 = new $util2.Long(0, 0, true);
            d.fanout = o.longs === String ? n2.toString() : o.longs === Number ? n2.toNumber() : n2;
          } else
            d.fanout = o.longs === String ? "0" : 0;
          d.mode = 0;
          d.mtime = null;
        }
        if (m.Type != null && m.hasOwnProperty("Type")) {
          d.Type = o.enums === String ? $root2.Data.DataType[m.Type] : m.Type;
        }
        if (m.Data != null && m.hasOwnProperty("Data")) {
          d.Data = o.bytes === String ? $util2.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
        }
        if (m.filesize != null && m.hasOwnProperty("filesize")) {
          if (typeof m.filesize === "number")
            d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
          else
            d.filesize = o.longs === String ? $util2.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util2.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
        }
        if (m.blocksizes && m.blocksizes.length) {
          d.blocksizes = [];
          for (var j = 0; j < m.blocksizes.length; ++j) {
            if (typeof m.blocksizes[j] === "number")
              d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
            else
              d.blocksizes[j] = o.longs === String ? $util2.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util2.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
          }
        }
        if (m.hashType != null && m.hasOwnProperty("hashType")) {
          if (typeof m.hashType === "number")
            d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
          else
            d.hashType = o.longs === String ? $util2.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util2.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
        }
        if (m.fanout != null && m.hasOwnProperty("fanout")) {
          if (typeof m.fanout === "number")
            d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
          else
            d.fanout = o.longs === String ? $util2.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util2.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
        }
        if (m.mode != null && m.hasOwnProperty("mode")) {
          d.mode = m.mode;
        }
        if (m.mtime != null && m.hasOwnProperty("mtime")) {
          d.mtime = $root2.UnixTime.toObject(m.mtime, o);
        }
        return d;
      };
      Data22.prototype.toJSON = function toJSON4() {
        return this.constructor.toObject(this, import_minimal2.default.util.toJSONOptions);
      };
      Data22.DataType = function() {
        const valuesById = {}, values2 = Object.create(valuesById);
        values2[valuesById[0] = "Raw"] = 0;
        values2[valuesById[1] = "Directory"] = 1;
        values2[valuesById[2] = "File"] = 2;
        values2[valuesById[3] = "Metadata"] = 3;
        values2[valuesById[4] = "Symlink"] = 4;
        values2[valuesById[5] = "HAMTShard"] = 5;
        return values2;
      }();
      return Data22;
    })();
    UnixTime2 = $root2.UnixTime = (() => {
      function UnixTime22(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      UnixTime22.prototype.Seconds = $util2.Long ? $util2.Long.fromBits(0, 0, false) : 0;
      UnixTime22.prototype.FractionalNanoseconds = 0;
      UnixTime22.encode = function encode132(m, w) {
        if (!w)
          w = $Writer2.create();
        w.uint32(8).int64(m.Seconds);
        if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, "FractionalNanoseconds"))
          w.uint32(21).fixed32(m.FractionalNanoseconds);
        return w;
      };
      UnixTime22.decode = function decode142(r, l2) {
        if (!(r instanceof $Reader2))
          r = $Reader2.create(r);
        var c = l2 === void 0 ? r.len : r.pos + l2, m = new $root2.UnixTime();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.Seconds = r.int64();
              break;
            case 2:
              m.FractionalNanoseconds = r.fixed32();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        if (!m.hasOwnProperty("Seconds"))
          throw $util2.ProtocolError("missing required 'Seconds'", { instance: m });
        return m;
      };
      UnixTime22.fromObject = function fromObject(d) {
        if (d instanceof $root2.UnixTime)
          return d;
        var m = new $root2.UnixTime();
        if (d.Seconds != null) {
          if ($util2.Long)
            (m.Seconds = $util2.Long.fromValue(d.Seconds)).unsigned = false;
          else if (typeof d.Seconds === "string")
            m.Seconds = parseInt(d.Seconds, 10);
          else if (typeof d.Seconds === "number")
            m.Seconds = d.Seconds;
          else if (typeof d.Seconds === "object")
            m.Seconds = new $util2.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
        }
        if (d.FractionalNanoseconds != null) {
          m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
        }
        return m;
      };
      UnixTime22.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if ($util2.Long) {
            var n2 = new $util2.Long(0, 0, false);
            d.Seconds = o.longs === String ? n2.toString() : o.longs === Number ? n2.toNumber() : n2;
          } else
            d.Seconds = o.longs === String ? "0" : 0;
          d.FractionalNanoseconds = 0;
        }
        if (m.Seconds != null && m.hasOwnProperty("Seconds")) {
          if (typeof m.Seconds === "number")
            d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
          else
            d.Seconds = o.longs === String ? $util2.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util2.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
        }
        if (m.FractionalNanoseconds != null && m.hasOwnProperty("FractionalNanoseconds")) {
          d.FractionalNanoseconds = m.FractionalNanoseconds;
        }
        return d;
      };
      UnixTime22.prototype.toJSON = function toJSON4() {
        return this.constructor.toObject(this, import_minimal2.default.util.toJSONOptions);
      };
      return UnixTime22;
    })();
    Metadata2 = $root2.Metadata = (() => {
      function Metadata22(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Metadata22.prototype.MimeType = "";
      Metadata22.encode = function encode132(m, w) {
        if (!w)
          w = $Writer2.create();
        if (m.MimeType != null && Object.hasOwnProperty.call(m, "MimeType"))
          w.uint32(10).string(m.MimeType);
        return w;
      };
      Metadata22.decode = function decode142(r, l2) {
        if (!(r instanceof $Reader2))
          r = $Reader2.create(r);
        var c = l2 === void 0 ? r.len : r.pos + l2, m = new $root2.Metadata();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.MimeType = r.string();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Metadata22.fromObject = function fromObject(d) {
        if (d instanceof $root2.Metadata)
          return d;
        var m = new $root2.Metadata();
        if (d.MimeType != null) {
          m.MimeType = String(d.MimeType);
        }
        return m;
      };
      Metadata22.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.MimeType = "";
        }
        if (m.MimeType != null && m.hasOwnProperty("MimeType")) {
          d.MimeType = m.MimeType;
        }
        return d;
      };
      Metadata22.prototype.toJSON = function toJSON4() {
        return this.constructor.toObject(this, import_minimal2.default.util.toJSONOptions);
      };
      return Metadata22;
    })();
    DEFAULT_FILE_MODE2 = parseInt("0644", 8);
    DEFAULT_DIRECTORY_MODE2 = parseInt("0755", 8);
    import_any_signal = __toESM2(require_any_signal(), 1);
    createPut = configure6((api) => {
      async function put2(data, options = {}) {
        const controller = new AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        let res;
        try {
          const response = await api.post("block/put", {
            signal,
            searchParams: toUrlSearchParams(options),
            ...await multipartRequest([data], controller, options.headers)
          });
          res = await response.json();
        } catch (err) {
          if (options.format === "dag-pb") {
            return put2(data, {
              ...options,
              format: "protobuf"
            });
          } else if (options.format === "dag-cbor") {
            return put2(data, {
              ...options,
              format: "cbor"
            });
          }
          throw err;
        }
        return CID4.parse(res.Key);
      }
      return put2;
    });
    init_cid();
    createRm = configure6((api) => {
      async function* rm(cid, options = {}) {
        if (!Array.isArray(cid)) {
          cid = [cid];
        }
        const res = await api.post("block/rm", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: cid.map((cid2) => cid2.toString()),
            "stream-channels": true,
            ...options
          }),
          headers: options.headers
        });
        for await (const removed of res.ndjson()) {
          yield toCoreInterface2(removed);
        }
      }
      return rm;
    });
    init_cid();
    createStat2 = configure6((api) => {
      async function stat(cid, options = {}) {
        const res = await api.post("block/stat", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: cid.toString(),
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return {
          cid: CID4.parse(data.Key),
          size: data.Size
        };
      }
      return stat;
    });
    import_multiaddr3 = __toESM2(require_src(), 1);
    createAdd = configure6((api) => {
      async function add9(addr, options = {}) {
        const res = await api.post("bootstrap/add", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: addr,
            ...options
          }),
          headers: options.headers
        });
        const { Peers } = await res.json();
        return { Peers: Peers.map((ma) => new import_multiaddr3.Multiaddr(ma)) };
      }
      return add9;
    });
    import_multiaddr4 = __toESM2(require_src(), 1);
    createClear = configure6((api) => {
      async function clear(options = {}) {
        const res = await api.post("bootstrap/rm", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            ...options,
            all: true
          }),
          headers: options.headers
        });
        const { Peers } = await res.json();
        return { Peers: Peers.map((ma) => new import_multiaddr4.Multiaddr(ma)) };
      }
      return clear;
    });
    import_multiaddr5 = __toESM2(require_src(), 1);
    createList = configure6((api) => {
      async function list7(options = {}) {
        const res = await api.post("bootstrap/list", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const { Peers } = await res.json();
        return { Peers: Peers.map((ma) => new import_multiaddr5.Multiaddr(ma)) };
      }
      return list7;
    });
    import_multiaddr6 = __toESM2(require_src(), 1);
    createReset = configure6((api) => {
      async function reset(options = {}) {
        const res = await api.post("bootstrap/add", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            ...options,
            default: true
          }),
          headers: options.headers
        });
        const { Peers } = await res.json();
        return { Peers: Peers.map((ma) => new import_multiaddr6.Multiaddr(ma)) };
      }
      return reset;
    });
    import_multiaddr7 = __toESM2(require_src(), 1);
    createRm2 = configure6((api) => {
      async function rm(addr, options = {}) {
        const res = await api.post("bootstrap/rm", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: addr,
            ...options
          }),
          headers: options.headers
        });
        const { Peers } = await res.json();
        return { Peers: Peers.map((ma) => new import_multiaddr7.Multiaddr(ma)) };
      }
      return rm;
    });
    createApply = configure6((api) => {
      async function apply(profile, options = {}) {
        const res = await api.post("config/profile/apply", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: profile,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return {
          original: data.OldCfg,
          updated: data.NewCfg
        };
      }
      return apply;
    });
    createList2 = configure6((api) => {
      async function list7(options = {}) {
        const res = await api.post("config/profile/list", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const data = await res.json();
        return data.map((profile) => objectToCamel(profile));
      }
      return list7;
    });
    createGet2 = configure6((api) => {
      const get15 = async (key, options = {}) => {
        if (!key) {
          throw new Error("key argument is required");
        }
        const res = await api.post("config", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: key,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return data.Value;
      };
      return get15;
    });
    createGetAll = configure6((api) => {
      const getAll = async (options = {}) => {
        const res = await api.post("config/show", {
          signal: options.signal,
          searchParams: toUrlSearchParams({ ...options }),
          headers: options.headers
        });
        const data = await res.json();
        return data;
      };
      return getAll;
    });
    init_from_string();
    createReplace = configure6((api) => {
      const replace = async (config2, options = {}) => {
        const controller = new AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const res = await api.post("config/replace", {
          signal,
          searchParams: toUrlSearchParams(options),
          ...await multipartRequest([fromString32(JSON.stringify(config2))], controller, options.headers)
        });
        await res.text();
      };
      return replace;
    });
    createSet = configure6((api) => {
      const set5 = async (key, value, options = {}) => {
        if (typeof key !== "string") {
          throw new Error("Invalid key type");
        }
        const params = {
          ...options,
          ...encodeParam(key, value)
        };
        const res = await api.post("config", {
          signal: options.signal,
          searchParams: toUrlSearchParams(params),
          headers: options.headers
        });
        await res.text();
      };
      return set5;
    });
    encodeParam = (key, value) => {
      switch (typeof value) {
        case "boolean":
          return {
            arg: [
              key,
              value.toString()
            ],
            bool: true
          };
        case "string":
          return {
            arg: [
              key,
              value
            ]
          };
        default:
          return {
            arg: [
              key,
              JSON.stringify(value)
            ],
            json: true
          };
      }
    };
    createExport = configure6((api) => {
      async function* dagExport(root2, options = {}) {
        const res = await api.post("dag/export", {
          signal: options.signal,
          searchParams: toUrlSearchParams({ arg: root2.toString() }),
          headers: options.headers
        });
        yield* res.iterator();
      }
      return dagExport;
    });
    init_cid();
    import_err_code5 = __toESM2(require_err_code(), 1);
    import_it_first = __toESM2(require_it_first(), 1);
    import_it_last = __toESM2(require_it_last(), 1);
    import_err_code6 = __toESM2(require_err_code(), 1);
    createGet3 = (codecs2, options) => {
      const fn = configure6((api, opts) => {
        const getBlock = createGet(opts);
        const get15 = async (cid, options2 = {}) => {
          if (options2.path) {
            const entry = options2.localResolve ? await (0, import_it_first.default)(resolve(cid, options2.path, codecs2, getBlock, options2)) : await (0, import_it_last.default)(resolve(cid, options2.path, codecs2, getBlock, options2));
            const result = entry;
            if (!result) {
              throw (0, import_err_code6.default)(new Error("Not found"), "ERR_NOT_FOUND");
            }
            return result;
          }
          const codec = await codecs2.getCodec(cid.code);
          const block = await getBlock(cid, options2);
          const node = codec.decode(block);
          return {
            value: node,
            remainderPath: ""
          };
        };
        return get15;
      });
      return fn(options);
    };
    init_cid();
    createImport = configure6((api) => {
      async function* dagImport(source, options = {}) {
        const controller = new AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const { headers, body } = await multipartRequest(source, controller, options.headers);
        const res = await api.post("dag/import", {
          signal,
          headers,
          body,
          searchParams: toUrlSearchParams({ "pin-roots": options.pinRoots })
        });
        for await (const { Root } of res.ndjson()) {
          if (Root !== void 0) {
            const {
              Cid: { "/": Cid },
              PinErrorMsg
            } = Root;
            yield {
              root: {
                cid: CID4.parse(Cid),
                pinErrorMsg: PinErrorMsg
              }
            };
          }
        }
      }
      return dagImport;
    });
    init_cid();
    createPut2 = (codecs2, options) => {
      const fn = configure6((api) => {
        const put2 = async (dagNode, options2 = {}) => {
          const settings = {
            storeCodec: "dag-cbor",
            hashAlg: "sha2-256",
            ...options2
          };
          let serialized;
          if (settings.inputCodec) {
            if (!(dagNode instanceof Uint8Array)) {
              throw new Error("Can only inputCodec on raw bytes that can be decoded");
            }
            serialized = dagNode;
          } else {
            const storeCodec = await codecs2.getCodec(settings.storeCodec);
            serialized = storeCodec.encode(dagNode);
            settings.inputCodec = settings.storeCodec;
          }
          const controller = new AbortController();
          const signal = abortSignal(controller.signal, settings.signal);
          const res = await api.post("dag/put", {
            timeout: settings.timeout,
            signal,
            searchParams: toUrlSearchParams(settings),
            ...await multipartRequest([serialized], controller, settings.headers)
          });
          const data = await res.json();
          return CID4.parse(data.Cid["/"]);
        };
        return put2;
      });
      return fn(options);
    };
    init_cid();
    createResolve = configure6((api) => {
      const resolve2 = async (ipfsPath, options = {}) => {
        const res = await api.post("dag/resolve", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${ipfsPath}${options.path ? `/${options.path}`.replace(/\/[/]+/g, "/") : ""}`,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return {
          cid: CID4.parse(data.Cid["/"]),
          remainderPath: data.RemPath
        };
      };
      return resolve2;
    });
    init_from_string();
    SendingQuery = 0;
    PeerResponse = 1;
    FinalPeer = 2;
    QueryError = 3;
    Provider = 4;
    Value = 5;
    AddingPeer = 6;
    DialingPeer = 7;
    import_multiaddr8 = __toESM2(require_src(), 1);
    mapEvent = (event) => {
      if (event.Type === SendingQuery) {
        return {
          to: event.ID,
          name: "SENDING_QUERY",
          type: event.Type
        };
      }
      if (event.Type === PeerResponse) {
        return {
          from: event.ID,
          name: "PEER_RESPONSE",
          type: event.Type,
          messageType: 0,
          messageName: "PUT_VALUE",
          closer: (event.Responses || []).map(({ ID: ID2, Addrs }) => ({
            id: ID2,
            multiaddrs: Addrs.map((addr) => new import_multiaddr8.Multiaddr(addr))
          })),
          providers: (event.Responses || []).map(({ ID: ID2, Addrs }) => ({
            id: ID2,
            multiaddrs: Addrs.map((addr) => new import_multiaddr8.Multiaddr(addr))
          }))
        };
      }
      if (event.Type === FinalPeer) {
        let peer = {
          id: event.ID,
          multiaddrs: []
        };
        if (event.Responses && event.Responses.length) {
          peer = {
            id: event.Responses[0].ID,
            multiaddrs: event.Responses[0].Addrs.map((addr) => new import_multiaddr8.Multiaddr(addr))
          };
        }
        return {
          from: event.ID,
          name: "FINAL_PEER",
          type: event.Type,
          peer
        };
      }
      if (event.Type === QueryError) {
        return {
          from: event.ID,
          name: "QUERY_ERROR",
          type: event.Type,
          error: new Error(event.Extra)
        };
      }
      if (event.Type === Provider) {
        return {
          from: event.ID,
          name: "PROVIDER",
          type: event.Type,
          providers: event.Responses.map(({ ID: ID2, Addrs }) => ({
            id: ID2,
            multiaddrs: Addrs.map((addr) => new import_multiaddr8.Multiaddr(addr))
          }))
        };
      }
      if (event.Type === Value) {
        return {
          from: event.ID,
          name: "VALUE",
          type: event.Type,
          value: fromString32(event.Extra, "base64pad")
        };
      }
      if (event.Type === AddingPeer) {
        const peers = event.Responses.map(({ ID: ID2 }) => ID2);
        if (!peers.length) {
          throw new Error("No peer found");
        }
        return {
          name: "ADDING_PEER",
          type: event.Type,
          peer: peers[0]
        };
      }
      if (event.Type === DialingPeer) {
        return {
          name: "DIALING_PEER",
          type: event.Type,
          peer: event.ID
        };
      }
      throw new Error("Unknown DHT event type");
    };
    createFindPeer = configure6((api) => {
      async function* findPeer(peerId, options = {}) {
        const res = await api.post("dht/findpeer", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: peerId,
            ...options
          }),
          headers: options.headers
        });
        for await (const event of res.ndjson()) {
          yield mapEvent(event);
        }
      }
      return findPeer;
    });
    createFindProvs = configure6((api) => {
      async function* findProvs(cid, options = {}) {
        const res = await api.post("dht/findprovs", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: cid.toString(),
            ...options
          }),
          headers: options.headers
        });
        for await (const event of res.ndjson()) {
          yield mapEvent(event);
        }
      }
      return findProvs;
    });
    init_to_string();
    createGet4 = configure6((api) => {
      async function* get15(key, options = {}) {
        const res = await api.post("dht/get", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: key instanceof Uint8Array ? toString32(key) : key.toString(),
            ...options
          }),
          headers: options.headers
        });
        for await (const event of res.ndjson()) {
          yield mapEvent(event);
        }
      }
      return get15;
    });
    createProvide = configure6((api) => {
      async function* provide(cids, options = { recursive: false }) {
        const cidArr = Array.isArray(cids) ? cids : [cids];
        const res = await api.post("dht/provide", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: cidArr.map((cid) => cid.toString()),
            ...options
          }),
          headers: options.headers
        });
        for await (const event of res.ndjson()) {
          yield mapEvent(event);
        }
      }
      return provide;
    });
    init_to_string();
    createPut3 = configure6((api) => {
      async function* put2(key, value, options = {}) {
        const controller = new AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const res = await api.post("dht/put", {
          signal,
          searchParams: toUrlSearchParams({
            arg: key instanceof Uint8Array ? toString32(key) : key.toString(),
            ...options
          }),
          ...await multipartRequest([value], controller, options.headers)
        });
        for await (const event of res.ndjson()) {
          yield mapEvent(event);
        }
      }
      return put2;
    });
    createQuery = configure6((api) => {
      async function* query(peerId, options = {}) {
        const res = await api.post("dht/query", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: peerId.toString(),
            ...options
          }),
          headers: options.headers
        });
        for await (const event of res.ndjson()) {
          yield mapEvent(event);
        }
      }
      return query;
    });
    createCmds = configure6((api) => {
      async function cmds(options = {}) {
        const res = await api.post("diag/cmds", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return res.json();
      }
      return cmds;
    });
    createNet = configure6((api) => {
      async function net(options = {}) {
        const res = await api.post("diag/net", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return res.json();
      }
      return net;
    });
    createSys = configure6((api) => {
      async function sys(options = {}) {
        const res = await api.post("diag/sys", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return res.json();
      }
      return sys;
    });
    createChmod = configure6((api) => {
      async function chmod(path, mode, options = {}) {
        const res = await api.post("files/chmod", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            mode,
            ...options
          }),
          headers: options.headers
        });
        await res.text();
      }
      return chmod;
    });
    init_cid();
    createCp = configure6((api) => {
      async function cp(sources, destination, options = {}) {
        const sourceArr = Array.isArray(sources) ? sources : [sources];
        const res = await api.post("files/cp", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: sourceArr.concat(destination).map((src22) => CID4.asCID(src22) ? `/ipfs/${src22}` : src22),
            ...options
          }),
          headers: options.headers
        });
        await res.text();
      }
      return cp;
    });
    init_cid();
    createFlush = configure6((api) => {
      async function flush3(path, options = {}) {
        if (!path || typeof path !== "string") {
          throw new Error("ipfs.files.flush requires a path");
        }
        const res = await api.post("files/flush", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return CID4.parse(data.Cid);
      }
      return flush3;
    });
    init_cid();
    createLs = configure6((api) => {
      async function* ls(path, options = {}) {
        if (!path) {
          throw new Error("ipfs.files.ls requires a path");
        }
        const res = await api.post("files/ls", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: CID4.asCID(path) ? `/ipfs/${path}` : path,
            long: true,
            ...options,
            stream: true
          }),
          headers: options.headers
        });
        for await (const result of res.ndjson()) {
          if ("Entries" in result) {
            for (const entry of result.Entries || []) {
              yield toCoreInterface3(objectToCamelWithMetadata(entry));
            }
          } else {
            yield toCoreInterface3(objectToCamelWithMetadata(result));
          }
        }
      }
      return ls;
    });
    createMkdir = configure6((api) => {
      async function mkdir(path, options = {}) {
        const res = await api.post("files/mkdir", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            ...options
          }),
          headers: options.headers
        });
        await res.text();
      }
      return mkdir;
    });
    createMv = configure6((api) => {
      async function mv(sources, destination, options = {}) {
        if (!Array.isArray(sources)) {
          sources = [sources];
        }
        const res = await api.post("files/mv", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: sources.concat(destination),
            ...options
          }),
          headers: options.headers
        });
        await res.text();
      }
      return mv;
    });
    import_source = __toESM2(require_source(), 1);
    createRead = configure6((api) => {
      async function* read22(path, options = {}) {
        const res = await api.post("files/read", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            count: options.length,
            ...options
          }),
          headers: options.headers
        });
        yield* (0, import_source.default)(res.body);
      }
      return read22;
    });
    import_http22 = __toESM2(require_http(), 1);
    createRm3 = configure6((api) => {
      async function rm(path, options = {}) {
        const res = await api.post("files/rm", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            ...options
          }),
          headers: options.headers
        });
        const body = await res.text();
        if (body !== "") {
          const error3 = new import_http22.default.HTTPError(res);
          error3.message = body;
          throw error3;
        }
      }
      return rm;
    });
    init_cid();
    createStat3 = configure6((api) => {
      async function stat(path, options = {}) {
        const res = await api.post("files/stat", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        data.WithLocality = data.WithLocality || false;
        return toCoreInterface4(objectToCamelWithMetadata(data));
      }
      return stat;
    });
    createTouch = configure6((api) => {
      async function touch(path, options = {}) {
        const res = await api.post("files/touch", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            ...options
          }),
          headers: options.headers
        });
        await res.text();
      }
      return touch;
    });
    createWrite = configure6((api) => {
      async function write8(path, input10, options = {}) {
        const controller = new AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const res = await api.post("files/write", {
          signal,
          searchParams: toUrlSearchParams({
            arg: path,
            streamChannels: true,
            count: options.length,
            ...options
          }),
          ...await multipartRequest([{
            content: input10,
            path: "arg",
            mode: modeToString(options.mode),
            mtime: parseMtime(options.mtime)
          }], controller, options.headers)
        });
        await res.text();
      }
      return write8;
    });
    import_err_code7 = __toESM2(require_err_code(), 1);
    createExport2 = configure6((api) => {
      const exportKey = async (name82, password, options = {}) => {
        throw (0, import_err_code7.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
      };
      return exportKey;
    });
    createGen = configure6((api) => {
      async function gen(name82, options = {
        type: "rsa",
        size: 2048
      }) {
        const res = await api.post("key/gen", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: name82,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return objectToCamel(data);
      }
      return gen;
    });
    createImport2 = configure6((api) => {
      async function importKey(name82, pem, password, options = {}) {
        const res = await api.post("key/import", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: name82,
            pem,
            password,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return objectToCamel(data);
      }
      return importKey;
    });
    import_err_code8 = __toESM2(require_err_code(), 1);
    createInfo = configure6((api) => {
      const info = async (name82, options = {}) => {
        throw (0, import_err_code8.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
      };
      return info;
    });
    createList3 = configure6((api) => {
      async function list7(options = {}) {
        const res = await api.post("key/list", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const data = await res.json();
        return (data.Keys || []).map((k) => objectToCamel(k));
      }
      return list7;
    });
    createRename = configure6((api) => {
      async function rename(oldName, newName, options = {}) {
        const res = await api.post("key/rename", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: [
              oldName,
              newName
            ],
            ...options
          }),
          headers: options.headers
        });
        return objectToCamel(await res.json());
      }
      return rename;
    });
    createRm4 = configure6((api) => {
      async function rm(name82, options = {}) {
        const res = await api.post("key/rm", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: name82,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return objectToCamel(data.Keys[0]);
      }
      return rm;
    });
    createLevel = configure6((api) => {
      async function level(subsystem, level2, options = {}) {
        const res = await api.post("log/level", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: [
              subsystem,
              level2
            ],
            ...options
          }),
          headers: options.headers
        });
        return objectToCamel(await res.json());
      }
      return level;
    });
    createLs2 = configure6((api) => {
      async function ls(options = {}) {
        const res = await api.post("log/ls", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const data = await res.json();
        return data.Strings;
      }
      return ls;
    });
    createTail = configure6((api) => {
      async function* tail(options = {}) {
        const res = await api.post("log/tail", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        yield* res.ndjson();
      }
      return tail;
    });
    createPublish = configure6((api) => {
      async function publish(path, options = {}) {
        const res = await api.post("name/publish", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${path}`,
            ...options
          }),
          headers: options.headers
        });
        return objectToCamel(await res.json());
      }
      return publish;
    });
    createResolve2 = configure6((api) => {
      async function* resolve2(path, options = {}) {
        const res = await api.post("name/resolve", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            stream: true,
            ...options
          }),
          headers: options.headers
        });
        for await (const result of res.ndjson()) {
          yield result.Path;
        }
      }
      return resolve2;
    });
    createCancel = configure6((api) => {
      async function cancel(name82, options = {}) {
        const res = await api.post("name/pubsub/cancel", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: name82,
            ...options
          }),
          headers: options.headers
        });
        return objectToCamel(await res.json());
      }
      return cancel;
    });
    createState = configure6((api) => {
      async function state(options = {}) {
        const res = await api.post("name/pubsub/state", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return objectToCamel(await res.json());
      }
      return state;
    });
    createSubs = configure6((api) => {
      async function subs(options = {}) {
        const res = await api.post("name/pubsub/subs", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const data = await res.json();
        return data.Strings || [];
      }
      return subs;
    });
    init_cid();
    createData = configure6((api) => {
      async function data(cid, options = {}) {
        const res = await api.post("object/data", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${cid instanceof Uint8Array ? CID4.decode(cid) : cid}`,
            ...options
          }),
          headers: options.headers
        });
        const data2 = await res.arrayBuffer();
        return new Uint8Array(data2, 0, data2.byteLength);
      }
      return data;
    });
    init_cid();
    init_from_string();
    createGet5 = configure6((api) => {
      async function get15(cid, options = {}) {
        const res = await api.post("object/get", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${cid instanceof Uint8Array ? CID4.decode(cid) : cid}`,
            dataEncoding: "base64",
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return {
          Data: fromString32(data.Data, "base64pad"),
          Links: (data.Links || []).map((link5) => ({
            Name: link5.Name,
            Hash: CID4.parse(link5.Hash),
            Tsize: link5.Size
          }))
        };
      }
      return get15;
    });
    init_cid();
    createLinks = configure6((api) => {
      async function links3(cid, options = {}) {
        const res = await api.post("object/links", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${cid instanceof Uint8Array ? CID4.decode(cid) : cid}`,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return (data.Links || []).map((l2) => ({
          Name: l2.Name,
          Tsize: l2.Size,
          Hash: CID4.parse(l2.Hash)
        }));
      }
      return links3;
    });
    init_cid();
    createNew = configure6((api) => {
      async function newObject(options = {}) {
        const res = await api.post("object/new", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: options.template,
            ...options
          }),
          headers: options.headers
        });
        const { Hash: Hash2 } = await res.json();
        return CID4.parse(Hash2);
      }
      return newObject;
    });
    createPut4 = (codecs2, options) => {
      const fn = configure6((api) => {
        const dagPut = createPut2(codecs2, options);
        async function put2(obj, options2 = {}) {
          return dagPut(obj, {
            ...options2,
            storeCodec: "dag-pb",
            hashAlg: "sha2-256",
            version: 1
          });
        }
        return put2;
      });
      return fn(options);
    };
    init_cid();
    createStat4 = configure6((api) => {
      async function stat(cid, options = {}) {
        const res = await api.post("object/stat", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${cid}`,
            ...options
          }),
          headers: options.headers
        });
        const output2 = await res.json();
        return {
          ...output2,
          Hash: CID4.parse(output2.Hash)
        };
      }
      return stat;
    });
    init_cid();
    createAddLink = configure6((api) => {
      async function addLink2(cid, dLink, options = {}) {
        const res = await api.post("object/patch/add-link", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: [
              `${cid}`,
              dLink.Name || dLink.name || "",
              (dLink.Hash || dLink.cid || "").toString() || null
            ],
            ...options
          }),
          headers: options.headers
        });
        const { Hash: Hash2 } = await res.json();
        return CID4.parse(Hash2);
      }
      return addLink2;
    });
    init_cid();
    createAppendData = configure6((api) => {
      async function appendData(cid, data, options = {}) {
        const controller = new AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const res = await api.post("object/patch/append-data", {
          signal,
          searchParams: toUrlSearchParams({
            arg: `${cid}`,
            ...options
          }),
          ...await multipartRequest([data], controller, options.headers)
        });
        const { Hash: Hash2 } = await res.json();
        return CID4.parse(Hash2);
      }
      return appendData;
    });
    init_cid();
    createRmLink = configure6((api) => {
      async function rmLink(cid, dLink, options = {}) {
        const res = await api.post("object/patch/rm-link", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: [
              `${cid}`,
              dLink.Name || dLink.name || null
            ],
            ...options
          }),
          headers: options.headers
        });
        const { Hash: Hash2 } = await res.json();
        return CID4.parse(Hash2);
      }
      return rmLink;
    });
    init_cid();
    createSetData = configure6((api) => {
      async function setData(cid, data, options = {}) {
        const controller = new AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const res = await api.post("object/patch/set-data", {
          signal,
          searchParams: toUrlSearchParams({
            arg: [`${cid}`],
            ...options
          }),
          ...await multipartRequest([data], controller, options.headers)
        });
        const { Hash: Hash2 } = await res.json();
        return CID4.parse(Hash2);
      }
      return setData;
    });
    init_cid();
    import_err_code9 = __toESM2(require_err_code(), 1);
    init_cid();
    createAddAll = configure6((api) => {
      async function* addAll(source, options = {}) {
        for await (const { path, recursive, metadata } of normaliseInput2(source)) {
          const res = await api.post("pin/add", {
            signal: options.signal,
            searchParams: toUrlSearchParams({
              ...options,
              arg: path,
              recursive,
              metadata: metadata ? JSON.stringify(metadata) : void 0,
              stream: true
            }),
            headers: options.headers
          });
          for await (const pin of res.ndjson()) {
            if (pin.Pins) {
              for (const cid of pin.Pins) {
                yield CID4.parse(cid);
              }
              continue;
            }
            yield CID4.parse(pin);
          }
        }
      }
      return addAll;
    });
    import_it_last2 = __toESM2(require_it_last(), 1);
    init_cid();
    createLs3 = configure6((api) => {
      async function* ls(options = {}) {
        let paths = [];
        if (options.paths) {
          paths = Array.isArray(options.paths) ? options.paths : [options.paths];
        }
        const res = await api.post("pin/ls", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            ...options,
            arg: paths.map((path) => `${path}`),
            stream: true
          }),
          headers: options.headers
        });
        for await (const pin of res.ndjson()) {
          if (pin.Keys) {
            for (const cid of Object.keys(pin.Keys)) {
              yield toPin2(pin.Keys[cid].Type, cid, pin.Keys[cid].Metadata);
            }
            return;
          }
          yield toPin2(pin.Type, pin.Cid, pin.Metadata);
        }
      }
      return ls;
    });
    init_cid();
    createRmAll = configure6((api) => {
      async function* rmAll(source, options = {}) {
        for await (const { path, recursive } of normaliseInput2(source)) {
          const searchParams = new URLSearchParams(options.searchParams);
          searchParams.append("arg", `${path}`);
          if (recursive != null)
            searchParams.set("recursive", String(recursive));
          const res = await api.post("pin/rm", {
            signal: options.signal,
            headers: options.headers,
            searchParams: toUrlSearchParams({
              ...options,
              arg: `${path}`,
              recursive
            })
          });
          for await (const pin of res.ndjson()) {
            if (pin.Pins) {
              yield* pin.Pins.map((cid) => CID4.parse(cid));
              continue;
            }
            yield CID4.parse(pin);
          }
        }
      }
      return rmAll;
    });
    import_it_last3 = __toESM2(require_it_last(), 1);
    createRm5 = (config2) => {
      const all22 = createRmAll(config2);
      return configure6(() => {
        async function rm(path, options = {}) {
          return (0, import_it_last3.default)(all22([{
            path,
            ...options
          }], options));
        }
        return rm;
      })(config2);
    };
    init_cid();
    decodePin = ({
      Name: name82,
      Status: status,
      Cid: cid
    }) => {
      return {
        cid: CID4.parse(cid),
        name: name82,
        status
      };
    };
    encodeService = (service) => {
      if (typeof service === "string" && service !== "") {
        return service;
      } else {
        throw new TypeError("service name must be passed");
      }
    };
    encodeCID22 = (cid) => {
      if (CID4.asCID(cid)) {
        return cid.toString();
      } else {
        throw new TypeError(`CID instance expected instead of ${typeof cid}`);
      }
    };
    encodeQuery = ({ service, cid, name: name82, status, all: all22 }) => {
      const query = toUrlSearchParams({
        service: encodeService(service),
        name: name82,
        force: all22 ? true : void 0
      });
      if (cid) {
        for (const value of cid) {
          query.append("cid", encodeCID22(value));
        }
      }
      if (status) {
        for (const value of status) {
          query.append("status", value);
        }
      }
      return query;
    };
    encodeAddParams = ({ cid, service, background, name: name82, origins }) => {
      const params = toUrlSearchParams({
        arg: encodeCID22(cid),
        service: encodeService(service),
        name: name82,
        background: background ? true : void 0
      });
      if (origins) {
        for (const origin2 of origins) {
          params.append("origin", origin2.toString());
        }
      }
      return params;
    };
    init_from_string();
    init_to_string();
    init_base64();
    rpcArrayToTextArray = (strings) => {
      if (Array.isArray(strings)) {
        return strings.map(rpcToText);
      }
      return strings;
    };
    rpcToText = (mb) => toString32(rpcToBytes(mb));
    rpcToBytes = (mb) => base64url3.decode(mb);
    textToUrlSafeRpc = (text2) => base64url3.encode(fromString32(text2));
    createLs6 = configure6((api) => {
      async function ls(options = {}) {
        const { Strings } = await (await api.post("pubsub/ls", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        })).json();
        return rpcArrayToTextArray(Strings) || [];
      }
      return ls;
    });
    createPeers = configure6((api) => {
      async function peers(topic, options = {}) {
        const res = await api.post("pubsub/peers", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: textToUrlSafeRpc(topic),
            ...options
          }),
          headers: options.headers
        });
        const { Strings } = await res.json();
        return Strings || [];
      }
      return peers;
    });
    createPublish2 = configure6((api) => {
      async function publish(topic, data, options = {}) {
        const searchParams = toUrlSearchParams({
          arg: textToUrlSafeRpc(topic),
          ...options
        });
        const controller = new AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const res = await api.post("pubsub/pub", {
          signal,
          searchParams,
          ...await multipartRequest([data], controller, options.headers)
        });
        await res.text();
      }
      return publish;
    });
    import_debug2 = __toESM2(require_browser(), 1);
    log2 = (0, import_debug2.default)("ipfs-http-client:pubsub:subscribe");
    createSubscribe = (options, subsTracker) => {
      return configure6((api) => {
        async function subscribe(topic, handler, options2 = {}) {
          options2.signal = subsTracker.subscribe(topic, handler, options2.signal);
          let done;
          let fail3;
          const result = new Promise((resolve2, reject) => {
            done = resolve2;
            fail3 = reject;
          });
          const ffWorkaround = setTimeout(() => done(), 1e3);
          api.post("pubsub/sub", {
            signal: options2.signal,
            searchParams: toUrlSearchParams({
              arg: textToUrlSafeRpc(topic),
              ...options2
            }),
            headers: options2.headers
          }).catch((err) => {
            subsTracker.unsubscribe(topic, handler);
            fail3(err);
          }).then((response) => {
            clearTimeout(ffWorkaround);
            if (!response) {
              return;
            }
            readMessages(response, {
              onMessage: handler,
              onEnd: () => subsTracker.unsubscribe(topic, handler),
              onError: options2.onError
            });
            done();
          });
          return result;
        }
        return subscribe;
      })(options);
    };
    isAbortError = (error3) => {
      switch (error3.type) {
        case "aborted":
          return true;
        case "abort":
          return true;
        default:
          return error3.name === "AbortError";
      }
    };
    createUnsubscribe = (options, subsTracker) => {
      async function unsubscribe(topic, handler) {
        subsTracker.unsubscribe(topic, handler);
      }
      return unsubscribe;
    };
    SubscriptionTracker = class {
      constructor() {
        this._subs = /* @__PURE__ */ new Map();
      }
      subscribe(topic, handler, signal) {
        const topicSubs = this._subs.get(topic) || [];
        if (topicSubs.find((s2) => s2.handler === handler)) {
          throw new Error(`Already subscribed to ${topic} with this handler`);
        }
        const controller = new AbortController();
        this._subs.set(topic, [{
          handler,
          controller
        }].concat(topicSubs));
        if (signal) {
          signal.addEventListener("abort", () => this.unsubscribe(topic, handler));
        }
        return controller.signal;
      }
      unsubscribe(topic, handler) {
        const subs = this._subs.get(topic) || [];
        let unsubs;
        if (handler) {
          this._subs.set(topic, subs.filter((s2) => s2.handler !== handler));
          unsubs = subs.filter((s2) => s2.handler === handler);
        } else {
          this._subs.set(topic, []);
          unsubs = subs;
        }
        if (!(this._subs.get(topic) || []).length) {
          this._subs.delete(topic);
        }
        unsubs.forEach((s2) => s2.controller.abort());
      }
    };
    init_cid();
    createLocal = configure6((api) => {
      async function* refsLocal(options = {}) {
        const res = await api.post("refs/local", {
          signal: options.signal,
          transform: objectToCamel,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        yield* res.ndjson();
      }
      return refsLocal;
    });
    createRefs = configure6((api, opts) => {
      const refs = async function* (args, options = {}) {
        const argsArr = Array.isArray(args) ? args : [args];
        const res = await api.post("refs", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: argsArr.map((arg) => `${arg instanceof Uint8Array ? CID4.decode(arg) : arg}`),
            ...options
          }),
          headers: options.headers,
          transform: objectToCamel
        });
        yield* res.ndjson();
      };
      return Object.assign(refs, { local: createLocal(opts) });
    });
    init_cid();
    createGc = configure6((api) => {
      async function* gc(options = {}) {
        const res = await api.post("repo/gc", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers,
          transform: (res2) => {
            return {
              err: res2.Error ? new Error(res2.Error) : null,
              cid: (res2.Key || {})["/"] ? CID4.parse(res2.Key["/"]) : null
            };
          }
        });
        yield* res.ndjson();
      }
      return gc;
    });
    createStat5 = configure6((api) => {
      async function stat(options = {}) {
        const res = await api.post("repo/stat", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const data = await res.json();
        return {
          numObjects: BigInt(data.NumObjects),
          repoSize: BigInt(data.RepoSize),
          repoPath: data.RepoPath,
          version: data.Version,
          storageMax: BigInt(data.StorageMax)
        };
      }
      return stat;
    });
    createVersion = configure6((api) => {
      async function version22(options = {}) {
        const res = await (await api.post("repo/version", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        })).json();
        return res.Version;
      }
      return version22;
    });
    createBw = configure6((api) => {
      async function* bw(options = {}) {
        const res = await api.post("stats/bw", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers,
          transform: (stats) => ({
            totalIn: BigInt(stats.TotalIn),
            totalOut: BigInt(stats.TotalOut),
            rateIn: parseFloat(stats.RateIn),
            rateOut: parseFloat(stats.RateOut)
          })
        });
        yield* res.ndjson();
      }
      return bw;
    });
    import_multiaddr9 = __toESM2(require_src(), 1);
    createAddrs = configure6((api) => {
      async function addrs(options = {}) {
        const res = await api.post("swarm/addrs", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const { Addrs } = await res.json();
        return Object.keys(Addrs).map((id) => ({
          id,
          addrs: (Addrs[id] || []).map((a) => new import_multiaddr9.Multiaddr(a))
        }));
      }
      return addrs;
    });
    createConnect = configure6((api) => {
      async function connect2(addr, options = {}) {
        const res = await api.post("swarm/connect", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: addr,
            ...options
          }),
          headers: options.headers
        });
        const { Strings } = await res.json();
        return Strings || [];
      }
      return connect2;
    });
    createDisconnect = configure6((api) => {
      async function disconnect(addr, options = {}) {
        const res = await api.post("swarm/disconnect", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: addr,
            ...options
          }),
          headers: options.headers
        });
        const { Strings } = await res.json();
        return Strings || [];
      }
      return disconnect;
    });
    import_multiaddr10 = __toESM2(require_src(), 1);
    createLocalAddrs = configure6((api) => {
      async function localAddrs(options = {}) {
        const res = await api.post("swarm/addrs/local", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const { Strings } = await res.json();
        return (Strings || []).map((a) => new import_multiaddr10.Multiaddr(a));
      }
      return localAddrs;
    });
    import_multiaddr11 = __toESM2(require_src(), 1);
    createPeers2 = configure6((api) => {
      async function peers(options = {}) {
        const res = await api.post("swarm/peers", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const { Peers } = await res.json();
        return (Peers || []).map((peer) => {
          return {
            addr: new import_multiaddr11.Multiaddr(peer.Addr),
            peer: peer.Peer,
            muxer: peer.Muxer,
            latency: peer.Latency,
            streams: peer.Streams,
            direction: peer.Direction == null ? void 0 : peer.Direction === 0 ? "inbound" : "outbound"
          };
        });
      }
      return peers;
    });
    init_cid();
    createAddAll2 = configure6((api) => {
      async function* addAll(source, options = {}) {
        const controller = new AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const { headers, body, total, parts } = await multipartRequest(source, controller, options.headers);
        const [progressFn, onUploadProgress] = typeof options.progress === "function" ? createProgressHandler(total, parts, options.progress) : [
          void 0,
          void 0
        ];
        const res = await api.post("add", {
          searchParams: toUrlSearchParams({
            "stream-channels": true,
            ...options,
            progress: Boolean(progressFn)
          }),
          onUploadProgress,
          signal,
          headers,
          body
        });
        for await (let file of res.ndjson()) {
          file = objectToCamel(file);
          if (file.hash !== void 0) {
            yield toCoreInterface5(file);
          } else if (progressFn) {
            progressFn(file.bytes || 0, file.name);
          }
        }
      }
      return addAll;
    });
    createProgressHandler = (total, parts, progress) => parts ? [
      void 0,
      createOnUploadProgress(total, parts, progress)
    ] : [
      progress,
      void 0
    ];
    createOnUploadProgress = (size5, parts, progress) => {
      let index2 = 0;
      const count = parts.length;
      return ({ loaded, total }) => {
        const position = Math.floor(loaded / total * size5);
        while (index2 < count) {
          const { start, end, name: name82 } = parts[index2];
          if (position < end) {
            progress(position - start, name82);
            break;
          } else {
            progress(end - start, name82);
            index2 += 1;
          }
        }
      };
    };
    import_it_last4 = __toESM2(require_it_last(), 1);
    import_err_code10 = __toESM2(require_err_code(), 1);
    import_browser_readablestream_to_it3 = __toESM2(require_browser_readablestream_to_it(), 1);
    import_it_peekable3 = __toESM2(require_it_peekable(), 1);
    createCat = configure6((api) => {
      async function* cat(path, options = {}) {
        const res = await api.post("cat", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path.toString(),
            ...options
          }),
          headers: options.headers
        });
        yield* res.iterator();
      }
      return cat;
    });
    createCommands = configure6((api) => {
      const commands = async (options = {}) => {
        const res = await api.post("commands", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return res.json();
      };
      return commands;
    });
    createDns = configure6((api) => {
      const dns = async (domain, options = {}) => {
        const res = await api.post("dns", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: domain,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return data.Path;
      };
      return dns;
    });
    createGetEndpointConfig = configure6((api) => {
      return () => {
        const url2 = new URL(api.opts.base || "");
        return {
          host: url2.hostname,
          port: url2.port,
          protocol: url2.protocol,
          pathname: url2.pathname,
          "api-path": url2.pathname
        };
      };
    });
    init_cid();
    createGet6 = configure6((api) => {
      async function* get15(path, options = {}) {
        const opts = {
          arg: `${path instanceof Uint8Array ? CID4.decode(path) : path}`,
          ...options
        };
        if (opts.compressionLevel) {
          opts["compression-level"] = opts.compressionLevel;
          delete opts.compressionLevel;
        }
        const res = await api.post("get", {
          signal: options.signal,
          searchParams: toUrlSearchParams(opts),
          headers: options.headers
        });
        yield* res.iterator();
      }
      return get15;
    });
    import_multiaddr12 = __toESM2(require_src(), 1);
    createId = configure6((api) => {
      async function id(options = {}) {
        const res = await api.post("id", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: options.peerId ? options.peerId.toString() : void 0,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        const output2 = { ...objectToCamel(data) };
        if (output2.addresses) {
          output2.addresses = output2.addresses.map((ma) => new import_multiaddr12.Multiaddr(ma));
        }
        return output2;
      }
      return id;
    });
    createIsOnline = (options) => {
      const id = createId(options);
      async function isOnline(options2 = {}) {
        const res = await id(options2);
        return Boolean(res && res.addresses && res.addresses.length);
      }
      return isOnline;
    };
    init_cid();
    createLs7 = configure6((api, opts) => {
      async function* ls(path, options = {}) {
        const pathStr = `${path instanceof Uint8Array ? CID4.decode(path) : path}`;
        async function mapLink(link5) {
          let hash = link5.Hash;
          if (hash.includes("/")) {
            const ipfsPath = hash.startsWith("/ipfs/") ? hash : `/ipfs/${hash}`;
            const stats = await createStat3(opts)(ipfsPath);
            hash = stats.cid;
          } else {
            hash = CID4.parse(hash);
          }
          const entry = {
            name: link5.Name,
            path: pathStr + (link5.Name ? `/${link5.Name}` : ""),
            size: link5.Size,
            cid: hash,
            type: typeOf(link5)
          };
          if (link5.Mode) {
            entry.mode = parseInt(link5.Mode, 8);
          }
          if (link5.Mtime !== void 0 && link5.Mtime !== null) {
            entry.mtime = { secs: link5.Mtime };
            if (link5.MtimeNsecs !== void 0 && link5.MtimeNsecs !== null) {
              entry.mtime.nsecs = link5.MtimeNsecs;
            }
          }
          return entry;
        }
        const res = await api.post("ls", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: pathStr,
            ...options
          }),
          headers: options.headers
        });
        for await (let result of res.ndjson()) {
          result = result.Objects;
          if (!result) {
            throw new Error("expected .Objects in results");
          }
          result = result[0];
          if (!result) {
            throw new Error("expected one array in results.Objects");
          }
          const links3 = result.Links;
          if (!Array.isArray(links3)) {
            throw new Error("expected one array in results.Objects[0].Links");
          }
          if (!links3.length) {
            yield mapLink(result);
            return;
          }
          yield* links3.map(mapLink);
        }
      }
      return ls;
    });
    createMount = configure6((api) => {
      async function mount(options = {}) {
        const res = await api.post("dns", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return objectToCamel(await res.json());
      }
      return mount;
    });
    createPing = configure6((api) => {
      async function* ping(peerId, options = {}) {
        const res = await api.post("ping", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${peerId}`,
            ...options
          }),
          headers: options.headers,
          transform: objectToCamel
        });
        yield* res.ndjson();
      }
      return ping;
    });
    createResolve3 = configure6((api) => {
      async function resolve2(path, options = {}) {
        const res = await api.post("resolve", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            ...options
          }),
          headers: options.headers
        });
        const { Path } = await res.json();
        return Path;
      }
      return resolve2;
    });
    import_err_code11 = __toESM2(require_err_code(), 1);
    createStart = configure6((api) => {
      const start = async (options = {}) => {
        throw (0, import_err_code11.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
      };
      return start;
    });
    createStop = configure6((api) => {
      async function stop(options = {}) {
        const res = await api.post("shutdown", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        await res.text();
      }
      return stop;
    });
    createVersion2 = configure6((api) => {
      async function version22(options = {}) {
        const res = await api.post("version", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return {
          ...objectToCamel(await res.json()),
          "ipfs-http-client": "1.0.0"
        };
      }
      return version22;
    });
    import_glob_source = __toESM2(require_glob_source(), 1);
    init_cid();
    import_multiaddr13 = __toESM2(require_src(), 1);
    import_url_source = __toESM2(require_url_source(), 1);
    globSource = import_glob_source.default;
    export_multiaddr = import_multiaddr13.Multiaddr;
    export_urlSource = import_url_source.default;
  }
});

// node_modules/@fleek-platform/sdk/dist/browser/src-VATP7N4C.js
var src_VATP7N4C_exports = {};
__export(src_VATP7N4C_exports, {
  Blob: () => blob_exports3,
  CAR: () => car_exports3,
  Index: () => index_exports2,
  Receipt: () => receipts_exports,
  ShardingStream: () => ShardingStream,
  Store: () => store_exports,
  UnixFS: () => unixfs_exports3,
  Upload: () => upload_exports2,
  defaultFileComparator: () => defaultFileComparator,
  receiptsEndpoint: () => receiptsEndpoint,
  uploadCAR: () => uploadCAR,
  uploadDirectory: () => uploadDirectory,
  uploadFile: () => uploadFile
});
var init_src_VATP7N4C = __esm({
  "node_modules/@fleek-platform/sdk/dist/browser/src-VATP7N4C.js"() {
    init_process_shim();
    init_chunk_BOSPY7YV();
    init_chunk_UHP4SR3D();
    init_chunk_77WUQNS7();
    init_chunk_DNE4QC7K();
  }
});

// node_modules/parallel-transform-web/index.js
var parallel_transform_web_exports = {};
__export(parallel_transform_web_exports, {
  Parallel: () => Parallel
});
var Parallel;
var init_parallel_transform_web = __esm({
  "node_modules/parallel-transform-web/index.js"() {
    init_process_shim();
    Parallel = class extends TransformStream {
      /**
       * @param {number} concurrency
       * @param {(input: I) => Promise<O>} transformer
       * @param {QueuingStrategy<I>} [writableStrategy]
       * @param {QueuingStrategy<O>} [readableStrategy]
       */
      constructor(concurrency, transformer, writableStrategy, readableStrategy) {
        let pending = 0;
        let onNext = null;
        let onIdle = null;
        super({
          transform(input10, controller) {
            pending++;
            transformer(input10).then((value) => {
              controller.enqueue(value);
              pending--;
              if (onNext) {
                onNext();
                onNext = null;
              }
              if (pending === 0 && onIdle) {
                return onIdle();
              }
            }).catch((error3) => controller.error(error3));
            if (pending === concurrency) {
              return new Promise((resolve2) => {
                onNext = resolve2;
              });
            }
          },
          flush() {
            if (pending !== 0) {
              return new Promise((resolve2) => {
                onIdle = resolve2;
              });
            }
          }
        }, writableStrategy, readableStrategy);
      }
    };
  }
});

// node_modules/dotenv/package.json
var require_package = __commonJS({
  "node_modules/dotenv/package.json"(exports2, module2) {
    module2.exports = {
      name: "dotenv",
      version: "16.4.5",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          types: "./lib/main.d.ts",
          require: "./lib/main.js",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        "lint-readme": "standard-markdown",
        pretest: "npm run lint && npm run dts-check",
        test: "tap tests/*.js --100 -Rspec",
        "test:coverage": "tap --coverage-report=lcov",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      funding: "https://dotenvx.com",
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@definitelytyped/dtslint": "^0.0.133",
        "@types/node": "^18.11.3",
        decache: "^4.6.1",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-markdown": "^7.1.0",
        "standard-version": "^9.5.0",
        tap: "^16.3.0",
        tar: "^6.1.11",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=12"
      },
      browser: {
        fs: false
      }
    };
  }
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/dotenv/lib/main.js"(exports2, module2) {
    init_process_shim();
    var fs = __require("fs");
    var path = __require("path");
    var os = __require("os");
    var crypto3 = __require("crypto");
    var packageJson = require_package();
    var version3 = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse10(src5) {
      const obj = {};
      let lines = src5.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match6;
      while ((match6 = LINE.exec(lines)) != null) {
        const key = match6[1];
        let value = match6[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _parseVault(options) {
      const vaultPath = _vaultPath(options);
      const result = DotenvModule.configDotenv({ path: vaultPath });
      if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = "MISSING_DATA";
        throw err;
      }
      const keys2 = _dotenvKey(options).split(",");
      const length5 = keys2.length;
      let decrypted;
      for (let i = 0; i < length5; i++) {
        try {
          const key = keys2[i].trim();
          const attrs = _instructions(result, key);
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error3) {
          if (i + 1 >= length5) {
            throw error3;
          }
        }
      }
      return DotenvModule.parse(decrypted);
    }
    function _log(message2) {
      console.log(`[dotenv@${version3}][INFO] ${message2}`);
    }
    function _warn(message2) {
      console.log(`[dotenv@${version3}][WARN] ${message2}`);
    }
    function _debug(message2) {
      console.log(`[dotenv@${version3}][DEBUG] ${message2}`);
    }
    function _dotenvKey(options) {
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    function _instructions(result, dotenvKey) {
      let uri2;
      try {
        uri2 = new URL(dotenvKey);
      } catch (error3) {
        if (error3.code === "ERR_INVALID_URL") {
          const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        throw error3;
      }
      const key = uri2.password;
      if (!key) {
        const err = new Error("INVALID_DOTENV_KEY: Missing key part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environment = uri2.searchParams.get("environment");
      if (!environment) {
        const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey];
      if (!ciphertext) {
        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
        throw err;
      }
      return { ciphertext, key };
    }
    function _vaultPath(options) {
      let possibleVaultPath = null;
      if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
          for (const filepath of options.path) {
            if (fs.existsSync(filepath)) {
              possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
            }
          }
        } else {
          possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
        }
      } else {
        possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
      }
      if (fs.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
      }
      return null;
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
      _log("Loading env from encrypted .env.vault");
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    }
    function configDotenv(options) {
      const dotenvPath = path.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug = Boolean(options && options.debug);
      if (options && options.encoding) {
        encoding = options.encoding;
      } else {
        if (debug) {
          _debug("No encoding is specified. UTF-8 is used by default");
        }
      }
      let optionPaths = [dotenvPath];
      if (options && options.path) {
        if (!Array.isArray(options.path)) {
          optionPaths = [_resolveHome(options.path)];
        } else {
          optionPaths = [];
          for (const filepath of options.path) {
            optionPaths.push(_resolveHome(filepath));
          }
        }
      }
      let lastError;
      const parsedAll = {};
      for (const path2 of optionPaths) {
        try {
          const parsed = DotenvModule.parse(fs.readFileSync(path2, { encoding }));
          DotenvModule.populate(parsedAll, parsed, options);
        } catch (e) {
          if (debug) {
            _debug(`Failed to load ${path2} ${e.message}`);
          }
          lastError = e;
        }
      }
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsedAll, options);
      if (lastError) {
        return { parsed: parsedAll, error: lastError };
      } else {
        return { parsed: parsedAll };
      }
    }
    function config2(options) {
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      const vaultPath = _vaultPath(options);
      if (!vaultPath) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    function decrypt4(encrypted, keyStr) {
      const key = Buffer.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer.from(encrypted, "base64");
      const nonce = ciphertext.subarray(0, 12);
      const authTag = ciphertext.subarray(-16);
      ciphertext = ciphertext.subarray(12, -16);
      try {
        const aesgcm = crypto3.createDecipheriv("aes-256-gcm", key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error3) {
        const isRange = error3 instanceof RangeError;
        const invalidKeyLength = error3.message === "Invalid key length";
        const decryptionFailed = error3.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        } else if (decryptionFailed) {
          const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          err.code = "DECRYPTION_FAILED";
          throw err;
        } else {
          throw error3;
        }
      }
    }
    function populate(processEnv, parsed, options = {}) {
      const debug = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (typeof parsed !== "object") {
        const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        err.code = "OBJECT_REQUIRED";
        throw err;
      }
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
          }
          if (debug) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
        }
      }
    }
    var DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config: config2,
      decrypt: decrypt4,
      parse: parse10,
      populate
    };
    module2.exports.configDotenv = DotenvModule.configDotenv;
    module2.exports._configVault = DotenvModule._configVault;
    module2.exports._parseVault = DotenvModule._parseVault;
    module2.exports.config = DotenvModule.config;
    module2.exports.decrypt = DotenvModule.decrypt;
    module2.exports.parse = DotenvModule.parse;
    module2.exports.populate = DotenvModule.populate;
    module2.exports = DotenvModule;
  }
});

// main.js
init_process_shim();

// test.js
init_process_shim();

// node_modules/@fleek-platform/sdk/dist/browser/index.js
init_process_shim();
init_chunk_BOSPY7YV();
init_chunk_UHP4SR3D();
init_chunk_77WUQNS7();
init_chunk_DNE4QC7K();

// node_modules/@web-std/file/src/lib.node.js
init_process_shim();

// node_modules/@web-std/file/src/package.js
init_process_shim();

// node_modules/@web-std/blob/src/lib.node.js
init_process_shim();

// node_modules/@web-std/blob/src/package.js
init_process_shim();

// node_modules/web-encoding/src/lib.mjs
init_process_shim();
var Encoder4 = TextEncoder;
var Decoder4 = TextDecoder;

// node_modules/@web-std/stream/src/lib.node.js
init_process_shim();
var import_stream = __toESM(require_stream(), 1);
var {
  ReadableStream: ReadableStream2,
  ReadableStreamDefaultReader,
  ReadableStreamBYOBReader,
  ReadableStreamBYOBRequest,
  ReadableByteStreamController,
  ReadableStreamDefaultController,
  TransformStream: TransformStream2,
  TransformStreamDefaultController,
  WritableStream: WritableStream2,
  WritableStreamDefaultWriter,
  WritableStreamDefaultController,
  ByteLengthQueuingStrategy,
  CountQueuingStrategy: CountQueuingStrategy2,
  TextEncoderStream,
  TextDecoderStream
} = import_stream.default;

// node_modules/@web-std/blob/src/blob.js
init_process_shim();
var WebBlob = class Blob2 {
  /**
   * @param {BlobPart[]} [init]
   * @param {BlobPropertyBag} [options]
   */
  constructor(init2 = [], options = {}) {
    const parts = [];
    let size5 = 0;
    for (const part of init2) {
      if (typeof part === "string") {
        const bytes3 = new Encoder4().encode(part);
        parts.push(bytes3);
        size5 += bytes3.byteLength;
      } else if (part instanceof WebBlob) {
        size5 += part.size;
        parts.push(...part._parts);
      } else if (part instanceof ArrayBuffer) {
        parts.push(new Uint8Array(part));
        size5 += part.byteLength;
      } else if (part instanceof Uint8Array) {
        parts.push(part);
        size5 += part.byteLength;
      } else if (ArrayBuffer.isView(part)) {
        const { buffer: buffer3, byteOffset, byteLength } = part;
        parts.push(new Uint8Array(buffer3, byteOffset, byteLength));
        size5 += byteLength;
      } else {
        const bytes3 = new Encoder4().encode(String(part));
        parts.push(bytes3);
        size5 += bytes3.byteLength;
      }
    }
    this._size = size5;
    this._type = readType(options.type);
    this._parts = parts;
    Object.defineProperties(this, {
      _size: { enumerable: false },
      _type: { enumerable: false },
      _parts: { enumerable: false }
    });
  }
  /**
   * A string indicating the MIME type of the data contained in the Blob.
   * If the type is unknown, this string is empty.
   * @type {string}
   */
  get type() {
    return this._type;
  }
  /**
   * The size, in bytes, of the data contained in the Blob object.
   * @type {number}
   */
  get size() {
    return this._size;
  }
  /**
   * Returns a new Blob object containing the data in the specified range of
   * bytes of the blob on which it's called.
   * @param {number} [start=0] - An index into the Blob indicating the first
   * byte to include in the new Blob. If you specify a negative value, it's
   * treated as an offset from the end of the Blob toward the beginning. For
   * example, `-10` would be the 10th from last byte in the Blob. The default
   * value is `0`. If you specify a value for start that is larger than the
   * size of the source Blob, the returned Blob has size 0 and contains no
   * data.
   * @param {number} [end] - An index into the `Blob` indicating the first byte
   *  that will *not* be included in the new `Blob` (i.e. the byte exactly at
   * this index is not included). If you specify a negative value, it's treated
   * as an offset from the end of the Blob toward the beginning. For example,
   * `-10` would be the 10th from last byte in the `Blob`. The default value is
   * size.
   * @param {string} [type] - The content type to assign to the new Blob;
   * this will be the value of its type property. The default value is an empty
   * string.
   * @returns {Blob}
   */
  slice(start = 0, end = this.size, type2 = "") {
    const { size: size5, _parts } = this;
    let offset3 = start < 0 ? Math.max(size5 + start, 0) : Math.min(start, size5);
    let limit = end < 0 ? Math.max(size5 + end, 0) : Math.min(end, size5);
    const span = Math.max(limit - offset3, 0);
    const blob3 = new Blob2([], { type: type2 });
    if (span === 0) {
      return blob3;
    }
    let blobSize = 0;
    const blobParts = [];
    for (const part of _parts) {
      const { byteLength } = part;
      if (offset3 > 0 && byteLength <= offset3) {
        offset3 -= byteLength;
        limit -= byteLength;
      } else {
        const chunk = part.subarray(offset3, Math.min(byteLength, limit));
        blobParts.push(chunk);
        blobSize += chunk.byteLength;
        offset3 = 0;
        if (blobSize >= span) {
          break;
        }
      }
    }
    blob3._parts = blobParts;
    blob3._size = blobSize;
    return blob3;
  }
  /**
   * Returns a promise that resolves with an ArrayBuffer containing the entire
   * contents of the Blob as binary data.
   * @returns {Promise<ArrayBuffer>}
   */
  // eslint-disable-next-line require-await
  async arrayBuffer() {
    const buffer3 = new ArrayBuffer(this.size);
    const bytes3 = new Uint8Array(buffer3);
    let offset3 = 0;
    for (const part of this._parts) {
      bytes3.set(part, offset3);
      offset3 += part.byteLength;
    }
    return buffer3;
  }
  /**
   * Returns a promise that resolves with a USVString containing the entire
   * contents of the Blob interpreted as UTF-8 text.
   * @returns {Promise<string>}
   */
  // eslint-disable-next-line require-await
  async text() {
    const decoder4 = new Decoder4();
    let text2 = "";
    for (const part of this._parts) {
      text2 += decoder4.decode(part);
    }
    return text2;
  }
  /**
   * @returns {BlobStream}
   */
  stream() {
    return new BlobStream(this._parts);
  }
  /**
   * @returns {string}
   */
  toString() {
    return "[object Blob]";
  }
  get [Symbol.toStringTag]() {
    return "Blob";
  }
};
var Blob3 = WebBlob;
var BlobStream = class extends ReadableStream2 {
  /**
   * @param {Uint8Array[]} chunks
   */
  constructor(chunks) {
    super(new BlobStreamController(chunks.values()), { type: "bytes" });
    this._chunks = chunks;
  }
  /**
   * @param {Object} [_options]
   * @property {boolean} [_options.preventCancel]
   * @returns {AsyncIterator<Uint8Array>}
   */
  async *[Symbol.asyncIterator](_options2) {
    const reader = this.getReader();
    yield* this._chunks;
    reader.releaseLock();
  }
};
var BlobStreamController = class {
  /**
   * @param {Iterator<Uint8Array>} chunks
   */
  constructor(chunks) {
    this.chunks = chunks;
  }
  /**
   * @param {ReadableStreamDefaultController} controller
   */
  start(controller) {
    this.work(controller);
    this.isWorking = false;
    this.isCancelled = false;
  }
  /**
   *
   * @param {ReadableStreamDefaultController} controller
   */
  async work(controller) {
    const { chunks } = this;
    this.isWorking = true;
    while (!this.isCancelled && (controller.desiredSize || 0) > 0) {
      let next = null;
      try {
        next = chunks.next();
      } catch (error3) {
        controller.error(error3);
        break;
      }
      if (next) {
        if (!next.done && !this.isCancelled) {
          controller.enqueue(next.value);
        } else {
          controller.close();
        }
      }
    }
    this.isWorking = false;
  }
  /**
   * @param {ReadableStreamDefaultController} controller
   */
  pull(controller) {
    if (!this.isWorking) {
      this.work(controller);
    }
  }
  cancel() {
    this.isCancelled = true;
  }
};
var readType = (input10 = "") => {
  const type2 = String(input10).toLowerCase();
  return /[^\u0020-\u007E]/.test(type2) ? "" : type2;
};

// node_modules/@web-std/blob/src/lib.node.js
var Blob4 = globalThis.Blob || // Disable node native blob until impractical perf issue is fixed
// @see https://github.com/nodejs/node/issues/42108
// NodeBlob ||
Blob3;

// node_modules/@web-std/file/src/file.js
init_process_shim();
var File2 = class extends Blob4 {
  /**
   *
   * @param {BlobPart[]} init
   * @param {string} name - A USVString representing the file name or the path
   * to the file.
   * @param {FilePropertyBag} [options]
   */
  constructor(init2, name15 = panic3(new TypeError("File constructor requires name argument")), options = {}) {
    super(init2, options);
    this._name = name15;
    this._lastModified = options.lastModified || Date.now();
  }
  /**
   * The name of the file referenced by the File object.
   * @type {string}
   */
  get name() {
    return this._name;
  }
  /**
   * The path the URL of the File is relative to.
   * @type {string}
   */
  get webkitRelativePath() {
    return "";
  }
  /**
   * Returns the last modified time of the file, in millisecond since the UNIX
   * epoch (January 1st, 1970 at Midnight).
   * @returns {number}
   */
  get lastModified() {
    return this._lastModified;
  }
  get [Symbol.toStringTag]() {
    return "File";
  }
};
var panic3 = (error3) => {
  throw error3;
};

// node_modules/@web-std/file/src/lib.node.js
var File3 = typeof globalThis.File === "function" ? globalThis.File : File2;

// node_modules/@noble/hashes/esm/blake3.js
init_process_shim();
init_assert();

// node_modules/@noble/hashes/esm/_u64.js
init_process_shim();
var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n2, le = false) {
  if (le)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}

// node_modules/@noble/hashes/esm/_blake.js
init_process_shim();
init_assert();
init_utils();
var BLAKE = class extends Hash {
  constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.length = 0;
    this.pos = 0;
    this.finished = false;
    this.destroyed = false;
    number(blockLen);
    number(outputLen);
    number(keyLen);
    if (outputLen < 0 || outputLen > keyLen)
      throw new Error("outputLen bigger than keyLen");
    if (opts.key !== void 0 && (opts.key.length < 1 || opts.key.length > keyLen))
      throw new Error(`key must be up 1..${keyLen} byte long or undefined`);
    if (opts.salt !== void 0 && opts.salt.length !== saltLen)
      throw new Error(`salt must be ${saltLen} byte long or undefined`);
    if (opts.personalization !== void 0 && opts.personalization.length !== persLen)
      throw new Error(`personalization must be ${persLen} byte long or undefined`);
    this.buffer32 = u32(this.buffer = new Uint8Array(blockLen));
  }
  update(data) {
    exists(this);
    const { blockLen, buffer: buffer3, buffer32 } = this;
    data = toBytes(data);
    const len = data.length;
    const offset3 = data.byteOffset;
    const buf3 = data.buffer;
    for (let pos = 0; pos < len; ) {
      if (this.pos === blockLen) {
        if (!isLE)
          byteSwap32(buffer32);
        this.compress(buffer32, 0, false);
        if (!isLE)
          byteSwap32(buffer32);
        this.pos = 0;
      }
      const take = Math.min(blockLen - this.pos, len - pos);
      const dataOffset = offset3 + pos;
      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
        const data32 = new Uint32Array(buf3, dataOffset, Math.floor((len - pos) / 4));
        if (!isLE)
          byteSwap32(data32);
        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
          this.length += blockLen;
          this.compress(data32, pos32, false);
        }
        if (!isLE)
          byteSwap32(data32);
        continue;
      }
      buffer3.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      this.length += take;
      pos += take;
    }
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    const { pos, buffer32 } = this;
    this.finished = true;
    this.buffer.subarray(pos).fill(0);
    if (!isLE)
      byteSwap32(buffer32);
    this.compress(buffer32, 0, true);
    if (!isLE)
      byteSwap32(buffer32);
    const out32 = u32(out);
    this.get().forEach((v, i) => out32[i] = byteSwapIfBE(v));
  }
  digest() {
    const { buffer: buffer3, outputLen } = this;
    this.digestInto(buffer3);
    const res = buffer3.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    const { buffer: buffer3, length: length5, finished, destroyed, outputLen, pos } = this;
    to || (to = new this.constructor({ dkLen: outputLen }));
    to.set(...this.get());
    to.length = length5;
    to.finished = finished;
    to.destroyed = destroyed;
    to.outputLen = outputLen;
    to.buffer.set(buffer3);
    to.pos = pos;
    return to;
  }
};

// node_modules/@noble/hashes/esm/blake2s.js
init_process_shim();
init_utils();
var B2S_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
function G1s(a, b, c, d, x) {
  a = a + b + x | 0;
  d = rotr(d ^ a, 16);
  c = c + d | 0;
  b = rotr(b ^ c, 12);
  return { a, b, c, d };
}
function G2s(a, b, c, d, x) {
  a = a + b + x | 0;
  d = rotr(d ^ a, 8);
  c = c + d | 0;
  b = rotr(b ^ c, 7);
  return { a, b, c, d };
}
function compress(s2, offset3, msg, rounds, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {
  let j = 0;
  for (let i = 0; i < rounds; i++) {
    ({ a: v0, b: v4, c: v8, d: v12 } = G1s(v0, v4, v8, v12, msg[offset3 + s2[j++]]));
    ({ a: v0, b: v4, c: v8, d: v12 } = G2s(v0, v4, v8, v12, msg[offset3 + s2[j++]]));
    ({ a: v1, b: v5, c: v9, d: v13 } = G1s(v1, v5, v9, v13, msg[offset3 + s2[j++]]));
    ({ a: v1, b: v5, c: v9, d: v13 } = G2s(v1, v5, v9, v13, msg[offset3 + s2[j++]]));
    ({ a: v2, b: v6, c: v10, d: v14 } = G1s(v2, v6, v10, v14, msg[offset3 + s2[j++]]));
    ({ a: v2, b: v6, c: v10, d: v14 } = G2s(v2, v6, v10, v14, msg[offset3 + s2[j++]]));
    ({ a: v3, b: v7, c: v11, d: v15 } = G1s(v3, v7, v11, v15, msg[offset3 + s2[j++]]));
    ({ a: v3, b: v7, c: v11, d: v15 } = G2s(v3, v7, v11, v15, msg[offset3 + s2[j++]]));
    ({ a: v0, b: v5, c: v10, d: v15 } = G1s(v0, v5, v10, v15, msg[offset3 + s2[j++]]));
    ({ a: v0, b: v5, c: v10, d: v15 } = G2s(v0, v5, v10, v15, msg[offset3 + s2[j++]]));
    ({ a: v1, b: v6, c: v11, d: v12 } = G1s(v1, v6, v11, v12, msg[offset3 + s2[j++]]));
    ({ a: v1, b: v6, c: v11, d: v12 } = G2s(v1, v6, v11, v12, msg[offset3 + s2[j++]]));
    ({ a: v2, b: v7, c: v8, d: v13 } = G1s(v2, v7, v8, v13, msg[offset3 + s2[j++]]));
    ({ a: v2, b: v7, c: v8, d: v13 } = G2s(v2, v7, v8, v13, msg[offset3 + s2[j++]]));
    ({ a: v3, b: v4, c: v9, d: v14 } = G1s(v3, v4, v9, v14, msg[offset3 + s2[j++]]));
    ({ a: v3, b: v4, c: v9, d: v14 } = G2s(v3, v4, v9, v14, msg[offset3 + s2[j++]]));
  }
  return { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 };
}

// node_modules/@noble/hashes/esm/blake3.js
init_utils();
var SIGMA = /* @__PURE__ */ (() => {
  const Id = Array.from({ length: 16 }, (_, i) => i);
  const permute = (arr) => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i) => arr[i]);
  const res = [];
  for (let i = 0, v = Id; i < 7; i++, v = permute(v))
    res.push(...v);
  return Uint8Array.from(res);
})();
var BLAKE3 = class _BLAKE3 extends BLAKE {
  constructor(opts = {}, flags = 0) {
    super(64, opts.dkLen === void 0 ? 32 : opts.dkLen, {}, Number.MAX_SAFE_INTEGER, 0, 0);
    this.flags = 0 | 0;
    this.chunkPos = 0;
    this.chunksDone = 0;
    this.stack = [];
    this.posOut = 0;
    this.bufferOut32 = new Uint32Array(16);
    this.chunkOut = 0;
    this.enableXOF = true;
    this.outputLen = opts.dkLen === void 0 ? 32 : opts.dkLen;
    number(this.outputLen);
    if (opts.key !== void 0 && opts.context !== void 0)
      throw new Error("Blake3: only key or context can be specified at same time");
    else if (opts.key !== void 0) {
      const key = toBytes(opts.key).slice();
      if (key.length !== 32)
        throw new Error("Blake3: key should be 32 byte");
      this.IV = u32(key);
      if (!isLE)
        byteSwap32(this.IV);
      this.flags = flags | 16;
    } else if (opts.context !== void 0) {
      const context_key = new _BLAKE3(
        { dkLen: 32 },
        32
        /* B3_Flags.DERIVE_KEY_CONTEXT */
      ).update(opts.context).digest();
      this.IV = u32(context_key);
      if (!isLE)
        byteSwap32(this.IV);
      this.flags = flags | 64;
    } else {
      this.IV = B2S_IV.slice();
      this.flags = flags;
    }
    this.state = this.IV.slice();
    this.bufferOut = u8(this.bufferOut32);
  }
  // Unused
  get() {
    return [];
  }
  set() {
  }
  b2Compress(counter, flags, buf3, bufPos = 0) {
    const { state: s2, pos } = this;
    const { h, l: l2 } = fromBig(BigInt(counter), true);
    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress(SIGMA, bufPos, buf3, 7, s2[0], s2[1], s2[2], s2[3], s2[4], s2[5], s2[6], s2[7], B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], h, l2, pos, flags);
    s2[0] = v0 ^ v8;
    s2[1] = v1 ^ v9;
    s2[2] = v2 ^ v10;
    s2[3] = v3 ^ v11;
    s2[4] = v4 ^ v12;
    s2[5] = v5 ^ v13;
    s2[6] = v6 ^ v14;
    s2[7] = v7 ^ v15;
  }
  compress(buf3, bufPos = 0, isLast = false) {
    let flags = this.flags;
    if (!this.chunkPos)
      flags |= 1;
    if (this.chunkPos === 15 || isLast)
      flags |= 2;
    if (!isLast)
      this.pos = this.blockLen;
    this.b2Compress(this.chunksDone, flags, buf3, bufPos);
    this.chunkPos += 1;
    if (this.chunkPos === 16 || isLast) {
      let chunk = this.state;
      this.state = this.IV.slice();
      for (let last, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {
        if (!(last = this.stack.pop()))
          break;
        this.buffer32.set(last, 0);
        this.buffer32.set(chunk, 8);
        this.pos = this.blockLen;
        this.b2Compress(0, this.flags | 4, this.buffer32, 0);
        chunk = this.state;
        this.state = this.IV.slice();
      }
      this.chunksDone++;
      this.chunkPos = 0;
      this.stack.push(chunk);
    }
    this.pos = 0;
  }
  _cloneInto(to) {
    to = super._cloneInto(to);
    const { IV, flags, state, chunkPos, posOut, chunkOut, stack, chunksDone } = this;
    to.state.set(state.slice());
    to.stack = stack.map((i) => Uint32Array.from(i));
    to.IV.set(IV);
    to.flags = flags;
    to.chunkPos = chunkPos;
    to.chunksDone = chunksDone;
    to.posOut = posOut;
    to.chunkOut = chunkOut;
    to.enableXOF = this.enableXOF;
    to.bufferOut32.set(this.bufferOut32);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
    this.buffer32.fill(0);
    this.IV.fill(0);
    this.bufferOut32.fill(0);
    for (let i of this.stack)
      i.fill(0);
  }
  // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)
  b2CompressOut() {
    const { state: s2, pos, flags, buffer32, bufferOut32: out32 } = this;
    const { h, l: l2 } = fromBig(BigInt(this.chunkOut++));
    if (!isLE)
      byteSwap32(buffer32);
    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress(SIGMA, 0, buffer32, 7, s2[0], s2[1], s2[2], s2[3], s2[4], s2[5], s2[6], s2[7], B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], l2, h, pos, flags);
    out32[0] = v0 ^ v8;
    out32[1] = v1 ^ v9;
    out32[2] = v2 ^ v10;
    out32[3] = v3 ^ v11;
    out32[4] = v4 ^ v12;
    out32[5] = v5 ^ v13;
    out32[6] = v6 ^ v14;
    out32[7] = v7 ^ v15;
    out32[8] = s2[0] ^ v8;
    out32[9] = s2[1] ^ v9;
    out32[10] = s2[2] ^ v10;
    out32[11] = s2[3] ^ v11;
    out32[12] = s2[4] ^ v12;
    out32[13] = s2[5] ^ v13;
    out32[14] = s2[6] ^ v14;
    out32[15] = s2[7] ^ v15;
    if (!isLE) {
      byteSwap32(buffer32);
      byteSwap32(out32);
    }
    this.posOut = 0;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    this.buffer.fill(0, this.pos);
    let flags = this.flags | 8;
    if (this.stack.length) {
      flags |= 4;
      if (!isLE)
        byteSwap32(this.buffer32);
      this.compress(this.buffer32, 0, true);
      if (!isLE)
        byteSwap32(this.buffer32);
      this.chunksDone = 0;
      this.pos = this.blockLen;
    } else {
      flags |= (!this.chunkPos ? 1 : 0) | 2;
    }
    this.flags = flags;
    this.b2CompressOut();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const { blockLen, bufferOut } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.b2CompressOut();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible after digest call");
    return this.writeInto(out);
  }
  xof(bytes3) {
    number(bytes3);
    return this.xofInto(new Uint8Array(bytes3));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.enableXOF = false;
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
};
var blake3 = /* @__PURE__ */ wrapXOFConstructorWithOpts((opts) => new BLAKE3(opts));

// node_modules/@web-std/form-data/src/lib.node.js
init_process_shim();

// node_modules/@web-std/form-data/src/form-data.js
init_process_shim();
var FormData2 = class {
  /**
   * @param {HTMLFormElement} [form]
   */
  constructor(form) {
    this._entries = [];
    Object.defineProperty(this, "_entries", { enumerable: false });
    if (isHTMLFormElement(form)) {
      for (const element of form.elements) {
        if (isSelectElement(element)) {
          for (const option of element.options) {
            if (option.selected) {
              this.append(element.name, option.value);
            }
          }
        } else if (isInputElement(element) && (element.checked || !["radio", "checkbox"].includes(element.type)) && element.name) {
          this.append(element.name, element.value);
        }
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "FormData";
  }
  /**
   * Appends a new value onto an existing key inside a FormData object, or adds
   * the key if it does not already exist.
   *
   * The difference between `set` and `append` is that if the specified key
   * already exists, `set` will overwrite all existing values with the new one,
   * whereas `append` will append the new value onto the end of the existing
   * set of values.
   *
   * @param {string} name
   * @param {string|Blob|File} value - The name of the field whose data is
   * contained in value.
   * @param {string} [filename] - The filename reported to the server, when a
   * value is a `Blob` or a `File`. The default filename for a `Blob` objects is
   * `"blob"`. The default filename for a `File` is the it's name.
   */
  append(name15, value = panic4(
    new TypeError("FormData.append: requires at least 2 arguments")
  ), filename) {
    this._entries.push([name15, toEntryValue(value, filename)]);
  }
  /**
   * Deletes a key and all its values from a FormData object.
   *
   * @param {string} name
   */
  delete(name15 = panic4(new TypeError("FormData.delete: requires string argument"))) {
    const entries3 = this._entries;
    let index2 = 0;
    while (index2 < entries3.length) {
      const [entryName] = (
        /** @type {[string, FormDataEntryValue]}*/
        entries3[index2]
      );
      if (entryName === name15) {
        entries3.splice(index2, 1);
      } else {
        index2++;
      }
    }
  }
  /**
   * Returns the first value associated with a given key from within a
   * FormData object.
   *
   * @param {string} name
   * @returns {FormDataEntryValue|null}
   */
  get(name15 = panic4(new TypeError("FormData.get: requires string argument"))) {
    for (const [entryName, value] of this._entries) {
      if (entryName === name15) {
        return value;
      }
    }
    return null;
  }
  /**
   * Returns an array of all the values associated with a given key from within
   * a FormData.
   *
   * @param {string} name
   * @returns {FormDataEntryValue[]}
   */
  getAll(name15 = panic4(new TypeError("FormData.getAll: requires string argument"))) {
    const values2 = [];
    for (const [entryName, value] of this._entries) {
      if (entryName === name15) {
        values2.push(value);
      }
    }
    return values2;
  }
  /**
   * Returns a boolean stating whether a FormData object contains a certain key.
   *
   * @param {string} name
   */
  has(name15 = panic4(new TypeError("FormData.has: requires string argument"))) {
    for (const [entryName] of this._entries) {
      if (entryName === name15) {
        return true;
      }
    }
    return false;
  }
  /**
   * Sets a new value for an existing key inside a FormData object, or adds the
   * key/value if it does not already exist.
   *
   * @param {string} name
   * @param {string|Blob|File} value
   * @param {string} [filename]
   */
  set(name15, value = panic4(new TypeError("FormData.set: requires at least 2 arguments")), filename) {
    let index2 = 0;
    const { _entries: entries3 } = this;
    const entryValue = toEntryValue(value, filename);
    let wasSet = false;
    while (index2 < entries3.length) {
      const entry = (
        /** @type {[string, FormDataEntryValue]}*/
        entries3[index2]
      );
      if (entry[0] === name15) {
        if (wasSet) {
          entries3.splice(index2, 1);
        } else {
          wasSet = true;
          entry[1] = entryValue;
          index2++;
        }
      } else {
        index2++;
      }
    }
    if (!wasSet) {
      entries3.push([name15, entryValue]);
    }
  }
  /**
   * Method returns an iterator allowing to go through all key/value pairs
   * contained in this object.
   */
  entries() {
    return this._entries.values();
  }
  /**
   * Returns an iterator allowing to go through all keys of the key/value pairs
   * contained in this object.
   *
   * @returns {IterableIterator<string>}
   */
  *keys() {
    for (const [name15] of this._entries) {
      yield name15;
    }
  }
  /**
   * Returns an iterator allowing to go through all values contained in this
   * object.
   *
   * @returns {IterableIterator<FormDataEntryValue>}
   */
  *values() {
    for (const [_, value] of this._entries) {
      yield value;
    }
  }
  [Symbol.iterator]() {
    return this._entries.values();
  }
  /**
   * @param {(value: FormDataEntryValue, key: string, parent: globalThis.FormData) => void} fn
   * @param {any} [thisArg]
   * @returns {void}
   */
  forEach(fn, thisArg) {
    for (const [key, value] of this._entries) {
      fn.call(thisArg, value, key, this);
    }
  }
};
var isHTMLFormElement = (value) => Object.prototype.toString.call(value) === "[object HTMLFormElement]";
var toEntryValue = (value, filename) => {
  if (isFile(value)) {
    return filename != null ? new BlobFile([value], filename, value) : value;
  } else if (isBlob(value)) {
    return new BlobFile([value], filename != null ? filename : "blob");
  } else {
    if (filename != null && filename != "") {
      throw new TypeError(
        "filename is only supported when value is Blob or File"
      );
    }
    return `${value}`;
  }
};
var isFile = (value) => Object.prototype.toString.call(value) === "[object File]" && typeof value.name === "string";
var isBlob = (value) => Object.prototype.toString.call(value) === "[object Blob]";
var BlobFile = class File4 {
  /**
   * @param {[Blob]} parts
   * @param {string} name
   * @param {FilePropertyBag} [options]
   */
  constructor([blob3], name15, { lastModified = Date.now() } = {}) {
    this.blob = blob3;
    this.name = name15;
    this.lastModified = lastModified;
  }
  get webkitRelativePath() {
    return "";
  }
  get size() {
    return this.blob.size;
  }
  get type() {
    return this.blob.type;
  }
  /**
   *
   * @param {number} [start]
   * @param {number} [end]
   * @param {string} [contentType]
   */
  slice(start, end, contentType9) {
    return this.blob.slice(start, end, contentType9);
  }
  stream() {
    return this.blob.stream();
  }
  text() {
    return this.blob.text();
  }
  arrayBuffer() {
    return this.blob.arrayBuffer();
  }
  get [Symbol.toStringTag]() {
    return "File";
  }
};
var panic4 = (error3) => {
  throw error3;
};
function isSelectElement(element) {
  return element.tagName === "SELECT";
}
function isInputElement(element) {
  return element.tagName === "INPUT" || element.tagName === "TEXTAREA";
}

// node_modules/@web-std/form-data/src/lib.node.js
var FormData3 = typeof globalThis.FormData === "function" ? globalThis.FormData : FormData2;

// node_modules/axios/index.js
init_process_shim();

// node_modules/axios/lib/axios.js
init_process_shim();

// node_modules/axios/lib/utils.js
init_process_shim();

// node_modules/axios/lib/helpers/bind.js
init_process_shim();
function bind(fn, thisArg) {
  return function wrap3() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString: toString4 } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = /* @__PURE__ */ ((cache5) => (thing) => {
  const str = toString4.call(thing);
  return cache5[str] || (cache5[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
var typeOfTest = (type2) => (thing) => typeof thing === type2;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer3(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile2 = kindOfTest("File");
var isBlob2 = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l2 = obj.length; i < l2; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys2.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys2[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys2 = Object.keys(obj);
  let i = keys2.length;
  let _key;
  while (i-- > 0) {
    _key = keys2[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context2) => !isUndefined(context2) && context2 !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l2 = arguments.length; i < l2; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content2) => {
  if (content2.charCodeAt(0) === 65279) {
    content2 = content2.slice(1);
  }
  return content2;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith2 = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty3 }) => (obj, prop) => hasOwnProperty3.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name15) => {
    let ret;
    if ((ret = reducer(descriptor, name15, obj)) !== false) {
      reducedDescriptors[name15] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name15) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name15) !== -1) {
      return false;
    }
    const value = obj[name15];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name15 + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
var noop2 = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size5 = 16, alphabet3 = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length: length5 } = alphabet3;
  while (size5--) {
    str += alphabet3[Math.random() * length5 | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer: isBuffer3,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile: isFile2,
  isBlob: isBlob2,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith: endsWith2,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop2,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};

// node_modules/axios/lib/core/Axios.js
init_process_shim();

// node_modules/axios/lib/helpers/buildURL.js
init_process_shim();

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
init_process_shim();

// node_modules/axios/lib/helpers/toFormData.js
init_process_shim();

// node_modules/axios/lib/core/AxiosError.js
init_process_shim();
function AxiosError(message2, code20, config2, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message2;
  this.name = "AxiosError";
  code20 && (this.code = code20);
  config2 && (this.config = config2);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code20) => {
  descriptors[code20] = { value: code20 };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error3, code20, config2, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error3, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error3.message, code20, config2, request, response);
  axiosError.cause = error3;
  axiosError.name = error3.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/platform/node/classes/FormData.js
init_process_shim();
var import_form_data = __toESM(require_form_data(), 1);
var FormData_default = import_form_data.default;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined2(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index2) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build3(value, path) {
    if (utils_default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build3(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build3(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode34(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match6) {
    return charMap[match6];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append2(name15, value) {
  this._pairs.push([name15, value]);
};
prototype2.toString = function toString5(encoder4) {
  const _encode = encoder4 ? function(value) {
    return encoder4.call(this, value, encode34);
  } : encode34;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode35(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode35;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}

// node_modules/axios/lib/core/InterceptorManager.js
init_process_shim();
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/core/dispatchRequest.js
init_process_shim();

// node_modules/axios/lib/core/transformData.js
init_process_shim();

// node_modules/axios/lib/defaults/index.js
init_process_shim();

// node_modules/axios/lib/defaults/transitional.js
init_process_shim();
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
init_process_shim();

// node_modules/axios/lib/platform/index.js
init_process_shim();

// node_modules/axios/lib/platform/node/index.js
init_process_shim();

// node_modules/axios/lib/platform/node/classes/URLSearchParams.js
init_process_shim();
import url from "url";
var URLSearchParams_default = url.URLSearchParams;

// node_modules/axios/lib/platform/node/index.js
var node_default = {
  isNode: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  protocols: ["http", "https", "file", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
init_process_shim();
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...node_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
init_process_shim();
function parsePropPath(name15) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name15).map((match6) => {
    return match6[0] === "[]" ? "" : match6[1] || match6[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys2 = Object.keys(arr);
  let i;
  const len = keys2.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys2[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index2) {
    let name15 = path[index2++];
    if (name15 === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name15);
    const isLast = index2 >= path.length;
    name15 = !name15 && utils_default.isArray(target) ? target.length : name15;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name15)) {
        target[name15] = [target[name15], value];
      } else {
        target[name15] = value;
      }
      return !isNumericKey;
    }
    if (!target[name15] || !utils_default.isObject(target[name15])) {
      target[name15] = [];
    }
    const result = buildPath(path, value, target[name15], index2);
    if (result && utils_default.isArray(target[name15])) {
      target[name15] = arrayToObject(target[name15]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name15, value) => {
      buildPath(parsePropPath(name15), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder4) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder4 || JSON.stringify)(rawValue);
}
var defaults5 = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType9 = headers.getContentType() || "";
    const hasJSONContentType = contentType9.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType9.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType9.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults5.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults5.headers[method] = {};
});
var defaults_default = defaults5;

// node_modules/axios/lib/core/AxiosHeaders.js
init_process_shim();

// node_modules/axios/lib/helpers/parseHeaders.js
init_process_shim();
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match6;
  while (match6 = tokensRE.exec(str)) {
    tokens[match6[1]] = match6[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context2, value, header, filter3, isHeaderNameFilter) {
  if (utils_default.isFunction(filter3)) {
    return filter3.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter3)) {
    return value.indexOf(filter3) !== -1;
  }
  if (utils_default.isRegExp(filter3)) {
    return filter3.test(value);
  }
}
function formatHeader2(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys2 = Object.keys(this);
    let i = keys2.length;
    let deleted = false;
    while (i--) {
      const key = keys2[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format11) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format11 ? formatHeader2(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config2 = this || defaults_default;
  const context2 = response || config2;
  const headers = AxiosHeaders_default.from(context2.headers);
  let data = context2.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
init_process_shim();
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
init_process_shim();
function CanceledError(message2, config2, request) {
  AxiosError_default.call(this, message2 == null ? "canceled" : message2, AxiosError_default.ERR_CANCELED, config2, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/adapters/adapters.js
init_process_shim();

// node_modules/axios/lib/adapters/http.js
init_process_shim();

// node_modules/axios/lib/core/settle.js
init_process_shim();
function settle(resolve2, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/core/buildFullPath.js
init_process_shim();

// node_modules/axios/lib/helpers/isAbsoluteURL.js
init_process_shim();
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}

// node_modules/axios/lib/helpers/combineURLs.js
init_process_shim();
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/adapters/http.js
var import_proxy_from_env = __toESM(require_proxy_from_env(), 1);
var import_follow_redirects = __toESM(require_follow_redirects(), 1);
import http from "http";
import https from "https";
import util from "util";
import zlib from "zlib";

// node_modules/axios/lib/env/data.js
init_process_shim();
var VERSION3 = "1.7.7";

// node_modules/axios/lib/helpers/fromDataURI.js
init_process_shim();

// node_modules/axios/lib/helpers/parseProtocol.js
init_process_shim();
function parseProtocol(url2) {
  const match6 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match6 && match6[1] || "";
}

// node_modules/axios/lib/helpers/fromDataURI.js
var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri2, asBlob, options) {
  const _Blob = options && options.Blob || platform_default.classes.Blob;
  const protocol = parseProtocol(uri2);
  if (asBlob === void 0 && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri2 = protocol.length ? uri2.slice(protocol.length + 1) : uri2;
    const match6 = DATA_URL_PATTERN.exec(uri2);
    if (!match6) {
      throw new AxiosError_default("Invalid URL", AxiosError_default.ERR_INVALID_URL);
    }
    const mime = match6[1];
    const isBase64 = match6[2];
    const body = match6[3];
    const buffer3 = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError_default("Blob is not supported", AxiosError_default.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer3], { type: mime });
    }
    return buffer3;
  }
  throw new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_NOT_SUPPORT);
}

// node_modules/axios/lib/adapters/http.js
import stream3 from "stream";

// node_modules/axios/lib/helpers/AxiosTransformStream.js
init_process_shim();
import stream from "stream";
var kInternals = Symbol("internals");
var AxiosTransformStream = class extends stream.Transform {
  constructor(options) {
    options = utils_default.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils_default.isUndefined(source[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    this.on("newListener", (event) => {
      if (event === "progress") {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }
  _read(size5) {
    const internals = this[kInternals];
    if (internals.onReadCallback) {
      internals.onReadCallback();
    }
    return super._read(size5);
  }
  _transform(chunk, encoding, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals.timeWindow;
    const divider = 1e3 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    const pushChunk = (_chunk, _callback) => {
      const bytes3 = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes3;
      internals.bytes += bytes3;
      internals.isCaptured && this.emit("progress", internals.bytesSeen);
      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    };
    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now3 = Date.now();
        if (!internals.ts || (passed = now3 - internals.ts) >= timeWindow) {
          internals.ts = now3;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }
      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
};
var AxiosTransformStream_default = AxiosTransformStream;

// node_modules/axios/lib/adapters/http.js
import { EventEmitter } from "events";

// node_modules/axios/lib/helpers/formDataToStream.js
init_process_shim();
import { TextEncoder as TextEncoder2 } from "util";
import { Readable as Readable2 } from "stream";

// node_modules/axios/lib/helpers/readBlob.js
init_process_shim();
var { asyncIterator } = Symbol;
var readBlob = async function* (blob3) {
  if (blob3.stream) {
    yield* blob3.stream();
  } else if (blob3.arrayBuffer) {
    yield await blob3.arrayBuffer();
  } else if (blob3[asyncIterator]) {
    yield* blob3[asyncIterator]();
  } else {
    yield blob3;
  }
};
var readBlob_default = readBlob;

// node_modules/axios/lib/helpers/formDataToStream.js
var BOUNDARY_ALPHABET = utils_default.ALPHABET.ALPHA_DIGIT + "-_";
var textEncoder5 = new TextEncoder2();
var CRLF = "\r\n";
var CRLF_BYTES = textEncoder5.encode(CRLF);
var CRLF_BYTES_COUNT = 2;
var FormDataPart = class {
  constructor(name15, value) {
    const { escapeName } = this.constructor;
    const isStringValue = utils_default.isString(value);
    let headers = `Content-Disposition: form-data; name="${escapeName(name15)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value = textEncoder5.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder5.encode(headers + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name15;
    this.value = value;
  }
  async *encode() {
    yield this.headers;
    const { value } = this;
    if (utils_default.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob_default(value);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name15) {
    return String(name15).replace(/[\r\n"]/g, (match6) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match6]);
  }
};
var formDataToStream = (form, headersHandler, options) => {
  const {
    tag: tag2 = "form-data-boundary",
    size: size5 = 25,
    boundary = tag2 + "-" + utils_default.generateString(size5, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils_default.isFormData(form)) {
    throw TypeError("FormData instance required");
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error("boundary must be 10-70 characters long");
  }
  const boundaryBytes = textEncoder5.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder5.encode("--" + boundary + "--" + CRLF + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name15, value]) => {
    const part = new FormDataPart(name15, value);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils_default.toFiniteNumber(contentLength);
  const computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return Readable2.from(async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  }());
};
var formDataToStream_default = formDataToStream;

// node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js
init_process_shim();
import stream2 from "stream";
var ZlibHeaderTransformStream = class extends stream2.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }
  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;
      if (chunk[0] !== 120) {
        const header = Buffer.alloc(2);
        header[0] = 120;
        header[1] = 156;
        this.push(header, encoding);
      }
    }
    this.__transform(chunk, encoding, callback);
  }
};
var ZlibHeaderTransformStream_default = ZlibHeaderTransformStream;

// node_modules/axios/lib/helpers/callbackify.js
init_process_shim();
var callbackify = (fn, reducer) => {
  return utils_default.isAsyncFn(fn) ? function(...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};
var callbackify_default = callbackify;

// node_modules/axios/lib/helpers/progressEventReducer.js
init_process_shim();

// node_modules/axios/lib/helpers/speedometer.js
init_process_shim();
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes3 = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push2(chunkLength) {
    const now3 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now3;
    }
    bytes3[head] = chunkLength;
    timestamps[head] = now3;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes3[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now3 - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now3 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
init_process_shim();
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke2 = (args, now3 = Date.now()) => {
    timestamp = now3;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now3 = Date.now();
    const passed = now3 - timestamp;
    if (passed >= threshold) {
      invoke2(args, now3);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke2(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush3 = () => lastArgs && invoke2(lastArgs);
  return [throttled, flush3];
}
var throttle_default = throttle;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));

// node_modules/axios/lib/adapters/http.js
var zlibOptions = {
  flush: zlib.constants.Z_SYNC_FLUSH,
  finishFlush: zlib.constants.Z_SYNC_FLUSH
};
var brotliOptions = {
  flush: zlib.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
};
var isBrotliSupported = utils_default.isFunction(zlib.createBrotliDecompress);
var { http: httpFollow, https: httpsFollow } = import_follow_redirects.default;
var isHttps = /https:?/;
var supportedProtocols = platform_default.protocols.map((protocol) => {
  return protocol + ":";
});
var flushOnFinish = (stream4, [throttled, flush3]) => {
  stream4.on("end", flush3).on("error", flush3);
  return throttled;
};
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}
function setProxy(options, configProxy, location2) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = (0, import_proxy_from_env.getProxyForUrl)(location2);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base644 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base644;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location2;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
var isHttpAdapterSupported = typeof process !== "undefined" && utils_default.kindOf(process) === "process";
var wrapAsync = (asyncExecutor) => {
  return new Promise((resolve2, reject) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone) return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = (value) => {
      done(value);
      resolve2(value);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
};
var resolveFamily = ({ address, family }) => {
  if (!utils_default.isString(address)) {
    throw TypeError("address must be a string");
  }
  return {
    address,
    family: family || (address.indexOf(".") < 0 ? 6 : 4)
  };
};
var buildAddressEntry = (address, family) => resolveFamily(utils_default.isObject(address) ? address : { address, family });
var http_default = isHttpAdapterSupported && function httpAdapter(config2) {
  return wrapAsync(async function dispatchHttpRequest(resolve2, reject, onDone) {
    let { data, lookup: lookup2, family } = config2;
    const { responseType, responseEncoding } = config2;
    const method = config2.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;
    if (lookup2) {
      const _lookup = callbackify_default(lookup2, (value) => utils_default.isArray(value) ? value : [value]);
      lookup2 = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }
          const addresses = utils_default.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }
    const emitter = new EventEmitter();
    const onFinished = () => {
      if (config2.cancelToken) {
        config2.cancelToken.unsubscribe(abort2);
      }
      if (config2.signal) {
        config2.signal.removeEventListener("abort", abort2);
      }
      emitter.removeAllListeners();
    };
    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });
    function abort2(reason) {
      emitter.emit("abort", !reason || reason.type ? new CanceledError_default(null, config2, req) : reason);
    }
    emitter.once("abort", reject);
    if (config2.cancelToken || config2.signal) {
      config2.cancelToken && config2.cancelToken.subscribe(abort2);
      if (config2.signal) {
        config2.signal.aborted ? abort2() : config2.signal.addEventListener("abort", abort2);
      }
    }
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    const parsed = new URL(fullPath, platform_default.hasBrowserEnv ? platform_default.origin : void 0);
    const protocol = parsed.protocol || supportedProtocols[0];
    if (protocol === "data:") {
      let convertedData;
      if (method !== "GET") {
        return settle(resolve2, reject, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config: config2
        });
      }
      try {
        convertedData = fromDataURI(config2.url, responseType === "blob", {
          Blob: config2.env && config2.env.Blob
        });
      } catch (err) {
        throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config2);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          convertedData = utils_default.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = stream3.Readable.from(convertedData);
      }
      return settle(resolve2, reject, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders_default(),
        config: config2
      });
    }
    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError_default(
        "Unsupported protocol " + protocol,
        AxiosError_default.ERR_BAD_REQUEST,
        config2
      ));
    }
    const headers = AxiosHeaders_default.from(config2.headers).normalize();
    headers.set("User-Agent", "axios/" + VERSION3, false);
    const { onUploadProgress, onDownloadProgress } = config2;
    const maxRate = config2.maxRate;
    let maxUploadRate = void 0;
    let maxDownloadRate = void 0;
    if (utils_default.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data = formDataToStream_default(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION3}-boundary`,
        boundary: userBoundary && userBoundary[1] || void 0
      });
    } else if (utils_default.isFormData(data) && utils_default.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());
      if (!headers.hasContentLength()) {
        try {
          const knownLength = await util.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
        } catch (e) {
        }
      }
    } else if (utils_default.isBlob(data)) {
      data.size && headers.setContentType(data.type || "application/octet-stream");
      headers.setContentLength(data.size || 0);
      data = stream3.Readable.from(readBlob_default(data));
    } else if (data && !utils_default.isStream(data)) {
      if (Buffer.isBuffer(data)) {
      } else if (utils_default.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils_default.isString(data)) {
        data = Buffer.from(data, "utf-8");
      } else {
        return reject(new AxiosError_default(
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          AxiosError_default.ERR_BAD_REQUEST,
          config2
        ));
      }
      headers.setContentLength(data.length, false);
      if (config2.maxBodyLength > -1 && data.length > config2.maxBodyLength) {
        return reject(new AxiosError_default(
          "Request body larger than maxBodyLength limit",
          AxiosError_default.ERR_BAD_REQUEST,
          config2
        ));
      }
    }
    const contentLength = utils_default.toFiniteNumber(headers.getContentLength());
    if (utils_default.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils_default.isStream(data)) {
        data = stream3.Readable.from(data, { objectMode: false });
      }
      data = stream3.pipeline([data, new AxiosTransformStream_default({
        maxRate: utils_default.toFiniteNumber(maxUploadRate)
      })], utils_default.noop);
      onUploadProgress && data.on("progress", flushOnFinish(
        data,
        progressEventDecorator(
          contentLength,
          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
        )
      ));
    }
    let auth = void 0;
    if (config2.auth) {
      const username = config2.auth.username || "";
      const password = config2.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers.delete("authorization");
    let path;
    try {
      path = buildURL(
        parsed.pathname + parsed.search,
        config2.params,
        config2.paramsSerializer
      ).replace(/^\?/, "");
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config2;
      customErr.url = config2.url;
      customErr.exists = true;
      return reject(customErr);
    }
    headers.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
      false
    );
    const options = {
      path,
      method,
      headers: headers.toJSON(),
      agents: { http: config2.httpAgent, https: config2.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    !utils_default.isUndefined(lookup2) && (options.lookup = lookup2);
    if (config2.socketPath) {
      options.socketPath = config2.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config2.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config2.httpsAgent : config2.httpAgent;
    if (config2.transport) {
      transport = config2.transport;
    } else if (config2.maxRedirects === 0) {
      transport = isHttpsRequest ? https : http;
    } else {
      if (config2.maxRedirects) {
        options.maxRedirects = config2.maxRedirects;
      }
      if (config2.beforeRedirect) {
        options.beforeRedirects.config = config2.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }
    if (config2.maxBodyLength > -1) {
      options.maxBodyLength = config2.maxBodyLength;
    } else {
      options.maxBodyLength = Infinity;
    }
    if (config2.insecureHTTPParser) {
      options.insecureHTTPParser = config2.insecureHTTPParser;
    }
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed) return;
      const streams2 = [res];
      const responseLength = +res.headers["content-length"];
      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new AxiosTransformStream_default({
          maxRate: utils_default.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", flushOnFinish(
          transformStream,
          progressEventDecorator(
            responseLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
          )
        ));
        streams2.push(transformStream);
      }
      let responseStream = res;
      const lastRequest = res.req || req;
      if (config2.decompress !== false && res.headers["content-encoding"]) {
        if (method === "HEAD" || res.statusCode === 204) {
          delete res.headers["content-encoding"];
        }
        switch ((res.headers["content-encoding"] || "").toLowerCase()) {
          /*eslint default-case:0*/
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            streams2.push(zlib.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "deflate":
            streams2.push(new ZlibHeaderTransformStream_default());
            streams2.push(zlib.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "br":
            if (isBrotliSupported) {
              streams2.push(zlib.createBrotliDecompress(brotliOptions));
              delete res.headers["content-encoding"];
            }
        }
      }
      responseStream = streams2.length > 1 ? stream3.pipeline(streams2, utils_default.noop) : streams2[0];
      const offListeners = stream3.finished(responseStream, () => {
        offListeners();
        onFinished();
      });
      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders_default(res.headers),
        config: config2,
        request: lastRequest
      };
      if (responseType === "stream") {
        response.data = responseStream;
        settle(resolve2, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on("data", function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;
          if (config2.maxContentLength > -1 && totalResponseBytes > config2.maxContentLength) {
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError_default(
              "maxContentLength size of " + config2.maxContentLength + " exceeded",
              AxiosError_default.ERR_BAD_RESPONSE,
              config2,
              lastRequest
            ));
          }
        });
        responseStream.on("aborted", function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err = new AxiosError_default(
            "maxContentLength size of " + config2.maxContentLength + " exceeded",
            AxiosError_default.ERR_BAD_RESPONSE,
            config2,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });
        responseStream.on("error", function handleStreamError(err) {
          if (req.destroyed) return;
          reject(AxiosError_default.from(err, null, config2, lastRequest));
        });
        responseStream.on("end", function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== "arraybuffer") {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === "utf8") {
                responseData = utils_default.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject(AxiosError_default.from(err, null, config2, response.request, response));
          }
          settle(resolve2, reject, response);
        });
      }
      emitter.once("abort", (err) => {
        if (!responseStream.destroyed) {
          responseStream.emit("error", err);
          responseStream.destroy();
        }
      });
    });
    emitter.once("abort", (err) => {
      reject(err);
      req.destroy(err);
    });
    req.on("error", function handleRequestError(err) {
      reject(AxiosError_default.from(err, null, config2, req));
    });
    req.on("socket", function handleRequestSocket(socket) {
      socket.setKeepAlive(true, 1e3 * 60);
    });
    if (config2.timeout) {
      const timeout = parseInt(config2.timeout, 10);
      if (Number.isNaN(timeout)) {
        reject(new AxiosError_default(
          "error trying to parse `config.timeout` to int",
          AxiosError_default.ERR_BAD_OPTION_VALUE,
          config2,
          req
        ));
        return;
      }
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone) return;
        let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = config2.transitional || transitional_default;
        if (config2.timeoutErrorMessage) {
          timeoutErrorMessage = config2.timeoutErrorMessage;
        }
        reject(new AxiosError_default(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
          config2,
          req
        ));
        abort2();
      });
    }
    if (utils_default.isStream(data)) {
      let ended = false;
      let errored = false;
      data.on("end", () => {
        ended = true;
      });
      data.once("error", (err) => {
        errored = true;
        req.destroy(err);
      });
      data.on("close", () => {
        if (!ended && !errored) {
          abort2(new CanceledError_default("Request stream has been aborted", config2, req));
        }
      });
      data.pipe(req);
    } else {
      req.end(data);
    }
  });
};

// node_modules/axios/lib/adapters/xhr.js
init_process_shim();

// node_modules/axios/lib/helpers/resolveConfig.js
init_process_shim();

// node_modules/axios/lib/helpers/isURLSameOrigin.js
init_process_shim();
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url2) {
      let href = url2;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }()
);

// node_modules/axios/lib/helpers/cookies.js
init_process_shim();
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name15, value, expires, path, domain, secure) {
      const cookie = [name15 + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path) && cookie.push("path=" + path);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name15) {
      const match6 = document.cookie.match(new RegExp("(^|;\\s*)(" + name15 + ")=([^;]*)"));
      return match6 ? decodeURIComponent(match6[3]) : null;
    },
    remove(name15) {
      this.write(name15, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/core/mergeConfig.js
init_process_shim();
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge3 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge3(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config2) => {
  const newConfig = mergeConfig({}, config2);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config2.params, config2.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType9;
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType9 = headers.getContentType()) !== false) {
      const [type2, ...tokens] = contentType9 ? contentType9.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type2 || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    const _config = resolveConfig_default(config2);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config2,
        request
      };
      settle(function _resolve(value) {
        resolve2(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config2, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config2, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config2,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config2, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config2));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/adapters/fetch.js
init_process_shim();

// node_modules/axios/lib/helpers/composeSignals.js
init_process_shim();
var composeSignals = (signals, timeout) => {
  const { length: length5 } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length5) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
init_process_shim();
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes2 = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream4) {
  if (stream4[Symbol.asyncIterator]) {
    yield* stream4;
    return;
  }
  const reader = stream4.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream4, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes2(stream4, chunkSize);
  let bytes3 = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes3 += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/axios/lib/adapters/fetch.js
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder4) => (str) => encoder4.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
var test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
var supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform_default.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
var resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type2) => {
    !resolvers[type2] && (resolvers[type2] = utils_default.isFunction(res[type2]) ? (res2) => res2[type2]() : (_, config2) => {
      throw new AxiosError_default(`Response type '${type2}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config2);
    });
  });
})(new Response());
var getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils_default.isBlob(body)) {
    return body.size;
  }
  if (utils_default.isSpecCompliantForm(body)) {
    const _request = new Request(platform_default.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils_default.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils_default.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
var resolveBodyLength = async (headers, body) => {
  const length5 = utils_default.toFiniteNumber(headers.getContentLength());
  return length5 == null ? getBodyLength(body) : length5;
};
var fetch_default = isFetchSupported && (async (config2) => {
  let {
    url: url2,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig_default(config2);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url2, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush3] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush3);
      }
    }
    if (!utils_default.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url2, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush3] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush3 && flush3();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config2);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve2, reject) => {
      settle(resolve2, reject, {
        data: responseData,
        headers: AxiosHeaders_default.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config: config2,
        request
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config2, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError_default.from(err, err && err.code, config2, request);
  }
});

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: http_default,
  xhr: xhr_default,
  fetch: fetch_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length: length5 } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length5; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s2 = length5 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s2,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError_default(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders_default.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config2.adapter || defaults_default.adapter);
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/helpers/validator.js
init_process_shim();
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i) => {
  validators[type2] = function validator(thing) {
    return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version3, message2) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION3 + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version3 ? " in " + version3 : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version3 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version3 + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema5, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys2 = Object.keys(options);
  let i = keys2.length;
  while (i-- > 0) {
    const opt = keys2[i];
    const validator = schema5[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config2) {
    try {
      return await this._request(configOrUrl, config2);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error3) {
        onRejected.call(this, error3);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error3) {
      return Promise.reject(error3);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url2, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url: url2,
      data: (config2 || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
init_process_shim();
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve2) => {
        token.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message2, config2, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message2, config2, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort2 = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort2);
    controller.signal.unsubscribe = () => this.unsubscribe(abort2);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
init_process_shim();
function spread(callback) {
  return function wrap3(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
init_process_shim();
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
init_process_shim();
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context2 = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context2);
  utils_default.extend(instance, Axios_default.prototype, context2, { allOwnKeys: true });
  utils_default.extend(instance, context2, null, { allOwnKeys: true });
  instance.create = function create19(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION3;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all3(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION4,
  all: all4,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// node_modules/@fleek-platform/sdk/dist/browser/index.js
var import_object_traversal = __toESM(require_dist());
var import_cross_fetch = __toESM(require_node_ponyfill());

// node_modules/luxon/src/luxon.js
init_process_shim();

// node_modules/luxon/src/datetime.js
init_process_shim();

// node_modules/luxon/src/duration.js
init_process_shim();

// node_modules/luxon/src/errors.js
init_process_shim();
var LuxonError = class extends Error {
};
var InvalidDateTimeError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
};
var InvalidIntervalError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
};
var InvalidDurationError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
};
var ConflictingSpecificationError = class extends LuxonError {
};
var InvalidUnitError = class extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
};
var InvalidArgumentError = class extends LuxonError {
};
var ZoneIsAbstractError = class extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
};

// node_modules/luxon/src/impl/formatter.js
init_process_shim();

// node_modules/luxon/src/impl/english.js
init_process_shim();

// node_modules/luxon/src/impl/formats.js
init_process_shim();
var n = "numeric";
var s = "short";
var l = "long";
var DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
var DATE_MED = {
  year: n,
  month: s,
  day: n
};
var DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s
};
var DATE_FULL = {
  year: n,
  month: l,
  day: n
};
var DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
var TIME_SIMPLE = {
  hour: n,
  minute: n
};
var TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
var TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
var TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s
};
var TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l
};
var DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n
};
var DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s
};
var DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
var DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};

// node_modules/luxon/src/impl/util.js
init_process_shim();

// node_modules/luxon/src/settings.js
init_process_shim();

// node_modules/luxon/src/zones/systemZone.js
init_process_shim();

// node_modules/luxon/src/zone.js
init_process_shim();
var Zone = class {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The IANA name of this zone.
   * Defaults to `name` if not overwritten by a subclass.
   * @abstract
   * @type {string}
   */
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format11) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
};

// node_modules/luxon/src/zones/systemZone.js
var singleton = null;
var SystemZone = class _SystemZone extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton === null) {
      singleton = new _SystemZone();
    }
    return singleton;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format: format11, locale }) {
    return parseZoneInfo(ts, format11, locale);
  }
  /** @override **/
  formatOffset(ts, format11) {
    return formatOffset(this.offset(ts), format11);
  }
  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }
  /** @override **/
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/IANAZone.js
init_process_shim();
var dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const { type: type2, value } = formatted[i];
    const pos = typeToPos[type2];
    if (type2 === "era") {
      filled[pos] = value;
    } else if (!isUndefined2(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
var ianaZoneCache = {};
var IANAZone = class _IANAZone extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name15) {
    if (!ianaZoneCache[name15]) {
      ianaZoneCache[name15] = new _IANAZone(name15);
    }
    return ianaZoneCache[name15];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated For backward compatibility, this forwards to isValidZone, better use `isValidZone()` directly instead.
   * @return {boolean}
   */
  static isValidSpecifier(s2) {
    return this.isValidZone(s2);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e) {
      return false;
    }
  }
  constructor(name15) {
    super();
    this.zoneName = name15;
    this.valid = _IANAZone.isValidZone(name15);
  }
  /**
   * The type of zone. `iana` for all instances of `IANAZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "iana";
  }
  /**
   * The name of this zone (i.e. the IANA zone name).
   * @override
   * @type {string}
   */
  get name() {
    return this.zoneName;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns false for all IANA zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return false;
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, { format: format11, locale }) {
    return parseZoneInfo(ts, format11, locale, this.name);
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format11) {
    return formatOffset(this.offset(ts), format11);
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @override
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    const date = new Date(ts);
    if (isNaN(date)) return NaN;
    const dtf = makeDTF(this.name);
    let [year2, month, day2, adOrBc, hour2, minute2, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
    if (adOrBc === "BC") {
      year2 = -Math.abs(year2) + 1;
    }
    const adjustedHour = hour2 === 24 ? 0 : hour2;
    const asUTC = objToLocalTS({
      year: year2,
      month,
      day: day2,
      hour: adjustedHour,
      minute: minute2,
      second,
      millisecond: 0
    });
    let asTS = +date;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  /**
   * Return whether this Zone is equal to another zone
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  /**
   * Return whether this Zone is valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return this.valid;
  }
};

// node_modules/luxon/src/impl/locale.js
init_process_shim();
var intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
var intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
var intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
var intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const { base: base5, ...cacheKeyOpts } = opts;
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
var sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
var weekInfoCache = {};
function getCachedWeekInfo(locString) {
  let data = weekInfoCache[locString];
  if (!data) {
    const locale = new Intl.Locale(locString);
    data = "getWeekInfo" in locale ? locale.getWeekInfo() : locale.weekInfo;
    weekInfoCache[locString] = data;
  }
  return data;
}
function parseLocaleString(localeStr) {
  const xIndex = localeStr.indexOf("-x-");
  if (xIndex !== -1) {
    localeStr = localeStr.substring(0, xIndex);
  }
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    let selectedStr;
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
      selectedStr = localeStr;
    } catch (e) {
      const smaller = localeStr.substring(0, uIndex);
      options = getCachedDTF(smaller).resolvedOptions();
      selectedStr = smaller;
    }
    const { numberingSystem, calendar } = options;
    return [selectedStr, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    if (!localeStr.includes("-u-")) {
      localeStr += "-u";
    }
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f) {
  const ms = [];
  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2009, i, 1);
    ms.push(f(dt));
  }
  return ms;
}
function mapWeekdays(f) {
  const ms = [];
  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }
  return ms;
}
function listStuff(loc, length5, englishFn, intlFn) {
  const mode = loc.listingMode();
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length5);
  } else {
    return intlFn(length5);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
var PolyNumberFormatter = class {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const { padTo, floor, ...otherOpts } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
};
var PolyDateFormatter = class {
  constructor(dt, intl, opts) {
    this.opts = opts;
    this.originalZone = void 0;
    let z = void 0;
    if (this.opts.timeZone) {
      this.dt = dt;
    } else if (dt.zone.type === "fixed") {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        z = "UTC";
        this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else if (dt.zone.type === "iana") {
      this.dt = dt;
      z = dt.zone.name;
    } else {
      z = "UTC";
      this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
      this.originalZone = dt.zone;
    }
    const intlOpts = { ...this.opts };
    intlOpts.timeZone = intlOpts.timeZone || z;
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    if (this.originalZone) {
      return this.formatToParts().map(({ value }) => value).join("");
    }
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const parts = this.dtf.formatToParts(this.dt.toJSDate());
    if (this.originalZone) {
      return parts.map((part) => {
        if (part.type === "timeZoneName") {
          const offsetName = this.originalZone.offsetName(this.dt.ts, {
            locale: this.dt.locale,
            format: this.opts.timeZoneName
          });
          return {
            ...part,
            value: offsetName
          };
        } else {
          return part;
        }
      });
    }
    return parts;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
};
var PolyRelFormatter = class {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
};
var fallbackWeekSettings = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};
var Locale = class _Locale {
  static fromOpts(opts) {
    return _Locale.create(
      opts.locale,
      opts.numberingSystem,
      opts.outputCalendar,
      opts.weekSettings,
      opts.defaultToEN
    );
  }
  static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
    return new _Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({ locale, numberingSystem, outputCalendar, weekSettings } = {}) {
    return _Locale.create(locale, numberingSystem, outputCalendar, weekSettings);
  }
  constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.weekSettings = weekSettings;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return _Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        validateWeekSettings(alts.weekSettings) || this.weekSettings,
        alts.defaultToEN || false
      );
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }
  months(length5, format11 = false) {
    return listStuff(this, length5, months, () => {
      const intl = format11 ? { month: length5, day: "numeric" } : { month: length5 }, formatStr = format11 ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length5]) {
        this.monthsCache[formatStr][length5] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length5];
    });
  }
  weekdays(length5, format11 = false) {
    return listStuff(this, length5, weekdays, () => {
      const intl = format11 ? { weekday: length5, year: "numeric", month: "long", day: "numeric" } : { weekday: length5 }, formatStr = format11 ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length5]) {
        this.weekdaysCache[formatStr][length5] = mapWeekdays(
          (dt) => this.extract(dt, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length5];
    });
  }
  meridiems() {
    return listStuff(
      this,
      void 0,
      () => meridiems,
      () => {
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            (dt) => this.extract(dt, intl, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(length5) {
    return listStuff(this, length5, eras, () => {
      const intl = { era: length5 };
      if (!this.eraCache[length5]) {
        this.eraCache[length5] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
          (dt) => this.extract(dt, intl, "era")
        );
      }
      return this.eraCache[length5];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  getWeekSettings() {
    if (this.weekSettings) {
      return this.weekSettings;
    } else if (!hasLocaleWeekInfo()) {
      return fallbackWeekSettings;
    } else {
      return getCachedWeekInfo(this.locale);
    }
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
  toString() {
    return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;
  }
};

// node_modules/luxon/src/impl/zoneUtil.js
init_process_shim();

// node_modules/luxon/src/zones/fixedOffsetZone.js
init_process_shim();
var singleton2 = null;
var FixedOffsetZone = class _FixedOffsetZone extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton2 === null) {
      singleton2 = new _FixedOffsetZone(0);
    }
    return singleton2;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset3) {
    return offset3 === 0 ? _FixedOffsetZone.utcInstance : new _FixedOffsetZone(offset3);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s2) {
    if (s2) {
      const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new _FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }
  constructor(offset3) {
    super();
    this.fixed = offset3;
  }
  /**
   * The type of zone. `fixed` for all instances of `FixedOffsetZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "fixed";
  }
  /**
   * The name of this zone.
   * All fixed zones' names always start with "UTC" (plus optional offset)
   * @override
   * @type {string}
   */
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  /**
   * The IANA name of this zone, i.e. `Etc/UTC` or `Etc/GMT+/-nn`
   *
   * @override
   * @type {string}
   */
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  /**
   * Returns the offset's common name at the specified timestamp.
   *
   * For fixed offset zones this equals to the zone name.
   * @override
   */
  offsetName() {
    return this.name;
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format11) {
    return formatOffset(this.fixed, format11);
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns true for all fixed offset zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return true;
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   *
   * For fixed offset zones, this is constant and does not depend on a timestamp.
   * @override
   * @return {number}
   */
  offset() {
    return this.fixed;
  }
  /**
   * Return whether this Zone is equal to another zone (i.e. also fixed and same offset)
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  /**
   * Return whether this Zone is valid:
   * All fixed offset zones are valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/invalidZone.js
init_process_shim();
var InvalidZone = class extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return false;
  }
  /** @override **/
  get isValid() {
    return false;
  }
};

// node_modules/luxon/src/impl/zoneUtil.js
function normalizeZone(input10, defaultZone2) {
  let offset3;
  if (isUndefined2(input10) || input10 === null) {
    return defaultZone2;
  } else if (input10 instanceof Zone) {
    return input10;
  } else if (isString2(input10)) {
    const lowered = input10.toLowerCase();
    if (lowered === "default") return defaultZone2;
    else if (lowered === "local" || lowered === "system") return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;
    else return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input10);
  } else if (isNumber2(input10)) {
    return FixedOffsetZone.instance(input10);
  } else if (typeof input10 === "object" && "offset" in input10 && typeof input10.offset === "function") {
    return input10;
  } else {
    return new InvalidZone(input10);
  }
}

// node_modules/luxon/src/impl/digits.js
init_process_shim();
var numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
var numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0; i < str.length; i++) {
      const code20 = str.charCodeAt(i);
      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code20 >= min && code20 <= max) {
            value += code20 - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
var digitRegexCache = {};
function resetDigitRegexCache() {
  digitRegexCache = {};
}
function digitRegex({ numberingSystem }, append3 = "") {
  const ns = numberingSystem || "latn";
  if (!digitRegexCache[ns]) {
    digitRegexCache[ns] = {};
  }
  if (!digitRegexCache[ns][append3]) {
    digitRegexCache[ns][append3] = new RegExp(`${numberingSystems[ns]}${append3}`);
  }
  return digitRegexCache[ns][append3];
}

// node_modules/luxon/src/settings.js
var now2 = () => Date.now();
var defaultZone = "system";
var defaultLocale = null;
var defaultNumberingSystem = null;
var defaultOutputCalendar = null;
var twoDigitCutoffYear = 60;
var throwOnInvalid;
var defaultWeekSettings = null;
var Settings = class {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now2;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n2) {
    now2 = n2;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  /**
   * @typedef {Object} WeekSettings
   * @property {number} firstDay
   * @property {number} minimalDays
   * @property {number[]} weekend
   */
  /**
   * @return {WeekSettings|null}
   */
  static get defaultWeekSettings() {
    return defaultWeekSettings;
  }
  /**
   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
   * how many days are required in the first week of a year.
   * Does not affect existing instances.
   *
   * @param {WeekSettings|null} weekSettings
   */
  static set defaultWeekSettings(weekSettings) {
    defaultWeekSettings = validateWeekSettings(weekSettings);
  }
  /**
   * Get the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }
  /**
   * Set the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // all 'yy' are interpreted as 20th century
   * @example Settings.twoDigitCutoffYear = 99 // all 'yy' are interpreted as 21st century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 2049; '50' -> 1950
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(cutoffYear) {
    twoDigitCutoffYear = cutoffYear % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
    DateTime.resetCache();
    resetDigitRegexCache();
  }
};

// node_modules/luxon/src/impl/conversions.js
init_process_shim();

// node_modules/luxon/src/impl/invalid.js
init_process_shim();
var Invalid = class {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
};

// node_modules/luxon/src/impl/conversions.js
var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value) {
  return new Invalid(
    "unit out of range",
    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
  );
}
function dayOfWeek(year2, month, day2) {
  const d = new Date(Date.UTC(year2, month - 1, day2));
  if (year2 < 100 && year2 >= 0) {
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  const js = d.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year2, month, day2) {
  return day2 + (isLeapYear(year2) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year2, ordinal) {
  const table = isLeapYear(year2) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal), day2 = ordinal - table[month0];
  return { month: month0 + 1, day: day2 };
}
function isoWeekdayToLocal(isoWeekday, startOfWeek) {
  return (isoWeekday - startOfWeek + 7) % 7 + 1;
}
function gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { year: year2, month, day: day2 } = gregObj, ordinal = computeOrdinal(year2, month, day2), weekday = isoWeekdayToLocal(dayOfWeek(year2, month, day2), startOfWeek);
  let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year2 - 1;
    weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
  } else if (weekNumber > weeksInWeekYear(year2, minDaysInFirstWeek, startOfWeek)) {
    weekYear = year2 + 1;
    weekNumber = 1;
  } else {
    weekYear = year2;
  }
  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}
function weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year2;
  if (ordinal < 1) {
    year2 = weekYear - 1;
    ordinal += daysInYear(year2);
  } else if (ordinal > yearInDays) {
    year2 = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year2 = weekYear;
  }
  const { month, day: day2 } = uncomputeOrdinal(year2, ordinal);
  return { year: year2, month, day: day2, ...timeObject(weekData) };
}
function gregorianToOrdinal(gregData) {
  const { year: year2, month, day: day2 } = gregData;
  const ordinal = computeOrdinal(year2, month, day2);
  return { year: year2, ordinal, ...timeObject(gregData) };
}
function ordinalToGregorian(ordinalData) {
  const { year: year2, ordinal } = ordinalData;
  const { month, day: day2 } = uncomputeOrdinal(year2, ordinal);
  return { year: year2, month, day: day2, ...timeObject(ordinalData) };
}
function usesLocalWeekValues(obj, loc) {
  const hasLocaleWeekData = !isUndefined2(obj.localWeekday) || !isUndefined2(obj.localWeekNumber) || !isUndefined2(obj.localWeekYear);
  if (hasLocaleWeekData) {
    const hasIsoWeekData = !isUndefined2(obj.weekday) || !isUndefined2(obj.weekNumber) || !isUndefined2(obj.weekYear);
    if (hasIsoWeekData) {
      throw new ConflictingSpecificationError(
        "Cannot mix locale-based week fields with ISO-based week fields"
      );
    }
    if (!isUndefined2(obj.localWeekday)) obj.weekday = obj.localWeekday;
    if (!isUndefined2(obj.localWeekNumber)) obj.weekNumber = obj.localWeekNumber;
    if (!isUndefined2(obj.localWeekYear)) obj.weekYear = obj.localWeekYear;
    delete obj.localWeekday;
    delete obj.localWeekNumber;
    delete obj.localWeekYear;
    return {
      minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
      startOfWeek: loc.getStartOfWeek()
    };
  } else {
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
  }
}
function hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(
    obj.weekNumber,
    1,
    weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)
  ), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.weekNumber);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else return false;
}
function hasInvalidTimeData(obj) {
  const { hour: hour2, minute: minute2, second, millisecond } = obj;
  const validHour = integerBetween(hour2, 0, 23) || hour2 === 24 && minute2 === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute2, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour2);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute2);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else return false;
}

// node_modules/luxon/src/impl/util.js
function isUndefined2(o) {
  return typeof o === "undefined";
}
function isNumber2(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString2(o) {
  return typeof o === "string";
}
function isDate2(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}
function hasLocaleWeekInfo() {
  try {
    return typeof Intl !== "undefined" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch (e) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare4) {
  if (arr.length === 0) {
    return void 0;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare4(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys2) {
  return keys2.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function validateWeekSettings(settings) {
  if (settings == null) {
    return null;
  } else if (typeof settings !== "object") {
    throw new InvalidArgumentError("Week settings must be an object");
  } else {
    if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v) => !integerBetween(v, 1, 7))) {
      throw new InvalidArgumentError("Invalid week settings");
    }
    return {
      firstDay: settings.firstDay,
      minimalDays: settings.minimalDays,
      weekend: Array.from(settings.weekend)
    };
  }
}
function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}
function floorMod(x, n2) {
  return x - n2 * Math.floor(x / n2);
}
function padStart(input10, n2 = 2) {
  const isNeg = input10 < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input10).padStart(n2, "0");
  } else {
    padded = ("" + input10).padStart(n2, "0");
  }
  return padded;
}
function parseInteger(string4) {
  if (isUndefined2(string4) || string4 === null || string4 === "") {
    return void 0;
  } else {
    return parseInt(string4, 10);
  }
}
function parseFloating(string4) {
  if (isUndefined2(string4) || string4 === null || string4 === "") {
    return void 0;
  } else {
    return parseFloat(string4);
  }
}
function parseMillis(fraction) {
  if (isUndefined2(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f);
  }
}
function roundTo(number3, digits, towardZero = false) {
  const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number3 * factor) / factor;
}
function isLeapYear(year2) {
  return year2 % 4 === 0 && (year2 % 100 !== 0 || year2 % 400 === 0);
}
function daysInYear(year2) {
  return isLeapYear(year2) ? 366 : 365;
}
function daysInMonth(year2, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year2 + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
  }
  return +d;
}
function firstWeekOffset(year2, minDaysInFirstWeek, startOfWeek) {
  const fwdlw = isoWeekdayToLocal(dayOfWeek(year2, 1, minDaysInFirstWeek), startOfWeek);
  return -fwdlw + minDaysInFirstWeek - 1;
}
function weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
  const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
  return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
}
function untruncateYear(year2) {
  if (year2 > 99) {
    return year2;
  } else return year2 > Settings.twoDigitCutoffYear ? 1900 + year2 : 2e3 + year2;
}
function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date = new Date(ts), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = { timeZoneName: offsetFormat, ...intlOpts };
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty2(obj, u)) {
      const v = obj[u];
      if (v === void 0 || v === null) continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}
function formatOffset(offset3, format11) {
  const hours = Math.trunc(Math.abs(offset3 / 60)), minutes = Math.trunc(Math.abs(offset3 % 60)), sign3 = offset3 >= 0 ? "+" : "-";
  switch (format11) {
    case "short":
      return `${sign3}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign3}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign3}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format11} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}

// node_modules/luxon/src/impl/english.js
var monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length5) {
  switch (length5) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
var weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length5) {
  switch (length5) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
var meridiems = ["AM", "PM"];
var erasLong = ["Before Christ", "Anno Domini"];
var erasShort = ["BC", "AD"];
var erasNarrow = ["B", "A"];
function eras(length5) {
  switch (length5) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length5) {
  return weekdays(length5)[dt.weekday - 1];
}
function monthForDateTime(dt, length5) {
  return months(length5)[dt.month - 1];
}
function eraForDateTime(dt, length5) {
  return eras(length5)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
      default:
    }
  }
  const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}

// node_modules/luxon/src/impl/formatter.js
function stringifyTokens(splits, tokenToString) {
  let s2 = "";
  for (const token of splits) {
    if (token.literal) {
      s2 += token.val;
    } else {
      s2 += tokenToString(token.val);
    }
  }
  return s2;
}
var macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
var Formatter = class _Formatter {
  static create(locale, opts = {}) {
    return new _Formatter(locale, opts);
  }
  static parseFormat(fmt) {
    let current2 = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt.length; i++) {
      const c = fmt.charAt(i);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        current2 = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current2) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
        }
        currentFull = c;
        current2 = c;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  dtFormatter(dt, opts = {}) {
    return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
  }
  formatDateTime(dt, opts) {
    return this.dtFormatter(dt, opts).format();
  }
  formatDateTimeParts(dt, opts) {
    return this.dtFormatter(dt, opts).formatToParts();
  }
  formatInterval(interval, opts) {
    const df = this.dtFormatter(interval.start, opts);
    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
  }
  resolvedOptions(dt, opts) {
    return this.dtFormatter(dt, opts).resolvedOptions();
  }
  num(n2, p = 0) {
    if (this.opts.forceSimple) {
      return padStart(n2, p);
    }
    const opts = { ...this.opts };
    if (p > 0) {
      opts.padTo = p;
    }
    return this.loc.numberFormatter(opts).format(n2);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string4 = (opts, extract2) => this.loc.extract(dt, opts, extract2), formatOffset2 = (opts) => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string4({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length5, standalone) => knownEnglish ? monthForDateTime(dt, length5) : string4(standalone ? { month: length5 } : { month: length5, day: "numeric" }, "month"), weekday = (length5, standalone) => knownEnglish ? weekdayForDateTime(dt, length5) : string4(
      standalone ? { weekday: length5 } : { weekday: length5, month: "long", day: "numeric" },
      "weekday"
    ), maybeMacro = (token) => {
      const formatOpts = _Formatter.macroTokenToFormatOpts(token);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    }, era = (length5) => knownEnglish ? eraForDateTime(dt, length5) : string4({ era: length5 }, "era"), tokenToString = (token) => {
      switch (token) {
        // ms
        case "S":
          return this.num(dt.millisecond);
        case "u":
        // falls through
        case "SSS":
          return this.num(dt.millisecond, 3);
        // seconds
        case "s":
          return this.num(dt.second);
        case "ss":
          return this.num(dt.second, 2);
        // fractional seconds
        case "uu":
          return this.num(Math.floor(dt.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt.millisecond / 100));
        // minutes
        case "m":
          return this.num(dt.minute);
        case "mm":
          return this.num(dt.minute, 2);
        // hours
        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
        case "H":
          return this.num(dt.hour);
        case "HH":
          return this.num(dt.hour, 2);
        // offset
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
        // zone
        case "z":
          return dt.zoneName;
        // meridiems
        case "a":
          return meridiem();
        // dates
        case "d":
          return useDateTimeFormatter ? string4({ day: "numeric" }, "day") : this.num(dt.day);
        case "dd":
          return useDateTimeFormatter ? string4({ day: "2-digit" }, "day") : this.num(dt.day, 2);
        // weekdays - standalone
        case "c":
          return this.num(dt.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        // weekdays - format
        case "E":
          return this.num(dt.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        // months - standalone
        case "L":
          return useDateTimeFormatter ? string4({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
        case "LL":
          return useDateTimeFormatter ? string4({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        // months - format
        case "M":
          return useDateTimeFormatter ? string4({ month: "numeric" }, "month") : this.num(dt.month);
        case "MM":
          return useDateTimeFormatter ? string4({ month: "2-digit" }, "month") : this.num(dt.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        // years
        case "y":
          return useDateTimeFormatter ? string4({ year: "numeric" }, "year") : this.num(dt.year);
        case "yy":
          return useDateTimeFormatter ? string4({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string4({ year: "numeric" }, "year") : this.num(dt.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string4({ year: "numeric" }, "year") : this.num(dt.year, 6);
        // eras
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt.weekYear, 4);
        case "W":
          return this.num(dt.weekNumber);
        case "WW":
          return this.num(dt.weekNumber, 2);
        case "n":
          return this.num(dt.localWeekNumber);
        case "nn":
          return this.num(dt.localWeekNumber, 2);
        case "ii":
          return this.num(dt.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(dt.localWeekYear, 4);
        case "o":
          return this.num(dt.ordinal);
        case "ooo":
          return this.num(dt.ordinal, 3);
        case "q":
          return this.num(dt.quarter);
        case "qq":
          return this.num(dt.quarter, 2);
        case "X":
          return this.num(Math.floor(dt.ts / 1e3));
        case "x":
          return this.num(dt.ts);
        default:
          return maybeMacro(token);
      }
    };
    return stringifyTokens(_Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
      switch (token[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, tokenToString = (lildur) => (token) => {
      const mapped = tokenToField(token);
      if (mapped) {
        return this.num(lildur.get(mapped), token.length);
      } else {
        return token;
      }
    }, tokens = _Formatter.parseFormat(fmt), realTokens = tokens.reduce(
      (found, { literal: literal2, val }) => literal2 ? found : found.concat(val),
      []
    ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
};

// node_modules/luxon/src/impl/regexParser.js
init_process_shim();
var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes(...regexes) {
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return (m) => extractors.reduce(
    ([mergedVals, mergedZone, cursor], ex) => {
      const [val, zone, next] = ex(m, cursor);
      return [{ ...mergedVals, ...val }, zone || mergedZone, next];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function parse7(s2, ...patterns) {
  if (s2 == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s2);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
}
function simpleParse(...keys2) {
  return (match6, cursor) => {
    const ret = {};
    let i;
    for (i = 0; i < keys2.length; i++) {
      ret[keys2[i]] = parseInteger(match6[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}
var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
var extractISOOrdinalData = simpleParse("year", "ordinal");
var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
var sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match6, pos, fallback) {
  const m = match6[pos];
  return isUndefined2(m) ? fallback : parseInteger(m);
}
function extractISOYmd(match6, cursor) {
  const item = {
    year: int(match6, cursor),
    month: int(match6, cursor + 1, 1),
    day: int(match6, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match6, cursor) {
  const item = {
    hours: int(match6, cursor, 0),
    minutes: int(match6, cursor + 1, 0),
    seconds: int(match6, cursor + 2, 0),
    milliseconds: parseMillis(match6[cursor + 3])
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match6, cursor) {
  const local = !match6[cursor] && !match6[cursor + 1], fullOffset = signedOffset(match6[cursor + 1], match6[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match6, cursor) {
  const zone = match6[cursor] ? IANAZone.create(match6[cursor]) : null;
  return [{}, zone, cursor + 1];
}
var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match6) {
  const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match6;
  const hasNegativePrefix = s2[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
}
var obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr) result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match6) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match6, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset3;
  if (obsOffset) {
    offset3 = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset3 = 0;
  } else {
    offset3 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset3)];
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
var ascii2 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match6) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match6, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match6) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match6, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
var extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseISODate(s2) {
  return parse7(
    s2,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}
function parseRFC2822Date(s2) {
  return parse7(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s2) {
  return parse7(
    s2,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii2, extractASCII]
  );
}
function parseISODuration(s2) {
  return parse7(s2, [isoDuration, extractISODuration]);
}
var extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s2) {
  return parse7(s2, [isoTimeOnly, extractISOTimeOnly]);
}
var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
var extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseSQL(s2) {
  return parse7(
    s2,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}

// node_modules/luxon/src/duration.js
var INVALID = "Invalid Duration";
var lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
};
var casualMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var daysInYearAccurate = 146097 / 400;
var daysInMonthAccurate = 146097 / 4800;
var accurateMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var orderedUnits = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
var reverseUnits = orderedUnits.slice(0).reverse();
function clone(dur, alts, clear = false) {
  const conf = {
    values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
}
function durationToMillis(matrix, vals) {
  let sum = vals.milliseconds ?? 0;
  for (const unit of reverseUnits.slice(1)) {
    if (vals[unit]) {
      sum += vals[unit] * matrix[unit]["milliseconds"];
    }
  }
  return sum;
}
function normalizeValues(matrix, vals) {
  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
  orderedUnits.reduceRight((previous, current2) => {
    if (!isUndefined2(vals[current2])) {
      if (previous) {
        const previousVal = vals[previous] * factor;
        const conv = matrix[current2][previous];
        const rollUp = Math.floor(previousVal / conv);
        vals[current2] += rollUp * factor;
        vals[previous] -= rollUp * conv * factor;
      }
      return current2;
    } else {
      return previous;
    }
  }, null);
  orderedUnits.reduce((previous, current2) => {
    if (!isUndefined2(vals[current2])) {
      if (previous) {
        const fraction = vals[previous] % 1;
        vals[previous] -= fraction;
        vals[current2] += fraction * matrix[previous][current2];
      }
      return current2;
    } else {
      return previous;
    }
  }, null);
}
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
}
var Duration = class _Duration {
  /**
   * @private
   */
  constructor(config2) {
    const accurate = config2.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config2.matrix) {
      matrix = config2.matrix;
    }
    this.values = config2.values;
    this.loc = config2.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config2.invalid || null;
    this.matrix = matrix;
    this.isLuxonDuration = true;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count, opts) {
    return _Duration.fromObject({ milliseconds: count }, opts);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
      );
    }
    return new _Duration({
      values: normalizeObject(obj, _Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber2(durationLike)) {
      return _Duration.fromMillis(durationLike);
    } else if (_Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return _Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text2, opts) {
    const [parsed] = parseISODuration(text2);
    if (parsed) {
      return _Duration.fromObject(parsed, opts);
    } else {
      return _Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text2, opts) {
    const [parsed] = parseISOTimeOnly(text2);
    if (parsed) {
      return _Duration.fromObject(parsed, opts);
    } else {
      return _Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new _Duration({ invalid });
    }
  }
  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized) throw new InvalidUnitError(unit);
    return normalized;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o) {
    return o && o.isLuxonDuration || false;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(opts = {}) {
    if (!this.isValid) return INVALID;
    const l2 = orderedUnits.map((unit) => {
      const val = this.values[unit];
      if (isUndefined2(val)) {
        return null;
      }
      return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
    }).filter((n2) => n2);
    return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l2);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid) return {};
    return { ...this.values };
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid) return null;
    let s2 = "P";
    if (this.years !== 0) s2 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0) s2 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0) s2 += this.weeks + "W";
    if (this.days !== 0) s2 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s2 += "T";
    if (this.hours !== 0) s2 += this.hours + "H";
    if (this.minutes !== 0) s2 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s2 === "P") s2 += "T0S";
    return s2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid) return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5) return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts,
      includeOffset: false
    };
    const dateTime = DateTime.fromMillis(millis, { zone: "UTC" });
    return dateTime.toISOTime(opts);
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Duration { values: ${JSON.stringify(this.values)} }`;
    } else {
      return `Duration { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    if (!this.isValid) return NaN;
    return durationToMillis(this.matrix, this.values);
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid) return this;
    const dur = _Duration.fromDurationLike(duration), result = {};
    for (const k of orderedUnits) {
      if (hasOwnProperty2(dur.values, k) || hasOwnProperty2(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }
    return clone(this, { values: result }, true);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid) return this;
    const dur = _Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn) {
    if (!this.isValid) return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn(this.values[k], k));
    }
    return clone(this, { values: result }, true);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[_Duration.normalizeUnit(unit)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values2) {
    if (!this.isValid) return this;
    const mixed = { ...this.values, ...normalizeObject(values2, _Duration.normalizeUnit) };
    return clone(this, { values: mixed });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone(this, opts);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid) return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone(this, { values: vals }, true);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid) return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone(this, { values: vals }, true);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid) return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u) => _Duration.normalizeUnit(u));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k of orderedUnits) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0;
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }
        if (isNumber2(vals[k])) {
          own += vals[k];
        }
        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
      } else if (isNumber2(vals[k])) {
        accumulated[k] = vals[k];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    normalizeValues(this.matrix, built);
    return clone(this, { values: built }, true);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    if (!this.isValid) return this;
    return this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    );
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid) return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone(this, { values: negated }, true);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v2) {
      if (v1 === void 0 || v1 === 0) return v2 === void 0 || v2 === 0;
      return v1 === v2;
    }
    for (const u of orderedUnits) {
      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/luxon/src/interval.js
init_process_shim();
var INVALID2 = "Invalid Interval";
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
    );
  } else {
    return null;
  }
}
var Interval = class _Interval {
  /**
   * @private
   */
  constructor(config2) {
    this.s = config2.start;
    this.e = config2.end;
    this.invalid = config2.invalid || null;
    this.isLuxonInterval = true;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new _Interval({ invalid });
    }
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new _Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
    return _Interval.fromDateTimes(dt, dt.plus(dur));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
    return _Interval.fromDateTimes(dt.minus(dur), dt);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text2, opts) {
    const [s2, e] = (text2 || "").split("/", 2);
    if (s2 && e) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s2, opts);
        startIsValid = start.isValid;
      } catch (e2) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e2) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return _Interval.fromDateTimes(start, end);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e, opts);
        if (dur.isValid) {
          return _Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s2, opts);
        if (dur.isValid) {
          return _Interval.before(end, dur);
        }
      }
    }
    return _Interval.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o) {
    return o && o.isLuxonInterval || false;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
   * @return {number}
   */
  count(unit = "milliseconds", opts) {
    if (!this.isValid) return NaN;
    const start = this.start.startOf(unit, opts);
    let end;
    if (opts?.useLocaleWeeks) {
      end = this.end.reconfigure({ locale: start.locale });
    } else {
      end = this.end;
    }
    end = end.startOf(unit, opts);
    return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid) return false;
    return this.s > dateTime;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid) return false;
    return this.e <= dateTime;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid) return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start, end } = {}) {
    if (!this.isValid) return this;
    return _Interval.fromDateTimes(start || this.s, end || this.e);
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid) return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort((a, b) => a.toMillis() - b.toMillis()), results = [];
    let { s: s2 } = this, i = 0;
    while (s2 < this.e) {
      const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
      results.push(_Interval.fromDateTimes(s2, next));
      s2 = next;
      i += 1;
    }
    return results;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration) {
    const dur = Duration.fromDurationLike(duration);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s2 } = this, idx = 1, next;
    const results = [];
    while (s2 < this.e) {
      const added = this.start.plus(dur.mapUnits((x) => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(_Interval.fromDateTimes(s2, next));
      s2 = next;
      idx += 1;
    }
    return results;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid) return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid) return false;
    return +this.e === +other.s;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid) return false;
    return +other.e === +this.s;
  }
  /**
   * Returns true if this Interval fully contains the specified Interval, specifically if the intersect (of this Interval and the other Interval) is equal to the other Interval; false otherwise.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid) return false;
    return this.s <= other.s && this.e >= other.e;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid) return this;
    const s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
    if (s2 >= e) {
      return null;
    } else {
      return _Interval.fromDateTimes(s2, e);
    }
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid) return this;
    const s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
    return _Interval.fromDateTimes(s2, e);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(
      ([sofar, current2], item) => {
        if (!current2) {
          return [sofar, item];
        } else if (current2.overlaps(item) || current2.abutsStart(item)) {
          return [sofar, current2.union(item)];
        } else {
          return [sofar.concat([current2]), item];
        }
      },
      [[], null]
    );
    if (final) {
      found.push(final);
    }
    return found;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start = null, currentCount = 0;
    const results = [], ends = intervals.map((i) => [
      { time: i.s, type: "s" },
      { time: i.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(_Interval.fromDateTimes(start, i.time));
        }
        start = null;
      }
    }
    return _Interval.merge(results);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return _Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid) return INVALID2;
    return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
  }
  /**
   * Returns a string representation of this Interval appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
    } else {
      return `Interval { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid) return INVALID2;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid) return INVALID2;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid) return INVALID2;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(dateFormat, { separator = " \u2013 " } = {}) {
    if (!this.isValid) return INVALID2;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return _Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
};

// node_modules/luxon/src/info.js
init_process_shim();
var Info = class {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input10) {
    return normalizeZone(input10, Settings.defaultZone);
  }
  /**
   * Get the weekday on which the week starts according to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
   */
  static getStartOfWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getStartOfWeek();
  }
  /**
   * Get the minimum number of days necessary in a week before it is considered part of the next year according
   * to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number}
   */
  static getMinimumDaysInFirstWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getMinDaysInFirstWeek();
  }
  /**
   * Get the weekdays, which are considered the weekend according to the given locale
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
   */
  static getWeekendWeekdays({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getWeekendDays().slice();
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {Array}
   */
  static months(length5 = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length5);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(length5 = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length5, true);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {Array}
   */
  static weekdays(length5 = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length5);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(length5 = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length5, true);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {Array}
   */
  static meridiems({ locale = null } = {}) {
    return Locale.create(locale).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {Array}
   */
  static eras(length5 = "short", { locale = null } = {}) {
    return Locale.create(locale, null, "gregory").eras(length5);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
   * @example Info.features() //=> { relative: false, localeWeek: true }
   * @return {Object}
   */
  static features() {
    return { relative: hasRelative(), localeWeek: hasLocaleWeekInfo() };
  }
};

// node_modules/luxon/src/impl/diff.js
init_process_shim();
function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a, b) => b.year - a.year],
    ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
    ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
    [
      "weeks",
      (a, b) => {
        const days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  const earlier = cursor;
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      results[unit] = differ(cursor, later);
      highWater = earlier.plus(results);
      if (highWater > later) {
        results[unit]--;
        cursor = earlier.plus(results);
        if (cursor > later) {
          highWater = cursor;
          results[unit]--;
          cursor = earlier.plus(results);
        }
      } else {
        cursor = highWater;
      }
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff_default(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter(
    (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
  );
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}

// node_modules/luxon/src/impl/tokenParser.js
init_process_shim();
var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = (i) => i) {
  return { regex, deser: ([s2]) => post(parseDigits(s2)) };
}
var NBSP = String.fromCharCode(160);
var spaceOrNBSP = `[ ${NBSP}]`;
var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s2) {
  return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s2) {
  return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
    };
  }
}
function offset2(regex, groups) {
  return { regex, deser: ([, h, m]) => signedOffset(h, m), groups };
}
function simple(regex) {
  return { regex, deser: ([s2]) => s2 };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
  const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal2 = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s2]) => s2, literal: true }), unitate = (t) => {
    if (token.literal) {
      return literal2(t);
    }
    switch (t.val) {
      // era
      case "G":
        return oneOf(loc.eras("short"), 0);
      case "GG":
        return oneOf(loc.eras("long"), 0);
      // years
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      // months
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true), 1);
      case "MMMM":
        return oneOf(loc.months("long", true), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false), 1);
      // dates
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      // ordinals
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      // time
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one);
      // meridiem
      case "a":
        return oneOf(loc.meridiems(), 0);
      // weekYear (k)
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear);
      // weekNumber (W)
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      // weekdays
      case "E":
      case "c":
        return intUnit(one);
      case "EEE":
        return oneOf(loc.weekdays("short", false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true), 1);
      // offset/zone
      case "Z":
      case "ZZ":
        return offset2(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset2(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
      // because we don't have any way to figure out what they are
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      // this special-case "token" represents a place where a macro-token expanded into a white-space literal
      // in this case we accept any non-newline white-space
      case " ":
        return simple(/[^\S\n\r]/);
      default:
        return literal2(t);
    }
  };
  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}
var partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, formatOpts, resolvedOpts) {
  const { type: type2, value } = part;
  if (type2 === "literal") {
    const isSpace = /^\s+$/.test(value);
    return {
      literal: !isSpace,
      val: isSpace ? " " : value
    };
  }
  const style = formatOpts[type2];
  let actualType = type2;
  if (type2 === "hour") {
    if (formatOpts.hour12 != null) {
      actualType = formatOpts.hour12 ? "hour12" : "hour24";
    } else if (formatOpts.hourCycle != null) {
      if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
        actualType = "hour12";
      } else {
        actualType = "hour24";
      }
    } else {
      actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
    }
  }
  let val = partTypeStyleToTokenVal[actualType];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re}$`, units];
}
function match5(input10, regex, handlers) {
  const matches = input10.match(regex);
  if (matches) {
    const all5 = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (hasOwnProperty2(handlers, i)) {
        const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all5[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all5];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined2(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined2(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined2(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined2(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined2(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }
    return r;
  }, {});
  return [vals, zone, specificOffset];
}
var dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);
  if (tokens == null || tokens.includes(void 0)) {
    return token;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));
}
var TokenParser = class {
  constructor(locale, format11) {
    this.locale = locale;
    this.format = format11;
    this.tokens = expandMacroTokens(Formatter.parseFormat(format11), locale);
    this.units = this.tokens.map((t) => unitForToken(t, locale));
    this.disqualifyingUnit = this.units.find((t) => t.invalidReason);
    if (!this.disqualifyingUnit) {
      const [regexString, handlers] = buildRegex(this.units);
      this.regex = RegExp(regexString, "i");
      this.handlers = handlers;
    }
  }
  explainFromTokens(input10) {
    if (!this.isValid) {
      return { input: input10, tokens: this.tokens, invalidReason: this.invalidReason };
    } else {
      const [rawMatches, matches] = match5(input10, this.regex, this.handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
      if (hasOwnProperty2(matches, "a") && hasOwnProperty2(matches, "H")) {
        throw new ConflictingSpecificationError(
          "Can't include meridiem when specifying 24-hour format"
        );
      }
      return {
        input: input10,
        tokens: this.tokens,
        regex: this.regex,
        rawMatches,
        matches,
        result,
        zone,
        specificOffset
      };
    }
  }
  get isValid() {
    return !this.disqualifyingUnit;
  }
  get invalidReason() {
    return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;
  }
};
function explainFromTokens(locale, input10, format11) {
  const parser = new TokenParser(locale, format11);
  return parser.explainFromTokens(input10);
}
function parseFromTokens(locale, input10, format11) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input10, format11);
  return [result, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter.create(locale, formatOpts);
  const df = formatter.dtFormatter(getDummyDateTime());
  const parts = df.formatToParts();
  const resolvedOpts = df.resolvedOptions();
  return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));
}

// node_modules/luxon/src/datetime.js
var INVALID3 = "Invalid DateTime";
var MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}
function possiblyCachedLocalWeekData(dt) {
  if (dt.localWeekData === null) {
    dt.localWeekData = gregorianToWeek(
      dt.c,
      dt.loc.getMinDaysInFirstWeek(),
      dt.loc.getStartOfWeek()
    );
  }
  return dt.localWeekData;
}
function clone2(inst, alts) {
  const current2 = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({ ...current2, ...alts, old: current2 });
}
function fixOffset(localTS, o, tz) {
  let utcGuess = localTS - o * 60 * 1e3;
  const o2 = tz.offset(utcGuess);
  if (o === o2) {
    return [utcGuess, o];
  }
  utcGuess -= (o2 - o) * 60 * 1e3;
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }
  return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
}
function tsToObj(ts, offset3) {
  ts += offset3 * 60 * 1e3;
  const d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
}
function objToTS(obj, offset3, zone) {
  return fixOffset(objToLocalTS(obj), offset3, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o, year2 = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
    ...inst.c,
    year: year2,
    month,
    day: Math.min(inst.c.day, daysInMonth(year2, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }, millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c);
  let [ts, o] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o = inst.zone.offset(ts);
  }
  return { ts, o };
}
function parseDataToDateTime(parsed, parsedZone, opts, format11, text2, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
    const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
      ...opts,
      zone: interpretationZone,
      specificOffset
    });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new Invalid("unparsable", `the input "${text2}" can't be parsed as ${format11}`)
    );
  }
}
function toTechFormat(dt, format11, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format11) : null;
}
function toISODate(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0) c += "+";
  c += padStart(o.c.year, longFormat ? 6 : 4);
  if (extended) {
    c += "-";
    c += padStart(o.c.month);
    c += "-";
    c += padStart(o.c.day);
  } else {
    c += padStart(o.c.month);
    c += padStart(o.c.day);
  }
  return c;
}
function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c = padStart(o.c.hour);
  if (extended) {
    c += ":";
    c += padStart(o.c.minute);
    if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
      c += ":";
    }
  } else {
    c += padStart(o.c.minute);
  }
  if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
    c += padStart(o.c.second);
    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c += ".";
      c += padStart(o.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += padStart(Math.trunc(-o.o / 60));
      c += ":";
      c += padStart(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += padStart(Math.trunc(o.o / 60));
      c += ":";
      c += padStart(Math.trunc(o.o % 60));
    }
  }
  if (extendedZone) {
    c += "[" + o.zone.ianaName + "]";
  }
  return c;
}
var defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var orderedUnits2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized) throw new InvalidUnitError(unit);
  return normalized;
}
function normalizeUnitWithLocalWeeks(unit) {
  switch (unit.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return normalizeUnit(unit);
  }
}
function guessOffsetForZone(zone) {
  if (!zoneOffsetGuessCache[zone]) {
    if (zoneOffsetTs === void 0) {
      zoneOffsetTs = Settings.now();
    }
    zoneOffsetGuessCache[zone] = zone.offset(zoneOffsetTs);
  }
  return zoneOffsetGuessCache[zone];
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone);
  if (!zone.isValid) {
    return DateTime.invalid(unsupportedZone(zone));
  }
  const loc = Locale.fromObject(opts);
  let ts, o;
  if (!isUndefined2(obj.year)) {
    for (const u of orderedUnits2) {
      if (isUndefined2(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = guessOffsetForZone(zone);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = Settings.now();
  }
  return new DateTime({ ts, zone, loc, o });
}
function diffRelative(start, end, opts) {
  const round = isUndefined2(opts.round) ? true : opts.round, format11 = (c, unit) => {
    c = roundTo(c, round || opts.calendary ? 0 : 2, true);
    const formatter = end.loc.clone(opts).relFormatter(opts);
    return formatter.format(c, unit);
  }, differ = (unit) => {
    if (opts.calendary) {
      if (!end.hasSame(start, unit)) {
        return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
      } else return 0;
    } else {
      return end.diff(start, unit).get(unit);
    }
  };
  if (opts.unit) {
    return format11(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format11(count, unit);
    }
  }
  return format11(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
var zoneOffsetTs;
var zoneOffsetGuessCache = {};
var DateTime = class _DateTime {
  /**
   * @access private
   */
  constructor(config2) {
    const zone = config2.zone || Settings.defaultZone;
    let invalid = config2.invalid || (Number.isNaN(config2.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined2(config2.ts) ? Settings.now() : config2.ts;
    let c = null, o = null;
    if (!invalid) {
      const unchanged = config2.old && config2.old.ts === this.ts && config2.old.zone.equals(zone);
      if (unchanged) {
        [c, o] = [config2.old.c, config2.old.o];
      } else {
        const ot = isNumber2(config2.o) && !config2.old ? config2.o : zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }
    this._zone = zone;
    this.loc = config2.loc || Locale.create();
    this.invalid = invalid;
    this.weekData = null;
    this.localWeekData = null;
    this.c = c;
    this.o = o;
    this.isLuxonDateTime = true;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new _DateTime({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments), [year2, month, day2, hour2, minute2, second, millisecond] = args;
    return quickDT({ year: year2, month, day: day2, hour: hour2, minute: minute2, second, millisecond }, opts);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [options.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments), [year2, month, day2, hour2, minute2, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year: year2, month, day: day2, hour: hour2, minute: minute2, second, millisecond }, opts);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date, options = {}) {
    const ts = isDate2(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return _DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return _DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new _DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber2(milliseconds)) {
      throw new InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
      );
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return _DateTime.invalid("Timestamp out of range");
    } else {
      return new _DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds, options = {}) {
    if (!isNumber2(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new _DateTime({
        ts: seconds * 1e3,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.localWeekYear - a week year, according to the locale
   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return _DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const loc = Locale.fromObject(opts);
    const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, loc);
    const tsNow = Settings.now(), offsetProvis = !isUndefined2(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined2(normalized.ordinal), containsGregorYear = !isUndefined2(normalized.year), containsGregorMD = !isUndefined2(normalized.month) || !isUndefined2(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits2;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined2(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return _DateTime.invalid(invalid);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new _DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return _DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
      );
    }
    if (!inst.isValid) {
      return _DateTime.invalid(inst.invalid);
    }
    return inst;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [opts.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text2, opts = {}) {
    const [vals, parsedZone] = parseISODate(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text2);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text2, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text2);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text2, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text2, fmt, opts = {}) {
    if (isUndefined2(text2) || isUndefined2(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text2, fmt);
    if (invalid) {
      return _DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text2, specificOffset);
    }
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text2, fmt, opts = {}) {
    return _DateTime.fromFormat(text2, fmt, opts);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text2, opts = {}) {
    const [vals, parsedZone] = parseSQL(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text2);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new _DateTime({ invalid });
    }
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map((t) => t.val).join("");
  }
  static resetCache() {
    zoneOffsetTs = void 0;
    zoneOffsetGuessCache = {};
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit) {
    return this[unit];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  /**
   * Returns true if this date is on a weekend according to the locale, false otherwise
   * @returns {boolean}
   */
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  /**
   * Get the day of the week according to the locale.
   * 1 is the first day of the week and 7 is the last day of the week.
   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
   * @returns {number}
   */
  get localWeekday() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
  }
  /**
   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
   * because the week can start on different days of the week (see localWeekday) and because a different number of days
   * is required for a week to count as the first week of a year.
   * @returns {number}
   */
  get localWeekNumber() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
   * differently, see localWeekNumber.
   * @returns {number}
   */
  get localWeekYear() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed) {
      return [this];
    }
    const dayMs = 864e5;
    const minuteMs = 6e4;
    const localTS = objToLocalTS(this.c);
    const oEarlier = this.zone.offset(localTS - dayMs);
    const oLater = this.zone.offset(localTS + dayMs);
    const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
    const o2 = this.zone.offset(localTS - oLater * minuteMs);
    if (o1 === o2) {
      return [this];
    }
    const ts1 = localTS - o1 * minuteMs;
    const ts2 = localTS - o2 * minuteMs;
    const c1 = tsToObj(ts1, o1);
    const c2 = tsToObj(ts2, o2);
    if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
      return [clone2(this, { ts: ts1 }), clone2(this, { ts: ts2 })];
    }
    return [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's local week year
   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
   * @type {number}
   */
  get weeksInLocalWeekYear() {
    return this.isValid ? weeksInWeekYear(
      this.localWeekYear,
      this.loc.getMinDaysInFirstWeek(),
      this.loc.getStartOfWeek()
    ) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset3 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset3), opts);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return _DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone2(this, { ts: newTS, zone });
    }
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone2(this, { loc });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale) {
    return this.reconfigure({ locale });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   *
   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
   * They cannot be mixed with ISO-week units like `weekday`.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values2) {
    if (!this.isValid) return this;
    const normalized = normalizeObject(values2, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, this.loc);
    const settingWeekStuff = !isUndefined2(normalized.weekYear) || !isUndefined2(normalized.weekNumber) || !isUndefined2(normalized.weekday), containsOrdinal = !isUndefined2(normalized.ordinal), containsGregorYear = !isUndefined2(normalized.year), containsGregorMD = !isUndefined2(normalized.month) || !isUndefined2(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian(
        { ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek), ...normalized },
        minDaysInFirstWeek,
        startOfWeek
      );
    } else if (!isUndefined2(normalized.ordinal)) {
      mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
    } else {
      mixed = { ...this.toObject(), ...normalized };
      if (isUndefined2(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone2(this, { ts, o });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration);
    return clone2(this, adjustTime(this, dur));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration).negate();
    return clone2(this, adjustTime(this, dur));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit, { useLocaleWeeks = false } = {}) {
    if (!this.isValid) return this;
    const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      // falls through
      case "quarters":
      case "months":
        o.day = 1;
      // falls through
      case "weeks":
      case "days":
        o.hour = 0;
      // falls through
      case "hours":
        o.minute = 0;
      // falls through
      case "minutes":
        o.second = 0;
      // falls through
      case "seconds":
        o.millisecond = 0;
        break;
      case "milliseconds":
        break;
    }
    if (normalizedUnit === "weeks") {
      if (useLocaleWeeks) {
        const startOfWeek = this.loc.getStartOfWeek();
        const { weekday } = this;
        if (weekday < startOfWeek) {
          o.weekNumber = this.weekNumber - 1;
        }
        o.weekday = startOfWeek;
      } else {
        o.weekday = 1;
      }
    }
    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }
    return this.set(o);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit, opts) {
    return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit, opts).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID3;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID3;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format: format11 = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format11 === "extended";
    let c = toISODate(this, ext);
    c += "T";
    c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format: format11 = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format11 === "extended");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format: format11 = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c = includePrefix ? "T" : "";
    return c + toISOTime(
      this,
      format11 === "extended",
      suppressSeconds,
      suppressMilliseconds,
      includeOffset,
      extendedZone
    );
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID3;
  }
  /**
   * Returns a string representation of this DateTime appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
    } else {
      return `DateTime { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid) return {};
    const base5 = { ...this.c };
    if (opts.includeConfig) {
      base5.outputCalendar = this.outputCalendar;
      base5.numberingSystem = this.loc.numberingSystem;
      base5.locale = this.loc.locale;
    }
    return base5;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
    const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff_default(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(_DateTime.now(), unit, opts);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit, opts) {
    if (!this.isValid) return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options = {}) {
    if (!this.isValid) return null;
    const base5 = options.base || _DateTime.fromObject({}, { zone: this.zone }), padding2 = options.padding ? this < base5 ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = void 0;
    }
    return diffRelative(base5, this.plus(padding2), {
      ...options,
      numeric: "always",
      units,
      unit
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options = {}) {
    if (!this.isValid) return null;
    return diffRelative(options.base || _DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(_DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(_DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text2, fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text2, fmt);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text2, fmt, options = {}) {
    return _DateTime.fromFormatExplain(text2, fmt, options);
  }
  /**
   * Build a parser for `fmt` using the given locale. This parser can be passed
   * to {@link DateTime.fromFormatParser} to a parse a date in this format. This
   * can be used to optimize cases where many dates need to be parsed in a
   * specific format.
   *
   * @param {String} fmt - the format the string is expected to be in (see
   * description)
   * @param {Object} options - options used to set locale and numberingSystem
   * for parser
   * @returns {TokenParser} - opaque object to be used
   */
  static buildFormatParser(fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return new TokenParser(localeToUse, fmt);
  }
  /**
   * Create a DateTime from an input string and format parser.
   *
   * The format parser must have been created with the same locale as this call.
   *
   * @param {String} text - the string to parse
   * @param {TokenParser} formatParser - parser from {@link DateTime.buildFormatParser}
   * @param {Object} opts - options taken by fromFormat()
   * @returns {DateTime}
   */
  static fromFormatParser(text2, formatParser, opts = {}) {
    if (isUndefined2(text2) || isUndefined2(formatParser)) {
      throw new InvalidArgumentError(
        "fromFormatParser requires an input string and a format parser"
      );
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    if (!localeToUse.equals(formatParser.locale)) {
      throw new InvalidArgumentError(
        `fromFormatParser called with a locale of ${localeToUse}, but the format parser was created for ${formatParser.locale}`
      );
    }
    const { result, zone, specificOffset, invalidReason } = formatParser.explainFromTokens(text2);
    if (invalidReason) {
      return _DateTime.invalid(invalidReason);
    } else {
      return parseDataToDateTime(
        result,
        zone,
        opts,
        `format ${formatParser.format}`,
        text2,
        specificOffset
      );
    }
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
};
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber2(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}

// node_modules/@fleek-platform/sdk/dist/browser/index.js
var webcrypto_default;
var isCryptoKey;
var init_webcrypto = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/webcrypto.js"() {
    webcrypto_default = crypto;
    isCryptoKey = (key) => key instanceof CryptoKey;
  }
});
var digest6;
var digest_default;
var init_digest2 = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/digest.js"() {
    init_webcrypto();
    digest6 = async (algorithm2, data) => {
      const subtleDigest = `SHA-${algorithm2.slice(-3)}`;
      return new Uint8Array(await webcrypto_default.subtle.digest(subtleDigest, data));
    };
    digest_default = digest6;
  }
});
function concat4(...buffers) {
  const size5 = buffers.reduce((acc, { length: length5 }) => acc + length5, 0);
  const buf3 = new Uint8Array(size5);
  let i = 0;
  buffers.forEach((buffer3) => {
    buf3.set(buffer3, i);
    i += buffer3.length;
  });
  return buf3;
}
function p2s(alg, p2sInput) {
  return concat4(encoder3.encode(alg), new Uint8Array([0]), p2sInput);
}
function writeUInt32BE(buf3, value, offset3) {
  if (value < 0 || value >= MAX_INT32) {
    throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);
  }
  buf3.set([value >>> 24, value >>> 16, value >>> 8, value & 255], offset3);
}
function uint64be(value) {
  const high = Math.floor(value / MAX_INT32);
  const low = value % MAX_INT32;
  const buf3 = new Uint8Array(8);
  writeUInt32BE(buf3, high, 0);
  writeUInt32BE(buf3, low, 4);
  return buf3;
}
function uint32be(value) {
  const buf3 = new Uint8Array(4);
  writeUInt32BE(buf3, value);
  return buf3;
}
function lengthAndInput(input10) {
  return concat4(uint32be(input10.length), input10);
}
async function concatKdf(secret, bits, value) {
  const iterations = Math.ceil((bits >> 3) / 32);
  const res = new Uint8Array(iterations * 32);
  for (let iter = 0; iter < iterations; iter++) {
    const buf3 = new Uint8Array(4 + secret.length + value.length);
    buf3.set(uint32be(iter + 1));
    buf3.set(secret, 4);
    buf3.set(value, 4 + secret.length);
    res.set(await digest_default("sha256", buf3), iter * 32);
  }
  return res.slice(0, bits >> 3);
}
var encoder3;
var decoder3;
var MAX_INT32;
var init_buffer_utils = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/lib/buffer_utils.js"() {
    init_digest2();
    encoder3 = new TextEncoder();
    decoder3 = new TextDecoder();
    MAX_INT32 = 2 ** 32;
  }
});
var encodeBase64;
var encode38;
var decodeBase64;
var decode41;
var init_base64url = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/base64url.js"() {
    init_buffer_utils();
    encodeBase64 = (input10) => {
      let unencoded = input10;
      if (typeof unencoded === "string") {
        unencoded = encoder3.encode(unencoded);
      }
      const CHUNK_SIZE = 32768;
      const arr = [];
      for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {
        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
      }
      return btoa(arr.join(""));
    };
    encode38 = (input10) => {
      return encodeBase64(input10).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    };
    decodeBase64 = (encoded) => {
      const binary = atob(encoded);
      const bytes3 = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes3[i] = binary.charCodeAt(i);
      }
      return bytes3;
    };
    decode41 = (input10) => {
      let encoded = input10;
      if (encoded instanceof Uint8Array) {
        encoded = decoder3.decode(encoded);
      }
      encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
      try {
        return decodeBase64(encoded);
      } catch (_a3) {
        throw new TypeError("The input to be decoded is not correctly encoded.");
      }
    };
  }
});
var errors_exports = {};
__export2(errors_exports, {
  JOSEAlgNotAllowed: () => JOSEAlgNotAllowed,
  JOSEError: () => JOSEError,
  JOSENotSupported: () => JOSENotSupported,
  JWEDecryptionFailed: () => JWEDecryptionFailed,
  JWEInvalid: () => JWEInvalid,
  JWKInvalid: () => JWKInvalid,
  JWKSInvalid: () => JWKSInvalid,
  JWKSMultipleMatchingKeys: () => JWKSMultipleMatchingKeys,
  JWKSNoMatchingKey: () => JWKSNoMatchingKey,
  JWKSTimeout: () => JWKSTimeout,
  JWSInvalid: () => JWSInvalid,
  JWSSignatureVerificationFailed: () => JWSSignatureVerificationFailed,
  JWTClaimValidationFailed: () => JWTClaimValidationFailed,
  JWTExpired: () => JWTExpired,
  JWTInvalid: () => JWTInvalid
});
var JOSEError;
var JWTClaimValidationFailed;
var JWTExpired;
var JOSEAlgNotAllowed;
var JOSENotSupported;
var JWEDecryptionFailed;
var JWEInvalid;
var JWSInvalid;
var JWTInvalid;
var JWKInvalid;
var JWKSInvalid;
var JWKSNoMatchingKey;
var JWKSMultipleMatchingKeys;
var JWKSTimeout;
var JWSSignatureVerificationFailed;
var init_errors = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/util/errors.js"() {
    JOSEError = class extends Error {
      static get code() {
        return "ERR_JOSE_GENERIC";
      }
      constructor(message2) {
        var _a3;
        super(message2);
        this.code = "ERR_JOSE_GENERIC";
        this.name = this.constructor.name;
        (_a3 = Error.captureStackTrace) === null || _a3 === void 0 ? void 0 : _a3.call(Error, this, this.constructor);
      }
    };
    JWTClaimValidationFailed = class extends JOSEError {
      static get code() {
        return "ERR_JWT_CLAIM_VALIDATION_FAILED";
      }
      constructor(message2, claim = "unspecified", reason = "unspecified") {
        super(message2);
        this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
        this.claim = claim;
        this.reason = reason;
      }
    };
    JWTExpired = class extends JOSEError {
      static get code() {
        return "ERR_JWT_EXPIRED";
      }
      constructor(message2, claim = "unspecified", reason = "unspecified") {
        super(message2);
        this.code = "ERR_JWT_EXPIRED";
        this.claim = claim;
        this.reason = reason;
      }
    };
    JOSEAlgNotAllowed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
      }
      static get code() {
        return "ERR_JOSE_ALG_NOT_ALLOWED";
      }
    };
    JOSENotSupported = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_NOT_SUPPORTED";
      }
      static get code() {
        return "ERR_JOSE_NOT_SUPPORTED";
      }
    };
    JWEDecryptionFailed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_DECRYPTION_FAILED";
        this.message = "decryption operation failed";
      }
      static get code() {
        return "ERR_JWE_DECRYPTION_FAILED";
      }
    };
    JWEInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_INVALID";
      }
      static get code() {
        return "ERR_JWE_INVALID";
      }
    };
    JWSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_INVALID";
      }
      static get code() {
        return "ERR_JWS_INVALID";
      }
    };
    JWTInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWT_INVALID";
      }
      static get code() {
        return "ERR_JWT_INVALID";
      }
    };
    JWKInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWK_INVALID";
      }
      static get code() {
        return "ERR_JWK_INVALID";
      }
    };
    JWKSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_INVALID";
      }
      static get code() {
        return "ERR_JWKS_INVALID";
      }
    };
    JWKSNoMatchingKey = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_NO_MATCHING_KEY";
        this.message = "no applicable key found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_NO_MATCHING_KEY";
      }
    };
    JWKSMultipleMatchingKeys = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
        this.message = "multiple matching keys found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
      }
    };
    JWKSTimeout = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_TIMEOUT";
        this.message = "request timed out";
      }
      static get code() {
        return "ERR_JWKS_TIMEOUT";
      }
    };
    JWSSignatureVerificationFailed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
        this.message = "signature verification failed";
      }
      static get code() {
        return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
      }
    };
  }
});
var random_default;
var init_random = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/random.js"() {
    init_webcrypto();
    random_default = webcrypto_default.getRandomValues.bind(webcrypto_default);
  }
});
function bitLength(alg) {
  switch (alg) {
    case "A128GCM":
    case "A128GCMKW":
    case "A192GCM":
    case "A192GCMKW":
    case "A256GCM":
    case "A256GCMKW":
      return 96;
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      return 128;
    default:
      throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
  }
}
var iv_default;
var init_iv = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/lib/iv.js"() {
    init_errors();
    init_random();
    iv_default = (alg) => random_default(new Uint8Array(bitLength(alg) >> 3));
  }
});
var checkIvLength;
var check_iv_length_default;
var init_check_iv_length = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/lib/check_iv_length.js"() {
    init_errors();
    init_iv();
    checkIvLength = (enc, iv) => {
      if (iv.length << 3 !== bitLength(enc)) {
        throw new JWEInvalid("Invalid Initialization Vector length");
      }
    };
    check_iv_length_default = checkIvLength;
  }
});
var checkCekLength;
var check_cek_length_default;
var init_check_cek_length = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/check_cek_length.js"() {
    init_errors();
    checkCekLength = (cek, expected) => {
      const actual = cek.byteLength << 3;
      if (actual !== expected) {
        throw new JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
      }
    };
    check_cek_length_default = checkCekLength;
  }
});
var timingSafeEqual;
var timing_safe_equal_default;
var init_timing_safe_equal = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/timing_safe_equal.js"() {
    timingSafeEqual = (a, b) => {
      if (!(a instanceof Uint8Array)) {
        throw new TypeError("First argument must be a buffer");
      }
      if (!(b instanceof Uint8Array)) {
        throw new TypeError("Second argument must be a buffer");
      }
      if (a.length !== b.length) {
        throw new TypeError("Input buffers must have the same length");
      }
      const len = a.length;
      let out = 0;
      let i = -1;
      while (++i < len) {
        out |= a[i] ^ b[i];
      }
      return out === 0;
    };
    timing_safe_equal_default = timingSafeEqual;
  }
});
function isCloudflareWorkers() {
  return typeof WebSocketPair !== "undefined" || typeof navigator !== "undefined" && navigator.userAgent === "Cloudflare-Workers" || typeof EdgeRuntime !== "undefined" && EdgeRuntime === "vercel";
}
var init_env = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/env.js"() {
  }
});
function unusable(name15, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name15}`);
}
function isAlgorithm(algorithm2, name15) {
  return algorithm2.name === name15;
}
function getHashLength(hash) {
  return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case (isCloudflareWorkers() && "EdDSA"): {
      if (!isAlgorithm(key.algorithm, "NODE-ED25519"))
        throw unusable("NODE-ED25519");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}
function checkEncCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "A128GCM":
    case "A192GCM":
    case "A256GCM": {
      if (!isAlgorithm(key.algorithm, "AES-GCM"))
        throw unusable("AES-GCM");
      const expected = parseInt(alg.slice(1, 4), 10);
      const actual = key.algorithm.length;
      if (actual !== expected)
        throw unusable(expected, "algorithm.length");
      break;
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      if (!isAlgorithm(key.algorithm, "AES-KW"))
        throw unusable("AES-KW");
      const expected = parseInt(alg.slice(1, 4), 10);
      const actual = key.algorithm.length;
      if (actual !== expected)
        throw unusable(expected, "algorithm.length");
      break;
    }
    case "ECDH": {
      switch (key.algorithm.name) {
        case "ECDH":
        case "X25519":
        case "X448":
          break;
        default:
          throw unusable("ECDH, X25519, or X448");
      }
      break;
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW":
      if (!isAlgorithm(key.algorithm, "PBKDF2"))
        throw unusable("PBKDF2");
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      if (!isAlgorithm(key.algorithm, "RSA-OAEP"))
        throw unusable("RSA-OAEP");
      const expected = parseInt(alg.slice(9), 10) || 1;
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}
var init_crypto_key = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/lib/crypto_key.js"() {
    init_env();
  }
});
function message(msg, actual, ...types2) {
  if (types2.length > 2) {
    const last = types2.pop();
    msg += `one of type ${types2.join(", ")}, or ${last}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor && actual.constructor.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
function withAlg(alg, actual, ...types2) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types2);
}
var invalid_key_input_default;
var init_invalid_key_input = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/lib/invalid_key_input.js"() {
    invalid_key_input_default = (actual, ...types2) => {
      return message("Key must be ", actual, ...types2);
    };
  }
});
var is_key_like_default;
var types;
var init_is_key_like = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/is_key_like.js"() {
    init_webcrypto();
    is_key_like_default = (key) => {
      return isCryptoKey(key);
    };
    types = ["CryptoKey"];
  }
});
async function cbcDecrypt(enc, cek, ciphertext, iv, tag2, aad) {
  if (!(cek instanceof Uint8Array)) {
    throw new TypeError(invalid_key_input_default(cek, "Uint8Array"));
  }
  const keySize = parseInt(enc.slice(1, 4), 10);
  const encKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(keySize >> 3), "AES-CBC", false, ["decrypt"]);
  const macKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(0, keySize >> 3), {
    hash: `SHA-${keySize << 1}`,
    name: "HMAC"
  }, false, ["sign"]);
  const macData = concat4(aad, iv, ciphertext, uint64be(aad.length << 3));
  const expectedTag = new Uint8Array((await webcrypto_default.subtle.sign("HMAC", macKey, macData)).slice(0, keySize >> 3));
  let macCheckPassed;
  try {
    macCheckPassed = timing_safe_equal_default(tag2, expectedTag);
  } catch (_a3) {
  }
  if (!macCheckPassed) {
    throw new JWEDecryptionFailed();
  }
  let plaintext;
  try {
    plaintext = new Uint8Array(await webcrypto_default.subtle.decrypt({ iv, name: "AES-CBC" }, encKey, ciphertext));
  } catch (_b) {
  }
  if (!plaintext) {
    throw new JWEDecryptionFailed();
  }
  return plaintext;
}
async function gcmDecrypt(enc, cek, ciphertext, iv, tag2, aad) {
  let encKey;
  if (cek instanceof Uint8Array) {
    encKey = await webcrypto_default.subtle.importKey("raw", cek, "AES-GCM", false, ["decrypt"]);
  } else {
    checkEncCryptoKey(cek, enc, "decrypt");
    encKey = cek;
  }
  try {
    return new Uint8Array(await webcrypto_default.subtle.decrypt({
      additionalData: aad,
      iv,
      name: "AES-GCM",
      tagLength: 128
    }, encKey, concat4(ciphertext, tag2)));
  } catch (_a3) {
    throw new JWEDecryptionFailed();
  }
}
var decrypt;
var decrypt_default;
var init_decrypt = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/decrypt.js"() {
    init_buffer_utils();
    init_check_iv_length();
    init_check_cek_length();
    init_timing_safe_equal();
    init_errors();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    decrypt = async (enc, cek, ciphertext, iv, tag2, aad) => {
      if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {
        throw new TypeError(invalid_key_input_default(cek, ...types, "Uint8Array"));
      }
      check_iv_length_default(enc, iv);
      switch (enc) {
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(-3), 10));
          return cbcDecrypt(enc, cek, ciphertext, iv, tag2, aad);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(1, 4), 10));
          return gcmDecrypt(enc, cek, ciphertext, iv, tag2, aad);
        default:
          throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
      }
    };
    decrypt_default = decrypt;
  }
});
var inflate;
var deflate;
var init_zlib = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/zlib.js"() {
    init_errors();
    inflate = async () => {
      throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation.');
    };
    deflate = async () => {
      throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `deflateRaw` encrypt option to provide Deflate Raw implementation.');
    };
  }
});
var isDisjoint;
var is_disjoint_default;
var init_is_disjoint = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/lib/is_disjoint.js"() {
    isDisjoint = (...headers) => {
      const sources = headers.filter(Boolean);
      if (sources.length === 0 || sources.length === 1) {
        return true;
      }
      let acc;
      for (const header of sources) {
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
          acc = new Set(parameters);
          continue;
        }
        for (const parameter of parameters) {
          if (acc.has(parameter)) {
            return false;
          }
          acc.add(parameter);
        }
      }
      return true;
    };
    is_disjoint_default = isDisjoint;
  }
});
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject2(input10) {
  if (!isObjectLike(input10) || Object.prototype.toString.call(input10) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input10) === null) {
    return true;
  }
  let proto = input10;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input10) === proto;
}
var init_is_object = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/lib/is_object.js"() {
  }
});
var bogusWebCrypto;
var bogus_default;
var init_bogus = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/bogus.js"() {
    bogusWebCrypto = [
      { hash: "SHA-256", name: "HMAC" },
      true,
      ["sign"]
    ];
    bogus_default = bogusWebCrypto;
  }
});
function checkKeySize(key, alg) {
  if (key.algorithm.length !== parseInt(alg.slice(1, 4), 10)) {
    throw new TypeError(`Invalid key size for alg: ${alg}`);
  }
}
function getCryptoKey(key, alg, usage) {
  if (isCryptoKey(key)) {
    checkEncCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    return webcrypto_default.subtle.importKey("raw", key, "AES-KW", true, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
var wrap;
var unwrap;
var init_aeskw = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/aeskw.js"() {
    init_bogus();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    wrap = async (alg, key, cek) => {
      const cryptoKey = await getCryptoKey(key, alg, "wrapKey");
      checkKeySize(cryptoKey, alg);
      const cryptoKeyCek = await webcrypto_default.subtle.importKey("raw", cek, ...bogus_default);
      return new Uint8Array(await webcrypto_default.subtle.wrapKey("raw", cryptoKeyCek, cryptoKey, "AES-KW"));
    };
    unwrap = async (alg, key, encryptedKey) => {
      const cryptoKey = await getCryptoKey(key, alg, "unwrapKey");
      checkKeySize(cryptoKey, alg);
      const cryptoKeyCek = await webcrypto_default.subtle.unwrapKey("raw", encryptedKey, cryptoKey, "AES-KW", ...bogus_default);
      return new Uint8Array(await webcrypto_default.subtle.exportKey("raw", cryptoKeyCek));
    };
  }
});
async function deriveKey(publicKey, privateKey, algorithm2, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {
  if (!isCryptoKey(publicKey)) {
    throw new TypeError(invalid_key_input_default(publicKey, ...types));
  }
  checkEncCryptoKey(publicKey, "ECDH");
  if (!isCryptoKey(privateKey)) {
    throw new TypeError(invalid_key_input_default(privateKey, ...types));
  }
  checkEncCryptoKey(privateKey, "ECDH", "deriveBits");
  const value = concat4(lengthAndInput(encoder3.encode(algorithm2)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLength));
  let length5;
  if (publicKey.algorithm.name === "X25519") {
    length5 = 256;
  } else if (publicKey.algorithm.name === "X448") {
    length5 = 448;
  } else {
    length5 = Math.ceil(parseInt(publicKey.algorithm.namedCurve.substr(-3), 10) / 8) << 3;
  }
  const sharedSecret = new Uint8Array(await webcrypto_default.subtle.deriveBits({
    name: publicKey.algorithm.name,
    public: publicKey
  }, privateKey, length5));
  return concatKdf(sharedSecret, keyLength, value);
}
async function generateEpk(key) {
  if (!isCryptoKey(key)) {
    throw new TypeError(invalid_key_input_default(key, ...types));
  }
  return webcrypto_default.subtle.generateKey(key.algorithm, true, ["deriveBits"]);
}
function ecdhAllowed(key) {
  if (!isCryptoKey(key)) {
    throw new TypeError(invalid_key_input_default(key, ...types));
  }
  return ["P-256", "P-384", "P-521"].includes(key.algorithm.namedCurve) || key.algorithm.name === "X25519" || key.algorithm.name === "X448";
}
var init_ecdhes = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/ecdhes.js"() {
    init_buffer_utils();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});
function checkP2s(p2s2) {
  if (!(p2s2 instanceof Uint8Array) || p2s2.length < 8) {
    throw new JWEInvalid("PBES2 Salt Input must be 8 or more octets");
  }
}
var init_check_p2s = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/lib/check_p2s.js"() {
    init_errors();
  }
});
function getCryptoKey2(key, alg) {
  if (key instanceof Uint8Array) {
    return webcrypto_default.subtle.importKey("raw", key, "PBKDF2", false, ["deriveBits"]);
  }
  if (isCryptoKey(key)) {
    checkEncCryptoKey(key, alg, "deriveBits", "deriveKey");
    return key;
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
async function deriveKey2(p2s2, alg, p2c, key) {
  checkP2s(p2s2);
  const salt = p2s(alg, p2s2);
  const keylen = parseInt(alg.slice(13, 16), 10);
  const subtleAlg = {
    hash: `SHA-${alg.slice(8, 11)}`,
    iterations: p2c,
    name: "PBKDF2",
    salt
  };
  const wrapAlg = {
    length: keylen,
    name: "AES-KW"
  };
  const cryptoKey = await getCryptoKey2(key, alg);
  if (cryptoKey.usages.includes("deriveBits")) {
    return new Uint8Array(await webcrypto_default.subtle.deriveBits(subtleAlg, cryptoKey, keylen));
  }
  if (cryptoKey.usages.includes("deriveKey")) {
    return webcrypto_default.subtle.deriveKey(subtleAlg, cryptoKey, wrapAlg, false, ["wrapKey", "unwrapKey"]);
  }
  throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"');
}
var encrypt;
var decrypt2;
var init_pbes2kw = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/pbes2kw.js"() {
    init_random();
    init_buffer_utils();
    init_base64url();
    init_aeskw();
    init_check_p2s();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    encrypt = async (alg, key, cek, p2c = 2048, p2s2 = random_default(new Uint8Array(16))) => {
      const derived = await deriveKey2(p2s2, alg, p2c, key);
      const encryptedKey = await wrap(alg.slice(-6), derived, cek);
      return { encryptedKey, p2c, p2s: encode38(p2s2) };
    };
    decrypt2 = async (alg, key, encryptedKey, p2c, p2s2) => {
      const derived = await deriveKey2(p2s2, alg, p2c, key);
      return unwrap(alg.slice(-6), derived, encryptedKey);
    };
  }
});
function subtleRsaEs(alg) {
  switch (alg) {
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      return "RSA-OAEP";
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
var init_subtle_rsaes = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/subtle_rsaes.js"() {
    init_errors();
  }
});
var check_key_length_default;
var init_check_key_length = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/check_key_length.js"() {
    check_key_length_default = (alg, key) => {
      if (alg.startsWith("RS") || alg.startsWith("PS")) {
        const { modulusLength } = key.algorithm;
        if (typeof modulusLength !== "number" || modulusLength < 2048) {
          throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
        }
      }
    };
  }
});
var encrypt2;
var decrypt3;
var init_rsaes = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/rsaes.js"() {
    init_subtle_rsaes();
    init_bogus();
    init_webcrypto();
    init_crypto_key();
    init_check_key_length();
    init_invalid_key_input();
    init_is_key_like();
    encrypt2 = async (alg, key, cek) => {
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types));
      }
      checkEncCryptoKey(key, alg, "encrypt", "wrapKey");
      check_key_length_default(alg, key);
      if (key.usages.includes("encrypt")) {
        return new Uint8Array(await webcrypto_default.subtle.encrypt(subtleRsaEs(alg), key, cek));
      }
      if (key.usages.includes("wrapKey")) {
        const cryptoKeyCek = await webcrypto_default.subtle.importKey("raw", cek, ...bogus_default);
        return new Uint8Array(await webcrypto_default.subtle.wrapKey("raw", cryptoKeyCek, key, subtleRsaEs(alg)));
      }
      throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation');
    };
    decrypt3 = async (alg, key, encryptedKey) => {
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types));
      }
      checkEncCryptoKey(key, alg, "decrypt", "unwrapKey");
      check_key_length_default(alg, key);
      if (key.usages.includes("decrypt")) {
        return new Uint8Array(await webcrypto_default.subtle.decrypt(subtleRsaEs(alg), key, encryptedKey));
      }
      if (key.usages.includes("unwrapKey")) {
        const cryptoKeyCek = await webcrypto_default.subtle.unwrapKey("raw", encryptedKey, key, subtleRsaEs(alg), ...bogus_default);
        return new Uint8Array(await webcrypto_default.subtle.exportKey("raw", cryptoKeyCek));
      }
      throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation');
    };
  }
});
function bitLength2(alg) {
  switch (alg) {
    case "A128GCM":
      return 128;
    case "A192GCM":
      return 192;
    case "A256GCM":
    case "A128CBC-HS256":
      return 256;
    case "A192CBC-HS384":
      return 384;
    case "A256CBC-HS512":
      return 512;
    default:
      throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
  }
}
var cek_default;
var init_cek = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/lib/cek.js"() {
    init_errors();
    init_random();
    cek_default = (alg) => random_default(new Uint8Array(bitLength2(alg) >> 3));
  }
});
var format_pem_default;
var init_format_pem = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/lib/format_pem.js"() {
    format_pem_default = (b64, descriptor) => {
      const newlined = (b64.match(/.{1,64}/g) || []).join("\n");
      return `-----BEGIN ${descriptor}-----
${newlined}
-----END ${descriptor}-----`;
    };
  }
});
var genericExport;
var toSPKI;
var toPKCS8;
var findOid;
var getNamedCurve2;
var genericImport;
var fromPKCS8;
var fromSPKI;
var init_asn1 = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/asn1.js"() {
    init_env();
    init_webcrypto();
    init_invalid_key_input();
    init_base64url();
    init_format_pem();
    init_errors();
    init_is_key_like();
    genericExport = async (keyType, keyFormat, key) => {
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types));
      }
      if (!key.extractable) {
        throw new TypeError("CryptoKey is not extractable");
      }
      if (key.type !== keyType) {
        throw new TypeError(`key is not a ${keyType} key`);
      }
      return format_pem_default(encodeBase64(new Uint8Array(await webcrypto_default.subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);
    };
    toSPKI = (key) => {
      return genericExport("public", "spki", key);
    };
    toPKCS8 = (key) => {
      return genericExport("private", "pkcs8", key);
    };
    findOid = (keyData, oid, from19 = 0) => {
      if (from19 === 0) {
        oid.unshift(oid.length);
        oid.unshift(6);
      }
      let i = keyData.indexOf(oid[0], from19);
      if (i === -1)
        return false;
      const sub = keyData.subarray(i, i + oid.length);
      if (sub.length !== oid.length)
        return false;
      return sub.every((value, index2) => value === oid[index2]) || findOid(keyData, oid, i + 1);
    };
    getNamedCurve2 = (keyData) => {
      switch (true) {
        case findOid(keyData, [42, 134, 72, 206, 61, 3, 1, 7]):
          return "P-256";
        case findOid(keyData, [43, 129, 4, 0, 34]):
          return "P-384";
        case findOid(keyData, [43, 129, 4, 0, 35]):
          return "P-521";
        case findOid(keyData, [43, 101, 110]):
          return "X25519";
        case findOid(keyData, [43, 101, 111]):
          return "X448";
        case findOid(keyData, [43, 101, 112]):
          return "Ed25519";
        case findOid(keyData, [43, 101, 113]):
          return "Ed448";
        default:
          throw new JOSENotSupported("Invalid or unsupported EC Key Curve or OKP Key Sub Type");
      }
    };
    genericImport = async (replace, keyFormat, pem, alg, options) => {
      var _a3;
      let algorithm2;
      let keyUsages;
      const keyData = new Uint8Array(atob(pem.replace(replace, "")).split("").map((c) => c.charCodeAt(0)));
      const isPublic = keyFormat === "spki";
      switch (alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm2 = { name: "RSA-PSS", hash: `SHA-${alg.slice(-3)}` };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm2 = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${alg.slice(-3)}` };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm2 = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`
          };
          keyUsages = isPublic ? ["encrypt", "wrapKey"] : ["decrypt", "unwrapKey"];
          break;
        case "ES256":
          algorithm2 = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ES384":
          algorithm2 = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ES512":
          algorithm2 = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW": {
          const namedCurve = getNamedCurve2(keyData);
          algorithm2 = namedCurve.startsWith("P-") ? { name: "ECDH", namedCurve } : { name: namedCurve };
          keyUsages = isPublic ? [] : ["deriveBits"];
          break;
        }
        case (isCloudflareWorkers() && "EdDSA"): {
          const namedCurve = getNamedCurve2(keyData).toUpperCase();
          algorithm2 = { name: `NODE-${namedCurve}`, namedCurve: `NODE-${namedCurve}` };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        }
        case "EdDSA":
          algorithm2 = { name: getNamedCurve2(keyData) };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported "alg" (Algorithm) value');
      }
      return webcrypto_default.subtle.importKey(keyFormat, keyData, algorithm2, (_a3 = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a3 !== void 0 ? _a3 : false, keyUsages);
    };
    fromPKCS8 = (pem, alg, options) => {
      return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, "pkcs8", pem, alg, options);
    };
    fromSPKI = (pem, alg, options) => {
      return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, "spki", pem, alg, options);
    };
  }
});
function subtleMapping(jwk) {
  let algorithm2;
  let keyUsages;
  switch (jwk.kty) {
    case "oct": {
      switch (jwk.alg) {
        case "HS256":
        case "HS384":
        case "HS512":
          algorithm2 = { name: "HMAC", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = ["sign", "verify"];
          break;
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          throw new JOSENotSupported(`${jwk.alg} keys cannot be imported as CryptoKey instances`);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
        case "A128GCMKW":
        case "A192GCMKW":
        case "A256GCMKW":
          algorithm2 = { name: "AES-GCM" };
          keyUsages = ["encrypt", "decrypt"];
          break;
        case "A128KW":
        case "A192KW":
        case "A256KW":
          algorithm2 = { name: "AES-KW" };
          keyUsages = ["wrapKey", "unwrapKey"];
          break;
        case "PBES2-HS256+A128KW":
        case "PBES2-HS384+A192KW":
        case "PBES2-HS512+A256KW":
          algorithm2 = { name: "PBKDF2" };
          keyUsages = ["deriveBits"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm2 = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm2 = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm2 = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm2 = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm2 = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm2 = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm2 = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case (isCloudflareWorkers() && "OKP"):
      if (jwk.alg !== "EdDSA") {
        throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      switch (jwk.crv) {
        case "Ed25519":
          algorithm2 = { name: "NODE-ED25519", namedCurve: "NODE-ED25519" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    case "OKP": {
      switch (jwk.alg) {
        case "EdDSA":
          algorithm2 = { name: jwk.crv };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm2 = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm: algorithm2, keyUsages };
}
var parse9;
var jwk_to_key_default;
var init_jwk_to_key = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/jwk_to_key.js"() {
    init_env();
    init_webcrypto();
    init_errors();
    init_base64url();
    parse9 = async (jwk) => {
      var _a3, _b;
      const { algorithm: algorithm2, keyUsages } = subtleMapping(jwk);
      const rest = [
        algorithm2,
        (_a3 = jwk.ext) !== null && _a3 !== void 0 ? _a3 : false,
        (_b = jwk.key_ops) !== null && _b !== void 0 ? _b : keyUsages
      ];
      if (algorithm2.name === "PBKDF2") {
        return webcrypto_default.subtle.importKey("raw", decode41(jwk.k), ...rest);
      }
      const keyData = { ...jwk };
      delete keyData.alg;
      delete keyData.use;
      return webcrypto_default.subtle.importKey("jwk", keyData, ...rest);
    };
    jwk_to_key_default = parse9;
  }
});
function getElement(seq) {
  let result = [];
  let next = 0;
  while (next < seq.length) {
    let nextPart = parseElement(seq.subarray(next));
    result.push(nextPart);
    next += nextPart.byteLength;
  }
  return result;
}
function parseElement(bytes3) {
  let position = 0;
  let tag2 = bytes3[0] & 31;
  position++;
  if (tag2 === 31) {
    tag2 = 0;
    while (bytes3[position] >= 128) {
      tag2 = tag2 * 128 + bytes3[position] - 128;
      position++;
    }
    tag2 = tag2 * 128 + bytes3[position] - 128;
    position++;
  }
  let length5 = 0;
  if (bytes3[position] < 128) {
    length5 = bytes3[position];
    position++;
  } else if (length5 === 128) {
    length5 = 0;
    while (bytes3[position + length5] !== 0 || bytes3[position + length5 + 1] !== 0) {
      if (length5 > bytes3.byteLength) {
        throw new TypeError("invalid indefinite form length");
      }
      length5++;
    }
    const byteLength2 = position + length5 + 2;
    return {
      byteLength: byteLength2,
      contents: bytes3.subarray(position, position + length5),
      raw: bytes3.subarray(0, byteLength2)
    };
  } else {
    let numberOfDigits = bytes3[position] & 127;
    position++;
    length5 = 0;
    for (let i = 0; i < numberOfDigits; i++) {
      length5 = length5 * 256 + bytes3[position];
      position++;
    }
  }
  const byteLength = position + length5;
  return {
    byteLength,
    contents: bytes3.subarray(position, byteLength),
    raw: bytes3.subarray(0, byteLength)
  };
}
function spkiFromX509(buf3) {
  const tbsCertificate = getElement(getElement(parseElement(buf3).contents)[0].contents);
  return encodeBase64(tbsCertificate[tbsCertificate[0].raw[0] === 160 ? 6 : 5].raw);
}
function getSPKI(x509) {
  const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g, "");
  const raw = decodeBase64(pem);
  return format_pem_default(spkiFromX509(raw), "PUBLIC KEY");
}
async function importSPKI(spki, alg, options) {
  if (typeof spki !== "string" || spki.indexOf("-----BEGIN PUBLIC KEY-----") !== 0) {
    throw new TypeError('"spki" must be SPKI formatted string');
  }
  return fromSPKI(spki, alg, options);
}
async function importX509(x509, alg, options) {
  if (typeof x509 !== "string" || x509.indexOf("-----BEGIN CERTIFICATE-----") !== 0) {
    throw new TypeError('"x509" must be X.509 formatted string');
  }
  let spki;
  try {
    spki = getSPKI(x509);
  } catch (cause) {
    throw new TypeError("failed to parse the X.509 certificate", { cause });
  }
  return fromSPKI(spki, alg, options);
}
async function importPKCS8(pkcs8, alg, options) {
  if (typeof pkcs8 !== "string" || pkcs8.indexOf("-----BEGIN PRIVATE KEY-----") !== 0) {
    throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
  }
  return fromPKCS8(pkcs8, alg, options);
}
async function importJWK(jwk, alg, octAsKeyObject) {
  var _a3;
  if (!isObject2(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  alg || (alg = jwk.alg);
  if (typeof alg !== "string" || !alg) {
    throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
  }
  switch (jwk.kty) {
    case "oct":
      if (typeof jwk.k !== "string" || !jwk.k) {
        throw new TypeError('missing "k" (Key Value) Parameter value');
      }
      octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : octAsKeyObject = jwk.ext !== true;
      if (octAsKeyObject) {
        return jwk_to_key_default({ ...jwk, alg, ext: (_a3 = jwk.ext) !== null && _a3 !== void 0 ? _a3 : false });
      }
      return decode41(jwk.k);
    case "RSA":
      if (jwk.oth !== void 0) {
        throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
      }
    case "EC":
    case "OKP":
      return jwk_to_key_default({ ...jwk, alg });
    default:
      throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
  }
}
var init_import = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/key/import.js"() {
    init_base64url();
    init_asn1();
    init_asn1();
    init_jwk_to_key();
    init_errors();
    init_format_pem();
    init_is_object();
  }
});
var symmetricTypeCheck;
var asymmetricTypeCheck;
var checkKeyType;
var check_key_type_default;
var init_check_key_type = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/lib/check_key_type.js"() {
    init_invalid_key_input();
    init_is_key_like();
    symmetricTypeCheck = (alg, key) => {
      if (key instanceof Uint8Array)
        return;
      if (!is_key_like_default(key)) {
        throw new TypeError(withAlg(alg, key, ...types, "Uint8Array"));
      }
      if (key.type !== "secret") {
        throw new TypeError(`${types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
      }
    };
    asymmetricTypeCheck = (alg, key, usage) => {
      if (!is_key_like_default(key)) {
        throw new TypeError(withAlg(alg, key, ...types));
      }
      if (key.type === "secret") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
      }
      if (usage === "sign" && key.type === "public") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
      }
      if (usage === "decrypt" && key.type === "public") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
      }
      if (key.algorithm && usage === "verify" && key.type === "private") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
      }
      if (key.algorithm && usage === "encrypt" && key.type === "private") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
      }
    };
    checkKeyType = (alg, key, usage) => {
      const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
      if (symmetric) {
        symmetricTypeCheck(alg, key);
      } else {
        asymmetricTypeCheck(alg, key, usage);
      }
    };
    check_key_type_default = checkKeyType;
  }
});
async function cbcEncrypt(enc, plaintext, cek, iv, aad) {
  if (!(cek instanceof Uint8Array)) {
    throw new TypeError(invalid_key_input_default(cek, "Uint8Array"));
  }
  const keySize = parseInt(enc.slice(1, 4), 10);
  const encKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(keySize >> 3), "AES-CBC", false, ["encrypt"]);
  const macKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(0, keySize >> 3), {
    hash: `SHA-${keySize << 1}`,
    name: "HMAC"
  }, false, ["sign"]);
  const ciphertext = new Uint8Array(await webcrypto_default.subtle.encrypt({
    iv,
    name: "AES-CBC"
  }, encKey, plaintext));
  const macData = concat4(aad, iv, ciphertext, uint64be(aad.length << 3));
  const tag2 = new Uint8Array((await webcrypto_default.subtle.sign("HMAC", macKey, macData)).slice(0, keySize >> 3));
  return { ciphertext, tag: tag2 };
}
async function gcmEncrypt(enc, plaintext, cek, iv, aad) {
  let encKey;
  if (cek instanceof Uint8Array) {
    encKey = await webcrypto_default.subtle.importKey("raw", cek, "AES-GCM", false, ["encrypt"]);
  } else {
    checkEncCryptoKey(cek, enc, "encrypt");
    encKey = cek;
  }
  const encrypted = new Uint8Array(await webcrypto_default.subtle.encrypt({
    additionalData: aad,
    iv,
    name: "AES-GCM",
    tagLength: 128
  }, encKey, plaintext));
  const tag2 = encrypted.slice(-16);
  const ciphertext = encrypted.slice(0, -16);
  return { ciphertext, tag: tag2 };
}
var encrypt3;
var encrypt_default;
var init_encrypt = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/encrypt.js"() {
    init_buffer_utils();
    init_check_iv_length();
    init_check_cek_length();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_errors();
    init_is_key_like();
    encrypt3 = async (enc, plaintext, cek, iv, aad) => {
      if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {
        throw new TypeError(invalid_key_input_default(cek, ...types, "Uint8Array"));
      }
      check_iv_length_default(enc, iv);
      switch (enc) {
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(-3), 10));
          return cbcEncrypt(enc, plaintext, cek, iv, aad);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(1, 4), 10));
          return gcmEncrypt(enc, plaintext, cek, iv, aad);
        default:
          throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
      }
    };
    encrypt_default = encrypt3;
  }
});
async function wrap2(alg, key, cek, iv) {
  const jweAlgorithm = alg.slice(0, 7);
  iv || (iv = iv_default(jweAlgorithm));
  const { ciphertext: encryptedKey, tag: tag2 } = await encrypt_default(jweAlgorithm, cek, key, iv, new Uint8Array(0));
  return { encryptedKey, iv: encode38(iv), tag: encode38(tag2) };
}
async function unwrap2(alg, key, encryptedKey, iv, tag2) {
  const jweAlgorithm = alg.slice(0, 7);
  return decrypt_default(jweAlgorithm, key, encryptedKey, iv, tag2, new Uint8Array(0));
}
var init_aesgcmkw = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/lib/aesgcmkw.js"() {
    init_encrypt();
    init_decrypt();
    init_iv();
    init_base64url();
  }
});
async function decryptKeyManagement(alg, key, encryptedKey, joseHeader, options) {
  check_key_type_default(alg, key, "decrypt");
  switch (alg) {
    case "dir": {
      if (encryptedKey !== void 0)
        throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");
      return key;
    }
    case "ECDH-ES":
      if (encryptedKey !== void 0)
        throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      if (!isObject2(joseHeader.epk))
        throw new JWEInvalid(`JOSE Header "epk" (Ephemeral Public Key) missing or invalid`);
      if (!ecdhAllowed(key))
        throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
      const epk = await importJWK(joseHeader.epk, alg);
      let partyUInfo;
      let partyVInfo;
      if (joseHeader.apu !== void 0) {
        if (typeof joseHeader.apu !== "string")
          throw new JWEInvalid(`JOSE Header "apu" (Agreement PartyUInfo) invalid`);
        partyUInfo = decode41(joseHeader.apu);
      }
      if (joseHeader.apv !== void 0) {
        if (typeof joseHeader.apv !== "string")
          throw new JWEInvalid(`JOSE Header "apv" (Agreement PartyVInfo) invalid`);
        partyVInfo = decode41(joseHeader.apv);
      }
      const sharedSecret = await deriveKey(epk, key, alg === "ECDH-ES" ? joseHeader.enc : alg, alg === "ECDH-ES" ? bitLength2(joseHeader.enc) : parseInt(alg.slice(-5, -2), 10), partyUInfo, partyVInfo);
      if (alg === "ECDH-ES")
        return sharedSecret;
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return unwrap(alg.slice(-6), sharedSecret, encryptedKey);
    }
    case "RSA1_5":
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return decrypt3(alg, key, encryptedKey);
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      if (typeof joseHeader.p2c !== "number")
        throw new JWEInvalid(`JOSE Header "p2c" (PBES2 Count) missing or invalid`);
      const p2cLimit = (options === null || options === void 0 ? void 0 : options.maxPBES2Count) || 1e4;
      if (joseHeader.p2c > p2cLimit)
        throw new JWEInvalid(`JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds`);
      if (typeof joseHeader.p2s !== "string")
        throw new JWEInvalid(`JOSE Header "p2s" (PBES2 Salt) missing or invalid`);
      return decrypt2(alg, key, encryptedKey, joseHeader.p2c, decode41(joseHeader.p2s));
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return unwrap(alg, key, encryptedKey);
    }
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      if (typeof joseHeader.iv !== "string")
        throw new JWEInvalid(`JOSE Header "iv" (Initialization Vector) missing or invalid`);
      if (typeof joseHeader.tag !== "string")
        throw new JWEInvalid(`JOSE Header "tag" (Authentication Tag) missing or invalid`);
      const iv = decode41(joseHeader.iv);
      const tag2 = decode41(joseHeader.tag);
      return unwrap2(alg, key, encryptedKey, iv, tag2);
    }
    default: {
      throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
    }
  }
}
var decrypt_key_management_default;
var init_decrypt_key_management = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/lib/decrypt_key_management.js"() {
    init_aeskw();
    init_ecdhes();
    init_pbes2kw();
    init_rsaes();
    init_base64url();
    init_errors();
    init_cek();
    init_import();
    init_check_key_type();
    init_is_object();
    init_aesgcmkw();
    decrypt_key_management_default = decryptKeyManagement;
  }
});
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input10) => typeof input10 !== "string" || input10.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    } else if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default;
var init_validate_crit = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/lib/validate_crit.js"() {
    init_errors();
    validate_crit_default = validateCrit;
  }
});
var validateAlgorithms;
var validate_algorithms_default;
var init_validate_algorithms = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/lib/validate_algorithms.js"() {
    validateAlgorithms = (option, algorithms) => {
      if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s2) => typeof s2 !== "string"))) {
        throw new TypeError(`"${option}" option must be an array of strings`);
      }
      if (!algorithms) {
        return void 0;
      }
      return new Set(algorithms);
    };
    validate_algorithms_default = validateAlgorithms;
  }
});
async function flattenedDecrypt(jwe, key, options) {
  var _a3;
  if (!isObject2(jwe)) {
    throw new JWEInvalid("Flattened JWE must be an object");
  }
  if (jwe.protected === void 0 && jwe.header === void 0 && jwe.unprotected === void 0) {
    throw new JWEInvalid("JOSE Header missing");
  }
  if (typeof jwe.iv !== "string") {
    throw new JWEInvalid("JWE Initialization Vector missing or incorrect type");
  }
  if (typeof jwe.ciphertext !== "string") {
    throw new JWEInvalid("JWE Ciphertext missing or incorrect type");
  }
  if (typeof jwe.tag !== "string") {
    throw new JWEInvalid("JWE Authentication Tag missing or incorrect type");
  }
  if (jwe.protected !== void 0 && typeof jwe.protected !== "string") {
    throw new JWEInvalid("JWE Protected Header incorrect type");
  }
  if (jwe.encrypted_key !== void 0 && typeof jwe.encrypted_key !== "string") {
    throw new JWEInvalid("JWE Encrypted Key incorrect type");
  }
  if (jwe.aad !== void 0 && typeof jwe.aad !== "string") {
    throw new JWEInvalid("JWE AAD incorrect type");
  }
  if (jwe.header !== void 0 && !isObject2(jwe.header)) {
    throw new JWEInvalid("JWE Shared Unprotected Header incorrect type");
  }
  if (jwe.unprotected !== void 0 && !isObject2(jwe.unprotected)) {
    throw new JWEInvalid("JWE Per-Recipient Unprotected Header incorrect type");
  }
  let parsedProt;
  if (jwe.protected) {
    try {
      const protectedHeader2 = decode41(jwe.protected);
      parsedProt = JSON.parse(decoder3.decode(protectedHeader2));
    } catch (_b) {
      throw new JWEInvalid("JWE Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jwe.header, jwe.unprotected)) {
    throw new JWEInvalid("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jwe.header,
    ...jwe.unprotected
  };
  validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
  if (joseHeader.zip !== void 0) {
    if (!parsedProt || !parsedProt.zip) {
      throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
    }
    if (joseHeader.zip !== "DEF") {
      throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
    }
  }
  const { alg, enc } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWEInvalid("missing JWE Algorithm (alg) in JWE Header");
  }
  if (typeof enc !== "string" || !enc) {
    throw new JWEInvalid("missing JWE Encryption Algorithm (enc) in JWE Header");
  }
  const keyManagementAlgorithms = options && validate_algorithms_default("keyManagementAlgorithms", options.keyManagementAlgorithms);
  const contentEncryptionAlgorithms = options && validate_algorithms_default("contentEncryptionAlgorithms", options.contentEncryptionAlgorithms);
  if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  }
  if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {
    throw new JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter not allowed');
  }
  let encryptedKey;
  if (jwe.encrypted_key !== void 0) {
    encryptedKey = decode41(jwe.encrypted_key);
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jwe);
    resolvedKey = true;
  }
  let cek;
  try {
    cek = await decrypt_key_management_default(alg, key, encryptedKey, joseHeader, options);
  } catch (err) {
    if (err instanceof TypeError || err instanceof JWEInvalid || err instanceof JOSENotSupported) {
      throw err;
    }
    cek = cek_default(enc);
  }
  const iv = decode41(jwe.iv);
  const tag2 = decode41(jwe.tag);
  const protectedHeader = encoder3.encode((_a3 = jwe.protected) !== null && _a3 !== void 0 ? _a3 : "");
  let additionalData;
  if (jwe.aad !== void 0) {
    additionalData = concat4(protectedHeader, encoder3.encode("."), encoder3.encode(jwe.aad));
  } else {
    additionalData = protectedHeader;
  }
  let plaintext = await decrypt_default(enc, cek, decode41(jwe.ciphertext), iv, tag2, additionalData);
  if (joseHeader.zip === "DEF") {
    plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || inflate)(plaintext);
  }
  const result = { plaintext };
  if (jwe.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jwe.aad !== void 0) {
    result.additionalAuthenticatedData = decode41(jwe.aad);
  }
  if (jwe.unprotected !== void 0) {
    result.sharedUnprotectedHeader = jwe.unprotected;
  }
  if (jwe.header !== void 0) {
    result.unprotectedHeader = jwe.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}
var init_decrypt2 = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jwe/flattened/decrypt.js"() {
    init_base64url();
    init_decrypt();
    init_zlib();
    init_errors();
    init_is_disjoint();
    init_is_object();
    init_decrypt_key_management();
    init_buffer_utils();
    init_cek();
    init_validate_crit();
    init_validate_algorithms();
  }
});
async function compactDecrypt(jwe, key, options) {
  if (jwe instanceof Uint8Array) {
    jwe = decoder3.decode(jwe);
  }
  if (typeof jwe !== "string") {
    throw new JWEInvalid("Compact JWE must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag2, length: length5 } = jwe.split(".");
  if (length5 !== 5) {
    throw new JWEInvalid("Invalid Compact JWE");
  }
  const decrypted = await flattenedDecrypt({
    ciphertext,
    iv: iv || void 0,
    protected: protectedHeader || void 0,
    tag: tag2 || void 0,
    encrypted_key: encryptedKey || void 0
  }, key, options);
  const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: decrypted.key };
  }
  return result;
}
var init_decrypt3 = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jwe/compact/decrypt.js"() {
    init_decrypt2();
    init_errors();
    init_buffer_utils();
  }
});
async function generalDecrypt(jwe, key, options) {
  if (!isObject2(jwe)) {
    throw new JWEInvalid("General JWE must be an object");
  }
  if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(isObject2)) {
    throw new JWEInvalid("JWE Recipients missing or incorrect type");
  }
  if (!jwe.recipients.length) {
    throw new JWEInvalid("JWE Recipients has no members");
  }
  for (const recipient of jwe.recipients) {
    try {
      return await flattenedDecrypt({
        aad: jwe.aad,
        ciphertext: jwe.ciphertext,
        encrypted_key: recipient.encrypted_key,
        header: recipient.header,
        iv: jwe.iv,
        protected: jwe.protected,
        tag: jwe.tag,
        unprotected: jwe.unprotected
      }, key, options);
    } catch (_a3) {
    }
  }
  throw new JWEDecryptionFailed();
}
var init_decrypt4 = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jwe/general/decrypt.js"() {
    init_decrypt2();
    init_errors();
    init_is_object();
  }
});
var keyToJWK;
var key_to_jwk_default;
var init_key_to_jwk = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/key_to_jwk.js"() {
    init_webcrypto();
    init_invalid_key_input();
    init_base64url();
    init_is_key_like();
    keyToJWK = async (key) => {
      if (key instanceof Uint8Array) {
        return {
          kty: "oct",
          k: encode38(key)
        };
      }
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
      }
      if (!key.extractable) {
        throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");
      }
      const { ext, key_ops, alg, use, ...jwk } = await webcrypto_default.subtle.exportKey("jwk", key);
      return jwk;
    };
    key_to_jwk_default = keyToJWK;
  }
});
async function exportSPKI(key) {
  return toSPKI(key);
}
async function exportPKCS8(key) {
  return toPKCS8(key);
}
async function exportJWK(key) {
  return key_to_jwk_default(key);
}
var init_export = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/key/export.js"() {
    init_asn1();
    init_asn1();
    init_key_to_jwk();
  }
});
async function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {
  let encryptedKey;
  let parameters;
  let cek;
  check_key_type_default(alg, key, "encrypt");
  switch (alg) {
    case "dir": {
      cek = key;
      break;
    }
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      if (!ecdhAllowed(key)) {
        throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
      }
      const { apu, apv } = providedParameters;
      let { epk: ephemeralKey } = providedParameters;
      ephemeralKey || (ephemeralKey = (await generateEpk(key)).privateKey);
      const { x, y, crv, kty } = await exportJWK(ephemeralKey);
      const sharedSecret = await deriveKey(key, ephemeralKey, alg === "ECDH-ES" ? enc : alg, alg === "ECDH-ES" ? bitLength2(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);
      parameters = { epk: { x, crv, kty } };
      if (kty === "EC")
        parameters.epk.y = y;
      if (apu)
        parameters.apu = encode38(apu);
      if (apv)
        parameters.apv = encode38(apv);
      if (alg === "ECDH-ES") {
        cek = sharedSecret;
        break;
      }
      cek = providedCek || cek_default(enc);
      const kwAlg = alg.slice(-6);
      encryptedKey = await wrap(kwAlg, sharedSecret, cek);
      break;
    }
    case "RSA1_5":
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      cek = providedCek || cek_default(enc);
      encryptedKey = await encrypt2(alg, key, cek);
      break;
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW": {
      cek = providedCek || cek_default(enc);
      const { p2c, p2s: p2s2 } = providedParameters;
      ({ encryptedKey, ...parameters } = await encrypt(alg, key, cek, p2c, p2s2));
      break;
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      cek = providedCek || cek_default(enc);
      encryptedKey = await wrap(alg, key, cek);
      break;
    }
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW": {
      cek = providedCek || cek_default(enc);
      const { iv } = providedParameters;
      ({ encryptedKey, ...parameters } = await wrap2(alg, key, cek, iv));
      break;
    }
    default: {
      throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
    }
  }
  return { cek, encryptedKey, parameters };
}
var encrypt_key_management_default;
var init_encrypt_key_management = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/lib/encrypt_key_management.js"() {
    init_aeskw();
    init_ecdhes();
    init_pbes2kw();
    init_rsaes();
    init_base64url();
    init_cek();
    init_errors();
    init_export();
    init_check_key_type();
    init_aesgcmkw();
    encrypt_key_management_default = encryptKeyManagement;
  }
});
var unprotected;
var FlattenedEncrypt;
var init_encrypt2 = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jwe/flattened/encrypt.js"() {
    init_base64url();
    init_encrypt();
    init_zlib();
    init_iv();
    init_encrypt_key_management();
    init_errors();
    init_is_disjoint();
    init_buffer_utils();
    init_validate_crit();
    unprotected = Symbol();
    FlattenedEncrypt = class {
      constructor(plaintext) {
        if (!(plaintext instanceof Uint8Array)) {
          throw new TypeError("plaintext must be an instance of Uint8Array");
        }
        this._plaintext = plaintext;
      }
      setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
          throw new TypeError("setKeyManagementParameters can only be called once");
        }
        this._keyManagementParameters = parameters;
        return this;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._sharedUnprotectedHeader) {
          throw new TypeError("setSharedUnprotectedHeader can only be called once");
        }
        this._sharedUnprotectedHeader = sharedUnprotectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
      }
      setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
      }
      setContentEncryptionKey(cek) {
        if (this._cek) {
          throw new TypeError("setContentEncryptionKey can only be called once");
        }
        this._cek = cek;
        return this;
      }
      setInitializationVector(iv) {
        if (this._iv) {
          throw new TypeError("setInitializationVector can only be called once");
        }
        this._iv = iv;
        return this;
      }
      async encrypt(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {
          throw new JWEInvalid("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");
        }
        if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {
          throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader,
          ...this._sharedUnprotectedHeader
        };
        validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        if (joseHeader.zip !== void 0) {
          if (!this._protectedHeader || !this._protectedHeader.zip) {
            throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
          }
          if (joseHeader.zip !== "DEF") {
            throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
          }
        }
        const { alg, enc } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
        }
        if (typeof enc !== "string" || !enc) {
          throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
        }
        let encryptedKey;
        if (alg === "dir") {
          if (this._cek) {
            throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption");
          }
        } else if (alg === "ECDH-ES") {
          if (this._cek) {
            throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");
          }
        }
        let cek;
        {
          let parameters;
          ({ cek, encryptedKey, parameters } = await encrypt_key_management_default(alg, enc, key, this._cek, this._keyManagementParameters));
          if (parameters) {
            if (options && unprotected in options) {
              if (!this._unprotectedHeader) {
                this.setUnprotectedHeader(parameters);
              } else {
                this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };
              }
            } else {
              if (!this._protectedHeader) {
                this.setProtectedHeader(parameters);
              } else {
                this._protectedHeader = { ...this._protectedHeader, ...parameters };
              }
            }
          }
        }
        this._iv || (this._iv = iv_default(enc));
        let additionalData;
        let protectedHeader;
        let aadMember;
        if (this._protectedHeader) {
          protectedHeader = encoder3.encode(encode38(JSON.stringify(this._protectedHeader)));
        } else {
          protectedHeader = encoder3.encode("");
        }
        if (this._aad) {
          aadMember = encode38(this._aad);
          additionalData = concat4(protectedHeader, encoder3.encode("."), encoder3.encode(aadMember));
        } else {
          additionalData = protectedHeader;
        }
        let ciphertext;
        let tag2;
        if (joseHeader.zip === "DEF") {
          const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || deflate)(this._plaintext);
          ({ ciphertext, tag: tag2 } = await encrypt_default(enc, deflated, cek, this._iv, additionalData));
        } else {
          ;
          ({ ciphertext, tag: tag2 } = await encrypt_default(enc, this._plaintext, cek, this._iv, additionalData));
        }
        const jwe = {
          ciphertext: encode38(ciphertext),
          iv: encode38(this._iv),
          tag: encode38(tag2)
        };
        if (encryptedKey) {
          jwe.encrypted_key = encode38(encryptedKey);
        }
        if (aadMember) {
          jwe.aad = aadMember;
        }
        if (this._protectedHeader) {
          jwe.protected = decoder3.decode(protectedHeader);
        }
        if (this._sharedUnprotectedHeader) {
          jwe.unprotected = this._sharedUnprotectedHeader;
        }
        if (this._unprotectedHeader) {
          jwe.header = this._unprotectedHeader;
        }
        return jwe;
      }
    };
  }
});
var IndividualRecipient;
var GeneralEncrypt;
var init_encrypt3 = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jwe/general/encrypt.js"() {
    init_encrypt2();
    init_errors();
    init_cek();
    init_is_disjoint();
    init_encrypt_key_management();
    init_base64url();
    init_validate_crit();
    IndividualRecipient = class {
      constructor(enc, key, options) {
        this.parent = enc;
        this.key = key;
        this.options = options;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
      }
      addRecipient(...args) {
        return this.parent.addRecipient(...args);
      }
      encrypt(...args) {
        return this.parent.encrypt(...args);
      }
      done() {
        return this.parent;
      }
    };
    GeneralEncrypt = class {
      constructor(plaintext) {
        this._recipients = [];
        this._plaintext = plaintext;
      }
      addRecipient(key, options) {
        const recipient = new IndividualRecipient(this, key, { crit: options === null || options === void 0 ? void 0 : options.crit });
        this._recipients.push(recipient);
        return recipient;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setSharedUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = sharedUnprotectedHeader;
        return this;
      }
      setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
      }
      async encrypt(options) {
        var _a3, _b, _c;
        if (!this._recipients.length) {
          throw new JWEInvalid("at least one recipient must be added");
        }
        options = { deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw };
        if (this._recipients.length === 1) {
          const [recipient] = this._recipients;
          const flattened = await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).encrypt(recipient.key, { ...recipient.options, ...options });
          let jwe2 = {
            ciphertext: flattened.ciphertext,
            iv: flattened.iv,
            recipients: [{}],
            tag: flattened.tag
          };
          if (flattened.aad)
            jwe2.aad = flattened.aad;
          if (flattened.protected)
            jwe2.protected = flattened.protected;
          if (flattened.unprotected)
            jwe2.unprotected = flattened.unprotected;
          if (flattened.encrypted_key)
            jwe2.recipients[0].encrypted_key = flattened.encrypted_key;
          if (flattened.header)
            jwe2.recipients[0].header = flattened.header;
          return jwe2;
        }
        let enc;
        for (let i = 0; i < this._recipients.length; i++) {
          const recipient = this._recipients[i];
          if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {
            throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
          }
          const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...recipient.unprotectedHeader
          };
          const { alg } = joseHeader;
          if (typeof alg !== "string" || !alg) {
            throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
          }
          if (alg === "dir" || alg === "ECDH-ES") {
            throw new JWEInvalid('"dir" and "ECDH-ES" alg may only be used with a single recipient');
          }
          if (typeof joseHeader.enc !== "string" || !joseHeader.enc) {
            throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
          }
          if (!enc) {
            enc = joseHeader.enc;
          } else if (enc !== joseHeader.enc) {
            throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');
          }
          validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), recipient.options.crit, this._protectedHeader, joseHeader);
          if (joseHeader.zip !== void 0) {
            if (!this._protectedHeader || !this._protectedHeader.zip) {
              throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
            }
          }
        }
        const cek = cek_default(enc);
        let jwe = {
          ciphertext: "",
          iv: "",
          recipients: [],
          tag: ""
        };
        for (let i = 0; i < this._recipients.length; i++) {
          const recipient = this._recipients[i];
          const target = {};
          jwe.recipients.push(target);
          const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...recipient.unprotectedHeader
          };
          const p2c = joseHeader.alg.startsWith("PBES2") ? 2048 + i : void 0;
          if (i === 0) {
            const flattened = await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(cek).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).setKeyManagementParameters({ p2c }).encrypt(recipient.key, {
              ...recipient.options,
              ...options,
              [unprotected]: true
            });
            jwe.ciphertext = flattened.ciphertext;
            jwe.iv = flattened.iv;
            jwe.tag = flattened.tag;
            if (flattened.aad)
              jwe.aad = flattened.aad;
            if (flattened.protected)
              jwe.protected = flattened.protected;
            if (flattened.unprotected)
              jwe.unprotected = flattened.unprotected;
            target.encrypted_key = flattened.encrypted_key;
            if (flattened.header)
              target.header = flattened.header;
            continue;
          }
          const { encryptedKey, parameters } = await encrypt_key_management_default(((_a3 = recipient.unprotectedHeader) === null || _a3 === void 0 ? void 0 : _a3.alg) || ((_b = this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) || ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient.key, cek, { p2c });
          target.encrypted_key = encode38(encryptedKey);
          if (recipient.unprotectedHeader || parameters)
            target.header = { ...recipient.unprotectedHeader, ...parameters };
        }
        return jwe;
      }
    };
  }
});
function subtleDsa(alg, algorithm2) {
  const hash = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash, name: "ECDSA", namedCurve: algorithm2.namedCurve };
    case (isCloudflareWorkers() && "EdDSA"):
      const { namedCurve } = algorithm2;
      return { name: namedCurve, namedCurve };
    case "EdDSA":
      return { name: algorithm2.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
var init_subtle_dsa = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/subtle_dsa.js"() {
    init_env();
    init_errors();
  }
});
function getCryptoKey3(alg, key, usage) {
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
var init_get_sign_verify_key = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/get_sign_verify_key.js"() {
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});
var verify2;
var verify_default;
var init_verify = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/verify.js"() {
    init_subtle_dsa();
    init_webcrypto();
    init_check_key_length();
    init_get_sign_verify_key();
    verify2 = async (alg, key, signature, data) => {
      const cryptoKey = await getCryptoKey3(alg, key, "verify");
      check_key_length_default(alg, cryptoKey);
      const algorithm2 = subtleDsa(alg, cryptoKey.algorithm);
      try {
        return await webcrypto_default.subtle.verify(algorithm2, cryptoKey, signature, data);
      } catch (_a3) {
        return false;
      }
    };
    verify_default = verify2;
  }
});
async function flattenedVerify(jws, key, options) {
  var _a3;
  if (!isObject2(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === void 0 && jws.header === void 0) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== void 0 && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === void 0) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== void 0 && !isObject2(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode41(jws.protected);
      parsedProt = JSON.parse(decoder3.decode(protectedHeader));
    } catch (_b) {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  check_key_type_default(alg, key, "verify");
  const data = concat4(encoder3.encode((_a3 = jws.protected) !== null && _a3 !== void 0 ? _a3 : ""), encoder3.encode("."), typeof jws.payload === "string" ? encoder3.encode(jws.payload) : jws.payload);
  const signature = decode41(jws.signature);
  const verified = await verify_default(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed();
  }
  let payload;
  if (b64) {
    payload = decode41(jws.payload);
  } else if (typeof jws.payload === "string") {
    payload = encoder3.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== void 0) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}
var init_verify2 = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jws/flattened/verify.js"() {
    init_base64url();
    init_verify();
    init_errors();
    init_buffer_utils();
    init_is_disjoint();
    init_is_object();
    init_check_key_type();
    init_validate_crit();
    init_validate_algorithms();
  }
});
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder3.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length: length5 } = jws.split(".");
  if (length5 !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
var init_verify3 = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jws/compact/verify.js"() {
    init_verify2();
    init_errors();
    init_buffer_utils();
  }
});
async function generalVerify(jws, key, options) {
  if (!isObject2(jws)) {
    throw new JWSInvalid("General JWS must be an object");
  }
  if (!Array.isArray(jws.signatures) || !jws.signatures.every(isObject2)) {
    throw new JWSInvalid("JWS Signatures missing or incorrect type");
  }
  for (const signature of jws.signatures) {
    try {
      return await flattenedVerify({
        header: signature.header,
        payload: jws.payload,
        protected: signature.protected,
        signature: signature.signature
      }, key, options);
    } catch (_a3) {
    }
  }
  throw new JWSSignatureVerificationFailed();
}
var init_verify4 = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jws/general/verify.js"() {
    init_verify2();
    init_errors();
    init_is_object();
  }
});
var epoch_default;
var init_epoch = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/lib/epoch.js"() {
    epoch_default = (date) => Math.floor(date.getTime() / 1e3);
  }
});
var minute;
var hour;
var day;
var week;
var year;
var REGEX;
var secs_default;
var init_secs = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/lib/secs.js"() {
    minute = 60;
    hour = minute * 60;
    day = hour * 24;
    week = day * 7;
    year = day * 365.25;
    REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
    secs_default = (str) => {
      const matched = REGEX.exec(str);
      if (!matched) {
        throw new TypeError("Invalid time period format");
      }
      const value = parseFloat(matched[1]);
      const unit = matched[2].toLowerCase();
      switch (unit) {
        case "sec":
        case "secs":
        case "second":
        case "seconds":
        case "s":
          return Math.round(value);
        case "minute":
        case "minutes":
        case "min":
        case "mins":
        case "m":
          return Math.round(value * minute);
        case "hour":
        case "hours":
        case "hr":
        case "hrs":
        case "h":
          return Math.round(value * hour);
        case "day":
        case "days":
        case "d":
          return Math.round(value * day);
        case "week":
        case "weeks":
        case "w":
          return Math.round(value * week);
        default:
          return Math.round(value * year);
      }
    };
  }
});
var normalizeTyp;
var checkAudiencePresence;
var jwt_claims_set_default;
var init_jwt_claims_set = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/lib/jwt_claims_set.js"() {
    init_errors();
    init_buffer_utils();
    init_epoch();
    init_secs();
    init_is_object();
    normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
    checkAudiencePresence = (audPayload, audOption) => {
      if (typeof audPayload === "string") {
        return audOption.includes(audPayload);
      }
      if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
      }
      return false;
    };
    jwt_claims_set_default = (protectedHeader, encodedPayload, options = {}) => {
      const { typ } = options;
      if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
        throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
      }
      let payload;
      try {
        payload = JSON.parse(decoder3.decode(encodedPayload));
      } catch (_a3) {
      }
      if (!isObject2(payload)) {
        throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
      }
      const { issuer } = options;
      if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
        throw new JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
      }
      const { subject } = options;
      if (subject && payload.sub !== subject) {
        throw new JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
      }
      const { audience } = options;
      if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
        throw new JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
      }
      let tolerance;
      switch (typeof options.clockTolerance) {
        case "string":
          tolerance = secs_default(options.clockTolerance);
          break;
        case "number":
          tolerance = options.clockTolerance;
          break;
        case "undefined":
          tolerance = 0;
          break;
        default:
          throw new TypeError("Invalid clockTolerance option type");
      }
      const { currentDate } = options;
      const now3 = epoch_default(currentDate || /* @__PURE__ */ new Date());
      if ((payload.iat !== void 0 || options.maxTokenAge) && typeof payload.iat !== "number") {
        throw new JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
      }
      if (payload.nbf !== void 0) {
        if (typeof payload.nbf !== "number") {
          throw new JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
        }
        if (payload.nbf > now3 + tolerance) {
          throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
        }
      }
      if (payload.exp !== void 0) {
        if (typeof payload.exp !== "number") {
          throw new JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
        }
        if (payload.exp <= now3 - tolerance) {
          throw new JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
        }
      }
      if (options.maxTokenAge) {
        const age = now3 - payload.iat;
        const max = typeof options.maxTokenAge === "number" ? options.maxTokenAge : secs_default(options.maxTokenAge);
        if (age - tolerance > max) {
          throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
        }
        if (age < 0 - tolerance) {
          throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
        }
      }
      return payload;
    };
  }
});
async function jwtVerify(jwt, key, options) {
  var _a3;
  const verified = await compactVerify(jwt, key, options);
  if (((_a3 = verified.protectedHeader.crit) === null || _a3 === void 0 ? void 0 : _a3.includes("b64")) && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
var init_verify5 = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jwt/verify.js"() {
    init_verify3();
    init_jwt_claims_set();
    init_errors();
  }
});
async function jwtDecrypt(jwt, key, options) {
  const decrypted = await compactDecrypt(jwt, key, options);
  const payload = jwt_claims_set_default(decrypted.protectedHeader, decrypted.plaintext, options);
  const { protectedHeader } = decrypted;
  if (protectedHeader.iss !== void 0 && protectedHeader.iss !== payload.iss) {
    throw new JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch', "iss", "mismatch");
  }
  if (protectedHeader.sub !== void 0 && protectedHeader.sub !== payload.sub) {
    throw new JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch', "sub", "mismatch");
  }
  if (protectedHeader.aud !== void 0 && JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {
    throw new JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch', "aud", "mismatch");
  }
  const result = { payload, protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: decrypted.key };
  }
  return result;
}
var init_decrypt5 = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jwt/decrypt.js"() {
    init_decrypt3();
    init_jwt_claims_set();
    init_errors();
  }
});
var CompactEncrypt;
var init_encrypt4 = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jwe/compact/encrypt.js"() {
    init_encrypt2();
    CompactEncrypt = class {
      constructor(plaintext) {
        this._flattened = new FlattenedEncrypt(plaintext);
      }
      setContentEncryptionKey(cek) {
        this._flattened.setContentEncryptionKey(cek);
        return this;
      }
      setInitializationVector(iv) {
        this._flattened.setInitializationVector(iv);
        return this;
      }
      setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
      }
      setKeyManagementParameters(parameters) {
        this._flattened.setKeyManagementParameters(parameters);
        return this;
      }
      async encrypt(key, options) {
        const jwe = await this._flattened.encrypt(key, options);
        return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join(".");
      }
    };
  }
});
var sign2;
var sign_default;
var init_sign = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/sign.js"() {
    init_subtle_dsa();
    init_webcrypto();
    init_check_key_length();
    init_get_sign_verify_key();
    sign2 = async (alg, key, data) => {
      const cryptoKey = await getCryptoKey3(alg, key, "sign");
      check_key_length_default(alg, cryptoKey);
      const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
      return new Uint8Array(signature);
    };
    sign_default = sign2;
  }
});
var FlattenedSign;
var init_sign2 = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jws/flattened/sign.js"() {
    init_base64url();
    init_sign();
    init_is_disjoint();
    init_errors();
    init_buffer_utils();
    init_check_key_type();
    init_validate_crit();
    FlattenedSign = class {
      constructor(payload) {
        if (!(payload instanceof Uint8Array)) {
          throw new TypeError("payload must be an instance of Uint8Array");
        }
        this._payload = payload;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
      }
      async sign(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader) {
          throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
        }
        if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
          throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader
        };
        const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        let b64 = true;
        if (extensions.has("b64")) {
          b64 = this._protectedHeader.b64;
          if (typeof b64 !== "boolean") {
            throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
          }
        }
        const { alg } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
        }
        check_key_type_default(alg, key, "sign");
        let payload = this._payload;
        if (b64) {
          payload = encoder3.encode(encode38(payload));
        }
        let protectedHeader;
        if (this._protectedHeader) {
          protectedHeader = encoder3.encode(encode38(JSON.stringify(this._protectedHeader)));
        } else {
          protectedHeader = encoder3.encode("");
        }
        const data = concat4(protectedHeader, encoder3.encode("."), payload);
        const signature = await sign_default(alg, key, data);
        const jws = {
          signature: encode38(signature),
          payload: ""
        };
        if (b64) {
          jws.payload = decoder3.decode(payload);
        }
        if (this._unprotectedHeader) {
          jws.header = this._unprotectedHeader;
        }
        if (this._protectedHeader) {
          jws.protected = decoder3.decode(protectedHeader);
        }
        return jws;
      }
    };
  }
});
var CompactSign;
var init_sign3 = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jws/compact/sign.js"() {
    init_sign2();
    CompactSign = class {
      constructor(payload) {
        this._flattened = new FlattenedSign(payload);
      }
      setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
      }
      async sign(key, options) {
        const jws = await this._flattened.sign(key, options);
        if (jws.payload === void 0) {
          throw new TypeError("use the flattened module for creating JWS with b64: false");
        }
        return `${jws.protected}.${jws.payload}.${jws.signature}`;
      }
    };
  }
});
var IndividualSignature;
var GeneralSign;
var init_sign4 = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jws/general/sign.js"() {
    init_sign2();
    init_errors();
    IndividualSignature = class {
      constructor(sig, key, options) {
        this.parent = sig;
        this.key = key;
        this.options = options;
      }
      setProtectedHeader(protectedHeader) {
        if (this.protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this.protectedHeader = protectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
      }
      addSignature(...args) {
        return this.parent.addSignature(...args);
      }
      sign(...args) {
        return this.parent.sign(...args);
      }
      done() {
        return this.parent;
      }
    };
    GeneralSign = class {
      constructor(payload) {
        this._signatures = [];
        this._payload = payload;
      }
      addSignature(key, options) {
        const signature = new IndividualSignature(this, key, options);
        this._signatures.push(signature);
        return signature;
      }
      async sign() {
        if (!this._signatures.length) {
          throw new JWSInvalid("at least one signature must be added");
        }
        const jws = {
          signatures: [],
          payload: ""
        };
        for (let i = 0; i < this._signatures.length; i++) {
          const signature = this._signatures[i];
          const flattened = new FlattenedSign(this._payload);
          flattened.setProtectedHeader(signature.protectedHeader);
          flattened.setUnprotectedHeader(signature.unprotectedHeader);
          const { payload, ...rest } = await flattened.sign(signature.key, signature.options);
          if (i === 0) {
            jws.payload = payload;
          } else if (jws.payload !== payload) {
            throw new JWSInvalid("inconsistent use of JWS Unencoded Payload Option (RFC7797)");
          }
          jws.signatures.push(rest);
        }
        return jws;
      }
    };
  }
});
var ProduceJWT;
var init_produce = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jwt/produce.js"() {
    init_epoch();
    init_is_object();
    init_secs();
    ProduceJWT = class {
      constructor(payload) {
        if (!isObject2(payload)) {
          throw new TypeError("JWT Claims Set MUST be an object");
        }
        this._payload = payload;
      }
      setIssuer(issuer) {
        this._payload = { ...this._payload, iss: issuer };
        return this;
      }
      setSubject(subject) {
        this._payload = { ...this._payload, sub: subject };
        return this;
      }
      setAudience(audience) {
        this._payload = { ...this._payload, aud: audience };
        return this;
      }
      setJti(jwtId) {
        this._payload = { ...this._payload, jti: jwtId };
        return this;
      }
      setNotBefore(input10) {
        if (typeof input10 === "number") {
          this._payload = { ...this._payload, nbf: input10 };
        } else {
          this._payload = { ...this._payload, nbf: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input10) };
        }
        return this;
      }
      setExpirationTime(input10) {
        if (typeof input10 === "number") {
          this._payload = { ...this._payload, exp: input10 };
        } else {
          this._payload = { ...this._payload, exp: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input10) };
        }
        return this;
      }
      setIssuedAt(input10) {
        if (typeof input10 === "undefined") {
          this._payload = { ...this._payload, iat: epoch_default(/* @__PURE__ */ new Date()) };
        } else {
          this._payload = { ...this._payload, iat: input10 };
        }
        return this;
      }
    };
  }
});
var SignJWT;
var init_sign5 = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jwt/sign.js"() {
    init_sign3();
    init_errors();
    init_buffer_utils();
    init_produce();
    SignJWT = class extends ProduceJWT {
      setProtectedHeader(protectedHeader) {
        this._protectedHeader = protectedHeader;
        return this;
      }
      async sign(key, options) {
        var _a3;
        const sig = new CompactSign(encoder3.encode(JSON.stringify(this._payload)));
        sig.setProtectedHeader(this._protectedHeader);
        if (Array.isArray((_a3 = this._protectedHeader) === null || _a3 === void 0 ? void 0 : _a3.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
          throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
        }
        return sig.sign(key, options);
      }
    };
  }
});
var EncryptJWT;
var init_encrypt5 = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jwt/encrypt.js"() {
    init_encrypt4();
    init_buffer_utils();
    init_produce();
    EncryptJWT = class extends ProduceJWT {
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
          throw new TypeError("setKeyManagementParameters can only be called once");
        }
        this._keyManagementParameters = parameters;
        return this;
      }
      setContentEncryptionKey(cek) {
        if (this._cek) {
          throw new TypeError("setContentEncryptionKey can only be called once");
        }
        this._cek = cek;
        return this;
      }
      setInitializationVector(iv) {
        if (this._iv) {
          throw new TypeError("setInitializationVector can only be called once");
        }
        this._iv = iv;
        return this;
      }
      replicateIssuerAsHeader() {
        this._replicateIssuerAsHeader = true;
        return this;
      }
      replicateSubjectAsHeader() {
        this._replicateSubjectAsHeader = true;
        return this;
      }
      replicateAudienceAsHeader() {
        this._replicateAudienceAsHeader = true;
        return this;
      }
      async encrypt(key, options) {
        const enc = new CompactEncrypt(encoder3.encode(JSON.stringify(this._payload)));
        if (this._replicateIssuerAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };
        }
        if (this._replicateSubjectAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };
        }
        if (this._replicateAudienceAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };
        }
        enc.setProtectedHeader(this._protectedHeader);
        if (this._iv) {
          enc.setInitializationVector(this._iv);
        }
        if (this._cek) {
          enc.setContentEncryptionKey(this._cek);
        }
        if (this._keyManagementParameters) {
          enc.setKeyManagementParameters(this._keyManagementParameters);
        }
        return enc.encrypt(key, options);
      }
    };
  }
});
async function calculateJwkThumbprint(jwk, digestAlgorithm) {
  if (!isObject2(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = "sha256";
  if (digestAlgorithm !== "sha256" && digestAlgorithm !== "sha384" && digestAlgorithm !== "sha512") {
    throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');
  }
  let components;
  switch (jwk.kty) {
    case "EC":
      check(jwk.crv, '"crv" (Curve) Parameter');
      check(jwk.x, '"x" (X Coordinate) Parameter');
      check(jwk.y, '"y" (Y Coordinate) Parameter');
      components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
      break;
    case "OKP":
      check(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
      check(jwk.x, '"x" (Public Key) Parameter');
      components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
      break;
    case "RSA":
      check(jwk.e, '"e" (Exponent) Parameter');
      check(jwk.n, '"n" (Modulus) Parameter');
      components = { e: jwk.e, kty: jwk.kty, n: jwk.n };
      break;
    case "oct":
      check(jwk.k, '"k" (Key Value) Parameter');
      components = { k: jwk.k, kty: jwk.kty };
      break;
    default:
      throw new JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported');
  }
  const data = encoder3.encode(JSON.stringify(components));
  return encode38(await digest_default(digestAlgorithm, data));
}
async function calculateJwkThumbprintUri(jwk, digestAlgorithm) {
  digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = "sha256";
  const thumbprint = await calculateJwkThumbprint(jwk, digestAlgorithm);
  return `urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`;
}
var check;
var init_thumbprint = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jwk/thumbprint.js"() {
    init_digest2();
    init_base64url();
    init_errors();
    init_buffer_utils();
    init_is_object();
    check = (value, description) => {
      if (typeof value !== "string" || !value) {
        throw new JWKInvalid(`${description} missing or invalid`);
      }
    };
  }
});
async function EmbeddedJWK(protectedHeader, token) {
  const joseHeader = {
    ...protectedHeader,
    ...token.header
  };
  if (!isObject2(joseHeader.jwk)) {
    throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a JSON object');
  }
  const key = await importJWK({ ...joseHeader.jwk, ext: true }, joseHeader.alg, true);
  if (key instanceof Uint8Array || key.type !== "public") {
    throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a public key');
  }
  return key;
}
var init_embedded = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jwk/embedded.js"() {
    init_import();
    init_is_object();
    init_errors();
  }
});
function getKtyFromAlg(alg) {
  switch (typeof alg === "string" && alg.slice(0, 2)) {
    case "RS":
    case "PS":
      return "RSA";
    case "ES":
      return "EC";
    case "Ed":
      return "OKP";
    default:
      throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
  }
}
function isJWKSLike(jwks) {
  return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
}
function isJWKLike(key) {
  return isObject2(key);
}
function clone3(obj) {
  if (typeof structuredClone === "function") {
    return structuredClone(obj);
  }
  return JSON.parse(JSON.stringify(obj));
}
function createLocalJWKSet(jwks) {
  return LocalJWKSet.prototype.getKey.bind(new LocalJWKSet(jwks));
}
var LocalJWKSet;
var init_local = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jwks/local.js"() {
    init_import();
    init_errors();
    init_is_object();
    LocalJWKSet = class {
      constructor(jwks) {
        this._cached = /* @__PURE__ */ new WeakMap();
        if (!isJWKSLike(jwks)) {
          throw new JWKSInvalid("JSON Web Key Set malformed");
        }
        this._jwks = clone3(jwks);
      }
      async getKey(protectedHeader, token) {
        const { alg, kid } = { ...protectedHeader, ...token.header };
        const kty = getKtyFromAlg(alg);
        const candidates = this._jwks.keys.filter((jwk2) => {
          let candidate = kty === jwk2.kty;
          if (candidate && typeof kid === "string") {
            candidate = kid === jwk2.kid;
          }
          if (candidate && typeof jwk2.alg === "string") {
            candidate = alg === jwk2.alg;
          }
          if (candidate && typeof jwk2.use === "string") {
            candidate = jwk2.use === "sig";
          }
          if (candidate && Array.isArray(jwk2.key_ops)) {
            candidate = jwk2.key_ops.includes("verify");
          }
          if (candidate && alg === "EdDSA") {
            candidate = jwk2.crv === "Ed25519" || jwk2.crv === "Ed448";
          }
          if (candidate) {
            switch (alg) {
              case "ES256":
                candidate = jwk2.crv === "P-256";
                break;
              case "ES256K":
                candidate = jwk2.crv === "secp256k1";
                break;
              case "ES384":
                candidate = jwk2.crv === "P-384";
                break;
              case "ES512":
                candidate = jwk2.crv === "P-521";
                break;
            }
          }
          return candidate;
        });
        const { 0: jwk, length: length5 } = candidates;
        if (length5 === 0) {
          throw new JWKSNoMatchingKey();
        } else if (length5 !== 1) {
          throw new JWKSMultipleMatchingKeys();
        }
        const cached = this._cached.get(jwk) || this._cached.set(jwk, {}).get(jwk);
        if (cached[alg] === void 0) {
          const keyObject = await importJWK({ ...jwk, ext: true }, alg);
          if (keyObject instanceof Uint8Array || keyObject.type !== "public") {
            throw new JWKSInvalid("JSON Web Key Set members must be public keys");
          }
          cached[alg] = keyObject;
        }
        return cached[alg];
      }
    };
  }
});
var fetchJwks;
var fetch_jwks_default;
var init_fetch_jwks = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/fetch_jwks.js"() {
    init_errors();
    fetchJwks = async (url2, timeout, options) => {
      let controller;
      let id;
      let timedOut = false;
      if (typeof AbortController === "function") {
        controller = new AbortController();
        id = setTimeout(() => {
          timedOut = true;
          controller.abort();
        }, timeout);
      }
      const response = await fetch(url2.href, {
        signal: controller ? controller.signal : void 0,
        redirect: "manual",
        headers: options.headers
      }).catch((err) => {
        if (timedOut)
          throw new JWKSTimeout();
        throw err;
      });
      if (id !== void 0)
        clearTimeout(id);
      if (response.status !== 200) {
        throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
      }
      try {
        return await response.json();
      } catch (_a3) {
        throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
      }
    };
    fetch_jwks_default = fetchJwks;
  }
});
function createRemoteJWKSet(url2, options) {
  return RemoteJWKSet.prototype.getKey.bind(new RemoteJWKSet(url2, options));
}
var RemoteJWKSet;
var init_remote = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jwks/remote.js"() {
    init_fetch_jwks();
    init_env();
    init_errors();
    init_local();
    RemoteJWKSet = class extends LocalJWKSet {
      constructor(url2, options) {
        super({ keys: [] });
        this._jwks = void 0;
        if (!(url2 instanceof URL)) {
          throw new TypeError("url must be an instance of URL");
        }
        this._url = new URL(url2.href);
        this._options = { agent: options === null || options === void 0 ? void 0 : options.agent, headers: options === null || options === void 0 ? void 0 : options.headers };
        this._timeoutDuration = typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === "number" ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5e3;
        this._cooldownDuration = typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === "number" ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 3e4;
        this._cacheMaxAge = typeof (options === null || options === void 0 ? void 0 : options.cacheMaxAge) === "number" ? options === null || options === void 0 ? void 0 : options.cacheMaxAge : 6e5;
      }
      coolingDown() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cooldownDuration : false;
      }
      fresh() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cacheMaxAge : false;
      }
      async getKey(protectedHeader, token) {
        if (!this._jwks || !this.fresh()) {
          await this.reload();
        }
        try {
          return await super.getKey(protectedHeader, token);
        } catch (err) {
          if (err instanceof JWKSNoMatchingKey) {
            if (this.coolingDown() === false) {
              await this.reload();
              return super.getKey(protectedHeader, token);
            }
          }
          throw err;
        }
      }
      async reload() {
        if (this._pendingFetch && isCloudflareWorkers()) {
          return new Promise((resolve2) => {
            const isDone = () => {
              if (this._pendingFetch === void 0) {
                resolve2();
              } else {
                setTimeout(isDone, 5);
              }
            };
            isDone();
          });
        }
        if (!this._pendingFetch) {
          this._pendingFetch = fetch_jwks_default(this._url, this._timeoutDuration, this._options).then((json) => {
            if (!isJWKSLike(json)) {
              throw new JWKSInvalid("JSON Web Key Set malformed");
            }
            this._jwks = { keys: json.keys };
            this._jwksTimestamp = Date.now();
            this._pendingFetch = void 0;
          }).catch((err) => {
            this._pendingFetch = void 0;
            throw err;
          });
        }
        await this._pendingFetch;
      }
    };
  }
});
var UnsecuredJWT;
var init_unsecured = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/jwt/unsecured.js"() {
    init_base64url();
    init_buffer_utils();
    init_errors();
    init_jwt_claims_set();
    init_produce();
    UnsecuredJWT = class extends ProduceJWT {
      encode() {
        const header = encode38(JSON.stringify({ alg: "none" }));
        const payload = encode38(JSON.stringify(this._payload));
        return `${header}.${payload}.`;
      }
      static decode(jwt, options) {
        if (typeof jwt !== "string") {
          throw new JWTInvalid("Unsecured JWT must be a string");
        }
        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length: length5 } = jwt.split(".");
        if (length5 !== 3 || signature !== "") {
          throw new JWTInvalid("Invalid Unsecured JWT");
        }
        let header;
        try {
          header = JSON.parse(decoder3.decode(decode41(encodedHeader)));
          if (header.alg !== "none")
            throw new Error();
        } catch (_a3) {
          throw new JWTInvalid("Invalid Unsecured JWT");
        }
        const payload = jwt_claims_set_default(header, decode41(encodedPayload), options);
        return { payload, header };
      }
    };
  }
});
var base64url_exports2 = {};
__export2(base64url_exports2, {
  decode: () => decode211,
  encode: () => encode211
});
var encode211;
var decode211;
var init_base64url2 = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/util/base64url.js"() {
    init_base64url();
    encode211 = encode38;
    decode211 = decode41;
  }
});
function decodeProtectedHeader(token) {
  let protectedB64u;
  if (typeof token === "string") {
    const parts = token.split(".");
    if (parts.length === 3 || parts.length === 5) {
      ;
      [protectedB64u] = parts;
    }
  } else if (typeof token === "object" && token) {
    if ("protected" in token) {
      protectedB64u = token.protected;
    } else {
      throw new TypeError("Token does not contain a Protected Header");
    }
  }
  try {
    if (typeof protectedB64u !== "string" || !protectedB64u) {
      throw new Error();
    }
    const result = JSON.parse(decoder3.decode(decode211(protectedB64u)));
    if (!isObject2(result)) {
      throw new Error();
    }
    return result;
  } catch (_a3) {
    throw new TypeError("Invalid Token or Protected Header formatting");
  }
}
var init_decode_protected_header = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/util/decode_protected_header.js"() {
    init_base64url2();
    init_buffer_utils();
    init_is_object();
  }
});
function decodeJwt(jwt) {
  if (typeof jwt !== "string")
    throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
  const { 1: payload, length: length5 } = jwt.split(".");
  if (length5 === 5)
    throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
  if (length5 !== 3)
    throw new JWTInvalid("Invalid JWT");
  if (!payload)
    throw new JWTInvalid("JWTs must contain a payload");
  let decoded;
  try {
    decoded = decode211(payload);
  } catch (_a3) {
    throw new JWTInvalid("Failed to parse the base64url encoded payload");
  }
  let result;
  try {
    result = JSON.parse(decoder3.decode(decoded));
  } catch (_b) {
    throw new JWTInvalid("Failed to parse the decoded payload as JSON");
  }
  if (!isObject2(result))
    throw new JWTInvalid("Invalid JWT Claims Set");
  return result;
}
var init_decode_jwt = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/util/decode_jwt.js"() {
    init_base64url2();
    init_buffer_utils();
    init_is_object();
    init_errors();
  }
});
async function generateSecret(alg, options) {
  var _a3;
  let length5;
  let algorithm2;
  let keyUsages;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      length5 = parseInt(alg.slice(-3), 10);
      algorithm2 = { name: "HMAC", hash: `SHA-${length5}`, length: length5 };
      keyUsages = ["sign", "verify"];
      break;
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      length5 = parseInt(alg.slice(-3), 10);
      return random_default(new Uint8Array(length5 >> 3));
    case "A128KW":
    case "A192KW":
    case "A256KW":
      length5 = parseInt(alg.slice(1, 4), 10);
      algorithm2 = { name: "AES-KW", length: length5 };
      keyUsages = ["wrapKey", "unwrapKey"];
      break;
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW":
    case "A128GCM":
    case "A192GCM":
    case "A256GCM":
      length5 = parseInt(alg.slice(1, 4), 10);
      algorithm2 = { name: "AES-GCM", length: length5 };
      keyUsages = ["encrypt", "decrypt"];
      break;
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
  }
  return webcrypto_default.subtle.generateKey(algorithm2, (_a3 = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a3 !== void 0 ? _a3 : false, keyUsages);
}
function getModulusLengthOption(options) {
  var _a3;
  const modulusLength = (_a3 = options === null || options === void 0 ? void 0 : options.modulusLength) !== null && _a3 !== void 0 ? _a3 : 2048;
  if (typeof modulusLength !== "number" || modulusLength < 2048) {
    throw new JOSENotSupported("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");
  }
  return modulusLength;
}
async function generateKeyPair(alg, options) {
  var _a3, _b, _c;
  let algorithm2;
  let keyUsages;
  switch (alg) {
    case "PS256":
    case "PS384":
    case "PS512":
      algorithm2 = {
        name: "RSA-PSS",
        hash: `SHA-${alg.slice(-3)}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["sign", "verify"];
      break;
    case "RS256":
    case "RS384":
    case "RS512":
      algorithm2 = {
        name: "RSASSA-PKCS1-v1_5",
        hash: `SHA-${alg.slice(-3)}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["sign", "verify"];
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      algorithm2 = {
        name: "RSA-OAEP",
        hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["decrypt", "unwrapKey", "encrypt", "wrapKey"];
      break;
    case "ES256":
      algorithm2 = { name: "ECDSA", namedCurve: "P-256" };
      keyUsages = ["sign", "verify"];
      break;
    case "ES384":
      algorithm2 = { name: "ECDSA", namedCurve: "P-384" };
      keyUsages = ["sign", "verify"];
      break;
    case "ES512":
      algorithm2 = { name: "ECDSA", namedCurve: "P-521" };
      keyUsages = ["sign", "verify"];
      break;
    case (isCloudflareWorkers() && "EdDSA"):
      switch (options === null || options === void 0 ? void 0 : options.crv) {
        case void 0:
        case "Ed25519":
          algorithm2 = { name: "NODE-ED25519", namedCurve: "NODE-ED25519" };
          keyUsages = ["sign", "verify"];
          break;
        default:
          throw new JOSENotSupported("Invalid or unsupported crv option provided");
      }
      break;
    case "EdDSA":
      keyUsages = ["sign", "verify"];
      const crv = (_a3 = options === null || options === void 0 ? void 0 : options.crv) !== null && _a3 !== void 0 ? _a3 : "Ed25519";
      switch (crv) {
        case "Ed25519":
        case "Ed448":
          algorithm2 = { name: crv };
          break;
        default:
          throw new JOSENotSupported("Invalid or unsupported crv option provided");
      }
      break;
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      keyUsages = ["deriveKey", "deriveBits"];
      const crv2 = (_b = options === null || options === void 0 ? void 0 : options.crv) !== null && _b !== void 0 ? _b : "P-256";
      switch (crv2) {
        case "P-256":
        case "P-384":
        case "P-521": {
          algorithm2 = { name: "ECDH", namedCurve: crv2 };
          break;
        }
        case "X25519":
        case "X448":
          algorithm2 = { name: crv2 };
          break;
        default:
          throw new JOSENotSupported("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448");
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
  }
  return webcrypto_default.subtle.generateKey(algorithm2, (_c = options === null || options === void 0 ? void 0 : options.extractable) !== null && _c !== void 0 ? _c : false, keyUsages);
}
var init_generate = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/runtime/generate.js"() {
    init_env();
    init_webcrypto();
    init_errors();
    init_random();
  }
});
async function generateKeyPair2(alg, options) {
  return generateKeyPair(alg, options);
}
var init_generate_key_pair = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/key/generate_key_pair.js"() {
    init_generate();
  }
});
async function generateSecret2(alg, options) {
  return generateSecret(alg, options);
}
var init_generate_secret = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/key/generate_secret.js"() {
    init_generate();
  }
});
var browser_exports = {};
__export2(browser_exports, {
  CompactEncrypt: () => CompactEncrypt,
  CompactSign: () => CompactSign,
  EmbeddedJWK: () => EmbeddedJWK,
  EncryptJWT: () => EncryptJWT,
  FlattenedEncrypt: () => FlattenedEncrypt,
  FlattenedSign: () => FlattenedSign,
  GeneralEncrypt: () => GeneralEncrypt,
  GeneralSign: () => GeneralSign,
  SignJWT: () => SignJWT,
  UnsecuredJWT: () => UnsecuredJWT,
  base64url: () => base64url_exports2,
  calculateJwkThumbprint: () => calculateJwkThumbprint,
  calculateJwkThumbprintUri: () => calculateJwkThumbprintUri,
  compactDecrypt: () => compactDecrypt,
  compactVerify: () => compactVerify,
  createLocalJWKSet: () => createLocalJWKSet,
  createRemoteJWKSet: () => createRemoteJWKSet,
  decodeJwt: () => decodeJwt,
  decodeProtectedHeader: () => decodeProtectedHeader,
  errors: () => errors_exports,
  exportJWK: () => exportJWK,
  exportPKCS8: () => exportPKCS8,
  exportSPKI: () => exportSPKI,
  flattenedDecrypt: () => flattenedDecrypt,
  flattenedVerify: () => flattenedVerify,
  generalDecrypt: () => generalDecrypt,
  generalVerify: () => generalVerify,
  generateKeyPair: () => generateKeyPair2,
  generateSecret: () => generateSecret2,
  importJWK: () => importJWK,
  importPKCS8: () => importPKCS8,
  importSPKI: () => importSPKI,
  importX509: () => importX509,
  jwtDecrypt: () => jwtDecrypt,
  jwtVerify: () => jwtVerify
});
var init_browser = __esm2({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/browser/index.js"() {
    init_decrypt3();
    init_decrypt2();
    init_decrypt4();
    init_encrypt3();
    init_verify3();
    init_verify2();
    init_verify4();
    init_verify5();
    init_decrypt5();
    init_encrypt4();
    init_encrypt2();
    init_sign3();
    init_sign2();
    init_sign4();
    init_sign5();
    init_encrypt5();
    init_thumbprint();
    init_embedded();
    init_local();
    init_remote();
    init_unsecured();
    init_export();
    init_import();
    init_decode_protected_header();
    init_decode_jwt();
    init_errors();
    init_generate_key_pair();
    init_generate_secret();
    init_base64url2();
  }
});
var require_createToken = __commonJS2({
  "../auth/dist/createToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createToken = void 0;
    var jose_1 = (init_browser(), __toCommonJS(browser_exports));
    var textEncoder7 = new TextEncoder();
    var createToken3 = async ({ payload, secret, expiration }) => {
      const secretKey = textEncoder7.encode(secret);
      const jwt = new jose_1.SignJWT(payload).setProtectedHeader({ alg: "HS256" });
      if (expiration) {
        jwt.setExpirationTime(expiration);
      }
      return jwt.sign(secretKey);
    };
    exports2.createToken = createToken3;
  }
});
var require_createAccessToken = __commonJS2({
  "../auth/dist/createAccessToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAccessToken = void 0;
    var createToken_1 = require_createToken();
    var createAccessToken = async (args) => (0, createToken_1.createToken)(args);
    exports2.createAccessToken = createAccessToken;
  }
});
var require_createAssetsAccessToken = __commonJS2({
  "../auth/dist/createAssetsAccessToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAssetsAccessToken = void 0;
    var createToken_1 = require_createToken();
    var createAssetsAccessToken = async (args) => (0, createToken_1.createToken)(args);
    exports2.createAssetsAccessToken = createAssetsAccessToken;
  }
});
var require_createMigrationToken = __commonJS2({
  "../auth/dist/createMigrationToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMigrationToken = void 0;
    var createToken_1 = require_createToken();
    var createMigrationToken = async (args) => (0, createToken_1.createToken)(args);
    exports2.createMigrationToken = createMigrationToken;
  }
});
var require_FleekError = __commonJS2({
  "../errors/dist/FleekError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekError = void 0;
    var FleekError2 = class extends Error {
      // eslint-disable-next-line fleek-custom/valid-argument-types
      constructor(data) {
        super();
        this.data = data;
      }
      get message() {
        return this.toString();
      }
    };
    exports2.FleekError = FleekError2;
  }
});
var require_BunnyPullZoneNotFoundError = __commonJS2({
  "../errors/dist/BunnyPullZoneNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BunnyPullZoneNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var BunnyPullZoneNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "BunnyPullZoneNotFoundError";
        this.toString = () => `PullZone with name ${this.data.name} was not found on BunnyCDN.`;
      }
    };
    exports2.BunnyPullZoneNotFoundError = BunnyPullZoneNotFoundError;
  }
});
var require_DomainNotFoundError = __commonJS2({
  "../errors/dist/DomainNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainNotFoundError";
        this.toString = () => {
          if (this.data.domain.hostname) {
            return `Domain ${this.data.domain.hostname} was not found.`;
          }
          return "Domain was not found.";
        };
      }
    };
    exports2.DomainNotFoundError = DomainNotFoundError2;
  }
});
var require_DomainsNotFoundError = __commonJS2({
  "../errors/dist/DomainsNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainsNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainsNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "DomainsNotFoundError";
        this.toString = () => "No domains found.";
      }
    };
    exports2.DomainsNotFoundError = DomainsNotFoundError2;
  }
});
var require_DomainAlreadyExistsInProjectError = __commonJS2({
  "../errors/dist/DomainAlreadyExistsInProjectError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainAlreadyExistsInProjectError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainAlreadyExistsInProjectError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainAlreadyExistsInProjectError";
        this.toString = () => {
          return `Domain ${this.data.domain.hostname} already exists under the project.`;
        };
      }
    };
    exports2.DomainAlreadyExistsInProjectError = DomainAlreadyExistsInProjectError;
  }
});
var require_DomainInPendingStateError = __commonJS2({
  "../errors/dist/DomainInPendingStateError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainInPendingStateError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainInPendingStateError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainInPendingStateError";
        this.toString = () => {
          return "Domain is in pending state. Please wait and try action again later.";
        };
      }
    };
    exports2.DomainInPendingStateError = DomainInPendingStateError;
  }
});
var require_DomainHostnameInvalidError = __commonJS2({
  "../errors/dist/DomainHostnameInvalidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainHostnameInvalidError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainHostnameInvalidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainHostnameInvalidError";
        this.toString = () => {
          return `The domain ${this.data.hostname} is invalid`;
        };
      }
    };
    exports2.DomainHostnameInvalidError = DomainHostnameInvalidError;
  }
});
var require_UnknownError = __commonJS2({
  "../errors/dist/UnknownError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnknownError = void 0;
    var FleekError_1 = require_FleekError();
    var UnknownError3 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "UnknownError";
        this.toString = () => `Unexpected error. Repeat the action or contact support.`;
      }
    };
    exports2.UnknownError = UnknownError3;
  }
});
var require_SiteNotFoundError = __commonJS2({
  "../errors/dist/SiteNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteNotFoundError3 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteNotFoundError";
        this.toString = () => {
          if (this.data.site.slug) {
            return `Site ${this.data.site.slug} not found.`;
          }
          return `Site not found.`;
        };
      }
    };
    exports2.SiteNotFoundError = SiteNotFoundError3;
  }
});
var require_SitesNotFoundError = __commonJS2({
  "../errors/dist/SitesNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SitesNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var SitesNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "SitesNotFoundError";
        this.toString = () => "No sites found.";
      }
    };
    exports2.SitesNotFoundError = SitesNotFoundError2;
  }
});
var require_SiteAlreadyExistsError = __commonJS2({
  "../errors/dist/SiteAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteAlreadyExistsError";
        this.toString = () => {
          if ("name" in this.data.site) {
            return `Site ${this.data.site.name} already exists in the project.`;
          }
          return `Site slug must be unique within Fleek but ${this.data.site.slug} already exists.`;
        };
      }
    };
    exports2.SiteAlreadyExistsError = SiteAlreadyExistsError;
  }
});
var require_SiteDeploymentNotFoundError = __commonJS2({
  "../errors/dist/SiteDeploymentNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteDeploymentNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteDeploymentNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteDeploymentNotFoundError";
        this.toString = () => `Deployment not found.`;
      }
    };
    exports2.SiteDeploymentNotFoundError = SiteDeploymentNotFoundError2;
  }
});
var require_SiteHasDependentsError = __commonJS2({
  "../errors/dist/SiteHasDependentsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteHasDependentsError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteHasDependentsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteHasDependentsError";
        this.toString = () => {
          const dependentsInfo = [];
          if (this.data.domains.length > 0) {
            dependentsInfo.push(`${this.data.domains.length} domains`);
          }
          if (this.data.ipnsRecords.length > 0) {
            dependentsInfo.push(`${this.data.ipnsRecords.length} IPNS records`);
          }
          return `Site has assigned ${dependentsInfo}. You have to delete them first.`;
        };
      }
    };
    exports2.SiteHasDependentsError = SiteHasDependentsError;
  }
});
var require_SiteHasNoSourceProviderError = __commonJS2({
  "../errors/dist/SiteHasNoSourceProviderError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteHasNoSourceProviderError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteHasNoSourceProviderError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteHasNoSourceProviderError";
        this.toString = () => {
          if (this.data.site.slug) {
            return `Site ${this.data.site.slug} does not have a source provider.`;
          }
          return `Site does not have a source provider.`;
        };
      }
    };
    exports2.SiteHasNoSourceProviderError = SiteHasNoSourceProviderError;
  }
});
var require_SiteNotDeployedError = __commonJS2({
  "../errors/dist/SiteNotDeployedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteNotDeployedError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteNotDeployedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteNotDeployedError";
        this.toString = () => {
          if (this.data.site.slug) {
            return `Site ${this.data.site.slug} does not have released deployments.`;
          }
          return `Site does not have released deployments.`;
        };
      }
    };
    exports2.SiteNotDeployedError = SiteNotDeployedError;
  }
});
var require_IpnsRecordNotFoundError = __commonJS2({
  "../errors/dist/IpnsRecordNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IpnsRecordNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var IpnsRecordNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "IpnsRecordNotFoundError";
        this.toString = () => `IPNS record not found.`;
      }
    };
    exports2.IpnsRecordNotFoundError = IpnsRecordNotFoundError;
  }
});
var require_IpnsRecordsNotFoundError = __commonJS2({
  "../errors/dist/IpnsRecordsNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IpnsRecordsNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var IpnsRecordsNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "IpnsRecordsNotFoundError";
        this.toString = () => "No IPNS records found.";
      }
    };
    exports2.IpnsRecordsNotFoundError = IpnsRecordsNotFoundError;
  }
});
var require_IpnsFailToDecryptKeyError = __commonJS2({
  "../errors/dist/IpnsFailToDecryptKeyError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IpnsFailToDecryptKeyError = void 0;
    var FleekError_1 = require_FleekError();
    var IpnsFailToDecryptKeyError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "IpnsFailToDecryptKeyError";
        this.toString = () => `Failed to decrypt IPNS key.`;
      }
    };
    exports2.IpnsFailToDecryptKeyError = IpnsFailToDecryptKeyError;
  }
});
var require_IpnsRecordsForSiteLimitError = __commonJS2({
  "../errors/dist/IpnsRecordsForSiteLimitError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IpnsRecordsForSiteLimitError = void 0;
    var FleekError_1 = require_FleekError();
    var IpnsRecordsForSiteLimitError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "IpnsRecordsForSiteLimitError";
        this.toString = () => {
          if (this.data.site.name) {
            return `Maximum amount of IPNS records that may be assigned to the ${this.data.site.name} site was exceeded.`;
          }
          return `Maximum amount of IPNS records that may be assigned to the site was exceeded.`;
        };
      }
    };
    exports2.IpnsRecordsForSiteLimitError = IpnsRecordsForSiteLimitError;
  }
});
var require_StorageIpfsUploadFailedError = __commonJS2({
  "../errors/dist/StorageIpfsUploadFailedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StorageIpfsUploadFailedError = void 0;
    var FleekError_1 = require_FleekError();
    var StorageIpfsUploadFailedError3 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "StorageIpfsUploadFailedError";
        this.toString = () => `Upload failed.`;
      }
    };
    exports2.StorageIpfsUploadFailedError = StorageIpfsUploadFailedError3;
  }
});
var require_SdkRequiredNodeRuntimeError = __commonJS2({
  "../errors/dist/SdkRequiredNodeRuntimeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SdkRequiredNodeRuntimeError = void 0;
    var FleekError_1 = require_FleekError();
    var SdkRequiredNodeRuntimeError6 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "SdkRequiredNodeRuntimeError";
        this.toString = () => `The functionality of this SDK feature is dependent on the Node.js runtime.`;
      }
    };
    exports2.SdkRequiredNodeRuntimeError = SdkRequiredNodeRuntimeError6;
  }
});
var require_AuthorizationError = __commonJS2({
  "../errors/dist/AuthorizationError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuthorizationError = void 0;
    var FleekError_1 = require_FleekError();
    var AuthorizationError5 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "AuthorizationError";
        this.toString = () => `Authorization with provided credentials is invalid.`;
      }
    };
    exports2.AuthorizationError = AuthorizationError5;
  }
});
var require_ProjectMembershipNotFoundError = __commonJS2({
  "../errors/dist/ProjectMembershipNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectMembershipNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectMembershipNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectMembershipNotFoundError";
        this.toString = () => `Membership not found for project.`;
      }
    };
    exports2.ProjectMembershipNotFoundError = ProjectMembershipNotFoundError;
  }
});
var require_GithubAppInstallationNotFoundError = __commonJS2({
  "../errors/dist/GithubAppInstallationNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GithubAppInstallationNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var GithubAppInstallationNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GithubAppInstallationNotFoundError";
        this.toString = () => {
          return "No GitHub App installation found for given project.";
        };
      }
    };
    exports2.GithubAppInstallationNotFoundError = GithubAppInstallationNotFoundError;
  }
});
var require_UserNotFoundError = __commonJS2({
  "../errors/dist/UserNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var UserNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UserNotFoundError";
        this.toString = () => {
          if (this.data.email) {
            return `User with email ${this.data.email} not found.`;
          }
          return `User not found.`;
        };
      }
    };
    exports2.UserNotFoundError = UserNotFoundError;
  }
});
var require_UserAlreadyExistsError = __commonJS2({
  "../errors/dist/UserAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var UserAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UserAlreadyExistsError";
        this.toString = () => "The username is already in use, please select another one";
      }
    };
    exports2.UserAlreadyExistsError = UserAlreadyExistsError;
  }
});
var require_ProjectNotFoundError = __commonJS2({
  "../errors/dist/ProjectNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectNotFoundError";
        this.toString = () => "Project not found.";
      }
    };
    exports2.ProjectNotFoundError = ProjectNotFoundError;
  }
});
var require_ProjectsNotFoundError = __commonJS2({
  "../errors/dist/ProjectsNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectsNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectsNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "ProjectsNotFoundError";
        this.toString = () => "No projects found.";
      }
    };
    exports2.ProjectsNotFoundError = ProjectsNotFoundError;
  }
});
var require_ProjectHasDependentsError = __commonJS2({
  "../errors/dist/ProjectHasDependentsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectHasDependentsError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectHasDependentsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectHasDependentsError";
        this.toString = () => {
          const dependentsInfo = [];
          if (this.data.sites.length > 0) {
            dependentsInfo.push(`${this.data.sites.length} sites`);
          }
          if (this.data.privateGateways.length > 0) {
            dependentsInfo.push(`${this.data.privateGateways.length} private gateways`);
          }
          if (this.data.ipnsRecords.length > 0) {
            dependentsInfo.push(`${this.data.ipnsRecords.length} IPNS records`);
          }
          return `Project has assigned ${dependentsInfo.join(", ")}. You have to delete them first.`;
        };
      }
    };
    exports2.ProjectHasDependentsError = ProjectHasDependentsError;
  }
});
var require_ProjectInvalidNameError = __commonJS2({
  "../errors/dist/ProjectInvalidNameError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectInvalidNameError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectInvalidNameError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectInvalidNameError";
        this.toString = () => `The project name ${this.data.name} is invalid.`;
      }
    };
    exports2.ProjectInvalidNameError = ProjectInvalidNameError;
  }
});
var require_PublicKeyAlreadyExistsError = __commonJS2({
  "../errors/dist/PublicKeyAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PublicKeyAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var PublicKeyAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PublicKeyAlreadyExistsError";
        this.toString = () => `Public key already exists.`;
      }
    };
    exports2.PublicKeyAlreadyExistsError = PublicKeyAlreadyExistsError;
  }
});
var require_VerificationSessionAlreadyExistsError = __commonJS2({
  "../errors/dist/VerificationSessionAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VerificationSessionAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var VerificationSessionAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "VerificationSessionAlreadyExistsError";
        this.toString = () => `Verification session already exists.`;
      }
    };
    exports2.VerificationSessionAlreadyExistsError = VerificationSessionAlreadyExistsError;
  }
});
var require_UnauthenticatedError = __commonJS2({
  "../errors/dist/UnauthenticatedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnauthenticatedError = void 0;
    var FleekError_1 = require_FleekError();
    var UnauthenticatedError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "UnauthenticatedError";
        this.toString = () => `The request is not authenticated.`;
      }
    };
    exports2.UnauthenticatedError = UnauthenticatedError;
  }
});
var require_DomainZoneNotFoundError = __commonJS2({
  "../errors/dist/DomainZoneNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainZoneNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainZoneNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainZoneNotFoundError";
        this.toString = () => {
          return "Domain zone not found.";
        };
      }
    };
    exports2.DomainZoneNotFoundError = DomainZoneNotFoundError;
  }
});
var require_DomainZoneHasDependentsError = __commonJS2({
  "../errors/dist/DomainZoneHasDependentsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainZoneHasDependentsError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainZoneHasDependentsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainZoneHasDependentsError";
        this.toString = () => "Domain zone has assigned domains or private gateways. You have to delete them first.";
      }
    };
    exports2.DomainZoneHasDependentsError = DomainZoneHasDependentsError;
  }
});
var require_DomainZoneInPendingStateError = __commonJS2({
  "../errors/dist/DomainZoneInPendingStateError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainZoneInPendingStateError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainZoneInPendingStateError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ZoneInPendingStateError";
        this.toString = () => {
          return "Domain zone is in pending state. Please wait and try action again later.";
        };
      }
    };
    exports2.DomainZoneInPendingStateError = DomainZoneInPendingStateError;
  }
});
var require_DomainNotFoundUnderPullzoneError = __commonJS2({
  "../errors/dist/DomainNotFoundUnderPullzoneError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainNotFoundUnderPullzoneError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainNotFoundUnderPullzoneError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainNotFoundUnderPullzoneError";
        this.toString = () => {
          return "Domain zone not found.";
        };
      }
    };
    exports2.DomainNotFoundUnderPullzoneError = DomainNotFoundUnderPullzoneError;
  }
});
var require_DomainZoneInvalidTypeError = __commonJS2({
  "../errors/dist/DomainZoneInvalidTypeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainZoneInvalidTypeError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainZoneInvalidTypeError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainZoneInvalidTypeError";
        this.toString = () => "Domain zone has different purpose of use.";
      }
    };
    exports2.DomainZoneInvalidTypeError = DomainZoneInvalidTypeError;
  }
});
var require_UnauthorizedError = __commonJS2({
  "../errors/dist/UnauthorizedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnauthorizedError = void 0;
    var FleekError_1 = require_FleekError();
    var UnauthorizedError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UnauthorizedError";
        this.toString = () => {
          if (this.data.scopes) {
            return `You are not authorized to access this resource because of missing permissions: ${this.data.scopes.join(", ")}.`;
          }
          return `You are not authorized to access this resource.`;
        };
      }
    };
    exports2.UnauthorizedError = UnauthorizedError2;
  }
});
var require_FleekConfigInvalidContentError = __commonJS2({
  "../errors/dist/FleekConfigInvalidContentError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekConfigInvalidContentError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekConfigInvalidContentError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekConfigInvalidContentError";
        this.toString = () => {
          if (this.data.validationResult) {
            return `Validation of loaded ${this.data.configPath} failed. ${this.data.validationResult}`;
          }
          return `Loaded ${this.data.configPath} file is corrupted.`;
        };
      }
    };
    exports2.FleekConfigInvalidContentError = FleekConfigInvalidContentError;
  }
});
var require_FleekConfigMissingFileError = __commonJS2({
  "../errors/dist/FleekConfigMissingFileError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekConfigMissingFileError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekConfigMissingFileError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekConfigMissingFileError";
        this.toString = () => {
          return `Unable to access or find the configuration file${this.data.configPath && " " + this.data.configPath + "." || "."}`;
        };
      }
    };
    exports2.FleekConfigMissingFileError = FleekConfigMissingFileError;
  }
});
var require_ApplicationWhitelistDomainDuplicityError = __commonJS2({
  "../errors/dist/ApplicationWhitelistDomainDuplicityError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationWhitelistDomainDuplicityError = void 0;
    var FleekError_1 = require_FleekError();
    var ApplicationWhitelistDomainDuplicityError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ApplicationWhitelistDomainDuplicityError";
        this.toString = () => `Application ${this.data.application.name} doesn't have unique white label domains.`;
      }
    };
    exports2.ApplicationWhitelistDomainDuplicityError = ApplicationWhitelistDomainDuplicityError;
  }
});
var require_ApplicationAlreadyExistsError = __commonJS2({
  "../errors/dist/ApplicationAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var ApplicationAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ApplicationAlreadyExistsError";
        this.toString = () => `Application ${this.data.application.name} already exists.`;
      }
    };
    exports2.ApplicationAlreadyExistsError = ApplicationAlreadyExistsError;
  }
});
var require_ApplicationsNotFoundError = __commonJS2({
  "../errors/dist/ApplicationsNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationsNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var ApplicationsNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ApplicationsNotFoundError";
        this.toString = () => "No applications found.";
      }
    };
    exports2.ApplicationsNotFoundError = ApplicationsNotFoundError;
  }
});
var require_ApplicationNotFoundError = __commonJS2({
  "../errors/dist/ApplicationNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var ApplicationNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ApplicationNotFoundError";
        this.toString = () => "Application not found.";
      }
    };
    exports2.ApplicationNotFoundError = ApplicationNotFoundError;
  }
});
var require_ApplicationNameInvalidError = __commonJS2({
  "../errors/dist/ApplicationNameInvalidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationNameInvalidError = void 0;
    var FleekError_1 = require_FleekError();
    var ApplicationNameInvalidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ApplicationNameInvalidError";
        this.toString = () => `The application name ${this.data.name} is invalid.`;
      }
    };
    exports2.ApplicationNameInvalidError = ApplicationNameInvalidError;
  }
});
var require_EnsRecordNotFoundError = __commonJS2({
  "../errors/dist/EnsRecordNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsRecordNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var EnsRecordNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnsRecordNotFoundError";
        this.toString = () => {
          if (this.data.site?.id) {
            return `No site associated with this ENS record.`;
          }
          return `ENS record was not found.`;
        };
      }
    };
    exports2.EnsRecordNotFoundError = EnsRecordNotFoundError;
  }
});
var require_EnsRecordAlreadyExistsInProjectError = __commonJS2({
  "../errors/dist/EnsRecordAlreadyExistsInProjectError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsRecordAlreadyExistsInProjectError = void 0;
    var FleekError_1 = require_FleekError();
    var EnsRecordAlreadyExistsInProjectError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnsRecordAlreadyExistsInProjectError";
        this.toString = () => {
          return `ENS record already exists under the project.`;
        };
      }
    };
    exports2.EnsRecordAlreadyExistsInProjectError = EnsRecordAlreadyExistsInProjectError;
  }
});
var require_EnsNameInvalidError = __commonJS2({
  "../errors/dist/EnsNameInvalidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsNameInvalidError = void 0;
    var FleekError_1 = require_FleekError();
    var EnsNameInvalidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnsNameInvalidError";
        this.toString = () => {
          return `ENS record name "${this.data.ensRecord.name}" is invalid.`;
        };
      }
    };
    exports2.EnsNameInvalidError = EnsNameInvalidError;
  }
});
var require_EnsRecordInPendingStateError = __commonJS2({
  "../errors/dist/EnsRecordInPendingStateError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsRecordInPendingStateError = void 0;
    var FleekError_1 = require_FleekError();
    var EnsRecordInPendingStateError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnsRecordInPendingStateError";
        this.toString = () => {
          return "ENS Record is in pending state. Please wait and try action again later.";
        };
      }
    };
    exports2.EnsRecordInPendingStateError = EnsRecordInPendingStateError;
  }
});
var require_InvalidPersonalAccessTokenError = __commonJS2({
  "../errors/dist/InvalidPersonalAccessTokenError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidPersonalAccessTokenError = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidPersonalAccessTokenError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidPersonalAccessTokenError";
        this.toString = () => "Personal access token is invalid.";
      }
    };
    exports2.InvalidPersonalAccessTokenError = InvalidPersonalAccessTokenError;
  }
});
var require_PersonalAccessTokenNotFoundError = __commonJS2({
  "../errors/dist/PersonalAccessTokenNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PersonalAccessTokenNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var PersonalAccessTokenNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PersonalAccessTokenNotFoundError";
        this.toString = () => `Personal access token with ID ${this.data.personalAccessToken.id} not found.`;
      }
    };
    exports2.PersonalAccessTokenNotFoundError = PersonalAccessTokenNotFoundError;
  }
});
var require_PrivateGatewayNotFoundError = __commonJS2({
  "../errors/dist/PrivateGatewayNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrivateGatewayNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var PrivateGatewayNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PrivateGatewayNotFoundError";
        this.toString = () => `Private gateway not found.`;
      }
    };
    exports2.PrivateGatewayNotFoundError = PrivateGatewayNotFoundError2;
  }
});
var require_PrivateGatewayAlreadyExistsError = __commonJS2({
  "../errors/dist/PrivateGatewayAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrivateGatewayAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var PrivateGatewayAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PrivateGatewayAlreadyExistsError";
        this.toString = () => `Private gateway already exists. Please choose different name for the private gateway.`;
      }
    };
    exports2.PrivateGatewayAlreadyExistsError = PrivateGatewayAlreadyExistsError;
  }
});
var require_PrivateGatewayNameInvalidError = __commonJS2({
  "../errors/dist/PrivateGatewayNameInvalidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrivateGatewayNameInvalidError = void 0;
    var FleekError_1 = require_FleekError();
    var PrivateGatewayNameInvalidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PrivateGatewayNameInvalidError";
        this.toString = () => `The private gateway name ${this.data.name} is invalid.`;
      }
    };
    exports2.PrivateGatewayNameInvalidError = PrivateGatewayNameInvalidError;
  }
});
var require_PrivateGatewaysNotFoundError = __commonJS2({
  "../errors/dist/PrivateGatewaysNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrivateGatewaysNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var PrivateGatewaysNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PrivateGatewaysNotFoundError";
        this.toString = () => "No private gateways found.";
      }
    };
    exports2.PrivateGatewaysNotFoundError = PrivateGatewaysNotFoundError2;
  }
});
var require_TemplateAlreadyExistsError = __commonJS2({
  "../errors/dist/TemplateAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var TemplateAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "TemplateAlreadyExistsError";
        this.toString = () => `Template already exists.`;
      }
    };
    exports2.TemplateAlreadyExistsError = TemplateAlreadyExistsError;
  }
});
var require_TemplateNotFoundError = __commonJS2({
  "../errors/dist/TemplateNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var TemplateNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "TemplateNotFoundError";
        this.toString = () => `Template not found.`;
      }
    };
    exports2.TemplateNotFoundError = TemplateNotFoundError;
  }
});
var require_UserHasNoAccessToAnotherUserError = __commonJS2({
  "../errors/dist/UserHasNoAccessToAnotherUserError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserHasNoAccessToAnotherUserError = void 0;
    var FleekError_1 = require_FleekError();
    var UserHasNoAccessToAnotherUserError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "UserHasNoAccessToAnotherUserError";
        this.toString = () => "You don`t have access to user you try to fetch data for.";
      }
    };
    exports2.UserHasNoAccessToAnotherUserError = UserHasNoAccessToAnotherUserError;
  }
});
var require_SiteFrameworkAlreadyExistsError = __commonJS2({
  "../errors/dist/SiteFrameworkAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteFrameworkAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteFrameworkAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteFrameworkAlreadyExistsError";
        this.toString = () => `Site framework already exists.`;
      }
    };
    exports2.SiteFrameworkAlreadyExistsError = SiteFrameworkAlreadyExistsError;
  }
});
var require_SiteFrameworkNotFoundError = __commonJS2({
  "../errors/dist/SiteFrameworkNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteFrameworkNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteFrameworkNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteFrameworkNotFoundError";
        this.toString = () => `Site framework not found.`;
      }
    };
    exports2.SiteFrameworkNotFoundError = SiteFrameworkNotFoundError;
  }
});
var require_TemplateCategoryNotFoundError = __commonJS2({
  "../errors/dist/TemplateCategoryNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateCategoryNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var TemplateCategoryNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "TemplateCategoryNotFoundError";
        this.toString = () => `Template category not found.`;
      }
    };
    exports2.TemplateCategoryNotFoundError = TemplateCategoryNotFoundError;
  }
});
var require_TemplateDeploymentNotFoundError = __commonJS2({
  "../errors/dist/TemplateDeploymentNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateDeploymentNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var TemplateDeploymentNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "TemplateDeploymentNotFoundError";
        this.toString = () => `Template deployment not found.`;
      }
    };
    exports2.TemplateDeploymentNotFoundError = TemplateDeploymentNotFoundError;
  }
});
var require_ProjectMembershipHasInefficientRoleError = __commonJS2({
  "../errors/dist/ProjectMembershipHasInefficientRoleError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectMembershipHasInefficientRoleError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectMembershipHasInefficientRoleError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectMembershipHasInefficientRoleError";
        this.toString = () => `Membership has inefficient role for this action.`;
      }
    };
    exports2.ProjectMembershipHasInefficientRoleError = ProjectMembershipHasInefficientRoleError;
  }
});
var require_SecretGroupNotFoundError = __commonJS2({
  "../errors/dist/SecretGroupNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecretGroupNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var SecretGroupNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SecretGroupNotFoundError";
        this.toString = () => {
          return "Secret group was not found.";
        };
      }
    };
    exports2.SecretGroupNotFoundError = SecretGroupNotFoundError;
  }
});
var require_SecretNotFoundError = __commonJS2({
  "../errors/dist/SecretNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecretNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var SecretNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SecretNotFoundError";
        this.toString = () => {
          return "Secret was not found.";
        };
      }
    };
    exports2.SecretNotFoundError = SecretNotFoundError;
  }
});
var require_SecretVisibilityAlreadyEncryptedError = __commonJS2({
  "../errors/dist/SecretVisibilityAlreadyEncryptedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecretVisibilityAlreadyEncryptedError = void 0;
    var FleekError_1 = require_FleekError();
    var SecretVisibilityAlreadyEncryptedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SecretVisibilityAlreadyEncryptedError";
        this.toString = () => {
          return "You cannot change visibility of already encrypted secret.";
        };
      }
    };
    exports2.SecretVisibilityAlreadyEncryptedError = SecretVisibilityAlreadyEncryptedError;
  }
});
var require_SecretKeyAlreadyExistsError = __commonJS2({
  "../errors/dist/SecretKeyAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecretKeyAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var SecretKeyAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SecretKeyAlreadyExistsError";
        this.toString = () => {
          return "Variable with this key is already set.";
        };
      }
    };
    exports2.SecretKeyAlreadyExistsError = SecretKeyAlreadyExistsError;
  }
});
var require_SecretFailToEncryptError = __commonJS2({
  "../errors/dist/SecretFailToEncryptError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecretFailToEncryptError = void 0;
    var FleekError_1 = require_FleekError();
    var SecretFailToEncryptError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SecretFailToEncryptError";
        this.toString = () => {
          return "Failed to encrypt secret.";
        };
      }
    };
    exports2.SecretFailToEncryptError = SecretFailToEncryptError;
  }
});
var require_PinNotFoundError = __commonJS2({
  "../errors/dist/PinNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PinNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var PinNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PinNotFoundError";
        this.toString = () => {
          return "Pin was not found.";
        };
      }
    };
    exports2.PinNotFoundError = PinNotFoundError2;
  }
});
var require_PinAlreadyExistsInProjectError = __commonJS2({
  "../errors/dist/PinAlreadyExistsInProjectError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PinAlreadyExistsInProjectError = void 0;
    var FleekError_1 = require_FleekError();
    var PinAlreadyExistsInProjectError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PinAlreadyExistsInProjectError";
        this.toString = () => {
          return `Pin with the same '${this.data.pin.cid ? "cid" : "path"}' already exists within the project.`;
        };
      }
    };
    exports2.PinAlreadyExistsInProjectError = PinAlreadyExistsInProjectError;
  }
});
var require_UnstoppableDeploymentError = __commonJS2({
  "../errors/dist/UnstoppableDeploymentError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnstoppableDeploymentError = void 0;
    var FleekError_1 = require_FleekError();
    var UnstoppableDeploymentError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UnstoppableDeploymentError";
        this.toString = () => `Deployment cannot be stopped.`;
      }
    };
    exports2.UnstoppableDeploymentError = UnstoppableDeploymentError;
  }
});
var require_SiteDeploymentNotReleasedError = __commonJS2({
  "../errors/dist/SiteDeploymentNotReleasedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteDeploymentNotReleasedError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteDeploymentNotReleasedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteDeploymentNotReleasedError";
        this.toString = () => `Deployment not released.`;
      }
    };
    exports2.SiteDeploymentNotReleasedError = SiteDeploymentNotReleasedError;
  }
});
var require_InvalidDeploymentTriggerError = __commonJS2({
  "../errors/dist/InvalidDeploymentTriggerError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidDeploymentTriggerError = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidDeploymentTriggerError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidDeploymentTriggerError";
        this.toString = () => `Deployment can not be triggered, source provider integrations missing.`;
      }
    };
    exports2.InvalidDeploymentTriggerError = InvalidDeploymentTriggerError;
  }
});
var require_IpfsGatewayContentUnreachableError = __commonJS2({
  "../errors/dist/IpfsGatewayContentUnreachableError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IpfsGatewayContentUnreachableError = void 0;
    var FleekError_1 = require_FleekError();
    var IpfsGatewayContentUnreachableError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "IpfsGatewayContentUnreachableError";
        this.toString = () => "Cannot get IPFS content through Fleek gateway.";
      }
    };
    exports2.IpfsGatewayContentUnreachableError = IpfsGatewayContentUnreachableError;
  }
});
var require_InvitationNotFoundError = __commonJS2({
  "../errors/dist/InvitationNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvitationNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var InvitationNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvitationNotFoundError";
        this.toString = () => {
          return "Invitation was not found.";
        };
      }
    };
    exports2.InvitationNotFoundError = InvitationNotFoundError;
  }
});
var require_MigrationTokenInvalidError = __commonJS2({
  "../errors/dist/MigrationTokenInvalidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MigrationTokenInvalidError = void 0;
    var FleekError_1 = require_FleekError();
    var MigrationTokenInvalidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "MigrationTokenInvalidError";
        this.toString = () => "Migration token is invalid or expired.";
      }
    };
    exports2.MigrationTokenInvalidError = MigrationTokenInvalidError;
  }
});
var require_MigrationRequestsAlreadyExistError = __commonJS2({
  "../errors/dist/MigrationRequestsAlreadyExistError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MigrationRequestsAlreadyExistError = void 0;
    var FleekError_1 = require_FleekError();
    var MigrationRequestsAlreadyExistError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "MigrationRequestsAlreadyExistError";
        this.toString = () => `All migration requests specified in token are either completed or in progress.`;
      }
    };
    exports2.MigrationRequestsAlreadyExistError = MigrationRequestsAlreadyExistError;
  }
});
var require_MigrationRequestNotFoundError = __commonJS2({
  "../errors/dist/MigrationRequestNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MigrationRequestNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var MigrationRequestNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "MigrationRequestNotFoundError";
        this.toString = () => `Migration request ${this.data.migrationRequest.id} not found.`;
      }
    };
    exports2.MigrationRequestNotFoundError = MigrationRequestNotFoundError;
  }
});
var require_MigrationRequestInPendingStateError = __commonJS2({
  "../errors/dist/MigrationRequestInPendingStateError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MigrationRequestInPendingStateError = void 0;
    var FleekError_1 = require_FleekError();
    var MigrationRequestInPendingStateError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "MigrationRequestInPendingStateError";
        this.toString = () => "Migration request is in pending state. Please wait and try action again later.";
      }
    };
    exports2.MigrationRequestInPendingStateError = MigrationRequestInPendingStateError;
  }
});
var require_ProjectInvitationAlreadyExistError = __commonJS2({
  "../errors/dist/ProjectInvitationAlreadyExistError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectInvitationAlreadyExistError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectInvitationAlreadyExistError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectInvitationAlreadyExistError";
        this.toString = () => `Project invitation with email ${this.data.user.email} for this project already exist.`;
      }
    };
    exports2.ProjectInvitationAlreadyExistError = ProjectInvitationAlreadyExistError;
  }
});
var require_ProjectMembershipAlreadyExistError = __commonJS2({
  "../errors/dist/ProjectMembershipAlreadyExistError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectMembershipAlreadyExistError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectMembershipAlreadyExistError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectMembershipAlreadyExistError";
        this.toString = () => `Project membership already exists.`;
      }
    };
    exports2.ProjectMembershipAlreadyExistError = ProjectMembershipAlreadyExistError;
  }
});
var require_ProjectMembershipNoOwnersError = __commonJS2({
  "../errors/dist/ProjectMembershipNoOwnersError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectMembershipNoOwnersError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectMembershipNoOwnersError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectMembershipNoOwnersError";
        this.toString = () => `Each project must have at least OWNER-role one membership.`;
      }
    };
    exports2.ProjectMembershipNoOwnersError = ProjectMembershipNoOwnersError;
  }
});
var require_UploadedS3KeyNotFoundError = __commonJS2({
  "../errors/dist/UploadedS3KeyNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UploadedS3KeyNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var UploadedS3KeyNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UploadedS3KeyNotFoundError";
        this.toString = () => "Uploaded S3 Key not found.";
      }
    };
    exports2.UploadedS3KeyNotFoundError = UploadedS3KeyNotFoundError;
  }
});
var require_PathIsNotADirectoryError = __commonJS2({
  "../errors/dist/PathIsNotADirectoryError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathIsNotADirectoryError = void 0;
    var FleekError_1 = require_FleekError();
    var PathIsNotADirectoryError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PathIsNotADirectoryError";
        this.toString = () => {
          return `Given path ${this.data.path} is not a directory.`;
        };
      }
    };
    exports2.PathIsNotADirectoryError = PathIsNotADirectoryError2;
  }
});
var require_FleekFunctionAlreadyExistsError = __commonJS2({
  "../errors/dist/FleekFunctionAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionAlreadyExistsError";
        this.toString = () => {
          if ("name" in this.data.function || "slug" in this.data.function) {
            return `Function ${this.data.function.name || this.data.function.slug} already exists.`;
          }
          return `Unexpected Function data structure ${JSON.stringify(this.data.function)}`;
        };
      }
    };
    exports2.FleekFunctionAlreadyExistsError = FleekFunctionAlreadyExistsError;
  }
});
var require_FleekFunctionNotFoundError = __commonJS2({
  "../errors/dist/FleekFunctionNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionNotFoundError";
        this.toString = () => {
          if (this.data.function?.name) {
            return `Function ${this.data.function.name} not found.`;
          }
          return `Function not found.`;
        };
      }
    };
    exports2.FleekFunctionNotFoundError = FleekFunctionNotFoundError2;
  }
});
var require_FleekFunctionDeploymentNotFoundError = __commonJS2({
  "../errors/dist/FleekFunctionDeploymentNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionDeploymentNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionDeploymentNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionDeploymentNotFoundError";
        this.toString = () => {
          return `Deployment not found.`;
        };
      }
    };
    exports2.FleekFunctionDeploymentNotFoundError = FleekFunctionDeploymentNotFoundError;
  }
});
var require_FleekFunctionsNotFoundError = __commonJS2({
  "../errors/dist/FleekFunctionsNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionsNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionsNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionsNotFoundError";
        this.toString = () => "No functions found.";
      }
    };
    exports2.FleekFunctionsNotFoundError = FleekFunctionsNotFoundError;
  }
});
var require_FleekFunctionPathNotValidError = __commonJS2({
  "../errors/dist/FleekFunctionPathNotValidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionPathNotValidError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionPathNotValidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionPathNotValidError";
        this.toString = () => {
          return `File or folder at path, ${this.data.path} is invalid. Please refer to our documentation for more information on function file conventions.`;
        };
      }
    };
    exports2.FleekFunctionPathNotValidError = FleekFunctionPathNotValidError;
  }
});
var require_FleekFunctionNameNotValidError = __commonJS2({
  "../errors/dist/FleekFunctionNameNotValidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionNameNotValidError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionNameNotValidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionNameNotValidError";
        this.toString = () => {
          return `The name, ${this.data.name}, is invalid`;
        };
      }
    };
    exports2.FleekFunctionNameNotValidError = FleekFunctionNameNotValidError;
  }
});
var require_FleekFunctionStatusNotValidError = __commonJS2({
  "../errors/dist/FleekFunctionStatusNotValidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionStatusNotValidError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionStatusNotValidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionStatusNotValidError";
        this.toString = () => {
          return `The function status is invalid. Must be one of ACTIVE and INACTIVE`;
        };
      }
    };
    exports2.FleekFunctionStatusNotValidError = FleekFunctionStatusNotValidError;
  }
});
var require_FleekFunctionSlugNotValidError = __commonJS2({
  "../errors/dist/FleekFunctionSlugNotValidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionSlugNotValidError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionSlugNotValidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionSlugNotValidError";
        this.toString = () => {
          return `The slug, ${this.data.slug}, is invalid`;
        };
      }
    };
    exports2.FleekFunctionSlugNotValidError = FleekFunctionSlugNotValidError;
  }
});
var require_MaintenanceError = __commonJS2({
  "../errors/dist/MaintenanceError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MaintenanceError = void 0;
    var FleekError_1 = require_FleekError();
    var MaintenanceError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "MaintenanceError";
        this.extensions = {
          http: {
            status: 503
            // Service Unavailable
          }
        };
        this.toString = () => "The platform is under maintenance. Please try again later.";
      }
    };
    exports2.MaintenanceError = MaintenanceError;
  }
});
var require_UserHasNoAccessToFeatureError = __commonJS2({
  "../errors/dist/UserHasNoAccessToFeatureError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserHasNoAccessToFeatureError = void 0;
    var FleekError_1 = require_FleekError();
    var UserHasNoAccessToFeatureError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UserHasNoAccessToFeatureError";
        this.toString = () => `User has no access to this feature.`;
      }
    };
    exports2.UserHasNoAccessToFeatureError = UserHasNoAccessToFeatureError;
  }
});
var require_InvalidCidError = __commonJS2({
  "../errors/dist/InvalidCidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidCidError = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidCidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidCidError";
        this.toString = () => `The cid ${this.data.name} is invalid.`;
      }
    };
    exports2.InvalidCidError = InvalidCidError;
  }
});
var require_ValidationError = __commonJS2({
  "../errors/dist/ValidationError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValidationError = void 0;
    var FleekError_1 = require_FleekError();
    var ValidationError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ValidationError";
        this.toString = () => `${JSON.stringify(this.data)}`;
      }
    };
    exports2.ValidationError = ValidationError;
  }
});
var require_UserInBlocklistError = __commonJS2({
  "../errors/dist/UserInBlocklistError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserInBlocklistError = void 0;
    var FleekError_1 = require_FleekError();
    var UserInBlocklistError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "UserInBlocklistError";
        this.toString = () => "User is in the blocklist.";
      }
    };
    exports2.UserInBlocklistError = UserInBlocklistError;
  }
});
var require_EnsNameContentHashCodecMistmatchError = __commonJS2({
  "../errors/dist/EnsNameContentHashCodecMistmatchError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsNameContentHashCodecMistmatchError = void 0;
    var FleekError_1 = require_FleekError();
    var EnsNameContentHashCodecMistmatchError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnsNameContentHashCodecMistmatchError";
        this.toString = () => {
          return `The content hash does not match or does not corresponds to ${this.data.codec} protocol`;
        };
      }
    };
    exports2.EnsNameContentHashCodecMistmatchError = EnsNameContentHashCodecMistmatchError;
  }
});
var require_EnsNameContentHashUndefinedError = __commonJS2({
  "../errors/dist/EnsNameContentHashUndefinedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsNameContentHashUndefinedError = void 0;
    var FleekError_1 = require_FleekError();
    var EnsNameContentHashUndefinedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnsNameContentHashUndefinedError";
        this.toString = () => {
          return `The content hash for ENS record name "${this.data.ensRecord.name}" is undefined.`;
        };
      }
    };
    exports2.EnsNameContentHashUndefinedError = EnsNameContentHashUndefinedError;
  }
});
var require_DnsConfigAlreadyExistsError = __commonJS2({
  "../errors/dist/DnsConfigAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DnsConfigAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var DnsConfigAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DnsConfigAlreadyExistsError";
        this.toString = () => `DNS config already exists for "${this.data.name}".`;
      }
    };
    exports2.DnsConfigAlreadyExistsError = DnsConfigAlreadyExistsError;
  }
});
var require_DnsConfigNotFoundError = __commonJS2({
  "../errors/dist/DnsConfigNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DnsConfigNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var DnsConfigNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DnsConfigNotFoundError";
        this.toString = () => `DNS config for the "${this.data.name}" name doesn't exist.`;
      }
    };
    exports2.DnsConfigNotFoundError = DnsConfigNotFoundError;
  }
});
var require_TwoFactorSecretKeyFailedToEncryptError = __commonJS2({
  "../errors/dist/TwoFactorSecretKeyFailedToEncryptError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TwoFactorSecretKeyFailedToEncryptError = void 0;
    var FleekError_1 = require_FleekError();
    var TwoFactorSecretKeyFailedToEncryptError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "TwoFactorSecretKeyFailedToEncryptError";
        this.toString = () => "Failed to encrypt 2FA secret key.";
      }
    };
    exports2.TwoFactorSecretKeyFailedToEncryptError = TwoFactorSecretKeyFailedToEncryptError;
  }
});
var require_UserSecretKeyAlreadyExistsError = __commonJS2({
  "../errors/dist/UserSecretKeyAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserSecretKeyAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var UserSecretKeyAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UserSecretKeyAlreadyExistsError";
        this.toString = () => "A secret key for this user already exists.";
      }
    };
    exports2.UserSecretKeyAlreadyExistsError = UserSecretKeyAlreadyExistsError;
  }
});
var require_UserSecretKeyNotFoundError = __commonJS2({
  "../errors/dist/UserSecretKeyNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserSecretKeyNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var UserSecretKeyNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UserSecretKeyNotFoundError";
        this.toString = () => "A secret key for this user not found.";
      }
    };
    exports2.UserSecretKeyNotFoundError = UserSecretKeyNotFoundError;
  }
});
var require_TwoFactorSecretKeyFailedToDecryptError = __commonJS2({
  "../errors/dist/TwoFactorSecretKeyFailedToDecryptError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TwoFactorSecretKeyFailedToDecryptError = void 0;
    var FleekError_1 = require_FleekError();
    var TwoFactorSecretKeyFailedToDecryptError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "TwoFactorSecretKeyFailedToDecryptError";
        this.toString = () => "Failed to decrypt 2FA secret key.";
      }
    };
    exports2.TwoFactorSecretKeyFailedToDecryptError = TwoFactorSecretKeyFailedToDecryptError;
  }
});
var require_RecoveryCodesAlreadyExistsError = __commonJS2({
  "../errors/dist/RecoveryCodesAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecoveryCodesAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var RecoveryCodesAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "RecoveryCodesAlreadyExistsError";
        this.toString = () => "Recovery codes already exists.";
      }
    };
    exports2.RecoveryCodesAlreadyExistsError = RecoveryCodesAlreadyExistsError;
  }
});
var require_WriteFileFromStreamError = __commonJS2({
  "../errors/dist/WriteFileFromStreamError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteFileFromStreamError = void 0;
    var FleekError_1 = require_FleekError();
    var WriteFileFromStreamError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "WriteFileFromStreamError";
        this.toString = () => `There was an error while writing file from stream in globSource`;
      }
    };
    exports2.WriteFileFromStreamError = WriteFileFromStreamError2;
  }
});
var require_InvalidTOTPTokenError = __commonJS2({
  "../errors/dist/InvalidTOTPTokenError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidTOTPTokenError = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidTOTPTokenError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidTOTPTokenError";
        this.toString = () => "TOTP token is invalid.";
      }
    };
    exports2.InvalidTOTPTokenError = InvalidTOTPTokenError;
  }
});
var require_InvalidRecoveryCodeError = __commonJS2({
  "../errors/dist/InvalidRecoveryCodeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidRecoveryCodeError = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidRecoveryCodeError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidRecoveryCodeError";
        this.toString = () => "Recovery code is invalid.";
      }
    };
    exports2.InvalidRecoveryCodeError = InvalidRecoveryCodeError;
  }
});
var require_MissingTwoFactorProtectionCredentialsError = __commonJS2({
  "../errors/dist/MissingTwoFactorProtectionCredentialsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingTwoFactorProtectionCredentialsError = void 0;
    var FleekError_1 = require_FleekError();
    var MissingTwoFactorProtectionCredentialsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "MissingTwoFactorProtectionCredentialsError";
        this.toString = () => "Missing two factor protection credentials. Either a token or a recovery key should be provided.";
      }
    };
    exports2.MissingTwoFactorProtectionCredentialsError = MissingTwoFactorProtectionCredentialsError;
  }
});
var require_DeploymentInProgressError = __commonJS2({
  "../errors/dist/DeploymentInProgressError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeploymentInProgressError = void 0;
    var FleekError_1 = require_FleekError();
    var DeploymentInProgressError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DeploymentInProgressError";
        this.toString = () => "Deployment is already in progress.";
      }
    };
    exports2.DeploymentInProgressError = DeploymentInProgressError;
  }
});
var require_PullzoneNotFoundForZoneIdError = __commonJS2({
  "../errors/dist/PullzoneNotFoundForZoneIdError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PullzoneNotFoundForZoneIdError = void 0;
    var FleekError_1 = require_FleekError();
    var PullzoneNotFoundForZoneIdError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PullzoneNotFoundForZoneIdError";
        this.toString = () => {
          return `The pullzone is not found for zone id: ${this.data.id}`;
        };
      }
    };
    exports2.PullzoneNotFoundForZoneIdError = PullzoneNotFoundForZoneIdError;
  }
});
var require_RecoveryCodeFailedToEncryptError = __commonJS2({
  "../errors/dist/RecoveryCodeFailedToEncryptError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecoveryCodeFailedToEncryptError = void 0;
    var FleekError_1 = require_FleekError();
    var RecoveryCodeFailedToEncryptError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "RecoveryCodeFailedToEncryptError";
        this.toString = () => "Failed to encrypt recovery code.";
      }
    };
    exports2.RecoveryCodeFailedToEncryptError = RecoveryCodeFailedToEncryptError;
  }
});
var require_RecoveryCodeFailedToDecryptError = __commonJS2({
  "../errors/dist/RecoveryCodeFailedToDecryptError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecoveryCodeFailedToDecryptError = void 0;
    var FleekError_1 = require_FleekError();
    var RecoveryCodeFailedToDecryptError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "RecoveryCodeFailedToDecryptError";
        this.toString = () => "Failed to decrypt recovery code.";
      }
    };
    exports2.RecoveryCodeFailedToDecryptError = RecoveryCodeFailedToDecryptError;
  }
});
var require_PermissionGroupNotFoundError = __commonJS2({
  "../errors/dist/PermissionGroupNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PermissionGroupNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var PermissionGroupNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PermissionGroupNotFoundError";
        this.toString = () => "Permission group not found";
      }
    };
    exports2.PermissionGroupNotFoundError = PermissionGroupNotFoundError;
  }
});
var require_PermissionScopeError = __commonJS2({
  "../errors/dist/PermissionScopeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PermissionScopeError = void 0;
    var FleekError_1 = require_FleekError();
    var PermissionScopeError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PermissionScopeError";
        this.toString = () => `Permission scope ${this.data.scope} doesn't exist.`;
      }
    };
    exports2.PermissionScopeError = PermissionScopeError;
  }
});
var require_InvalidAdminAccessTokenError = __commonJS2({
  "../errors/dist/InvalidAdminAccessTokenError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidAdminAccessTokenError = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidAdminAccessTokenError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidAdminAccessTokenError";
        this.toString = () => "Admin access token is invalid.";
      }
    };
    exports2.InvalidAdminAccessTokenError = InvalidAdminAccessTokenError;
  }
});
var require_MissingExpectedDataError = __commonJS2({
  "../errors/dist/MissingExpectedDataError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingExpectedDataError = void 0;
    var FleekError_1 = require_FleekError();
    var MissingExpectedDataError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "MissingExpectedDataError";
        this.toString = () => "Oops! This is embarassing but the app is missing important data. Please report this issue to the team.";
      }
    };
    exports2.MissingExpectedDataError = MissingExpectedDataError;
  }
});
var require_EnvNotSetError = __commonJS2({
  "../errors/dist/EnvNotSetError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnvNotSetError = void 0;
    var FleekError_1 = require_FleekError();
    var EnvNotSetError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnvNotSetError";
        this.toString = () => this.data ? `Environment variable "${this.data}" is not set.` : `Missing the defined object key pair values.`;
      }
    };
    exports2.EnvNotSetError = EnvNotSetError;
  }
});
var require_GitSecretsFailedToEncryptError = __commonJS2({
  "../errors/dist/GitSecretsFailedToEncryptError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitSecretsFailedToEncryptError = void 0;
    var FleekError_1 = require_FleekError();
    var GitSecretsFailedToEncryptError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitSecretsFailedToEncryptError";
        this.toString = () => "Failed to encrypt Git Secrets.";
      }
    };
    exports2.GitSecretsFailedToEncryptError = GitSecretsFailedToEncryptError;
  }
});
var require_GitConfigFailedToParseError = __commonJS2({
  "../errors/dist/GitConfigFailedToParseError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitConfigFailedToParseError = void 0;
    var FleekError_1 = require_FleekError();
    var GitConfigFailedToParseError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitSecretsFailedToEncryptError";
        this.toString = () => "Failed to parse Git Configs.";
      }
    };
    exports2.GitConfigFailedToParseError = GitConfigFailedToParseError;
  }
});
var require_PathIsNotAFileError = __commonJS2({
  "../errors/dist/PathIsNotAFileError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathIsNotAFileError = void 0;
    var FleekError_1 = require_FleekError();
    var PathIsNotAFileError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PathIsNotAFileError";
        this.toString = () => {
          return `Given path ${this.data.path} is not a file.`;
        };
      }
    };
    exports2.PathIsNotAFileError = PathIsNotAFileError2;
  }
});
var require_FleekFunctionBundlingFailedError = __commonJS2({
  "../errors/dist/FleekFunctionBundlingFailedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionBundlingFailedError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionBundlingFailedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionBundlingFailedError";
        this.toString = () => {
          return `Bundle creation failed. For information on supported packages, please consult our documentation.
Error: ${this.data.error}`;
        };
      }
    };
    exports2.FleekFunctionBundlingFailedError = FleekFunctionBundlingFailedError;
  }
});
var require_GitIntegrationNotFoundError = __commonJS2({
  "../errors/dist/GitIntegrationNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitIntegrationNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var GitIntegrationNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitIntegrationNotFoundError";
        this.toString = () => {
          let infix = "";
          if ("siteId" in this.data) {
            infix = `for site ${this.data.siteId}`;
          } else if ("id" in this.data) {
            infix = `with id ${this.data.id}`;
          }
          return `Git Integration ${infix} not found`;
        };
      }
    };
    exports2.GitIntegrationNotFoundError = GitIntegrationNotFoundError;
  }
});
var require_GitProviderNotFoundError = __commonJS2({
  "../errors/dist/GitProviderNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitProviderNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var GitProviderNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitProviderNotFoundError";
        this.toString = () => {
          return `No Git Provider found with id: ${this.data.providerId}`;
        };
      }
    };
    exports2.GitProviderNotFoundError = GitProviderNotFoundError;
  }
});
var require_ExpectedOneOfValuesError = __commonJS2({
  "../errors/dist/ExpectedOneOfValuesError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExpectedOneOfValuesError = void 0;
    var FleekError_1 = require_FleekError();
    var ExpectedOneOfValuesError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ExpectedOneOfValuesError";
        this.toString = () => `Expected one of ${this.data.expectedValues.join(", ")} but got ${this.data.receivedValue}`;
      }
    };
    exports2.ExpectedOneOfValuesError = ExpectedOneOfValuesError;
  }
});
var require_InvalidJSONFormat = __commonJS2({
  "../errors/dist/InvalidJSONFormat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidJSONFormat = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidJSONFormat = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidJSONFormat";
        this.toString = () => `Invalid JSON format.`;
      }
    };
    exports2.InvalidJSONFormat = InvalidJSONFormat;
  }
});
var require_StorageUploadFileCountQuotaExceededError = __commonJS2({
  "../errors/dist/StorageUploadFileCountQuotaExceededError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StorageUploadFileCountQuotaExceededError = void 0;
    var FleekError_1 = require_FleekError();
    var StorageUploadFileCountQuotaExceededError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "StorageUploadFileCountQuotaExceededError";
        this.toString = () => `You have exceeded your storage upload quota for total number of files for the last 24 hours.`;
      }
    };
    exports2.StorageUploadFileCountQuotaExceededError = StorageUploadFileCountQuotaExceededError2;
  }
});
var require_StorageUploadTotalSizeQuotaExceededError = __commonJS2({
  "../errors/dist/StorageUploadTotalSizeQuotaExceededError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StorageUploadTotalSizeQuotaExceededError = void 0;
    var FleekError_1 = require_FleekError();
    var StorageUploadTotalSizeQuotaExceededError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "StorageUploadTotalSizeQuotaExceededError";
        this.toString = () => `You have exceeded your storage upload quota for total size for the last 24 hours.`;
      }
    };
    exports2.StorageUploadTotalSizeQuotaExceededError = StorageUploadTotalSizeQuotaExceededError2;
  }
});
var require_GitProviderNotSupportedError = __commonJS2({
  "../errors/dist/GitProviderNotSupportedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitProviderNotSupportedError = void 0;
    var FleekError_1 = require_FleekError();
    var GitProviderNotSupportedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitProviderNotSupportedError";
        this.toString = () => `Git provider: ${this.data.provider} not Supported`;
      }
    };
    exports2.GitProviderNotSupportedError = GitProviderNotSupportedError;
  }
});
var require_GitProviderNotAuthorizedError = __commonJS2({
  "../errors/dist/GitProviderNotAuthorizedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitProviderNotAuthorizedError = void 0;
    var FleekError_1 = require_FleekError();
    var GitProviderNotAuthorizedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitProviderNotAuthorizedError";
        this.toString = () => `The user has not authorized the Git provider: ${this.data.provider}`;
      }
    };
    exports2.GitProviderNotAuthorizedError = GitProviderNotAuthorizedError;
  }
});
var require_GitAccessTokenInvalidError = __commonJS2({
  "../errors/dist/GitAccessTokenInvalidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitAccessTokenInvalidError = void 0;
    var FleekError_1 = require_FleekError();
    var GitAccessTokenInvalidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitAccessTokenInvalidError";
        this.toString = () => {
          return "The git access token for the user is invalid";
        };
      }
    };
    exports2.GitAccessTokenInvalidError = GitAccessTokenInvalidError;
  }
});
var require_QueuedDeploymentsLimitError = __commonJS2({
  "../errors/dist/QueuedDeploymentsLimitError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueuedDeploymentsLimitError = void 0;
    var FleekError_1 = require_FleekError();
    var QueuedDeploymentsLimitError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "QueuedDeploymentsLimitError";
        this.toString = () => `You've reached the limit of ${this.data.limit} queued deployments.`;
      }
    };
    exports2.QueuedDeploymentsLimitError = QueuedDeploymentsLimitError;
  }
});
var require_GitIntegrationInstallationConflictError = __commonJS2({
  "../errors/dist/GitIntegrationInstallationConflictError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitIntegrationInstallationConflictError = void 0;
    var FleekError_1 = require_FleekError();
    var GitIntegrationInstallationConflictError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitIntegrationInstallationConflictError";
        this.toString = () => `The Git Integration installation for this provider already exists in this project`;
      }
    };
    exports2.GitIntegrationInstallationConflictError = GitIntegrationInstallationConflictError;
  }
});
var require_GitLinkMultipleAccountError = __commonJS2({
  "../errors/dist/GitLinkMultipleAccountError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitLinkMultipleAccountError = void 0;
    var FleekError_1 = require_FleekError();
    var GitLinkMultipleAccountError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitLinkMultipleAccountError";
        this.toString = () => `Oops! You already have a Git profile linked to your Fleek account. We don't allow multiple connections`;
      }
    };
    exports2.GitLinkMultipleAccountError = GitLinkMultipleAccountError;
  }
});
var require_GitRepoByNameAndOwnerNotFoundError = __commonJS2({
  "../errors/dist/GitRepoByNameAndOwnerNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitRepoByNameAndOwnerNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var GitRepoByNameAndOwnerNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitRepoByNameAndOwnerNotFoundError";
        this.toString = () => `Git repo "${this.data.owner}/${this.data.repo}" not found`;
      }
    };
    exports2.GitRepoByNameAndOwnerNotFoundError = GitRepoByNameAndOwnerNotFoundError;
  }
});
var require_GitAccessTokenNotFoundError = __commonJS2({
  "../errors/dist/GitAccessTokenNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitAccessTokenNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var GitAccessTokenNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitAccessTokenNotFoundError";
        this.toString = () => {
          return "The git access token for the user is not found";
        };
      }
    };
    exports2.GitAccessTokenNotFoundError = GitAccessTokenNotFoundError;
  }
});
var require_FolderNotFoundError = __commonJS2({
  "../errors/dist/FolderNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FolderNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var FolderNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FolderNotFoundError";
        this.toString = () => `Folder was not found.`;
      }
    };
    exports2.FolderNotFoundError = FolderNotFoundError2;
  }
});
var require_FolderAlreadyExistsError = __commonJS2({
  "../errors/dist/FolderAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FolderAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var FolderAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FolderAlreadyExistsError";
        this.toString = () => `Folder ${this.data.folder.name} already exists in ${this.data.folder.parentFolderId ? "parent" : "root project"} folder.`;
      }
    };
    exports2.FolderAlreadyExistsError = FolderAlreadyExistsError;
  }
});
var require_PinsNotFoundError = __commonJS2({
  "../errors/dist/PinsNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PinsNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var PinsNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PinsNotFoundError";
        this.toString = () => {
          return "No pins found.";
        };
      }
    };
    exports2.PinsNotFoundError = PinsNotFoundError2;
  }
});
var require_SiteCreationFailedError = __commonJS2({
  "../errors/dist/SiteCreationFailedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteCreationFailedError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteCreationFailedError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "SiteCreationFailedError";
        this.toString = () => `Site creation failed.`;
      }
    };
    exports2.SiteCreationFailedError = SiteCreationFailedError2;
  }
});
var require_FleekFunctionInvalidWasmCodeError = __commonJS2({
  "../errors/dist/FleekFunctionInvalidWasmCodeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionInvalidWasmCodeError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionInvalidWasmCodeError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionInvalidWasmCodeError";
        this.toString = () => {
          return `Fleek function encountered corrupt or invalid WASM code.`;
        };
      }
    };
    exports2.FleekFunctionInvalidWasmCodeError = FleekFunctionInvalidWasmCodeError;
  }
});
var require_FleekFunctionWasmEncryptionFailedError = __commonJS2({
  "../errors/dist/FleekFunctionWasmEncryptionFailedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionWasmEncryptionFailedError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionWasmEncryptionFailedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionWasmEncryptionFailedError";
        this.toString = () => {
          return `Unable to encrypt WASM code for Fleek function`;
        };
      }
    };
    exports2.FleekFunctionWasmEncryptionFailedError = FleekFunctionWasmEncryptionFailedError;
  }
});
var require_UploadProxyStoreAsCarError = __commonJS2({
  "../errors/dist/UploadProxyStoreAsCarError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UploadProxyStoreAsCarError = void 0;
    var FleekError_1 = require_FleekError();
    var UploadProxyStoreAsCarError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "UploadProxyStoreAsCarError";
        this.toString = () => `Failed to Store as a CAR file.`;
      }
    };
    exports2.UploadProxyStoreAsCarError = UploadProxyStoreAsCarError2;
  }
});
var require_UploadProxyUploadFileError = __commonJS2({
  "../errors/dist/UploadProxyUploadFileError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UploadProxyUploadFileError = void 0;
    var FleekError_1 = require_FleekError();
    var UploadProxyUploadFileError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "UploadProxyUploadFileError";
        this.toString = () => `Failed to Upload file.`;
      }
    };
    exports2.UploadProxyUploadFileError = UploadProxyUploadFileError2;
  }
});
var require_dist2 = __commonJS2({
  "../errors/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsRecordInPendingStateError = exports2.EnsNameInvalidError = exports2.EnsRecordAlreadyExistsInProjectError = exports2.EnsRecordNotFoundError = exports2.ApplicationNameInvalidError = exports2.ApplicationNotFoundError = exports2.ApplicationsNotFoundError = exports2.ApplicationAlreadyExistsError = exports2.ApplicationWhitelistDomainDuplicityError = exports2.FleekConfigMissingFileError = exports2.FleekConfigInvalidContentError = exports2.UnauthorizedError = exports2.DomainZoneInvalidTypeError = exports2.DomainNotFoundUnderPullzoneError = exports2.DomainZoneInPendingStateError = exports2.DomainZoneHasDependentsError = exports2.DomainZoneNotFoundError = exports2.UnauthenticatedError = exports2.VerificationSessionAlreadyExistsError = exports2.PublicKeyAlreadyExistsError = exports2.ProjectInvalidNameError = exports2.ProjectHasDependentsError = exports2.ProjectsNotFoundError = exports2.ProjectNotFoundError = exports2.UserAlreadyExistsError = exports2.UserNotFoundError = exports2.GithubAppInstallationNotFoundError = exports2.ProjectMembershipNotFoundError = exports2.AuthorizationError = exports2.SdkRequiredNodeRuntimeError = exports2.StorageIpfsUploadFailedError = exports2.IpnsRecordsForSiteLimitError = exports2.IpnsFailToDecryptKeyError = exports2.IpnsRecordsNotFoundError = exports2.IpnsRecordNotFoundError = exports2.SiteNotDeployedError = exports2.SiteHasNoSourceProviderError = exports2.SiteHasDependentsError = exports2.SiteDeploymentNotFoundError = exports2.SiteAlreadyExistsError = exports2.SitesNotFoundError = exports2.SiteNotFoundError = exports2.UnknownError = exports2.DomainHostnameInvalidError = exports2.DomainInPendingStateError = exports2.DomainAlreadyExistsInProjectError = exports2.DomainsNotFoundError = exports2.DomainNotFoundError = exports2.BunnyPullZoneNotFoundError = exports2.FleekError = void 0;
    exports2.EnsNameContentHashUndefinedError = exports2.EnsNameContentHashCodecMistmatchError = exports2.UserInBlocklistError = exports2.ValidationError = exports2.InvalidCidError = exports2.UserHasNoAccessToFeatureError = exports2.MaintenanceError = exports2.FleekFunctionSlugNotValidError = exports2.FleekFunctionStatusNotValidError = exports2.FleekFunctionNameNotValidError = exports2.FleekFunctionPathNotValidError = exports2.FleekFunctionsNotFoundError = exports2.FleekFunctionDeploymentNotFoundError = exports2.FleekFunctionNotFoundError = exports2.FleekFunctionAlreadyExistsError = exports2.PathIsNotADirectoryError = exports2.UploadedS3KeyNotFoundError = exports2.ProjectMembershipNoOwnersError = exports2.ProjectMembershipAlreadyExistError = exports2.ProjectInvitationAlreadyExistError = exports2.MigrationRequestInPendingStateError = exports2.MigrationRequestNotFoundError = exports2.MigrationRequestsAlreadyExistError = exports2.MigrationTokenInvalidError = exports2.InvitationNotFoundError = exports2.IpfsGatewayContentUnreachableError = exports2.InvalidDeploymentTriggerError = exports2.SiteDeploymentNotReleasedError = exports2.UnstoppableDeploymentError = exports2.PinAlreadyExistsInProjectError = exports2.PinNotFoundError = exports2.SecretFailToEncryptError = exports2.SecretKeyAlreadyExistsError = exports2.SecretVisibilityAlreadyEncryptedError = exports2.SecretNotFoundError = exports2.SecretGroupNotFoundError = exports2.ProjectMembershipHasInefficientRoleError = exports2.TemplateDeploymentNotFoundError = exports2.TemplateCategoryNotFoundError = exports2.SiteFrameworkNotFoundError = exports2.SiteFrameworkAlreadyExistsError = exports2.UserHasNoAccessToAnotherUserError = exports2.TemplateNotFoundError = exports2.TemplateAlreadyExistsError = exports2.PrivateGatewaysNotFoundError = exports2.PrivateGatewayNameInvalidError = exports2.PrivateGatewayAlreadyExistsError = exports2.PrivateGatewayNotFoundError = exports2.PersonalAccessTokenNotFoundError = exports2.InvalidPersonalAccessTokenError = void 0;
    exports2.UploadProxyUploadFileError = exports2.UploadProxyStoreAsCarError = exports2.FleekFunctionWasmEncryptionFailedError = exports2.FleekFunctionInvalidWasmCodeError = exports2.SiteCreationFailedError = exports2.PinsNotFoundError = exports2.FolderAlreadyExistsError = exports2.FolderNotFoundError = exports2.GitAccessTokenNotFoundError = exports2.GitRepoByNameAndOwnerNotFoundError = exports2.GitLinkMultipleAccountError = exports2.GitIntegrationInstallationConflictError = exports2.QueuedDeploymentsLimitError = exports2.GitAccessTokenInvalidError = exports2.GitProviderNotAuthorizedError = exports2.GitProviderNotSupportedError = exports2.StorageUploadTotalSizeQuotaExceededError = exports2.StorageUploadFileCountQuotaExceededError = exports2.InvalidJSONFormat = exports2.ExpectedOneOfValuesError = exports2.GitProviderNotFoundError = exports2.GitIntegrationNotFoundError = exports2.FleekFunctionBundlingFailedError = exports2.PathIsNotAFileError = exports2.GitConfigFailedToParseError = exports2.GitSecretsFailedToEncryptError = exports2.EnvNotSetError = exports2.MissingExpectedDataError = exports2.InvalidAdminAccessTokenError = exports2.PermissionScopeError = exports2.PermissionGroupNotFoundError = exports2.RecoveryCodeFailedToDecryptError = exports2.RecoveryCodeFailedToEncryptError = exports2.PullzoneNotFoundForZoneIdError = exports2.DeploymentInProgressError = exports2.MissingTwoFactorProtectionCredentialsError = exports2.InvalidRecoveryCodeError = exports2.InvalidTOTPTokenError = exports2.WriteFileFromStreamError = exports2.RecoveryCodesAlreadyExistsError = exports2.TwoFactorSecretKeyFailedToDecryptError = exports2.UserSecretKeyNotFoundError = exports2.UserSecretKeyAlreadyExistsError = exports2.TwoFactorSecretKeyFailedToEncryptError = exports2.DnsConfigNotFoundError = exports2.DnsConfigAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    Object.defineProperty(exports2, "FleekError", { enumerable: true, get: function() {
      return FleekError_1.FleekError;
    } });
    var BunnyPullZoneNotFoundError_1 = require_BunnyPullZoneNotFoundError();
    Object.defineProperty(exports2, "BunnyPullZoneNotFoundError", { enumerable: true, get: function() {
      return BunnyPullZoneNotFoundError_1.BunnyPullZoneNotFoundError;
    } });
    var DomainNotFoundError_1 = require_DomainNotFoundError();
    Object.defineProperty(exports2, "DomainNotFoundError", { enumerable: true, get: function() {
      return DomainNotFoundError_1.DomainNotFoundError;
    } });
    var DomainsNotFoundError_1 = require_DomainsNotFoundError();
    Object.defineProperty(exports2, "DomainsNotFoundError", { enumerable: true, get: function() {
      return DomainsNotFoundError_1.DomainsNotFoundError;
    } });
    var DomainAlreadyExistsInProjectError_1 = require_DomainAlreadyExistsInProjectError();
    Object.defineProperty(exports2, "DomainAlreadyExistsInProjectError", { enumerable: true, get: function() {
      return DomainAlreadyExistsInProjectError_1.DomainAlreadyExistsInProjectError;
    } });
    var DomainInPendingStateError_1 = require_DomainInPendingStateError();
    Object.defineProperty(exports2, "DomainInPendingStateError", { enumerable: true, get: function() {
      return DomainInPendingStateError_1.DomainInPendingStateError;
    } });
    var DomainHostnameInvalidError_1 = require_DomainHostnameInvalidError();
    Object.defineProperty(exports2, "DomainHostnameInvalidError", { enumerable: true, get: function() {
      return DomainHostnameInvalidError_1.DomainHostnameInvalidError;
    } });
    var UnknownError_1 = require_UnknownError();
    Object.defineProperty(exports2, "UnknownError", { enumerable: true, get: function() {
      return UnknownError_1.UnknownError;
    } });
    var SiteNotFoundError_1 = require_SiteNotFoundError();
    Object.defineProperty(exports2, "SiteNotFoundError", { enumerable: true, get: function() {
      return SiteNotFoundError_1.SiteNotFoundError;
    } });
    var SitesNotFoundError_1 = require_SitesNotFoundError();
    Object.defineProperty(exports2, "SitesNotFoundError", { enumerable: true, get: function() {
      return SitesNotFoundError_1.SitesNotFoundError;
    } });
    var SiteAlreadyExistsError_1 = require_SiteAlreadyExistsError();
    Object.defineProperty(exports2, "SiteAlreadyExistsError", { enumerable: true, get: function() {
      return SiteAlreadyExistsError_1.SiteAlreadyExistsError;
    } });
    var SiteDeploymentNotFoundError_1 = require_SiteDeploymentNotFoundError();
    Object.defineProperty(exports2, "SiteDeploymentNotFoundError", { enumerable: true, get: function() {
      return SiteDeploymentNotFoundError_1.SiteDeploymentNotFoundError;
    } });
    var SiteHasDependentsError_1 = require_SiteHasDependentsError();
    Object.defineProperty(exports2, "SiteHasDependentsError", { enumerable: true, get: function() {
      return SiteHasDependentsError_1.SiteHasDependentsError;
    } });
    var SiteHasNoSourceProviderError_1 = require_SiteHasNoSourceProviderError();
    Object.defineProperty(exports2, "SiteHasNoSourceProviderError", { enumerable: true, get: function() {
      return SiteHasNoSourceProviderError_1.SiteHasNoSourceProviderError;
    } });
    var SiteNotDeployedError_1 = require_SiteNotDeployedError();
    Object.defineProperty(exports2, "SiteNotDeployedError", { enumerable: true, get: function() {
      return SiteNotDeployedError_1.SiteNotDeployedError;
    } });
    var IpnsRecordNotFoundError_1 = require_IpnsRecordNotFoundError();
    Object.defineProperty(exports2, "IpnsRecordNotFoundError", { enumerable: true, get: function() {
      return IpnsRecordNotFoundError_1.IpnsRecordNotFoundError;
    } });
    var IpnsRecordsNotFoundError_1 = require_IpnsRecordsNotFoundError();
    Object.defineProperty(exports2, "IpnsRecordsNotFoundError", { enumerable: true, get: function() {
      return IpnsRecordsNotFoundError_1.IpnsRecordsNotFoundError;
    } });
    var IpnsFailToDecryptKeyError_1 = require_IpnsFailToDecryptKeyError();
    Object.defineProperty(exports2, "IpnsFailToDecryptKeyError", { enumerable: true, get: function() {
      return IpnsFailToDecryptKeyError_1.IpnsFailToDecryptKeyError;
    } });
    var IpnsRecordsForSiteLimitError_1 = require_IpnsRecordsForSiteLimitError();
    Object.defineProperty(exports2, "IpnsRecordsForSiteLimitError", { enumerable: true, get: function() {
      return IpnsRecordsForSiteLimitError_1.IpnsRecordsForSiteLimitError;
    } });
    var StorageIpfsUploadFailedError_1 = require_StorageIpfsUploadFailedError();
    Object.defineProperty(exports2, "StorageIpfsUploadFailedError", { enumerable: true, get: function() {
      return StorageIpfsUploadFailedError_1.StorageIpfsUploadFailedError;
    } });
    var SdkRequiredNodeRuntimeError_1 = require_SdkRequiredNodeRuntimeError();
    Object.defineProperty(exports2, "SdkRequiredNodeRuntimeError", { enumerable: true, get: function() {
      return SdkRequiredNodeRuntimeError_1.SdkRequiredNodeRuntimeError;
    } });
    var AuthorizationError_1 = require_AuthorizationError();
    Object.defineProperty(exports2, "AuthorizationError", { enumerable: true, get: function() {
      return AuthorizationError_1.AuthorizationError;
    } });
    var ProjectMembershipNotFoundError_1 = require_ProjectMembershipNotFoundError();
    Object.defineProperty(exports2, "ProjectMembershipNotFoundError", { enumerable: true, get: function() {
      return ProjectMembershipNotFoundError_1.ProjectMembershipNotFoundError;
    } });
    var GithubAppInstallationNotFoundError_1 = require_GithubAppInstallationNotFoundError();
    Object.defineProperty(exports2, "GithubAppInstallationNotFoundError", { enumerable: true, get: function() {
      return GithubAppInstallationNotFoundError_1.GithubAppInstallationNotFoundError;
    } });
    var UserNotFoundError_1 = require_UserNotFoundError();
    Object.defineProperty(exports2, "UserNotFoundError", { enumerable: true, get: function() {
      return UserNotFoundError_1.UserNotFoundError;
    } });
    var UserAlreadyExistsError_1 = require_UserAlreadyExistsError();
    Object.defineProperty(exports2, "UserAlreadyExistsError", { enumerable: true, get: function() {
      return UserAlreadyExistsError_1.UserAlreadyExistsError;
    } });
    var ProjectNotFoundError_1 = require_ProjectNotFoundError();
    Object.defineProperty(exports2, "ProjectNotFoundError", { enumerable: true, get: function() {
      return ProjectNotFoundError_1.ProjectNotFoundError;
    } });
    var ProjectsNotFoundError_1 = require_ProjectsNotFoundError();
    Object.defineProperty(exports2, "ProjectsNotFoundError", { enumerable: true, get: function() {
      return ProjectsNotFoundError_1.ProjectsNotFoundError;
    } });
    var ProjectHasDependentsError_1 = require_ProjectHasDependentsError();
    Object.defineProperty(exports2, "ProjectHasDependentsError", { enumerable: true, get: function() {
      return ProjectHasDependentsError_1.ProjectHasDependentsError;
    } });
    var ProjectInvalidNameError_1 = require_ProjectInvalidNameError();
    Object.defineProperty(exports2, "ProjectInvalidNameError", { enumerable: true, get: function() {
      return ProjectInvalidNameError_1.ProjectInvalidNameError;
    } });
    var PublicKeyAlreadyExistsError_1 = require_PublicKeyAlreadyExistsError();
    Object.defineProperty(exports2, "PublicKeyAlreadyExistsError", { enumerable: true, get: function() {
      return PublicKeyAlreadyExistsError_1.PublicKeyAlreadyExistsError;
    } });
    var VerificationSessionAlreadyExistsError_1 = require_VerificationSessionAlreadyExistsError();
    Object.defineProperty(exports2, "VerificationSessionAlreadyExistsError", { enumerable: true, get: function() {
      return VerificationSessionAlreadyExistsError_1.VerificationSessionAlreadyExistsError;
    } });
    var UnauthenticatedError_1 = require_UnauthenticatedError();
    Object.defineProperty(exports2, "UnauthenticatedError", { enumerable: true, get: function() {
      return UnauthenticatedError_1.UnauthenticatedError;
    } });
    var DomainZoneNotFoundError_1 = require_DomainZoneNotFoundError();
    Object.defineProperty(exports2, "DomainZoneNotFoundError", { enumerable: true, get: function() {
      return DomainZoneNotFoundError_1.DomainZoneNotFoundError;
    } });
    var DomainZoneHasDependentsError_1 = require_DomainZoneHasDependentsError();
    Object.defineProperty(exports2, "DomainZoneHasDependentsError", { enumerable: true, get: function() {
      return DomainZoneHasDependentsError_1.DomainZoneHasDependentsError;
    } });
    var DomainZoneInPendingStateError_1 = require_DomainZoneInPendingStateError();
    Object.defineProperty(exports2, "DomainZoneInPendingStateError", { enumerable: true, get: function() {
      return DomainZoneInPendingStateError_1.DomainZoneInPendingStateError;
    } });
    var DomainNotFoundUnderPullzoneError_1 = require_DomainNotFoundUnderPullzoneError();
    Object.defineProperty(exports2, "DomainNotFoundUnderPullzoneError", { enumerable: true, get: function() {
      return DomainNotFoundUnderPullzoneError_1.DomainNotFoundUnderPullzoneError;
    } });
    var DomainZoneInvalidTypeError_1 = require_DomainZoneInvalidTypeError();
    Object.defineProperty(exports2, "DomainZoneInvalidTypeError", { enumerable: true, get: function() {
      return DomainZoneInvalidTypeError_1.DomainZoneInvalidTypeError;
    } });
    var UnauthorizedError_1 = require_UnauthorizedError();
    Object.defineProperty(exports2, "UnauthorizedError", { enumerable: true, get: function() {
      return UnauthorizedError_1.UnauthorizedError;
    } });
    var FleekConfigInvalidContentError_1 = require_FleekConfigInvalidContentError();
    Object.defineProperty(exports2, "FleekConfigInvalidContentError", { enumerable: true, get: function() {
      return FleekConfigInvalidContentError_1.FleekConfigInvalidContentError;
    } });
    var FleekConfigMissingFileError_1 = require_FleekConfigMissingFileError();
    Object.defineProperty(exports2, "FleekConfigMissingFileError", { enumerable: true, get: function() {
      return FleekConfigMissingFileError_1.FleekConfigMissingFileError;
    } });
    var ApplicationWhitelistDomainDuplicityError_1 = require_ApplicationWhitelistDomainDuplicityError();
    Object.defineProperty(exports2, "ApplicationWhitelistDomainDuplicityError", { enumerable: true, get: function() {
      return ApplicationWhitelistDomainDuplicityError_1.ApplicationWhitelistDomainDuplicityError;
    } });
    var ApplicationAlreadyExistsError_1 = require_ApplicationAlreadyExistsError();
    Object.defineProperty(exports2, "ApplicationAlreadyExistsError", { enumerable: true, get: function() {
      return ApplicationAlreadyExistsError_1.ApplicationAlreadyExistsError;
    } });
    var ApplicationsNotFoundError_1 = require_ApplicationsNotFoundError();
    Object.defineProperty(exports2, "ApplicationsNotFoundError", { enumerable: true, get: function() {
      return ApplicationsNotFoundError_1.ApplicationsNotFoundError;
    } });
    var ApplicationNotFoundError_1 = require_ApplicationNotFoundError();
    Object.defineProperty(exports2, "ApplicationNotFoundError", { enumerable: true, get: function() {
      return ApplicationNotFoundError_1.ApplicationNotFoundError;
    } });
    var ApplicationNameInvalidError_1 = require_ApplicationNameInvalidError();
    Object.defineProperty(exports2, "ApplicationNameInvalidError", { enumerable: true, get: function() {
      return ApplicationNameInvalidError_1.ApplicationNameInvalidError;
    } });
    var EnsRecordNotFoundError_1 = require_EnsRecordNotFoundError();
    Object.defineProperty(exports2, "EnsRecordNotFoundError", { enumerable: true, get: function() {
      return EnsRecordNotFoundError_1.EnsRecordNotFoundError;
    } });
    var EnsRecordAlreadyExistsInProjectError_1 = require_EnsRecordAlreadyExistsInProjectError();
    Object.defineProperty(exports2, "EnsRecordAlreadyExistsInProjectError", { enumerable: true, get: function() {
      return EnsRecordAlreadyExistsInProjectError_1.EnsRecordAlreadyExistsInProjectError;
    } });
    var EnsNameInvalidError_1 = require_EnsNameInvalidError();
    Object.defineProperty(exports2, "EnsNameInvalidError", { enumerable: true, get: function() {
      return EnsNameInvalidError_1.EnsNameInvalidError;
    } });
    var EnsRecordInPendingStateError_1 = require_EnsRecordInPendingStateError();
    Object.defineProperty(exports2, "EnsRecordInPendingStateError", { enumerable: true, get: function() {
      return EnsRecordInPendingStateError_1.EnsRecordInPendingStateError;
    } });
    var InvalidPersonalAccessTokenError_1 = require_InvalidPersonalAccessTokenError();
    Object.defineProperty(exports2, "InvalidPersonalAccessTokenError", { enumerable: true, get: function() {
      return InvalidPersonalAccessTokenError_1.InvalidPersonalAccessTokenError;
    } });
    var PersonalAccessTokenNotFoundError_1 = require_PersonalAccessTokenNotFoundError();
    Object.defineProperty(exports2, "PersonalAccessTokenNotFoundError", { enumerable: true, get: function() {
      return PersonalAccessTokenNotFoundError_1.PersonalAccessTokenNotFoundError;
    } });
    var PrivateGatewayNotFoundError_1 = require_PrivateGatewayNotFoundError();
    Object.defineProperty(exports2, "PrivateGatewayNotFoundError", { enumerable: true, get: function() {
      return PrivateGatewayNotFoundError_1.PrivateGatewayNotFoundError;
    } });
    var PrivateGatewayAlreadyExistsError_1 = require_PrivateGatewayAlreadyExistsError();
    Object.defineProperty(exports2, "PrivateGatewayAlreadyExistsError", { enumerable: true, get: function() {
      return PrivateGatewayAlreadyExistsError_1.PrivateGatewayAlreadyExistsError;
    } });
    var PrivateGatewayNameInvalidError_1 = require_PrivateGatewayNameInvalidError();
    Object.defineProperty(exports2, "PrivateGatewayNameInvalidError", { enumerable: true, get: function() {
      return PrivateGatewayNameInvalidError_1.PrivateGatewayNameInvalidError;
    } });
    var PrivateGatewaysNotFoundError_1 = require_PrivateGatewaysNotFoundError();
    Object.defineProperty(exports2, "PrivateGatewaysNotFoundError", { enumerable: true, get: function() {
      return PrivateGatewaysNotFoundError_1.PrivateGatewaysNotFoundError;
    } });
    var TemplateAlreadyExistsError_1 = require_TemplateAlreadyExistsError();
    Object.defineProperty(exports2, "TemplateAlreadyExistsError", { enumerable: true, get: function() {
      return TemplateAlreadyExistsError_1.TemplateAlreadyExistsError;
    } });
    var TemplateNotFoundError_1 = require_TemplateNotFoundError();
    Object.defineProperty(exports2, "TemplateNotFoundError", { enumerable: true, get: function() {
      return TemplateNotFoundError_1.TemplateNotFoundError;
    } });
    var UserHasNoAccessToAnotherUserError_1 = require_UserHasNoAccessToAnotherUserError();
    Object.defineProperty(exports2, "UserHasNoAccessToAnotherUserError", { enumerable: true, get: function() {
      return UserHasNoAccessToAnotherUserError_1.UserHasNoAccessToAnotherUserError;
    } });
    var SiteFrameworkAlreadyExistsError_1 = require_SiteFrameworkAlreadyExistsError();
    Object.defineProperty(exports2, "SiteFrameworkAlreadyExistsError", { enumerable: true, get: function() {
      return SiteFrameworkAlreadyExistsError_1.SiteFrameworkAlreadyExistsError;
    } });
    var SiteFrameworkNotFoundError_1 = require_SiteFrameworkNotFoundError();
    Object.defineProperty(exports2, "SiteFrameworkNotFoundError", { enumerable: true, get: function() {
      return SiteFrameworkNotFoundError_1.SiteFrameworkNotFoundError;
    } });
    var TemplateCategoryNotFoundError_1 = require_TemplateCategoryNotFoundError();
    Object.defineProperty(exports2, "TemplateCategoryNotFoundError", { enumerable: true, get: function() {
      return TemplateCategoryNotFoundError_1.TemplateCategoryNotFoundError;
    } });
    var TemplateDeploymentNotFoundError_1 = require_TemplateDeploymentNotFoundError();
    Object.defineProperty(exports2, "TemplateDeploymentNotFoundError", { enumerable: true, get: function() {
      return TemplateDeploymentNotFoundError_1.TemplateDeploymentNotFoundError;
    } });
    var ProjectMembershipHasInefficientRoleError_1 = require_ProjectMembershipHasInefficientRoleError();
    Object.defineProperty(exports2, "ProjectMembershipHasInefficientRoleError", { enumerable: true, get: function() {
      return ProjectMembershipHasInefficientRoleError_1.ProjectMembershipHasInefficientRoleError;
    } });
    var SecretGroupNotFoundError_1 = require_SecretGroupNotFoundError();
    Object.defineProperty(exports2, "SecretGroupNotFoundError", { enumerable: true, get: function() {
      return SecretGroupNotFoundError_1.SecretGroupNotFoundError;
    } });
    var SecretNotFoundError_1 = require_SecretNotFoundError();
    Object.defineProperty(exports2, "SecretNotFoundError", { enumerable: true, get: function() {
      return SecretNotFoundError_1.SecretNotFoundError;
    } });
    var SecretVisibilityAlreadyEncryptedError_1 = require_SecretVisibilityAlreadyEncryptedError();
    Object.defineProperty(exports2, "SecretVisibilityAlreadyEncryptedError", { enumerable: true, get: function() {
      return SecretVisibilityAlreadyEncryptedError_1.SecretVisibilityAlreadyEncryptedError;
    } });
    var SecretKeyAlreadyExistsError_1 = require_SecretKeyAlreadyExistsError();
    Object.defineProperty(exports2, "SecretKeyAlreadyExistsError", { enumerable: true, get: function() {
      return SecretKeyAlreadyExistsError_1.SecretKeyAlreadyExistsError;
    } });
    var SecretFailToEncryptError_1 = require_SecretFailToEncryptError();
    Object.defineProperty(exports2, "SecretFailToEncryptError", { enumerable: true, get: function() {
      return SecretFailToEncryptError_1.SecretFailToEncryptError;
    } });
    var PinNotFoundError_1 = require_PinNotFoundError();
    Object.defineProperty(exports2, "PinNotFoundError", { enumerable: true, get: function() {
      return PinNotFoundError_1.PinNotFoundError;
    } });
    var PinAlreadyExistsInProjectError_1 = require_PinAlreadyExistsInProjectError();
    Object.defineProperty(exports2, "PinAlreadyExistsInProjectError", { enumerable: true, get: function() {
      return PinAlreadyExistsInProjectError_1.PinAlreadyExistsInProjectError;
    } });
    var UnstoppableDeploymentError_1 = require_UnstoppableDeploymentError();
    Object.defineProperty(exports2, "UnstoppableDeploymentError", { enumerable: true, get: function() {
      return UnstoppableDeploymentError_1.UnstoppableDeploymentError;
    } });
    var SiteDeploymentNotReleasedError_1 = require_SiteDeploymentNotReleasedError();
    Object.defineProperty(exports2, "SiteDeploymentNotReleasedError", { enumerable: true, get: function() {
      return SiteDeploymentNotReleasedError_1.SiteDeploymentNotReleasedError;
    } });
    var InvalidDeploymentTriggerError_1 = require_InvalidDeploymentTriggerError();
    Object.defineProperty(exports2, "InvalidDeploymentTriggerError", { enumerable: true, get: function() {
      return InvalidDeploymentTriggerError_1.InvalidDeploymentTriggerError;
    } });
    var IpfsGatewayContentUnreachableError_1 = require_IpfsGatewayContentUnreachableError();
    Object.defineProperty(exports2, "IpfsGatewayContentUnreachableError", { enumerable: true, get: function() {
      return IpfsGatewayContentUnreachableError_1.IpfsGatewayContentUnreachableError;
    } });
    var InvitationNotFoundError_1 = require_InvitationNotFoundError();
    Object.defineProperty(exports2, "InvitationNotFoundError", { enumerable: true, get: function() {
      return InvitationNotFoundError_1.InvitationNotFoundError;
    } });
    var MigrationTokenInvalidError_1 = require_MigrationTokenInvalidError();
    Object.defineProperty(exports2, "MigrationTokenInvalidError", { enumerable: true, get: function() {
      return MigrationTokenInvalidError_1.MigrationTokenInvalidError;
    } });
    var MigrationRequestsAlreadyExistError_1 = require_MigrationRequestsAlreadyExistError();
    Object.defineProperty(exports2, "MigrationRequestsAlreadyExistError", { enumerable: true, get: function() {
      return MigrationRequestsAlreadyExistError_1.MigrationRequestsAlreadyExistError;
    } });
    var MigrationRequestNotFoundError_1 = require_MigrationRequestNotFoundError();
    Object.defineProperty(exports2, "MigrationRequestNotFoundError", { enumerable: true, get: function() {
      return MigrationRequestNotFoundError_1.MigrationRequestNotFoundError;
    } });
    var MigrationRequestInPendingStateError_1 = require_MigrationRequestInPendingStateError();
    Object.defineProperty(exports2, "MigrationRequestInPendingStateError", { enumerable: true, get: function() {
      return MigrationRequestInPendingStateError_1.MigrationRequestInPendingStateError;
    } });
    var ProjectInvitationAlreadyExistError_1 = require_ProjectInvitationAlreadyExistError();
    Object.defineProperty(exports2, "ProjectInvitationAlreadyExistError", { enumerable: true, get: function() {
      return ProjectInvitationAlreadyExistError_1.ProjectInvitationAlreadyExistError;
    } });
    var ProjectMembershipAlreadyExistError_1 = require_ProjectMembershipAlreadyExistError();
    Object.defineProperty(exports2, "ProjectMembershipAlreadyExistError", { enumerable: true, get: function() {
      return ProjectMembershipAlreadyExistError_1.ProjectMembershipAlreadyExistError;
    } });
    var ProjectMembershipNoOwnersError_1 = require_ProjectMembershipNoOwnersError();
    Object.defineProperty(exports2, "ProjectMembershipNoOwnersError", { enumerable: true, get: function() {
      return ProjectMembershipNoOwnersError_1.ProjectMembershipNoOwnersError;
    } });
    var UploadedS3KeyNotFoundError_1 = require_UploadedS3KeyNotFoundError();
    Object.defineProperty(exports2, "UploadedS3KeyNotFoundError", { enumerable: true, get: function() {
      return UploadedS3KeyNotFoundError_1.UploadedS3KeyNotFoundError;
    } });
    var PathIsNotADirectoryError_1 = require_PathIsNotADirectoryError();
    Object.defineProperty(exports2, "PathIsNotADirectoryError", { enumerable: true, get: function() {
      return PathIsNotADirectoryError_1.PathIsNotADirectoryError;
    } });
    var FleekFunctionAlreadyExistsError_1 = require_FleekFunctionAlreadyExistsError();
    Object.defineProperty(exports2, "FleekFunctionAlreadyExistsError", { enumerable: true, get: function() {
      return FleekFunctionAlreadyExistsError_1.FleekFunctionAlreadyExistsError;
    } });
    var FleekFunctionNotFoundError_1 = require_FleekFunctionNotFoundError();
    Object.defineProperty(exports2, "FleekFunctionNotFoundError", { enumerable: true, get: function() {
      return FleekFunctionNotFoundError_1.FleekFunctionNotFoundError;
    } });
    var FleekFunctionDeploymentNotFoundError_1 = require_FleekFunctionDeploymentNotFoundError();
    Object.defineProperty(exports2, "FleekFunctionDeploymentNotFoundError", { enumerable: true, get: function() {
      return FleekFunctionDeploymentNotFoundError_1.FleekFunctionDeploymentNotFoundError;
    } });
    var FleekFunctionsNotFoundError_1 = require_FleekFunctionsNotFoundError();
    Object.defineProperty(exports2, "FleekFunctionsNotFoundError", { enumerable: true, get: function() {
      return FleekFunctionsNotFoundError_1.FleekFunctionsNotFoundError;
    } });
    var FleekFunctionPathNotValidError_1 = require_FleekFunctionPathNotValidError();
    Object.defineProperty(exports2, "FleekFunctionPathNotValidError", { enumerable: true, get: function() {
      return FleekFunctionPathNotValidError_1.FleekFunctionPathNotValidError;
    } });
    var FleekFunctionNameNotValidError_1 = require_FleekFunctionNameNotValidError();
    Object.defineProperty(exports2, "FleekFunctionNameNotValidError", { enumerable: true, get: function() {
      return FleekFunctionNameNotValidError_1.FleekFunctionNameNotValidError;
    } });
    var FleekFunctionStatusNotValidError_1 = require_FleekFunctionStatusNotValidError();
    Object.defineProperty(exports2, "FleekFunctionStatusNotValidError", { enumerable: true, get: function() {
      return FleekFunctionStatusNotValidError_1.FleekFunctionStatusNotValidError;
    } });
    var FleekFunctionSlugNotValidError_1 = require_FleekFunctionSlugNotValidError();
    Object.defineProperty(exports2, "FleekFunctionSlugNotValidError", { enumerable: true, get: function() {
      return FleekFunctionSlugNotValidError_1.FleekFunctionSlugNotValidError;
    } });
    var MaintenanceError_1 = require_MaintenanceError();
    Object.defineProperty(exports2, "MaintenanceError", { enumerable: true, get: function() {
      return MaintenanceError_1.MaintenanceError;
    } });
    var UserHasNoAccessToFeatureError_1 = require_UserHasNoAccessToFeatureError();
    Object.defineProperty(exports2, "UserHasNoAccessToFeatureError", { enumerable: true, get: function() {
      return UserHasNoAccessToFeatureError_1.UserHasNoAccessToFeatureError;
    } });
    var InvalidCidError_1 = require_InvalidCidError();
    Object.defineProperty(exports2, "InvalidCidError", { enumerable: true, get: function() {
      return InvalidCidError_1.InvalidCidError;
    } });
    var ValidationError_1 = require_ValidationError();
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return ValidationError_1.ValidationError;
    } });
    var UserInBlocklistError_1 = require_UserInBlocklistError();
    Object.defineProperty(exports2, "UserInBlocklistError", { enumerable: true, get: function() {
      return UserInBlocklistError_1.UserInBlocklistError;
    } });
    var EnsNameContentHashCodecMistmatchError_1 = require_EnsNameContentHashCodecMistmatchError();
    Object.defineProperty(exports2, "EnsNameContentHashCodecMistmatchError", { enumerable: true, get: function() {
      return EnsNameContentHashCodecMistmatchError_1.EnsNameContentHashCodecMistmatchError;
    } });
    var EnsNameContentHashUndefinedError_1 = require_EnsNameContentHashUndefinedError();
    Object.defineProperty(exports2, "EnsNameContentHashUndefinedError", { enumerable: true, get: function() {
      return EnsNameContentHashUndefinedError_1.EnsNameContentHashUndefinedError;
    } });
    var DnsConfigAlreadyExistsError_1 = require_DnsConfigAlreadyExistsError();
    Object.defineProperty(exports2, "DnsConfigAlreadyExistsError", { enumerable: true, get: function() {
      return DnsConfigAlreadyExistsError_1.DnsConfigAlreadyExistsError;
    } });
    var DnsConfigNotFoundError_1 = require_DnsConfigNotFoundError();
    Object.defineProperty(exports2, "DnsConfigNotFoundError", { enumerable: true, get: function() {
      return DnsConfigNotFoundError_1.DnsConfigNotFoundError;
    } });
    var TwoFactorSecretKeyFailedToEncryptError_1 = require_TwoFactorSecretKeyFailedToEncryptError();
    Object.defineProperty(exports2, "TwoFactorSecretKeyFailedToEncryptError", { enumerable: true, get: function() {
      return TwoFactorSecretKeyFailedToEncryptError_1.TwoFactorSecretKeyFailedToEncryptError;
    } });
    var UserSecretKeyAlreadyExistsError_1 = require_UserSecretKeyAlreadyExistsError();
    Object.defineProperty(exports2, "UserSecretKeyAlreadyExistsError", { enumerable: true, get: function() {
      return UserSecretKeyAlreadyExistsError_1.UserSecretKeyAlreadyExistsError;
    } });
    var UserSecretKeyNotFoundError_1 = require_UserSecretKeyNotFoundError();
    Object.defineProperty(exports2, "UserSecretKeyNotFoundError", { enumerable: true, get: function() {
      return UserSecretKeyNotFoundError_1.UserSecretKeyNotFoundError;
    } });
    var TwoFactorSecretKeyFailedToDecryptError_1 = require_TwoFactorSecretKeyFailedToDecryptError();
    Object.defineProperty(exports2, "TwoFactorSecretKeyFailedToDecryptError", { enumerable: true, get: function() {
      return TwoFactorSecretKeyFailedToDecryptError_1.TwoFactorSecretKeyFailedToDecryptError;
    } });
    var RecoveryCodesAlreadyExistsError_1 = require_RecoveryCodesAlreadyExistsError();
    Object.defineProperty(exports2, "RecoveryCodesAlreadyExistsError", { enumerable: true, get: function() {
      return RecoveryCodesAlreadyExistsError_1.RecoveryCodesAlreadyExistsError;
    } });
    var WriteFileFromStreamError_1 = require_WriteFileFromStreamError();
    Object.defineProperty(exports2, "WriteFileFromStreamError", { enumerable: true, get: function() {
      return WriteFileFromStreamError_1.WriteFileFromStreamError;
    } });
    var InvalidTOTPTokenError_1 = require_InvalidTOTPTokenError();
    Object.defineProperty(exports2, "InvalidTOTPTokenError", { enumerable: true, get: function() {
      return InvalidTOTPTokenError_1.InvalidTOTPTokenError;
    } });
    var InvalidRecoveryCodeError_1 = require_InvalidRecoveryCodeError();
    Object.defineProperty(exports2, "InvalidRecoveryCodeError", { enumerable: true, get: function() {
      return InvalidRecoveryCodeError_1.InvalidRecoveryCodeError;
    } });
    var MissingTwoFactorProtectionCredentialsError_1 = require_MissingTwoFactorProtectionCredentialsError();
    Object.defineProperty(exports2, "MissingTwoFactorProtectionCredentialsError", { enumerable: true, get: function() {
      return MissingTwoFactorProtectionCredentialsError_1.MissingTwoFactorProtectionCredentialsError;
    } });
    var DeploymentInProgressError_1 = require_DeploymentInProgressError();
    Object.defineProperty(exports2, "DeploymentInProgressError", { enumerable: true, get: function() {
      return DeploymentInProgressError_1.DeploymentInProgressError;
    } });
    var PullzoneNotFoundForZoneIdError_1 = require_PullzoneNotFoundForZoneIdError();
    Object.defineProperty(exports2, "PullzoneNotFoundForZoneIdError", { enumerable: true, get: function() {
      return PullzoneNotFoundForZoneIdError_1.PullzoneNotFoundForZoneIdError;
    } });
    var RecoveryCodeFailedToEncryptError_1 = require_RecoveryCodeFailedToEncryptError();
    Object.defineProperty(exports2, "RecoveryCodeFailedToEncryptError", { enumerable: true, get: function() {
      return RecoveryCodeFailedToEncryptError_1.RecoveryCodeFailedToEncryptError;
    } });
    var RecoveryCodeFailedToDecryptError_1 = require_RecoveryCodeFailedToDecryptError();
    Object.defineProperty(exports2, "RecoveryCodeFailedToDecryptError", { enumerable: true, get: function() {
      return RecoveryCodeFailedToDecryptError_1.RecoveryCodeFailedToDecryptError;
    } });
    var PermissionGroupNotFoundError_1 = require_PermissionGroupNotFoundError();
    Object.defineProperty(exports2, "PermissionGroupNotFoundError", { enumerable: true, get: function() {
      return PermissionGroupNotFoundError_1.PermissionGroupNotFoundError;
    } });
    var PermissionScopeError_1 = require_PermissionScopeError();
    Object.defineProperty(exports2, "PermissionScopeError", { enumerable: true, get: function() {
      return PermissionScopeError_1.PermissionScopeError;
    } });
    var InvalidAdminAccessTokenError_1 = require_InvalidAdminAccessTokenError();
    Object.defineProperty(exports2, "InvalidAdminAccessTokenError", { enumerable: true, get: function() {
      return InvalidAdminAccessTokenError_1.InvalidAdminAccessTokenError;
    } });
    var MissingExpectedDataError_1 = require_MissingExpectedDataError();
    Object.defineProperty(exports2, "MissingExpectedDataError", { enumerable: true, get: function() {
      return MissingExpectedDataError_1.MissingExpectedDataError;
    } });
    var EnvNotSetError_1 = require_EnvNotSetError();
    Object.defineProperty(exports2, "EnvNotSetError", { enumerable: true, get: function() {
      return EnvNotSetError_1.EnvNotSetError;
    } });
    var GitSecretsFailedToEncryptError_1 = require_GitSecretsFailedToEncryptError();
    Object.defineProperty(exports2, "GitSecretsFailedToEncryptError", { enumerable: true, get: function() {
      return GitSecretsFailedToEncryptError_1.GitSecretsFailedToEncryptError;
    } });
    var GitConfigFailedToParseError_1 = require_GitConfigFailedToParseError();
    Object.defineProperty(exports2, "GitConfigFailedToParseError", { enumerable: true, get: function() {
      return GitConfigFailedToParseError_1.GitConfigFailedToParseError;
    } });
    var PathIsNotAFileError_1 = require_PathIsNotAFileError();
    Object.defineProperty(exports2, "PathIsNotAFileError", { enumerable: true, get: function() {
      return PathIsNotAFileError_1.PathIsNotAFileError;
    } });
    var FleekFunctionBundlingFailedError_1 = require_FleekFunctionBundlingFailedError();
    Object.defineProperty(exports2, "FleekFunctionBundlingFailedError", { enumerable: true, get: function() {
      return FleekFunctionBundlingFailedError_1.FleekFunctionBundlingFailedError;
    } });
    var GitIntegrationNotFoundError_1 = require_GitIntegrationNotFoundError();
    Object.defineProperty(exports2, "GitIntegrationNotFoundError", { enumerable: true, get: function() {
      return GitIntegrationNotFoundError_1.GitIntegrationNotFoundError;
    } });
    var GitProviderNotFoundError_1 = require_GitProviderNotFoundError();
    Object.defineProperty(exports2, "GitProviderNotFoundError", { enumerable: true, get: function() {
      return GitProviderNotFoundError_1.GitProviderNotFoundError;
    } });
    var ExpectedOneOfValuesError_1 = require_ExpectedOneOfValuesError();
    Object.defineProperty(exports2, "ExpectedOneOfValuesError", { enumerable: true, get: function() {
      return ExpectedOneOfValuesError_1.ExpectedOneOfValuesError;
    } });
    var InvalidJSONFormat_1 = require_InvalidJSONFormat();
    Object.defineProperty(exports2, "InvalidJSONFormat", { enumerable: true, get: function() {
      return InvalidJSONFormat_1.InvalidJSONFormat;
    } });
    var StorageUploadFileCountQuotaExceededError_1 = require_StorageUploadFileCountQuotaExceededError();
    Object.defineProperty(exports2, "StorageUploadFileCountQuotaExceededError", { enumerable: true, get: function() {
      return StorageUploadFileCountQuotaExceededError_1.StorageUploadFileCountQuotaExceededError;
    } });
    var StorageUploadTotalSizeQuotaExceededError_1 = require_StorageUploadTotalSizeQuotaExceededError();
    Object.defineProperty(exports2, "StorageUploadTotalSizeQuotaExceededError", { enumerable: true, get: function() {
      return StorageUploadTotalSizeQuotaExceededError_1.StorageUploadTotalSizeQuotaExceededError;
    } });
    var GitProviderNotSupportedError_1 = require_GitProviderNotSupportedError();
    Object.defineProperty(exports2, "GitProviderNotSupportedError", { enumerable: true, get: function() {
      return GitProviderNotSupportedError_1.GitProviderNotSupportedError;
    } });
    var GitProviderNotAuthorizedError_1 = require_GitProviderNotAuthorizedError();
    Object.defineProperty(exports2, "GitProviderNotAuthorizedError", { enumerable: true, get: function() {
      return GitProviderNotAuthorizedError_1.GitProviderNotAuthorizedError;
    } });
    var GitAccessTokenInvalidError_1 = require_GitAccessTokenInvalidError();
    Object.defineProperty(exports2, "GitAccessTokenInvalidError", { enumerable: true, get: function() {
      return GitAccessTokenInvalidError_1.GitAccessTokenInvalidError;
    } });
    var QueuedDeploymentsLimitError_1 = require_QueuedDeploymentsLimitError();
    Object.defineProperty(exports2, "QueuedDeploymentsLimitError", { enumerable: true, get: function() {
      return QueuedDeploymentsLimitError_1.QueuedDeploymentsLimitError;
    } });
    var GitIntegrationInstallationConflictError_1 = require_GitIntegrationInstallationConflictError();
    Object.defineProperty(exports2, "GitIntegrationInstallationConflictError", { enumerable: true, get: function() {
      return GitIntegrationInstallationConflictError_1.GitIntegrationInstallationConflictError;
    } });
    var GitLinkMultipleAccountError_1 = require_GitLinkMultipleAccountError();
    Object.defineProperty(exports2, "GitLinkMultipleAccountError", { enumerable: true, get: function() {
      return GitLinkMultipleAccountError_1.GitLinkMultipleAccountError;
    } });
    var GitRepoByNameAndOwnerNotFoundError_1 = require_GitRepoByNameAndOwnerNotFoundError();
    Object.defineProperty(exports2, "GitRepoByNameAndOwnerNotFoundError", { enumerable: true, get: function() {
      return GitRepoByNameAndOwnerNotFoundError_1.GitRepoByNameAndOwnerNotFoundError;
    } });
    var GitAccessTokenNotFoundError_1 = require_GitAccessTokenNotFoundError();
    Object.defineProperty(exports2, "GitAccessTokenNotFoundError", { enumerable: true, get: function() {
      return GitAccessTokenNotFoundError_1.GitAccessTokenNotFoundError;
    } });
    var FolderNotFoundError_1 = require_FolderNotFoundError();
    Object.defineProperty(exports2, "FolderNotFoundError", { enumerable: true, get: function() {
      return FolderNotFoundError_1.FolderNotFoundError;
    } });
    var FolderAlreadyExistsError_1 = require_FolderAlreadyExistsError();
    Object.defineProperty(exports2, "FolderAlreadyExistsError", { enumerable: true, get: function() {
      return FolderAlreadyExistsError_1.FolderAlreadyExistsError;
    } });
    var PinsNotFoundError_1 = require_PinsNotFoundError();
    Object.defineProperty(exports2, "PinsNotFoundError", { enumerable: true, get: function() {
      return PinsNotFoundError_1.PinsNotFoundError;
    } });
    var SiteCreationFailedError_1 = require_SiteCreationFailedError();
    Object.defineProperty(exports2, "SiteCreationFailedError", { enumerable: true, get: function() {
      return SiteCreationFailedError_1.SiteCreationFailedError;
    } });
    var FleekFunctionInvalidWasmCodeError_1 = require_FleekFunctionInvalidWasmCodeError();
    Object.defineProperty(exports2, "FleekFunctionInvalidWasmCodeError", { enumerable: true, get: function() {
      return FleekFunctionInvalidWasmCodeError_1.FleekFunctionInvalidWasmCodeError;
    } });
    var FleekFunctionWasmEncryptionFailedError_1 = require_FleekFunctionWasmEncryptionFailedError();
    Object.defineProperty(exports2, "FleekFunctionWasmEncryptionFailedError", { enumerable: true, get: function() {
      return FleekFunctionWasmEncryptionFailedError_1.FleekFunctionWasmEncryptionFailedError;
    } });
    var UploadProxyStoreAsCarError_1 = require_UploadProxyStoreAsCarError();
    Object.defineProperty(exports2, "UploadProxyStoreAsCarError", { enumerable: true, get: function() {
      return UploadProxyStoreAsCarError_1.UploadProxyStoreAsCarError;
    } });
    var UploadProxyUploadFileError_1 = require_UploadProxyUploadFileError();
    Object.defineProperty(exports2, "UploadProxyUploadFileError", { enumerable: true, get: function() {
      return UploadProxyUploadFileError_1.UploadProxyUploadFileError;
    } });
  }
});
var require_verifyToken = __commonJS2({
  "../auth/dist/verifyToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyToken = void 0;
    var errors_1 = require_dist2();
    var jose_1 = (init_browser(), __toCommonJS(browser_exports));
    var textEncoder7 = new TextEncoder();
    var verifyToken = async ({ secret, token }) => {
      const secretKey = textEncoder7.encode(secret);
      const verifiedToken = await (0, jose_1.jwtVerify)(token, secretKey).catch(() => {
        throw new errors_1.AuthorizationError();
      });
      return verifiedToken.payload;
    };
    exports2.verifyToken = verifyToken;
  }
});
var require_verifyAccessToken = __commonJS2({
  "../auth/dist/verifyAccessToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyAccessToken = void 0;
    var verifyToken_1 = require_verifyToken();
    var verifyAccessToken = (args) => (0, verifyToken_1.verifyToken)(args);
    exports2.verifyAccessToken = verifyAccessToken;
  }
});
var require_verifyMigrationToken = __commonJS2({
  "../auth/dist/verifyMigrationToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyMigrationToken = void 0;
    var verifyToken_1 = require_verifyToken();
    var verifyMigrationToken = (args) => (0, verifyToken_1.verifyToken)(args);
    exports2.verifyMigrationToken = verifyMigrationToken;
  }
});
var require_jscrypto = __commonJS2({
  "../../node_modules/.pnpm/jscrypto@1.0.3/node_modules/jscrypto/index.js"(exports2, module2) {
    !function(n2, t) {
      if ("object" == typeof exports2 && "object" == typeof module2) module2.exports = t();
      else if ("function" == typeof define && define.amd) define([], t);
      else if ("object" == typeof exports2) exports2.JsCrypto = t();
      else {
        var r = t();
        for (var i in n2.JsCrypto = n2.JsCrypto || {}, r) n2.JsCrypto[i] = r[i];
      }
    }(exports2, function() {
      return function() {
        "use strict";
        var n2 = { 9691: function(n22, t2, r2) {
          r2.d(t2, { AES: function() {
            return _;
          } });
          var i2, e = r2(9456), o = r2(787), u = r2(5693), f = r2(9109), c = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), s2 = function() {
            return (s2 = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, a = [], h = [], v = [], w = [], l2 = [], b = [], d = [], y = [], p = [], O = [];
          !function() {
            for (var n3 = [], t3 = 0; t3 < 256; t3++) n3[t3] = t3 < 128 ? t3 << 1 : t3 << 1 ^ 283;
            var r3 = 0, i3 = 0;
            for (t3 = 0; t3 < 256; t3++) {
              var e2 = i3 ^ i3 << 1 ^ i3 << 2 ^ i3 << 3 ^ i3 << 4;
              e2 = e2 >>> 8 ^ 255 & e2 ^ 99, a[r3] = e2, h[e2] = r3;
              var o2 = n3[r3], u2 = n3[o2], f2 = n3[u2], c2 = 257 * n3[e2] ^ 16843008 * e2;
              v[r3] = c2 << 24 | c2 >>> 8, w[r3] = c2 << 16 | c2 >>> 16, l2[r3] = c2 << 8 | c2 >>> 24, b[r3] = c2, c2 = 16843009 * f2 ^ 65537 * u2 ^ 257 * o2 ^ 16843008 * r3, d[e2] = c2 << 24 | c2 >>> 8, y[e2] = c2 << 16 | c2 >>> 16, p[e2] = c2 << 8 | c2 >>> 24, O[e2] = c2, r3 ? (r3 = o2 ^ n3[n3[n3[f2 ^ o2]]], i3 ^= n3[n3[i3]]) : r3 = i3 = 1;
            }
          }();
          var j = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], _ = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.u = 0, r3.h = [], r3.v = [], r3.O = t4, r3.A(), r3;
            }
            return c(t3, n3), t3.prototype.A = function() {
              var n4;
              if (!this.u || this.k !== this.H) {
                for (var t4 = this.k = this.H, r3 = t4.words, i3 = t4.nSigBytes / 4, e2 = 4 * ((this.u = i3 + 6) + 1), o2 = this.h = [], u2 = 0; u2 < e2; u2++) u2 < i3 ? o2[u2] = r3[u2] : (n4 = o2[u2 - 1], u2 % i3 ? i3 > 6 && u2 % i3 == 4 && (n4 = a[n4 >>> 24] << 24 | a[n4 >>> 16 & 255] << 16 | a[n4 >>> 8 & 255] << 8 | a[255 & n4]) : (n4 = a[(n4 = n4 << 8 | n4 >>> 24) >>> 24] << 24 | a[n4 >>> 16 & 255] << 16 | a[n4 >>> 8 & 255] << 8 | a[255 & n4], n4 ^= j[u2 / i3 | 0] << 24), o2[u2] = o2[u2 - i3] ^ n4);
                this.v = [];
                for (var f2 = 0; f2 < e2; f2++) {
                  u2 = e2 - f2;
                  n4 = f2 % 4 ? o2[u2] : o2[u2 - 4], this.v[f2] = f2 < 4 || u2 <= 4 ? n4 : d[a[n4 >>> 24]] ^ y[a[n4 >>> 16 & 255]] ^ p[a[n4 >>> 8 & 255]] ^ O[a[255 & n4]];
                }
              }
            }, t3.prototype.encryptBlock = function(n4, t4) {
              this.B(n4, t4, this.h, v, w, l2, b, a);
            }, t3.prototype.decryptBlock = function(n4, t4) {
              var r3 = n4[t4 + 1];
              n4[t4 + 1] = n4[t4 + 3], n4[t4 + 3] = r3, this.B(n4, t4, this.v, d, y, p, O, h), r3 = n4[t4 + 1], n4[t4 + 1] = n4[t4 + 3], n4[t4 + 3] = r3;
            }, t3.prototype.B = function(n4, t4, r3, i3, e2, o2, u2, f2) {
              for (var c2 = this.u, s22 = n4[t4] ^ r3[0], a2 = n4[t4 + 1] ^ r3[1], h2 = n4[t4 + 2] ^ r3[2], v2 = n4[t4 + 3] ^ r3[3], w2 = 4, l22 = 1; l22 < c2; l22++) {
                var b2 = i3[s22 >>> 24] ^ e2[a2 >>> 16 & 255] ^ o2[h2 >>> 8 & 255] ^ u2[255 & v2] ^ r3[w2++], d2 = i3[a2 >>> 24] ^ e2[h2 >>> 16 & 255] ^ o2[v2 >>> 8 & 255] ^ u2[255 & s22] ^ r3[w2++], y2 = i3[h2 >>> 24] ^ e2[v2 >>> 16 & 255] ^ o2[s22 >>> 8 & 255] ^ u2[255 & a2] ^ r3[w2++], p2 = i3[v2 >>> 24] ^ e2[s22 >>> 16 & 255] ^ o2[a2 >>> 8 & 255] ^ u2[255 & h2] ^ r3[w2++];
                s22 = b2, a2 = d2, h2 = y2, v2 = p2;
              }
              var O2 = (f2[s22 >>> 24] << 24 | f2[a2 >>> 16 & 255] << 16 | f2[h2 >>> 8 & 255] << 8 | f2[255 & v2]) ^ r3[w2++], j2 = (f2[a2 >>> 24] << 24 | f2[h2 >>> 16 & 255] << 16 | f2[v2 >>> 8 & 255] << 8 | f2[255 & s22]) ^ r3[w2++], _2 = (f2[h2 >>> 24] << 24 | f2[v2 >>> 16 & 255] << 16 | f2[s22 >>> 8 & 255] << 8 | f2[255 & a2]) ^ r3[w2++], m = (f2[v2 >>> 24] << 24 | f2[s22 >>> 16 & 255] << 16 | f2[a2 >>> 8 & 255] << 8 | f2[255 & h2]) ^ r3[w2++];
              n4[t4] = O2, n4[t4 + 1] = j2, n4[t4 + 2] = _2, n4[t4 + 3] = m;
            }, t3.createEncryptor = function(n4, r3) {
              return new t3(s2(s2({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: e.t.ENC_TRANSFORM_MODE }));
            }, t3.createDecryptor = function(n4, r3) {
              return new t3(s2(s2({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: e.t.DEC_TRANSFORM_MODE }));
            }, t3.encrypt = function(n4, r3, i3) {
              if ("string" == typeof r3) return u.E.encrypt(t3, n4, r3, i3);
              if (r3.nSigBytes % 4 != 0) throw new Error("Key size must be multiple of 32bit/4byte/1word");
              return f.D.encrypt(t3, n4, r3, i3);
            }, t3.decrypt = function(n4, r3, i3) {
              if ("string" == typeof r3) return u.E.decrypt(t3, n4, r3, i3);
              if (r3.nSigBytes % 4 != 0) throw new Error("Key size must be multiple of 32bit/4byte/1word");
              return f.D.decrypt(t3, n4, r3, i3);
            }, t3.keySize = 8, t3;
          }(o.G);
        }, 3967: function(n22, t2, r2) {
          r2.d(t2, { CBCMAC: function() {
            return f;
          } });
          var i2 = r2(4768), e = r2(3354), o = r2(9691), u = r2(3664);
          function f(n3, t3, r3, f2, c, s2) {
            var a = s2 && s2.Cipher ? s2.Cipher : o.AES, h = "string" == typeof r3 ? i2.d.parse(r3) : r3, v = f2 || new e.e([0, 0]), w = "string" == typeof t3 ? i2.d.parse(t3) : t3, l2 = "string" == typeof n3 ? i2.d.parse(n3) : n3, b = c || 16;
            return u.K.mac(a, h, v, w, l2, b);
          }
        }, 9910: function(n22, t2, r2) {
          r2.d(t2, { DES: function() {
            return b;
          } });
          var i2, e = r2(787), o = r2(9456), u = r2(5693), f = r2(9109), c = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), s2 = function() {
            return (s2 = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, a = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4], h = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32], v = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28], w = [{ 0: 8421888, 268435456: 32768, 536870912: 8421378, 805306368: 2, 1073741824: 512, 1342177280: 8421890, 1610612736: 8389122, 1879048192: 8388608, 2147483648: 514, 2415919104: 8389120, 2684354560: 33280, 2952790016: 8421376, 3221225472: 32770, 3489660928: 8388610, 3758096384: 0, 4026531840: 33282, 134217728: 0, 402653184: 8421890, 671088640: 33282, 939524096: 32768, 1207959552: 8421888, 1476395008: 512, 1744830464: 8421378, 2013265920: 2, 2281701376: 8389120, 2550136832: 33280, 2818572288: 8421376, 3087007744: 8389122, 3355443200: 8388610, 3623878656: 32770, 3892314112: 514, 4160749568: 8388608, 1: 32768, 268435457: 2, 536870913: 8421888, 805306369: 8388608, 1073741825: 8421378, 1342177281: 33280, 1610612737: 512, 1879048193: 8389122, 2147483649: 8421890, 2415919105: 8421376, 2684354561: 8388610, 2952790017: 33282, 3221225473: 514, 3489660929: 8389120, 3758096385: 32770, 4026531841: 0, 134217729: 8421890, 402653185: 8421376, 671088641: 8388608, 939524097: 512, 1207959553: 32768, 1476395009: 8388610, 1744830465: 2, 2013265921: 33282, 2281701377: 32770, 2550136833: 8389122, 2818572289: 514, 3087007745: 8421888, 3355443201: 8389120, 3623878657: 0, 3892314113: 33280, 4160749569: 8421378 }, { 0: 1074282512, 16777216: 16384, 33554432: 524288, 50331648: 1074266128, 67108864: 1073741840, 83886080: 1074282496, 100663296: 1073758208, 117440512: 16, 134217728: 540672, 150994944: 1073758224, 167772160: 1073741824, 184549376: 540688, 201326592: 524304, 218103808: 0, 234881024: 16400, 251658240: 1074266112, 8388608: 1073758208, 25165824: 540688, 41943040: 16, 58720256: 1073758224, 75497472: 1074282512, 92274688: 1073741824, 109051904: 524288, 125829120: 1074266128, 142606336: 524304, 159383552: 0, 176160768: 16384, 192937984: 1074266112, 209715200: 1073741840, 226492416: 540672, 243269632: 1074282496, 260046848: 16400, 268435456: 0, 285212672: 1074266128, 301989888: 1073758224, 318767104: 1074282496, 335544320: 1074266112, 352321536: 16, 369098752: 540688, 385875968: 16384, 402653184: 16400, 419430400: 524288, 436207616: 524304, 452984832: 1073741840, 469762048: 540672, 486539264: 1073758208, 503316480: 1073741824, 520093696: 1074282512, 276824064: 540688, 293601280: 524288, 310378496: 1074266112, 327155712: 16384, 343932928: 1073758208, 360710144: 1074282512, 377487360: 16, 394264576: 1073741824, 411041792: 1074282496, 427819008: 1073741840, 444596224: 1073758224, 461373440: 524304, 478150656: 0, 494927872: 16400, 511705088: 1074266128, 528482304: 540672 }, { 0: 260, 1048576: 0, 2097152: 67109120, 3145728: 65796, 4194304: 65540, 5242880: 67108868, 6291456: 67174660, 7340032: 67174400, 8388608: 67108864, 9437184: 67174656, 10485760: 65792, 11534336: 67174404, 12582912: 67109124, 13631488: 65536, 14680064: 4, 15728640: 256, 524288: 67174656, 1572864: 67174404, 2621440: 0, 3670016: 67109120, 4718592: 67108868, 5767168: 65536, 6815744: 65540, 7864320: 260, 8912896: 4, 9961472: 256, 11010048: 67174400, 12058624: 65796, 13107200: 65792, 14155776: 67109124, 15204352: 67174660, 16252928: 67108864, 16777216: 67174656, 17825792: 65540, 18874368: 65536, 19922944: 67109120, 20971520: 256, 22020096: 67174660, 23068672: 67108868, 24117248: 0, 25165824: 67109124, 26214400: 67108864, 27262976: 4, 28311552: 65792, 29360128: 67174400, 30408704: 260, 31457280: 65796, 32505856: 67174404, 17301504: 67108864, 18350080: 260, 19398656: 67174656, 20447232: 0, 21495808: 65540, 22544384: 67109120, 23592960: 256, 24641536: 67174404, 25690112: 65536, 26738688: 67174660, 27787264: 65796, 28835840: 67108868, 29884416: 67109124, 30932992: 67174400, 31981568: 4, 33030144: 65792 }, { 0: 2151682048, 65536: 2147487808, 131072: 4198464, 196608: 2151677952, 262144: 0, 327680: 4198400, 393216: 2147483712, 458752: 4194368, 524288: 2147483648, 589824: 4194304, 655360: 64, 720896: 2147487744, 786432: 2151678016, 851968: 4160, 917504: 4096, 983040: 2151682112, 32768: 2147487808, 98304: 64, 163840: 2151678016, 229376: 2147487744, 294912: 4198400, 360448: 2151682112, 425984: 0, 491520: 2151677952, 557056: 4096, 622592: 2151682048, 688128: 4194304, 753664: 4160, 819200: 2147483648, 884736: 4194368, 950272: 4198464, 1015808: 2147483712, 1048576: 4194368, 1114112: 4198400, 1179648: 2147483712, 1245184: 0, 1310720: 4160, 1376256: 2151678016, 1441792: 2151682048, 1507328: 2147487808, 1572864: 2151682112, 1638400: 2147483648, 1703936: 2151677952, 1769472: 4198464, 1835008: 2147487744, 1900544: 4194304, 1966080: 64, 2031616: 4096, 1081344: 2151677952, 1146880: 2151682112, 1212416: 0, 1277952: 4198400, 1343488: 4194368, 1409024: 2147483648, 1474560: 2147487808, 1540096: 64, 1605632: 2147483712, 1671168: 4096, 1736704: 2147487744, 1802240: 2151678016, 1867776: 4160, 1933312: 2151682048, 1998848: 4194304, 2064384: 4198464 }, { 0: 128, 4096: 17039360, 8192: 262144, 12288: 536870912, 16384: 537133184, 20480: 16777344, 24576: 553648256, 28672: 262272, 32768: 16777216, 36864: 537133056, 40960: 536871040, 45056: 553910400, 49152: 553910272, 53248: 0, 57344: 17039488, 61440: 553648128, 2048: 17039488, 6144: 553648256, 10240: 128, 14336: 17039360, 18432: 262144, 22528: 537133184, 26624: 553910272, 30720: 536870912, 34816: 537133056, 38912: 0, 43008: 553910400, 47104: 16777344, 51200: 536871040, 55296: 553648128, 59392: 16777216, 63488: 262272, 65536: 262144, 69632: 128, 73728: 536870912, 77824: 553648256, 81920: 16777344, 86016: 553910272, 90112: 537133184, 94208: 16777216, 98304: 553910400, 102400: 553648128, 106496: 17039360, 110592: 537133056, 114688: 262272, 118784: 536871040, 122880: 0, 126976: 17039488, 67584: 553648256, 71680: 16777216, 75776: 17039360, 79872: 537133184, 83968: 536870912, 88064: 17039488, 92160: 128, 96256: 553910272, 100352: 262272, 104448: 553910400, 108544: 0, 112640: 553648128, 116736: 16777344, 120832: 262144, 124928: 537133056, 129024: 536871040 }, { 0: 268435464, 256: 8192, 512: 270532608, 768: 270540808, 1024: 268443648, 1280: 2097152, 1536: 2097160, 1792: 268435456, 2048: 0, 2304: 268443656, 2560: 2105344, 2816: 8, 3072: 270532616, 3328: 2105352, 3584: 8200, 3840: 270540800, 128: 270532608, 384: 270540808, 640: 8, 896: 2097152, 1152: 2105352, 1408: 268435464, 1664: 268443648, 1920: 8200, 2176: 2097160, 2432: 8192, 2688: 268443656, 2944: 270532616, 3200: 0, 3456: 270540800, 3712: 2105344, 3968: 268435456, 4096: 268443648, 4352: 270532616, 4608: 270540808, 4864: 8200, 5120: 2097152, 5376: 268435456, 5632: 268435464, 5888: 2105344, 6144: 2105352, 6400: 0, 6656: 8, 6912: 270532608, 7168: 8192, 7424: 268443656, 7680: 270540800, 7936: 2097160, 4224: 8, 4480: 2105344, 4736: 2097152, 4992: 268435464, 5248: 268443648, 5504: 8200, 5760: 270540808, 6016: 270532608, 6272: 270540800, 6528: 270532616, 6784: 8192, 7040: 2105352, 7296: 2097160, 7552: 0, 7808: 268435456, 8064: 268443656 }, { 0: 1048576, 16: 33555457, 32: 1024, 48: 1049601, 64: 34604033, 80: 0, 96: 1, 112: 34603009, 128: 33555456, 144: 1048577, 160: 33554433, 176: 34604032, 192: 34603008, 208: 1025, 224: 1049600, 240: 33554432, 8: 34603009, 24: 0, 40: 33555457, 56: 34604032, 72: 1048576, 88: 33554433, 104: 33554432, 120: 1025, 136: 1049601, 152: 33555456, 168: 34603008, 184: 1048577, 200: 1024, 216: 34604033, 232: 1, 248: 1049600, 256: 33554432, 272: 1048576, 288: 33555457, 304: 34603009, 320: 1048577, 336: 33555456, 352: 34604032, 368: 1049601, 384: 1025, 400: 34604033, 416: 1049600, 432: 1, 448: 0, 464: 34603008, 480: 33554433, 496: 1024, 264: 1049600, 280: 33555457, 296: 34603009, 312: 1, 328: 33554432, 344: 1048576, 360: 1025, 376: 34604032, 392: 33554433, 408: 34603008, 424: 0, 440: 34604033, 456: 1049601, 472: 1024, 488: 33555456, 504: 1048577 }, { 0: 134219808, 1: 131072, 2: 134217728, 3: 32, 4: 131104, 5: 134350880, 6: 134350848, 7: 2048, 8: 134348800, 9: 134219776, 10: 133120, 11: 134348832, 12: 2080, 13: 0, 14: 134217760, 15: 133152, 2147483648: 2048, 2147483649: 134350880, 2147483650: 134219808, 2147483651: 134217728, 2147483652: 134348800, 2147483653: 133120, 2147483654: 133152, 2147483655: 32, 2147483656: 134217760, 2147483657: 2080, 2147483658: 131104, 2147483659: 134350848, 2147483660: 0, 2147483661: 134348832, 2147483662: 134219776, 2147483663: 131072, 16: 133152, 17: 134350848, 18: 32, 19: 2048, 20: 134219776, 21: 134217760, 22: 134348832, 23: 131072, 24: 0, 25: 131104, 26: 134348800, 27: 134219808, 28: 134350880, 29: 133120, 30: 2080, 31: 134217728, 2147483664: 131072, 2147483665: 2048, 2147483666: 134348832, 2147483667: 133152, 2147483668: 32, 2147483669: 134348800, 2147483670: 134217728, 2147483671: 134219808, 2147483672: 134350880, 2147483673: 134217760, 2147483674: 134219776, 2147483675: 0, 2147483676: 133120, 2147483677: 2080, 2147483678: 131104, 2147483679: 134350848 }], l2 = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679], b = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.N = 2, r3.I = [], r3.U = [], r3.L = 0, r3.F = 0, r3.O = t4, r3.A(), r3;
            }
            return c(t3, n3), t3.prototype.A = function() {
              for (var n4 = this.H.words, t4 = [], r3 = 0; r3 < 56; r3++) {
                var i3 = a[r3] - 1;
                t4[r3] = n4[i3 >>> 5] >>> 31 - i3 % 32 & 1;
              }
              for (var e2 = this.I = [], o2 = 0; o2 < 16; o2++) {
                var u2 = e2[o2] = [], f2 = v[o2];
                for (r3 = 0; r3 < 24; r3++) u2[r3 / 6 | 0] |= t4[(h[r3] - 1 + f2) % 28] << 31 - r3 % 6, u2[4 + (r3 / 6 | 0)] |= t4[28 + (h[r3 + 24] - 1 + f2) % 28] << 31 - r3 % 6;
                u2[0] = u2[0] << 1 | u2[0] >>> 31;
                for (r3 = 1; r3 < 7; r3++) u2[r3] = u2[r3] >>> 4 * (r3 - 1) + 3;
                u2[7] = u2[7] << 5 | u2[7] >>> 27;
              }
              this.U = [];
              for (r3 = 0; r3 < 16; r3++) this.U[r3] = e2[15 - r3];
            }, t3.prototype.encryptBlock = function(n4, t4) {
              this.R(n4, t4, this.I);
            }, t3.prototype.decryptBlock = function(n4, t4) {
              this.R(n4, t4, this.U);
            }, t3.prototype.R = function(n4, t4, r3) {
              this.L = n4[t4], this.F = n4[t4 + 1], this.X(4, 252645135), this.X(16, 65535), this.Z(2, 858993459), this.Z(8, 16711935), this.X(1, 1431655765);
              for (var i3 = 0; i3 < 16; i3++) {
                for (var e2 = r3[i3], o2 = this.L, u2 = this.F, f2 = 0, c2 = 0; c2 < 8; c2++) {
                  var s22 = (u2 ^ e2[c2]) & l2[c2];
                  f2 |= w[c2][s22 >>> 0];
                }
                this.L = u2, this.F = o2 ^ f2;
              }
              var a2 = this.L;
              this.L = this.F, this.F = a2, this.X(1, 1431655765), this.Z(8, 16711935), this.Z(2, 858993459), this.X(16, 65535), this.X(4, 252645135), n4[t4] = this.L, n4[t4 + 1] = this.F;
            }, t3.prototype.X = function(n4, t4) {
              var r3 = (this.L >>> n4 ^ this.F) & t4;
              this.F ^= r3, this.L ^= r3 << n4;
            }, t3.prototype.Z = function(n4, t4) {
              var r3 = (this.F >>> n4 ^ this.L) & t4;
              this.L ^= r3, this.F ^= r3 << n4;
            }, t3.createEncryptor = function(n4, r3) {
              return new t3(s2(s2({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: o.t.ENC_TRANSFORM_MODE }));
            }, t3.createDecryptor = function(n4, r3) {
              return new t3(s2(s2({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: o.t.DEC_TRANSFORM_MODE }));
            }, t3.encrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? u.E.encrypt(t3, n4, r3, i3) : f.D.encrypt(t3, n4, r3, i3);
            }, t3.decrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? u.E.decrypt(t3, n4, r3, i3) : f.D.decrypt(t3, n4, r3, i3);
            }, t3.keySize = 2, t3.ivSize = 2, t3;
          }(e.G);
        }, 6739: function(n22, t2, r2) {
          r2.d(t2, { DES3: function() {
            return v;
          } });
          var i2, e = r2(9109), o = r2(787), u = r2(9456), f = r2(9910), c = r2(3354), s2 = r2(5693), a = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), h = function() {
            return (h = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, v = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              r3.N = 2, r3.O = t4;
              var i3 = r3.J();
              return r3.Y = i3[0], r3.$ = i3[1], r3.nn = i3[2], r3;
            }
            return a(t3, n3), t3.prototype.J = function() {
              var n4 = this.H.words;
              if (2 !== n4.length && 4 !== n4.length && n4.length < 6) throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
              var t4 = n4.slice(0, 2), r3 = n4.length < 4 ? n4.slice(0, 2) : n4.slice(2, 4), i3 = n4.length < 6 ? n4.slice(0, 2) : n4.slice(4, 6);
              return [f.DES.createEncryptor(new c.e(t4)), f.DES.createEncryptor(new c.e(r3)), f.DES.createEncryptor(new c.e(i3))];
            }, t3.prototype.A = function() {
              var n4 = this.J();
              this.Y = n4[0], this.$ = n4[1], this.nn = n4[2];
            }, t3.prototype.encryptBlock = function(n4, t4) {
              this.Y.encryptBlock(n4, t4), this.$.decryptBlock(n4, t4), this.nn.encryptBlock(n4, t4);
            }, t3.prototype.decryptBlock = function(n4, t4) {
              this.nn.decryptBlock(n4, t4), this.$.encryptBlock(n4, t4), this.Y.decryptBlock(n4, t4);
            }, t3.createEncryptor = function(n4, r3) {
              return new t3(h(h({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: u.t.ENC_TRANSFORM_MODE }));
            }, t3.createDecryptor = function(n4, r3) {
              return new t3(h(h({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: u.t.DEC_TRANSFORM_MODE }));
            }, t3.encrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? s2.E.encrypt(t3, n4, r3, i3) : e.D.encrypt(t3, n4, r3, i3);
            }, t3.decrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? s2.E.decrypt(t3, n4, r3, i3) : e.D.decrypt(t3, n4, r3, i3);
            }, t3.keySize = 6, t3.ivSize = 2, t3;
          }(o.G);
        }, 7753: function(n22, t2, r2) {
          r2.d(t2, { GMAC: function() {
            return f;
          } });
          var i2 = r2(4768), e = r2(3354), o = r2(9691), u = r2(5607);
          function f(n3, t3, r3, f2, c) {
            var s2 = "string" == typeof n3 ? i2.d.parse(n3) : n3, a = r3 || new e.e([0, 0, 0, 0]), h = c && c.Cipher ? c.Cipher : o.AES, v = "string" == typeof t3 ? i2.d.parse(t3) : t3, w = f2 || 16;
            return u.V.mac(h, v, a, s2, void 0, w);
          }
        }, 6367: function(n22, t2, r2) {
          r2.d(t2, { Hmac: function() {
            return e;
          } });
          var i2 = r2(4768), e = function() {
            function n3(n4, t3) {
              this.tn = n4, "string" == typeof t3 && (t3 = i2.d.parse(t3));
              var r3 = n4.blockSize, e2 = 4 * r3;
              t3.nSigBytes > e2 && (t3 = n4.finalize(t3)), t3.clamp();
              for (var o = this.rn = t3.clone(), u = this.en = t3.clone(), f = o.words, c = u.words, s2 = 0; s2 < r3; s2++) f[s2] ^= 1549556828, c[s2] ^= 909522486;
              u.nSigBytes = e2, o.nSigBytes = e2, this.reset();
            }
            return n3.prototype.reset = function() {
              this.tn.reset(), this.tn.update(this.en);
            }, n3.prototype.update = function(n4) {
              return this.tn.update(n4), this;
            }, n3.prototype.finalize = function(n4) {
              var t3 = this.tn.finalize(n4);
              return this.tn.reset(), this.tn.finalize(this.rn.clone().concat(t3));
            }, n3;
          }();
        }, 3027: function(n22, t2, r2) {
          r2.d(t2, { HmacMD5: function() {
            return o;
          } });
          var i2 = r2(6367), e = r2(670);
          function o(n3, t3) {
            return new i2.Hmac(new e.MD5(), t3).finalize(n3);
          }
        }, 149: function(n22, t2, r2) {
          r2.d(t2, { HmacSHA1: function() {
            return o;
          } });
          var i2 = r2(6367), e = r2(3173);
          function o(n3, t3) {
            return new i2.Hmac(new e.SHA1(), t3).finalize(n3);
          }
        }, 4105: function(n22, t2, r2) {
          r2.d(t2, { HmacSHA224: function() {
            return o;
          } });
          var i2 = r2(6367), e = r2(766);
          function o(n3, t3) {
            return new i2.Hmac(new e.SHA224(), t3).finalize(n3);
          }
        }, 980: function(n22, t2, r2) {
          r2.d(t2, { HmacSHA256: function() {
            return o;
          } });
          var i2 = r2(6367), e = r2(5561);
          function o(n3, t3) {
            return new i2.Hmac(new e.SHA256(), t3).finalize(n3);
          }
        }, 5838: function(n22, t2, r2) {
          r2.d(t2, { HmacSHA384: function() {
            return o;
          } });
          var i2 = r2(6367), e = r2(6324);
          function o(n3, t3) {
            return new i2.Hmac(new e.SHA384(), t3).finalize(n3);
          }
        }, 9902: function(n22, t2, r2) {
          r2.d(t2, { HmacSHA512: function() {
            return o;
          } });
          var i2 = r2(6367), e = r2(7491);
          function o(n3, t3) {
            return new i2.Hmac(new e.SHA512(), t3).finalize(n3);
          }
        }, 670: function(n22, t2, r2) {
          r2.d(t2, { MD5: function() {
            return v;
          } });
          var i2, e = r2(3354), o = r2(1868), u = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), f = [];
          function c(n3, t3, r3, i3, e2, o2, u2) {
            var f2 = n3 + (t3 & r3 | ~t3 & i3) + e2 + u2;
            return (f2 << o2 | f2 >>> 32 - o2) + t3;
          }
          function s2(n3, t3, r3, i3, e2, o2, u2) {
            var f2 = n3 + (t3 & i3 | r3 & ~i3) + e2 + u2;
            return (f2 << o2 | f2 >>> 32 - o2) + t3;
          }
          function a(n3, t3, r3, i3, e2, o2, u2) {
            var f2 = n3 + (t3 ^ r3 ^ i3) + e2 + u2;
            return (f2 << o2 | f2 >>> 32 - o2) + t3;
          }
          function h(n3, t3, r3, i3, e2, o2, u2) {
            var f2 = n3 + (r3 ^ (t3 | ~i3)) + e2 + u2;
            return (f2 << o2 | f2 >>> 32 - o2) + t3;
          }
          !function() {
            for (var n3 = 0; n3 < 64; n3++) f[n3] = 4294967296 * Math.abs(Math.sin(n3 + 1)) | 0;
          }();
          var v = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.on = new e.e([1732584193, 4023233417, 2562383102, 271733878]), t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
            }
            return u(t3, n3), t3.prototype.A = function() {
              this.on = new e.e([1732584193, 4023233417, 2562383102, 271733878]);
            }, t3.prototype.un = function(n4, t4) {
              for (var r3 = 0; r3 < 16; r3++) {
                var i3 = t4 + r3, e2 = n4[i3];
                n4[i3] = 16711935 & (e2 << 8 | e2 >>> 24) | 4278255360 & (e2 << 24 | e2 >>> 8);
              }
              var o2 = this.on.words, u2 = n4[t4], v2 = n4[t4 + 1], w = n4[t4 + 2], l2 = n4[t4 + 3], b = n4[t4 + 4], d = n4[t4 + 5], y = n4[t4 + 6], p = n4[t4 + 7], O = n4[t4 + 8], j = n4[t4 + 9], _ = n4[t4 + 10], m = n4[t4 + 11], A = n4[t4 + 12], g = n4[t4 + 13], E = n4[t4 + 14], S = n4[t4 + 15], M = o2[0], k = o2[1], H = o2[2], C = o2[3];
              M = c(M, k, H, C, u2, 7, f[0]), C = c(C, M, k, H, v2, 12, f[1]), H = c(H, C, M, k, w, 17, f[2]), k = c(k, H, C, M, l2, 22, f[3]), M = c(M, k, H, C, b, 7, f[4]), C = c(C, M, k, H, d, 12, f[5]), H = c(H, C, M, k, y, 17, f[6]), k = c(k, H, C, M, p, 22, f[7]), M = c(M, k, H, C, O, 7, f[8]), C = c(C, M, k, H, j, 12, f[9]), H = c(H, C, M, k, _, 17, f[10]), k = c(k, H, C, M, m, 22, f[11]), M = c(M, k, H, C, A, 7, f[12]), C = c(C, M, k, H, g, 12, f[13]), H = c(H, C, M, k, E, 17, f[14]), M = s2(M, k = c(k, H, C, M, S, 22, f[15]), H, C, v2, 5, f[16]), C = s2(C, M, k, H, y, 9, f[17]), H = s2(H, C, M, k, m, 14, f[18]), k = s2(k, H, C, M, u2, 20, f[19]), M = s2(M, k, H, C, d, 5, f[20]), C = s2(C, M, k, H, _, 9, f[21]), H = s2(H, C, M, k, S, 14, f[22]), k = s2(k, H, C, M, b, 20, f[23]), M = s2(M, k, H, C, j, 5, f[24]), C = s2(C, M, k, H, E, 9, f[25]), H = s2(H, C, M, k, l2, 14, f[26]), k = s2(k, H, C, M, O, 20, f[27]), M = s2(M, k, H, C, g, 5, f[28]), C = s2(C, M, k, H, w, 9, f[29]), H = s2(H, C, M, k, p, 14, f[30]), M = a(M, k = s2(k, H, C, M, A, 20, f[31]), H, C, d, 4, f[32]), C = a(C, M, k, H, O, 11, f[33]), H = a(H, C, M, k, m, 16, f[34]), k = a(k, H, C, M, E, 23, f[35]), M = a(M, k, H, C, v2, 4, f[36]), C = a(C, M, k, H, b, 11, f[37]), H = a(H, C, M, k, p, 16, f[38]), k = a(k, H, C, M, _, 23, f[39]), M = a(M, k, H, C, g, 4, f[40]), C = a(C, M, k, H, u2, 11, f[41]), H = a(H, C, M, k, l2, 16, f[42]), k = a(k, H, C, M, y, 23, f[43]), M = a(M, k, H, C, j, 4, f[44]), C = a(C, M, k, H, A, 11, f[45]), H = a(H, C, M, k, S, 16, f[46]), M = h(M, k = a(k, H, C, M, w, 23, f[47]), H, C, u2, 6, f[48]), C = h(C, M, k, H, p, 10, f[49]), H = h(H, C, M, k, E, 15, f[50]), k = h(k, H, C, M, d, 21, f[51]), M = h(M, k, H, C, A, 6, f[52]), C = h(C, M, k, H, l2, 10, f[53]), H = h(H, C, M, k, _, 15, f[54]), k = h(k, H, C, M, v2, 21, f[55]), M = h(M, k, H, C, O, 6, f[56]), C = h(C, M, k, H, S, 10, f[57]), H = h(H, C, M, k, y, 15, f[58]), k = h(k, H, C, M, g, 21, f[59]), M = h(M, k, H, C, b, 6, f[60]), C = h(C, M, k, H, m, 10, f[61]), H = h(H, C, M, k, w, 15, f[62]), k = h(k, H, C, M, j, 21, f[63]), o2[0] = o2[0] + M | 0, o2[1] = o2[1] + k | 0, o2[2] = o2[2] + H | 0, o2[3] = o2[3] + C | 0;
            }, t3.prototype.fn = function() {
              var n4 = this.cn, t4 = n4.words, r3 = 8 * this.sn, i3 = 8 * n4.nSigBytes;
              t4[i3 >>> 5] |= 128 << 24 - i3 % 32;
              var e2 = Math.floor(r3 / 4294967296), o2 = r3;
              t4[15 + (i3 + 64 >>> 9 << 4)] = 16711935 & (e2 << 8 | e2 >>> 24) | 4278255360 & (e2 << 24 | e2 >>> 8), t4[14 + (i3 + 64 >>> 9 << 4)] = 16711935 & (o2 << 8 | o2 >>> 24) | 4278255360 & (o2 << 24 | o2 >>> 8), n4.nSigBytes = 4 * (t4.length + 1), this.an();
              for (var u2 = this.on, f2 = u2.words, c2 = 0; c2 < 4; c2++) {
                var s22 = f2[c2];
                f2[c2] = 16711935 & (s22 << 8 | s22 >>> 24) | 4278255360 & (s22 << 24 | s22 >>> 8);
              }
              return u2;
            }, t3.prototype.clone = function() {
              return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
            }, t3.hash = function(n4) {
              return new t3().finalize(n4);
            }, t3;
          }(o.P);
        }, 4615: function(n22, t2, r2) {
          r2.d(t2, { RC4: function() {
            return s2;
          } });
          var i2, e = r2(30), o = r2(5693), u = r2(9109), f = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), c = function() {
            return (c = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, s2 = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.S = [], r3.i = 0, r3.j = 0, r3.O = t4, r3.A(), r3;
            }
            return f(t3, n3), t3.prototype.A = function() {
              var n4 = this.H, t4 = n4.words, r3 = n4.nSigBytes;
              this.S = [];
              for (var i3 = 0; i3 < 256; i3++) this.S[i3] = i3;
              i3 = 0;
              for (var e2 = 0; i3 < 256; i3++) {
                var o2 = i3 % r3, u2 = t4[o2 >>> 2] >>> 24 - o2 % 4 * 8 & 255;
                e2 = (e2 + this.S[i3] + u2) % 256;
                var f2 = this.S[i3];
                this.S[i3] = this.S[e2], this.S[e2] = f2;
              }
              this.i = this.j = 0;
            }, t3.prototype.un = function(n4, t4) {
              n4[t4] ^= this.generateKeyStreamWord();
            }, t3.prototype.generateKeyStreamWord = function() {
              for (var n4 = this.S, t4 = this.i, r3 = this.j, i3 = 0, e2 = 0; e2 < 4; e2++) {
                r3 = (r3 + n4[t4 = (t4 + 1) % 256]) % 256;
                var o2 = n4[t4];
                n4[t4] = n4[r3], n4[r3] = o2, i3 |= n4[(n4[t4] + n4[r3]) % 256] << 24 - 8 * e2;
              }
              return this.i = t4, this.j = r3, i3;
            }, t3.createEncryptor = function(n4, r3) {
              return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
            }, t3.createDecryptor = function(n4, r3) {
              return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
            }, t3.encrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? o.E.encrypt(t3, n4, r3, i3) : u.D.encrypt(t3, n4, r3, i3);
            }, t3.decrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? o.E.decrypt(t3, n4, r3, i3) : u.D.decrypt(t3, n4, r3, i3);
            }, t3.ivSize = 0, t3.keySize = 8, t3;
          }(e.q);
        }, 9639: function(n22, t2, r2) {
          r2.d(t2, { RC4Drop: function() {
            return s2;
          } });
          var i2, e = r2(5693), o = r2(9109), u = r2(4615), f = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), c = function() {
            return (c = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, s2 = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.drop = 192, r3.O = t4, t4 && "number" == typeof t4.drop && (r3.drop = t4.drop), r3.A(), r3;
            }
            return f(t3, n3), t3.prototype.A = function() {
              n3.prototype.A.call(this);
              for (var t4 = this.drop; t4 > 0; t4--) this.generateKeyStreamWord();
            }, t3.createEncryptor = function(n4, r3) {
              return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
            }, t3.createDecryptor = function(n4, r3) {
              return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
            }, t3.encrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? e.E.encrypt(t3, n4, r3, i3) : o.D.encrypt(t3, n4, r3, i3);
            }, t3.decrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? e.E.decrypt(t3, n4, r3, i3) : o.D.decrypt(t3, n4, r3, i3);
            }, t3;
          }(u.RC4);
        }, 7104: function(n22, t2, r2) {
          r2.d(t2, { RIPEMD160: function() {
            return O;
          } });
          var i2, e = r2(1868), o = r2(3354), u = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), f = new o.e([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]), c = new o.e([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]), s2 = new o.e([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]), a = new o.e([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]), h = new o.e([0, 1518500249, 1859775393, 2400959708, 2840853838]), v = new o.e([1352829926, 1548603684, 1836072691, 2053994217, 0]);
          function w(n3, t3, r3) {
            return n3 ^ t3 ^ r3;
          }
          function l2(n3, t3, r3) {
            return n3 & t3 | ~n3 & r3;
          }
          function b(n3, t3, r3) {
            return (n3 | ~t3) ^ r3;
          }
          function d(n3, t3, r3) {
            return n3 & r3 | t3 & ~r3;
          }
          function y(n3, t3, r3) {
            return n3 ^ (t3 | ~r3);
          }
          function p(n3, t3) {
            return n3 << t3 | n3 >>> 32 - t3;
          }
          var O = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.on = new o.e([1732584193, 4023233417, 2562383102, 271733878, 3285377520]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
            }
            return u(t3, n3), t3.prototype.A = function() {
              this.on = new o.e([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
            }, t3.prototype.un = function(n4, t4) {
              for (var r3 = 0; r3 < 16; r3++) {
                var i3 = t4 + r3, e2 = n4[i3];
                n4[i3] = 16711935 & (e2 << 8 | e2 >>> 24) | 4278255360 & (e2 << 24 | e2 >>> 8);
              }
              var o2, u2, O2, j, _, m, A, g, E, S, M, k = this.on.words, H = h.words, C = v.words, B = f.words, N = c.words, I = s2.words, z = a.words;
              m = o2 = k[0], A = u2 = k[1], g = O2 = k[2], E = j = k[3], S = _ = k[4];
              for (r3 = 0; r3 < 80; r3 += 1) M = o2 + n4[t4 + B[r3]] | 0, M += r3 < 16 ? w(u2, O2, j) + H[0] : r3 < 32 ? l2(u2, O2, j) + H[1] : r3 < 48 ? b(u2, O2, j) + H[2] : r3 < 64 ? d(u2, O2, j) + H[3] : y(u2, O2, j) + H[4], M = (M = p(M |= 0, I[r3])) + _ | 0, o2 = _, _ = j, j = p(O2, 10), O2 = u2, u2 = M, M = m + n4[t4 + N[r3]] | 0, M += r3 < 16 ? y(A, g, E) + C[0] : r3 < 32 ? d(A, g, E) + C[1] : r3 < 48 ? b(A, g, E) + C[2] : r3 < 64 ? l2(A, g, E) + C[3] : w(A, g, E) + C[4], M = (M = p(M |= 0, z[r3])) + S | 0, m = S, S = E, E = p(g, 10), g = A, A = M;
              M = k[1] + O2 + E | 0, k[1] = k[2] + j + S | 0, k[2] = k[3] + _ + m | 0, k[3] = k[4] + o2 + A | 0, k[4] = k[0] + u2 + g | 0, k[0] = M;
            }, t3.prototype.fn = function() {
              var n4 = this.cn, t4 = n4.words, r3 = 8 * this.sn, i3 = 8 * n4.nSigBytes;
              t4[i3 >>> 5] |= 128 << 24 - i3 % 32, t4[14 + (i3 + 64 >>> 9 << 4)] = 16711935 & (r3 << 8 | r3 >>> 24) | 4278255360 & (r3 << 24 | r3 >>> 8), n4.nSigBytes = 4 * (t4.length + 1), this.an();
              for (var e2 = this.on, o2 = e2.words, u2 = 0; u2 < 5; u2++) {
                var f2 = o2[u2];
                o2[u2] = 16711935 & (f2 << 8 | f2 >>> 24) | 4278255360 & (f2 << 24 | f2 >>> 8);
              }
              return e2;
            }, t3.prototype.clone = function() {
              return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
            }, t3.hash = function(n4, r3) {
              return new t3(r3).finalize(n4);
            }, t3;
          }(e.P);
        }, 5187: function(n22, t2, r2) {
          r2.d(t2, { Rabbit: function() {
            return s2;
          } });
          var i2, e = r2(30), o = r2(5693), u = r2(9109), f = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), c = function() {
            return (c = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, s2 = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.N = 4, r3.S = [], r3.C = [], r3.G = [], r3.hn = [], r3.vn = [], r3.wn = 0, r3.O = t4, r3.A(), r3;
            }
            return f(t3, n3), t3.prototype.A = function() {
              for (var n4 = this.H.words, t4 = this.ln, r3 = 0; r3 < 4; r3++) n4[r3] = 16711935 & (n4[r3] << 8 | n4[r3] >>> 24) | 4278255360 & (n4[r3] << 24 | n4[r3] >>> 8);
              var i3 = this.hn = [n4[0], n4[3] << 16 | n4[2] >>> 16, n4[1], n4[0] << 16 | n4[3] >>> 16, n4[2], n4[1] << 16 | n4[0] >>> 16, n4[3], n4[2] << 16 | n4[1] >>> 16], e2 = this.vn = [n4[2] << 16 | n4[2] >>> 16, 4294901760 & n4[0] | 65535 & n4[1], n4[3] << 16 | n4[3] >>> 16, 4294901760 & n4[1] | 65535 & n4[2], n4[0] << 16 | n4[0] >>> 16, 4294901760 & n4[2] | 65535 & n4[3], n4[1] << 16 | n4[1] >>> 16, 4294901760 & n4[3] | 65535 & n4[0]];
              this.wn = 0;
              for (r3 = 0; r3 < 4; r3++) this.nextState();
              for (r3 = 0; r3 < 8; r3++) e2[r3] ^= i3[r3 + 4 & 7];
              if (t4) {
                var o2 = t4.words, u2 = o2[0], f2 = o2[1], c2 = 16711935 & (u2 << 8 | u2 >>> 24) | 4278255360 & (u2 << 24 | u2 >>> 8), s22 = 16711935 & (f2 << 8 | f2 >>> 24) | 4278255360 & (f2 << 24 | f2 >>> 8), a = c2 >>> 16 | 4294901760 & s22, h = s22 << 16 | 65535 & c2;
                e2[0] ^= c2, e2[1] ^= a, e2[2] ^= s22, e2[3] ^= h, e2[4] ^= c2, e2[5] ^= a, e2[6] ^= s22, e2[7] ^= h;
                for (r3 = 0; r3 < 4; r3++) this.nextState();
              }
            }, t3.prototype.un = function(n4, t4) {
              var r3 = this.hn;
              this.nextState(), this.S[0] = r3[0] ^ r3[5] >>> 16 ^ r3[3] << 16, this.S[1] = r3[2] ^ r3[7] >>> 16 ^ r3[5] << 16, this.S[2] = r3[4] ^ r3[1] >>> 16 ^ r3[7] << 16, this.S[3] = r3[6] ^ r3[3] >>> 16 ^ r3[1] << 16;
              for (var i3 = 0; i3 < 4; i3++) this.S[i3] = 16711935 & (this.S[i3] << 8 | this.S[i3] >>> 24) | 4278255360 & (this.S[i3] << 24 | this.S[i3] >>> 8), n4[t4 + i3] ^= this.S[i3];
            }, t3.prototype.nextState = function() {
              for (var n4 = this.hn, t4 = this.vn, r3 = 0; r3 < 8; r3++) this.C[r3] = t4[r3];
              t4[0] = t4[0] + 1295307597 + this.wn | 0, t4[1] = t4[1] + 3545052371 + (t4[0] >>> 0 < this.C[0] >>> 0 ? 1 : 0) | 0, t4[2] = t4[2] + 886263092 + (t4[1] >>> 0 < this.C[1] >>> 0 ? 1 : 0) | 0, t4[3] = t4[3] + 1295307597 + (t4[2] >>> 0 < this.C[2] >>> 0 ? 1 : 0) | 0, t4[4] = t4[4] + 3545052371 + (t4[3] >>> 0 < this.C[3] >>> 0 ? 1 : 0) | 0, t4[5] = t4[5] + 886263092 + (t4[4] >>> 0 < this.C[4] >>> 0 ? 1 : 0) | 0, t4[6] = t4[6] + 1295307597 + (t4[5] >>> 0 < this.C[5] >>> 0 ? 1 : 0) | 0, t4[7] = t4[7] + 3545052371 + (t4[6] >>> 0 < this.C[6] >>> 0 ? 1 : 0) | 0, this.wn = t4[7] >>> 0 < this.C[7] >>> 0 ? 1 : 0;
              for (r3 = 0; r3 < 8; r3++) {
                var i3 = n4[r3] + t4[r3], e2 = 65535 & i3, o2 = i3 >>> 16, u2 = ((e2 * e2 >>> 17) + e2 * o2 >>> 15) + o2 * o2, f2 = ((4294901760 & i3) * i3 | 0) + ((65535 & i3) * i3 | 0);
                this.G[r3] = u2 ^ f2;
              }
              var c2 = this.G;
              n4[0] = c2[0] + (c2[7] << 16 | c2[7] >>> 16) + (c2[6] << 16 | c2[6] >>> 16) | 0, n4[1] = c2[1] + (c2[0] << 8 | c2[0] >>> 24) + c2[7] | 0, n4[2] = c2[2] + (c2[1] << 16 | c2[1] >>> 16) + (c2[0] << 16 | c2[0] >>> 16) | 0, n4[3] = c2[3] + (c2[2] << 8 | c2[2] >>> 24) + c2[1] | 0, n4[4] = c2[4] + (c2[3] << 16 | c2[3] >>> 16) + (c2[2] << 16 | c2[2] >>> 16) | 0, n4[5] = c2[5] + (c2[4] << 8 | c2[4] >>> 24) + c2[3] | 0, n4[6] = c2[6] + (c2[5] << 16 | c2[5] >>> 16) + (c2[4] << 16 | c2[4] >>> 16) | 0, n4[7] = c2[7] + (c2[6] << 8 | c2[6] >>> 24) + c2[5] | 0;
            }, t3.createEncryptor = function(n4, r3) {
              return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
            }, t3.createDecryptor = function(n4, r3) {
              return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
            }, t3.encrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? o.E.encrypt(t3, n4, r3, i3) : u.D.encrypt(t3, n4, r3, i3);
            }, t3.decrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? o.E.decrypt(t3, n4, r3, i3) : u.D.decrypt(t3, n4, r3, i3);
            }, t3.ivSize = 4, t3;
          }(e.q);
        }, 3173: function(n22, t2, r2) {
          r2.d(t2, { SHA1: function() {
            return c;
          } });
          var i2, e = r2(1868), o = r2(3354), u = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), f = [], c = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.on = new o.e([1732584193, 4023233417, 2562383102, 271733878, 3285377520]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
            }
            return u(t3, n3), t3.prototype.A = function() {
              this.on = new o.e([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
            }, t3.prototype.un = function(n4, t4) {
              for (var r3 = this.on.words, i3 = r3[0], e2 = r3[1], o2 = r3[2], u2 = r3[3], c2 = r3[4], s2 = 0; s2 < 80; s2++) {
                if (s2 < 16) f[s2] = 0 | n4[t4 + s2];
                else {
                  var a = f[s2 - 3] ^ f[s2 - 8] ^ f[s2 - 14] ^ f[s2 - 16];
                  f[s2] = a << 1 | a >>> 31;
                }
                var h = (i3 << 5 | i3 >>> 27) + c2 + f[s2];
                h += s2 < 20 ? 1518500249 + (e2 & o2 | ~e2 & u2) : s2 < 40 ? 1859775393 + (e2 ^ o2 ^ u2) : s2 < 60 ? (e2 & o2 | e2 & u2 | o2 & u2) - 1894007588 : (e2 ^ o2 ^ u2) - 899497514, c2 = u2, u2 = o2, o2 = e2 << 30 | e2 >>> 2, e2 = i3, i3 = h;
              }
              r3[0] = r3[0] + i3 | 0, r3[1] = r3[1] + e2 | 0, r3[2] = r3[2] + o2 | 0, r3[3] = r3[3] + u2 | 0, r3[4] = r3[4] + c2 | 0;
            }, t3.prototype.fn = function() {
              var n4 = this.cn.words, t4 = 8 * this.sn, r3 = 8 * this.cn.nSigBytes;
              return n4[r3 >>> 5] |= 128 << 24 - r3 % 32, n4[14 + (r3 + 64 >>> 9 << 4)] = Math.floor(t4 / 4294967296), n4[15 + (r3 + 64 >>> 9 << 4)] = t4, this.cn.nSigBytes = 4 * n4.length, this.an(), this.on;
            }, t3.prototype.clone = function() {
              return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
            }, t3.hash = function(n4, r3) {
              return new t3(r3).finalize(n4);
            }, t3;
          }(e.P);
        }, 766: function(n22, t2, r2) {
          r2.d(t2, { SHA224: function() {
            return f;
          } });
          var i2, e = r2(3354), o = r2(5561), u = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), f = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.on = new e.e([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
            }
            return u(t3, n3), t3.prototype.A = function() {
              this.on = new e.e([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]);
            }, t3.prototype.fn = function() {
              var t4 = n3.prototype.fn.call(this);
              return t4.nSigBytes -= 4, t4;
            }, t3.prototype.clone = function() {
              return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
            }, t3.hash = function(n4, r3) {
              return new t3(r3).finalize(n4);
            }, t3;
          }(o.SHA256);
        }, 5561: function(n22, t2, r2) {
          r2.d(t2, { SHA256: function() {
            return v;
          } });
          var i2, e = r2(1868), o = r2(3354), u = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), f = [], c = [];
          function s2(n3) {
            for (var t3 = Math.sqrt(n3), r3 = 2; r3 <= t3; r3++) if (!(n3 % r3)) return false;
            return true;
          }
          function a(n3) {
            return 4294967296 * (n3 - (0 | n3)) | 0;
          }
          !function() {
            for (var n3 = 2, t3 = 0; t3 < 64; ) s2(n3) && (t3 < 8 && (f[t3] = a(Math.pow(n3, 0.5))), c[t3] = a(Math.pow(n3, 1 / 3)), t3++), n3++;
          }();
          var h = [], v = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.on = new o.e(f.slice(0)), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
            }
            return u(t3, n3), t3.prototype.A = function() {
              this.on = new o.e(f.slice(0));
            }, t3.prototype.un = function(n4, t4) {
              for (var r3 = this.on.words, i3 = r3[0], e2 = r3[1], o2 = r3[2], u2 = r3[3], f2 = r3[4], s22 = r3[5], a2 = r3[6], v2 = r3[7], w = 0; w < 64; w++) {
                if (w < 16) h[w] = 0 | n4[t4 + w];
                else {
                  var l2 = h[w - 15], b = (l2 << 25 | l2 >>> 7) ^ (l2 << 14 | l2 >>> 18) ^ l2 >>> 3, d = h[w - 2], y = (d << 15 | d >>> 17) ^ (d << 13 | d >>> 19) ^ d >>> 10;
                  h[w] = b + h[w - 7] + y + h[w - 16];
                }
                var p = i3 & e2 ^ i3 & o2 ^ e2 & o2, O = (i3 << 30 | i3 >>> 2) ^ (i3 << 19 | i3 >>> 13) ^ (i3 << 10 | i3 >>> 22), j = v2 + ((f2 << 26 | f2 >>> 6) ^ (f2 << 21 | f2 >>> 11) ^ (f2 << 7 | f2 >>> 25)) + (f2 & s22 ^ ~f2 & a2) + c[w] + h[w];
                v2 = a2, a2 = s22, s22 = f2, f2 = u2 + j | 0, u2 = o2, o2 = e2, e2 = i3, i3 = j + (O + p) | 0;
              }
              r3[0] = r3[0] + i3 | 0, r3[1] = r3[1] + e2 | 0, r3[2] = r3[2] + o2 | 0, r3[3] = r3[3] + u2 | 0, r3[4] = r3[4] + f2 | 0, r3[5] = r3[5] + s22 | 0, r3[6] = r3[6] + a2 | 0, r3[7] = r3[7] + v2 | 0;
            }, t3.prototype.fn = function() {
              var n4 = this.cn.words, t4 = 8 * this.sn, r3 = 8 * this.cn.nSigBytes;
              return n4[r3 >>> 5] |= 128 << 24 - r3 % 32, n4[14 + (r3 + 64 >>> 9 << 4)] = Math.floor(t4 / 4294967296), n4[15 + (r3 + 64 >>> 9 << 4)] = t4, this.cn.nSigBytes = 4 * n4.length, this.an(), this.on;
            }, t3.prototype.clone = function() {
              return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
            }, t3.hash = function(n4, r3) {
              return new t3(r3).finalize(n4);
            }, t3;
          }(e.P);
        }, 3408: function(n22, t2, r2) {
          r2.d(t2, { SHA3: function() {
            return v;
          } });
          var i2, e = r2(6957), o = r2(1868), u = r2(3354), f = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), c = [], s2 = [], a = [];
          !function() {
            for (var n3 = 1, t3 = 0, r3 = 0; r3 < 24; r3++) {
              c[n3 + 5 * t3] = (r3 + 1) * (r3 + 2) / 2 % 64;
              var i3 = (2 * n3 + 3 * t3) % 5;
              n3 = t3 % 5, t3 = i3;
            }
            for (var o2 = 0; o2 < 5; o2++) for (var u2 = 0; u2 < 5; u2++) s2[o2 + 5 * u2] = u2 + (2 * o2 + 3 * u2) % 5 * 5;
            for (var f2 = 1, h2 = 0; h2 < 24; h2++) {
              for (var v2 = 0, w = 0, l2 = 0; l2 < 7; l2++) {
                if (1 & f2) {
                  var b = (1 << l2) - 1;
                  b < 32 ? w ^= 1 << b : v2 ^= 1 << b - 32;
                }
                128 & f2 ? f2 = f2 << 1 ^ 113 : f2 <<= 1;
              }
              a[h2] = new e.r(v2, w);
            }
          }();
          var h = [];
          !function() {
            for (var n3 = 0; n3 < 25; n3++) h[n3] = new e.r(0, 0);
          }();
          var v = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              if (r3.N = 32, r3.bn = [], r3.dn = 512, r3.O = t4, t4) {
                if (void 0 !== t4.outputLength) {
                  if (![224, 256, 384, 512].includes(t4.outputLength)) throw new Error("Unsupported output length.");
                  r3.dn = t4.outputLength;
                }
                void 0 !== t4.state && (r3.bn = t4.state.map(function(n4) {
                  return n4.clone();
                }));
              }
              if (0 === r3.bn.length) for (var i3 = 0; i3 < 25; i3++) r3.bn[i3] = new e.r(0, 0);
              return r3.N = (1600 - 2 * r3.dn) / 32, r3;
            }
            return f(t3, n3), t3.prototype.A = function() {
              this.bn = [];
              for (var n4 = 0; n4 < 25; n4++) this.bn[n4] = new e.r(0, 0);
              this.N = (1600 - 2 * this.dn) / 32;
            }, t3.prototype.un = function(n4, t4) {
              for (var r3 = this.bn, i3 = this.N / 2, e2 = 0; e2 < i3; e2++) {
                var o2 = n4[t4 + 2 * e2], u2 = n4[t4 + 2 * e2 + 1];
                o2 = 16711935 & (o2 << 8 | o2 >>> 24) | 4278255360 & (o2 << 24 | o2 >>> 8), u2 = 16711935 & (u2 << 8 | u2 >>> 24) | 4278255360 & (u2 << 24 | u2 >>> 8), r3[e2].high ^= u2, r3[e2].low ^= o2;
              }
              for (var f2 = 0; f2 < 24; f2++) {
                for (var v2 = 0; v2 < 5; v2++) {
                  for (var w = 0, l2 = 0, b = 0; b < 5; b++) {
                    w ^= (k = r3[v2 + 5 * b]).high, l2 ^= k.low;
                  }
                  var d = h[v2];
                  d.high = w, d.low = l2;
                }
                for (v2 = 0; v2 < 5; v2++) {
                  var y = h[(v2 + 4) % 5], p = h[(v2 + 1) % 5], O = p.high, j = p.low;
                  for (w = y.high ^ (O << 1 | j >>> 31), l2 = y.low ^ (j << 1 | O >>> 31), b = 0; b < 5; b++) {
                    (k = r3[v2 + 5 * b]).high ^= w, k.low ^= l2;
                  }
                }
                for (var _ = 1; _ < 25; _++) {
                  w = void 0, l2 = void 0;
                  var m = r3[_].high, A = r3[_].low, g = c[_];
                  g < 32 ? (w = m << g | A >>> 32 - g, l2 = A << g | m >>> 32 - g) : (w = A << g - 32 | m >>> 64 - g, l2 = m << g - 32 | A >>> 64 - g);
                  var E = h[s2[_]];
                  E.high = w, E.low = l2;
                }
                var S = h[0], M = r3[0];
                S.high = M.high, S.low = M.low;
                for (v2 = 0; v2 < 5; v2++) for (b = 0; b < 5; b++) {
                  var k = r3[_ = v2 + 5 * b], H = h[_], C = h[(v2 + 1) % 5 + 5 * b], B = h[(v2 + 2) % 5 + 5 * b];
                  k.high = H.high ^ ~C.high & B.high, k.low = H.low ^ ~C.low & B.low;
                }
                var N = r3[0], I = a[f2];
                N.high ^= I.high, N.low ^= I.low;
              }
            }, t3.prototype.fn = function() {
              var n4 = this.cn, t4 = n4.words, r3 = 8 * n4.nSigBytes, i3 = 32 * this.blockSize;
              t4[r3 >>> 5] |= 1 << 24 - r3 % 32, t4[(Math.ceil((r3 + 1) / i3) * i3 >>> 5) - 1] |= 128, n4.nSigBytes = 4 * t4.length, this.an();
              for (var e2 = this.bn, o2 = this.dn / 8, f2 = o2 / 8, c2 = [], s22 = 0; s22 < f2; s22++) {
                var a2 = e2[s22], h2 = a2.high, v2 = a2.low;
                h2 = 16711935 & (h2 << 8 | h2 >>> 24) | 4278255360 & (h2 << 24 | h2 >>> 8), v2 = 16711935 & (v2 << 8 | v2 >>> 24) | 4278255360 & (v2 << 24 | v2 >>> 8), c2.push(v2), c2.push(h2);
              }
              return new u.e(c2, o2);
            }, t3.prototype.clone = function() {
              return new t3({ outputLength: this.dn, state: this.bn, blockSize: this.N, data: this.cn, nBytes: this.sn });
            }, t3.hash = function(n4, r3) {
              return new t3(r3).finalize(n4);
            }, t3;
          }(o.P);
        }, 6324: function(n22, t2, r2) {
          r2.d(t2, { SHA384: function() {
            return f;
          } });
          var i2, e = r2(6957), o = r2(7491), u = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), f = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.on = new e.m([new e.r(3418070365, 3238371032), new e.r(1654270250, 914150663), new e.r(2438529370, 812702999), new e.r(355462360, 4144912697), new e.r(1731405415, 4290775857), new e.r(2394180231, 1750603025), new e.r(3675008525, 1694076839), new e.r(1203062813, 3204075428)]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
            }
            return u(t3, n3), t3.prototype.A = function() {
              this.on = new e.m([new e.r(3418070365, 3238371032), new e.r(1654270250, 914150663), new e.r(2438529370, 812702999), new e.r(355462360, 4144912697), new e.r(1731405415, 4290775857), new e.r(2394180231, 1750603025), new e.r(3675008525, 1694076839), new e.r(1203062813, 3204075428)]);
            }, t3.prototype.fn = function() {
              var t4 = n3.prototype.fn.call(this);
              return t4.nSigBytes -= 16, t4;
            }, t3.prototype.clone = function() {
              return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
            }, t3.hash = function(n4, r3) {
              return new t3(r3).finalize(n4);
            }, t3;
          }(o.SHA512);
        }, 7491: function(n22, t2, r2) {
          r2.d(t2, { SHA512: function() {
            return s2;
          } });
          var i2, e = r2(1868), o = r2(6957), u = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), f = [new o.r(1116352408, 3609767458), new o.r(1899447441, 602891725), new o.r(3049323471, 3964484399), new o.r(3921009573, 2173295548), new o.r(961987163, 4081628472), new o.r(1508970993, 3053834265), new o.r(2453635748, 2937671579), new o.r(2870763221, 3664609560), new o.r(3624381080, 2734883394), new o.r(310598401, 1164996542), new o.r(607225278, 1323610764), new o.r(1426881987, 3590304994), new o.r(1925078388, 4068182383), new o.r(2162078206, 991336113), new o.r(2614888103, 633803317), new o.r(3248222580, 3479774868), new o.r(3835390401, 2666613458), new o.r(4022224774, 944711139), new o.r(264347078, 2341262773), new o.r(604807628, 2007800933), new o.r(770255983, 1495990901), new o.r(1249150122, 1856431235), new o.r(1555081692, 3175218132), new o.r(1996064986, 2198950837), new o.r(2554220882, 3999719339), new o.r(2821834349, 766784016), new o.r(2952996808, 2566594879), new o.r(3210313671, 3203337956), new o.r(3336571891, 1034457026), new o.r(3584528711, 2466948901), new o.r(113926993, 3758326383), new o.r(338241895, 168717936), new o.r(666307205, 1188179964), new o.r(773529912, 1546045734), new o.r(1294757372, 1522805485), new o.r(1396182291, 2643833823), new o.r(1695183700, 2343527390), new o.r(1986661051, 1014477480), new o.r(2177026350, 1206759142), new o.r(2456956037, 344077627), new o.r(2730485921, 1290863460), new o.r(2820302411, 3158454273), new o.r(3259730800, 3505952657), new o.r(3345764771, 106217008), new o.r(3516065817, 3606008344), new o.r(3600352804, 1432725776), new o.r(4094571909, 1467031594), new o.r(275423344, 851169720), new o.r(430227734, 3100823752), new o.r(506948616, 1363258195), new o.r(659060556, 3750685593), new o.r(883997877, 3785050280), new o.r(958139571, 3318307427), new o.r(1322822218, 3812723403), new o.r(1537002063, 2003034995), new o.r(1747873779, 3602036899), new o.r(1955562222, 1575990012), new o.r(2024104815, 1125592928), new o.r(2227730452, 2716904306), new o.r(2361852424, 442776044), new o.r(2428436474, 593698344), new o.r(2756734187, 3733110249), new o.r(3204031479, 2999351573), new o.r(3329325298, 3815920427), new o.r(3391569614, 3928383900), new o.r(3515267271, 566280711), new o.r(3940187606, 3454069534), new o.r(4118630271, 4000239992), new o.r(116418474, 1914138554), new o.r(174292421, 2731055270), new o.r(289380356, 3203993006), new o.r(460393269, 320620315), new o.r(685471733, 587496836), new o.r(852142971, 1086792851), new o.r(1017036298, 365543100), new o.r(1126000580, 2618297676), new o.r(1288033470, 3409855158), new o.r(1501505948, 4234509866), new o.r(1607167915, 987167468), new o.r(1816402316, 1246189591)], c = [];
          !function() {
            for (var n3 = 0; n3 < 80; n3++) c[n3] = new o.r(0, 0);
          }();
          var s2 = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.N = 32, r3.on = new o.m([new o.r(1779033703, 4089235720), new o.r(3144134277, 2227873595), new o.r(1013904242, 4271175723), new o.r(2773480762, 1595750129), new o.r(1359893119, 2917565137), new o.r(2600822924, 725511199), new o.r(528734635, 4215389547), new o.r(1541459225, 327033209)]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
            }
            return u(t3, n3), t3.prototype.A = function() {
              this.on = new o.m([new o.r(1779033703, 4089235720), new o.r(3144134277, 2227873595), new o.r(1013904242, 4271175723), new o.r(2773480762, 1595750129), new o.r(1359893119, 2917565137), new o.r(2600822924, 725511199), new o.r(528734635, 4215389547), new o.r(1541459225, 327033209)]);
            }, t3.prototype.un = function(n4, t4) {
              for (var r3 = this.on.words, i3 = r3[0], e2 = r3[1], o2 = r3[2], u2 = r3[3], s22 = r3[4], a = r3[5], h = r3[6], v = r3[7], w = i3.high, l2 = i3.low, b = e2.high, d = e2.low, y = o2.high, p = o2.low, O = u2.high, j = u2.low, _ = s22.high, m = s22.low, A = a.high, g = a.low, E = h.high, S = h.low, M = v.high, k = v.low, H = w, C = l2, B = b, N = d, I = y, z = p, D = O, U = j, L = _, F = m, x = A, P = g, R = E, T = S, K = M, W = k, G = 0; G < 80; G++) {
                var q = void 0, Q = void 0, X = c[G];
                if (G < 16) Q = X.high = 0 | n4[t4 + 2 * G], q = X.low = 0 | n4[t4 + 2 * G + 1];
                else {
                  var V = c[G - 15], Z = V.high, J = V.low, Y = (Z >>> 1 | J << 31) ^ (Z >>> 8 | J << 24) ^ Z >>> 7, $ = (J >>> 1 | Z << 31) ^ (J >>> 8 | Z << 24) ^ (J >>> 7 | Z << 25), nn = c[G - 2], tn = nn.high, rn = nn.low, en = (tn >>> 19 | rn << 13) ^ (tn << 3 | rn >>> 29) ^ tn >>> 6, on = (rn >>> 19 | tn << 13) ^ (rn << 3 | tn >>> 29) ^ (rn >>> 6 | tn << 26), un = c[G - 7], fn = un.high, cn = un.low, sn = c[G - 16], an = sn.high, hn = sn.low;
                  Q = (Q = (Q = Y + fn + ((q = $ + cn) >>> 0 < $ >>> 0 ? 1 : 0)) + en + ((q += on) >>> 0 < on >>> 0 ? 1 : 0)) + an + ((q += hn) >>> 0 < hn >>> 0 ? 1 : 0), X.high = Q, X.low = q;
                }
                var vn = L & x ^ ~L & R, wn = F & P ^ ~F & T, ln = H & B ^ H & I ^ B & I, bn = C & N ^ C & z ^ N & z, dn = (H >>> 28 | C << 4) ^ (H << 30 | C >>> 2) ^ (H << 25 | C >>> 7), yn = (C >>> 28 | H << 4) ^ (C << 30 | H >>> 2) ^ (C << 25 | H >>> 7), pn = (L >>> 14 | F << 18) ^ (L >>> 18 | F << 14) ^ (L << 23 | F >>> 9), On = (F >>> 14 | L << 18) ^ (F >>> 18 | L << 14) ^ (F << 23 | L >>> 9), jn = f[G], _n = jn.high, mn = jn.low, An = W + On, gn = K + pn + (An >>> 0 < W >>> 0 ? 1 : 0), En = yn + bn;
                K = R, W = T, R = x, T = P, x = L, P = F, L = D + (gn = (gn = (gn = gn + vn + ((An += wn) >>> 0 < wn >>> 0 ? 1 : 0)) + _n + ((An += mn) >>> 0 < mn >>> 0 ? 1 : 0)) + Q + ((An += q) >>> 0 < q >>> 0 ? 1 : 0)) + ((F = U + An | 0) >>> 0 < U >>> 0 ? 1 : 0) | 0, D = I, U = z, I = B, z = N, B = H, N = C, H = gn + (dn + ln + (En >>> 0 < yn >>> 0 ? 1 : 0)) + ((C = An + En | 0) >>> 0 < An >>> 0 ? 1 : 0) | 0;
              }
              l2 = i3.low = l2 + C, i3.high = w + H + (l2 >>> 0 < C >>> 0 ? 1 : 0), d = e2.low = d + N, e2.high = b + B + (d >>> 0 < N >>> 0 ? 1 : 0), p = o2.low = p + z, o2.high = y + I + (p >>> 0 < z >>> 0 ? 1 : 0), j = u2.low = j + U, u2.high = O + D + (j >>> 0 < U >>> 0 ? 1 : 0), m = s22.low = m + F, s22.high = _ + L + (m >>> 0 < F >>> 0 ? 1 : 0), g = a.low = g + P, a.high = A + x + (g >>> 0 < P >>> 0 ? 1 : 0), S = h.low = S + T, h.high = E + R + (S >>> 0 < T >>> 0 ? 1 : 0), k = v.low = k + W, v.high = M + K + (k >>> 0 < W >>> 0 ? 1 : 0);
            }, t3.prototype.fn = function() {
              var n4 = this.cn, t4 = n4.words, r3 = 8 * this.sn, i3 = 8 * n4.nSigBytes;
              return t4[i3 >>> 5] |= 128 << 24 - i3 % 32, t4[30 + (i3 + 128 >>> 10 << 5)] = Math.floor(r3 / 4294967296), t4[31 + (i3 + 128 >>> 10 << 5)] = r3, n4.nSigBytes = 4 * t4.length, this.an(), this.on.to32();
            }, t3.prototype.clone = function() {
              return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
            }, t3.hash = function(n4, r3) {
              return new t3(r3).finalize(n4);
            }, t3;
          }(e.P);
        }, 3354: function(n22, t2, r2) {
          r2.d(t2, { e: function() {
            return o;
          } });
          var i2 = r2(5720), e = r2(9054), o = function() {
            function n3(t3, r3) {
              if (Array.isArray(t3) || !t3) return this.yn = Array.isArray(t3) ? t3 : [], void (this.pn = "number" == typeof r3 ? r3 : 4 * this.yn.length);
              if (t3 instanceof n3) return this.yn = t3.words.slice(), void (this.pn = t3.nSigBytes);
              var i3;
              try {
                t3 instanceof ArrayBuffer ? i3 = new Uint8Array(t3) : (t3 instanceof Uint8Array || t3 instanceof Int8Array || t3 instanceof Uint8ClampedArray || t3 instanceof Int16Array || t3 instanceof Uint16Array || t3 instanceof Int32Array || t3 instanceof Uint32Array || t3 instanceof Float32Array || t3 instanceof Float64Array) && (i3 = new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength));
              } catch (n4) {
                throw new Error("Invalid argument");
              }
              if (!i3) throw new Error("Invalid argument");
              for (var e2 = i3.byteLength, o2 = [], u = 0; u < e2; u++) o2[u >>> 2] |= i3[u] << 24 - u % 4 * 8;
              this.yn = o2, this.pn = e2;
            }
            return Object.defineProperty(n3.prototype, "nSigBytes", { get: function() {
              return this.pn;
            }, set: function(n4) {
              this.pn = n4;
            }, enumerable: false, configurable: true }), Object.defineProperty(n3.prototype, "words", { get: function() {
              return this.yn;
            }, enumerable: false, configurable: true }), n3.prototype.toString = function(n4) {
              return n4 ? n4.stringify(this) : i2.p.stringify(this);
            }, n3.prototype.toUint8Array = function() {
              for (var n4 = this.yn, t3 = this.pn, r3 = new Uint8Array(t3), i3 = 0; i3 < t3; i3++) r3[i3] = n4[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
              return r3;
            }, n3.prototype.concat = function(n4) {
              var t3 = n4.words.slice(), r3 = n4.nSigBytes;
              if (this.clamp(), this.pn % 4) for (var i3 = 0; i3 < r3; i3++) {
                var e2 = t3[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
                this.yn[this.pn + i3 >>> 2] |= e2 << 24 - (this.pn + i3) % 4 * 8;
              }
              else for (i3 = 0; i3 < r3; i3 += 4) this.yn[this.pn + i3 >>> 2] = t3[i3 >>> 2];
              return this.pn += r3, this;
            }, n3.prototype.clamp = function() {
              var n4 = this.pn;
              this.yn[n4 >>> 2] &= 4294967295 << 32 - n4 % 4 * 8, this.yn.length = Math.ceil(n4 / 4);
            }, n3.prototype.clone = function() {
              return new n3(this.yn.slice(), this.pn);
            }, n3.random = function(t3) {
              for (var r3 = [], i3 = 0; i3 < t3; i3 += 4) r3.push((0, e.M)());
              return new n3(r3, t3);
            }, n3;
          }();
        }, 6957: function(n22, t2, r2) {
          r2.d(t2, { r: function() {
            return o;
          }, m: function() {
            return u;
          } });
          var i2 = r2(5720), e = r2(3354), o = function() {
            function n3(n4, t3) {
              this.high = n4, this.low = t3;
            }
            return n3.prototype.clone = function() {
              return new n3(this.high, this.low);
            }, n3;
          }(), u = function() {
            function n3(n4, t3) {
              this.yn = n4 || [], this.pn = "number" == typeof t3 ? t3 : 8 * this.yn.length;
            }
            return Object.defineProperty(n3.prototype, "nSigBytes", { get: function() {
              return this.pn;
            }, set: function(n4) {
              this.pn = n4;
            }, enumerable: false, configurable: true }), Object.defineProperty(n3.prototype, "words", { get: function() {
              return this.yn;
            }, enumerable: false, configurable: true }), n3.prototype.to32 = function() {
              for (var n4 = [], t3 = 0; t3 < this.yn.length; t3++) {
                var r3 = this.yn[t3];
                n4.push(r3.high), n4.push(r3.low);
              }
              return new e.e(n4, this.pn);
            }, n3.prototype.toString = function(n4) {
              return n4 ? n4.stringify(this.to32()) : i2.p.stringify(this.to32());
            }, n3.prototype.clone = function() {
              for (var t3 = this.yn.slice(), r3 = 0; r3 < t3.length; r3++) t3[r3] = t3[r3].clone();
              return new n3(t3, this.pn);
            }, n3;
          }();
        }, 7211: function(n22, t2, r2) {
          r2.d(t2, { C: function() {
            return o;
          } });
          var i2 = r2(3354), e = r2(4768), o = function() {
            function n3(n4) {
              this.On = 0, this.N = 0, this.O = n4, this.cn = n4 && void 0 !== n4.data ? n4.data.clone() : new i2.e(), this.sn = n4 && "number" == typeof n4.nBytes ? n4.nBytes : 0;
            }
            return Object.defineProperty(n3.prototype, "blockSize", { get: function() {
              return this.N;
            }, enumerable: false, configurable: true }), n3.prototype.reset = function(n4, t3) {
              this.cn = void 0 !== n4 ? n4.clone() : new i2.e(), this.sn = "number" == typeof t3 ? t3 : 0;
            }, n3.prototype.jn = function(n4) {
              var t3 = "string" == typeof n4 ? e.d.parse(n4) : n4;
              this.cn.concat(t3), this.sn += t3.nSigBytes;
            }, n3.prototype.an = function(n4) {
              var t3, r3 = this.cn.words, e2 = this.cn.nSigBytes, o2 = this.N, u = e2 / (4 * this.N), f = (u = n4 ? Math.ceil(u) : Math.max((0 | u) - this.On, 0)) * o2, c = Math.min(4 * f, e2);
              if (f) {
                for (var s2 = 0; s2 < f; s2 += o2) this.un(r3, s2);
                t3 = r3.splice(0, f), this.cn.nSigBytes -= c;
              }
              return new i2.e(t3, c);
            }, n3.prototype.un = function(n4, t3) {
              throw new Error("Not implemented");
            }, n3;
          }();
        }, 1868: function(n22, t2, r2) {
          r2.d(t2, { P: function() {
            return u;
          } });
          var i2, e = r2(7211), o = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), u = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.N = 16, r3.O = t4, t4 && "number" == typeof t4.blockSize && (r3.N = t4.blockSize), r3.reset(t4 ? t4.data : void 0, t4 ? t4.nBytes : void 0), r3;
            }
            return o(t3, n3), Object.defineProperty(t3.prototype, "blockSize", { get: function() {
              return this.N;
            }, enumerable: false, configurable: true }), t3.prototype.reset = function(t4, r3) {
              n3.prototype.reset.call(this, t4, r3), this.A();
            }, t3.prototype.update = function(n4) {
              return this.jn(n4), this.an(), this;
            }, t3.prototype.finalize = function(n4) {
              return n4 && this.jn(n4), this.fn();
            }, t3.prototype.A = function() {
              throw new Error("Not implemented");
            }, t3.prototype.fn = function() {
              throw new Error("Not implemented");
            }, t3;
          }(e.C);
        }, 787: function(n22, t2, r2) {
          r2.d(t2, { G: function() {
            return s2;
          } });
          var i2, e = r2(9456), o = r2(4344), u = r2(7919), f = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), c = function() {
            return (c = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, s2 = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.N = 4, r3._n = o.n, r3.mn = u.l, r3.O = t4, r3._n = void 0 !== t4.mode ? t4.mode : r3._n, r3.mn = void 0 !== t4.padding ? t4.padding : r3.mn, r3.reset(null == t4 ? void 0 : t4.data, null == t4 ? void 0 : t4.nBytes), r3;
            }
            return f(t3, n3), Object.defineProperty(t3.prototype, "mode", { get: function() {
              return this.An;
            }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "padding", { get: function() {
              return this.mn;
            }, enumerable: false, configurable: true }), t3.prototype.reset = function(t4, r3) {
              var i3;
              n3.prototype.reset.call(this, t4, r3), this.gn === e.t.ENC_TRANSFORM_MODE ? i3 = this._n.createEncryptor : (i3 = this._n.createDecryptor, this.On = 1), this._n && this.En === i3 ? this.An = new this._n({ cipher: this, iv: this.ln }) : (this.An = i3.call(this._n, { cipher: this, iv: this.ln }), this.En = i3);
            }, t3.prototype.un = function(n4, t4) {
              var r3;
              null === (r3 = this.An) || void 0 === r3 || r3.processBlock(n4, t4);
            }, t3.prototype.fn = function() {
              var n4, t4 = this.mn;
              return this.gn === e.t.ENC_TRANSFORM_MODE ? (t4.pad(this.cn, this.blockSize), n4 = this.an(true)) : (n4 = this.an(true), t4.unpad(n4)), n4;
            }, t3.prototype.encryptBlock = function(n4, t4) {
              throw new Error("Not implemented");
            }, t3.prototype.decryptBlock = function(n4, t4) {
              throw new Error("Not implemented");
            }, t3.createEncryptor = function(n4, r3) {
              return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: e.t.ENC_TRANSFORM_MODE }));
            }, t3.createDecryptor = function(n4, r3) {
              return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: e.t.DEC_TRANSFORM_MODE }));
            }, t3;
          }(e.t);
        }, 9456: function(n22, t2, r2) {
          r2.d(t2, { t: function() {
            return f;
          } });
          var i2, e = r2(7211), o = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), u = function() {
            return (u = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, f = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.gn = 1, r3.O = t4, r3.H = t4.key, r3.ln = void 0 !== t4.iv ? t4.iv : r3.ln, r3.gn = void 0 !== t4.transformMode ? t4.transformMode : r3.gn, r3;
            }
            return o(t3, n3), Object.defineProperty(t3.prototype, "iv", { get: function() {
              return this.ln;
            }, enumerable: false, configurable: true }), t3.prototype.reset = function(t4, r3) {
              n3.prototype.reset.call(this, t4, r3), this.A();
            }, t3.prototype.process = function(n4) {
              return this.jn(n4), this.an();
            }, t3.prototype.finalize = function(n4) {
              return n4 && this.jn(n4), this.fn();
            }, t3.prototype.A = function() {
              throw new Error("Not implemented");
            }, t3.prototype.un = function(n4, t4) {
              throw new Error("Not implemented");
            }, t3.prototype.fn = function() {
              throw new Error("Not implemented");
            }, t3.createEncryptor = function(n4, r3) {
              return new t3(u(u({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: t3.ENC_TRANSFORM_MODE }));
            }, t3.createDecryptor = function(n4, r3) {
              return new t3(u(u({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: t3.DEC_TRANSFORM_MODE }));
            }, t3.ENC_TRANSFORM_MODE = 1, t3.DEC_TRANSFORM_MODE = 2, t3.keySize = 4, t3.ivSize = 4, t3;
          }(e.C);
        }, 2505: function(n22, t2, r2) {
          r2.d(t2, { Q: function() {
            return e;
          } });
          var i2 = r2(1232), e = function() {
            function n3(n4) {
              this.formatter = i2.w, n4 && (this.cipherText = n4.cipherText, this.key = n4.key, this.iv = n4.iv, this.salt = n4.salt, this.Algorithm = n4.Algorithm, this.mode = n4.mode, this.padding = n4.padding, this.blockSize = n4.blockSize, this.formatter = n4.formatter || i2.w);
            }
            return n3.prototype.toString = function(n4) {
              return (n4 || this.formatter).stringify(this);
            }, n3;
          }();
        }, 5693: function(n22, t2, r2) {
          r2.d(t2, { E: function() {
            return c;
          } });
          var i2 = r2(9109), e = r2(2214), o = r2(2505), u = r2(1232), f = function() {
            return (f = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, c = { encrypt: function(n3, t3, r3, u2) {
            var c2 = u2 ? f({}, u2) : {}, s2 = u2 && u2.KDF ? u2.KDF : e.s, a = {};
            u2 && u2.kdfHasher && (a.kdfHasher = u2.kdfHasher), u2 && u2.kdfIterations && (a.kdfIterations = u2.kdfIterations), u2 && u2.kdfModule && (a.kdfModule = u2.kdfModule);
            var h = s2.execute(r3, n3.keySize, n3.ivSize, c2.kdfSalt, a);
            c2.iv = h.iv;
            var v = i2.D.encrypt(n3, t3, h.key, c2);
            return new o.Q(f(f({}, v), { key: h.key, iv: h.iv, salt: h.salt }));
          }, decrypt: function(n3, t3, r3, o2) {
            var c2 = o2 ? f({}, o2) : {}, s2 = c2.KDF ? c2.KDF : e.s, a = c2.formatter ? c2.formatter : u.w, h = (0, i2.W)(t3, a), v = {};
            o2 && o2.kdfHasher && (v.kdfHasher = o2.kdfHasher), o2 && o2.kdfIterations && (v.kdfIterations = o2.kdfIterations), o2 && o2.kdfModule && (v.kdfModule = o2.kdfModule);
            var w = s2.execute(r3, n3.keySize, n3.ivSize, h.salt, v);
            return c2.iv = w.iv, i2.D.decrypt(n3, h, w.key, c2);
          } };
        }, 9109: function(n22, t2, r2) {
          r2.d(t2, { W: function() {
            return o;
          }, D: function() {
            return u;
          } });
          var i2 = r2(1232), e = r2(2505);
          function o(n3, t3) {
            return "string" == typeof n3 ? t3.parse(n3) : n3;
          }
          var u = { encrypt: function(n3, t3, r3, o2) {
            var u2 = n3.createEncryptor(r3, o2), f = u2.finalize(t3);
            return new e.Q({ cipherText: f, key: r3, iv: u2.iv, Algorithm: n3, mode: u2.mode, padding: u2.padding, blockSize: u2.blockSize, formatter: (null == o2 ? void 0 : o2.formatter) || i2.w });
          }, decrypt: function(n3, t3, r3, e2) {
            var u2 = n3.createDecryptor(r3, e2), f = o(t3, (null == e2 ? void 0 : e2.formatter) || i2.w);
            return u2.finalize(f.cipherText || "");
          } };
        }, 30: function(n22, t2, r2) {
          r2.d(t2, { q: function() {
            return u;
          } });
          var i2, e = r2(9456), o = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), u = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.N = 1, r3;
            }
            return o(t3, n3), t3.prototype.fn = function() {
              return this.an(true);
            }, t3;
          }(e.t);
        }, 1232: function(n22, t2, r2) {
          r2.d(t2, { w: function() {
            return u;
          } });
          var i2 = r2(2505), e = r2(3354), o = r2(1773), u = { stringify: function(n3) {
            var t3 = n3.cipherText, r3 = n3.salt;
            return t3 ? r3 ? new e.e([1398893684, 1701076831]).concat(r3).concat(t3).toString(o.D) : t3.toString(o.D) : "";
          }, parse: function(n3) {
            var t3, r3 = o.D.parse(n3), u2 = r3.words;
            return 1398893684 === u2[0] && 1701076831 === u2[1] && (t3 = new e.e(u2.slice(2, 4)), u2.splice(0, 4), r3.nSigBytes -= 16), new i2.Q({ cipherText: r3, salt: t3 });
          } };
        }, 2214: function(n22, t2, r2) {
          r2.d(t2, { s: function() {
            return f;
          } });
          var i2 = r2(3354), e = r2(2505), o = r2(7008), u = function() {
            return (u = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, f = { execute: function(n3, t3, r3, f2, c) {
            f2 || (f2 = i2.e.random(8));
            var s2 = c && c.kdfModule || o.E, a = c ? { Hasher: c.kdfHasher, iterations: c.kdfIterations } : {}, h = s2.getKey(n3, f2, u(u({}, a), { keySize: t3 + r3 })), v = new i2.e(h.words.slice(t3), 4 * r3);
            return h.nSigBytes = 4 * t3, new e.Q({ key: h, iv: v, salt: f2 });
          } };
        }, 7008: function(n22, t2, r2) {
          r2.d(t2, { E: function() {
            return s2;
          } });
          var i2, e = r2(5561), o = r2(6367), u = r2(3354), f = r2(9541), c = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), s2 = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.Sn = 4, r3.Mn = e.SHA256, r3.kn = 1e4, t4 && (r3.Sn = void 0 !== t4.keySize ? t4.keySize : r3.Sn, r3.Mn = void 0 !== t4.Hasher ? t4.Hasher : r3.Mn, r3.kn = void 0 !== t4.iterations ? t4.iterations : r3.kn), r3;
            }
            return c(t3, n3), t3.prototype.compute = function(n4, t4) {
              for (var r3 = new o.Hmac(new this.Mn(), n4), i3 = new u.e(), e2 = new u.e([1]), f2 = i3.words, c2 = e2.words, s22 = this.Sn, a = this.kn; f2.length < s22; ) {
                var h = r3.update(t4).finalize(e2);
                r3.reset();
                for (var v = h.words, w = v.length, l2 = h, b = 1; b < a; b++) {
                  l2 = r3.finalize(l2), r3.reset();
                  for (var d = l2.words, y = 0; y < w; y++) v[y] ^= d[y];
                }
                i3.concat(h), c2[0]++;
              }
              return i3.nSigBytes = 4 * s22, i3;
            }, t3.getKey = function(n4, r3, i3) {
              return new t3(i3).compute(n4, r3);
            }, t3;
          }(f._);
        }, 9541: function(n22, t2, r2) {
          r2.d(t2, { _: function() {
            return i2;
          } });
          var i2 = function() {
            function n3(n4) {
              this.O = n4;
            }
            return n3.prototype.compute = function(n4, t3) {
              throw new Error("Not implemented");
            }, n3.getKey = function(n4, t3, r3) {
              throw new Error("Not implemented");
            }, n3;
          }();
        }, 1863: function(n22, t2, r2) {
          r2.d(t2, { T: function() {
            return i2;
          } });
          var i2 = function() {
            function n3(n4) {
              this.O = n4, this.Hn = n4.cipher, this.ln = n4.iv;
            }
            return n3.prototype.processBlock = function(n4, t3) {
            }, n3.createEncryptor = function(n4) {
              throw new Error("Not implemented yet");
            }, n3.createDecryptor = function(n4) {
              throw new Error("Not implemented yet");
            }, n3;
          }();
        }, 4344: function(n22, t2, r2) {
          r2.d(t2, { n: function() {
            return u;
          } });
          var i2, e = r2(1863), o = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), u = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.Cn = [], r3;
            }
            return o(t3, n3), t3.prototype.xorBlock = function(n4, t4, r3) {
              var i3, e2 = this.ln;
              e2 ? (i3 = e2.words, this.ln = void 0) : i3 = this.Cn;
              for (var o2 = 0; o2 < r3; o2++) n4[t4 + o2] ^= i3[o2];
            }, t3.createEncryptor = function(n4) {
              return new t3.Encryptor(n4);
            }, t3.createDecryptor = function(n4) {
              return new t3.Decryptor(n4);
            }, t3.Encryptor = function(n4) {
              function t4() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return o(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                var r3 = this.Hn, i3 = r3.blockSize;
                this.xorBlock(n5, t5, i3), r3.encryptBlock(n5, t5), this.Cn = n5.slice(t5, t5 + i3);
              }, t4;
            }(t3), t3.Decryptor = function(n4) {
              function t4() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return o(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                var r3 = this.Hn, i3 = r3.blockSize, e2 = n5.slice(t5, t5 + i3);
                r3.decryptBlock(n5, t5), this.xorBlock(n5, t5, i3), this.Cn = e2;
              }, t4;
            }(t3), t3;
          }(e.T);
        }, 4055: function(n22, t2, r2) {
          r2.d(t2, { I4: function() {
            return e;
          }, z6: function() {
            return o;
          }, ur: function() {
            return u;
          } });
          var i2 = r2(3354);
          function e(n3) {
            var t3 = n3.nSigBytes % 16;
            if (0 !== t3) {
              for (var r3 = 16 - t3, e2 = [], o2 = Math.floor(r3 / 4), u2 = 0; u2 < o2; u2++) e2.push(0);
              r3 % 4 > 0 && e2.push(0), n3.concat(new i2.e(e2, r3));
            }
          }
          function o(n3, t3) {
            return new i2.e(n3.words.slice(), t3);
          }
          function u(n3, t3) {
            for (var r3 = n3.nSigBytes - t3, e2 = [], o2 = 0; o2 < t3; o2++) {
              var u2 = o2 >>> 2, f = r3 + o2, c = f >>> 2, s2 = n3.words[c] >>> 24 - f % 4 * 8 & 255;
              e2[u2] = 0 | e2[u2] | s2 << 24 - o2 % 4 * 8;
            }
            var a = new i2.e(e2, t3);
            return a.clamp(), a;
          }
        }, 7919: function(n22, t2, r2) {
          r2.d(t2, { l: function() {
            return e;
          } });
          var i2 = r2(3354);
          var e = { pad: function(n3, t3) {
            for (var r3 = 4 * t3, e2 = r3 - n3.nSigBytes % r3, o = e2 << 24 | e2 << 16 | e2 << 8 | e2, u = [], f = 0; f < e2; f += 4) u.push(o);
            var c = new i2.e(u, e2);
            n3.concat(c);
          }, unpad: function(n3) {
            var t3 = 255 & n3.words[n3.nSigBytes - 1 >>> 2];
            n3.nSigBytes -= t3;
          } };
        }, 1756: function(n22, t2, r2) {
          r2.d(t2, { w: function() {
            return u;
          } });
          var i2, e = "undefined" != typeof navigator && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", o = (i2 = parseInt((/msie (\d+)/.exec(e) || [])[1], 10), isNaN(i2) ? (i2 = parseInt((/trident\/.*; rv:(\d+)/.exec(e) || [])[1], 10), !isNaN(i2) && i2) : i2);
          function u(n3, t3) {
            return false !== o && (!t3 || ("<" === n3 ? o < t3 : "<=" === n3 ? o <= t3 : ">" === n3 ? o > t3 : ">=" === n3 ? o >= t3 : o === t3));
          }
        }, 1773: function(n22, t2, r2) {
          r2.d(t2, { D: function() {
            return f;
          } });
          for (var i2 = r2(3354), e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", o = [], u = 0; u < e.length; u++) o[e.charCodeAt(u)] = u;
          var f = { stringify: function(n3) {
            var t3 = n3.words, r3 = n3.nSigBytes;
            n3.clamp();
            for (var i3 = [], o2 = 0; o2 < r3; o2 += 3) for (var u2 = (t3[o2 >>> 2] >>> 24 - o2 % 4 * 8 & 255) << 16 | (t3[o2 + 1 >>> 2] >>> 24 - (o2 + 1) % 4 * 8 & 255) << 8 | t3[o2 + 2 >>> 2] >>> 24 - (o2 + 2) % 4 * 8 & 255, f2 = 0; f2 < 4 && o2 + 0.75 * f2 < r3; f2++) i3.push(e.charAt(u2 >>> 6 * (3 - f2) & 63));
            var c = e.charAt(64);
            if (c) for (; i3.length % 4; ) i3.push(c);
            return i3.join("");
          }, parse: function(n3) {
            var t3 = n3.length, r3 = e.charAt(64);
            if (r3) {
              var u2 = n3.indexOf(r3);
              -1 !== u2 && (t3 = u2);
            }
            for (var f2 = [], c = 0, s2 = 0; s2 < t3; s2++) if (s2 % 4) {
              var a = o[n3.charCodeAt(s2 - 1)] << s2 % 4 * 2 | o[n3.charCodeAt(s2)] >>> 6 - s2 % 4 * 2;
              f2[c >>> 2] |= a << 24 - c % 4 * 8, c++;
            }
            return new i2.e(f2, c);
          } };
        }, 5720: function(n22, t2, r2) {
          r2.d(t2, { p: function() {
            return e;
          } });
          var i2 = r2(3354), e = { stringify: function(n3) {
            for (var t3 = n3.nSigBytes, r3 = n3.words, i3 = [], e2 = 0; e2 < t3; e2++) {
              var o = r3[e2 >>> 2] >>> 24 - e2 % 4 * 8 & 255;
              i3.push((o >>> 4).toString(16)), i3.push((15 & o).toString(16));
            }
            return i3.join("");
          }, parse: function(n3) {
            var t3 = n3.length;
            if (t3 % 2 != 0) throw new Error("Hex string count must be even");
            if (!/^[a-fA-F0-9]+$/.test(n3)) throw new Error("Invalid Hex string: " + n3);
            for (var r3 = [], e2 = 0; e2 < t3; e2 += 2) r3[e2 >>> 3] |= parseInt(n3.substr(e2, 2), 16) << 24 - e2 % 8 * 4;
            return new i2.e(r3, t3 / 2);
          } };
        }, 8702: function(n22, t2, r2) {
          r2.d(t2, { m: function() {
            return e;
          } });
          var i2 = r2(3354), e = { stringify: function(n3) {
            for (var t3 = n3.nSigBytes, r3 = n3.words, i3 = [], e2 = 0; e2 < t3; e2++) {
              var o = r3[e2 >>> 2] >>> 24 - e2 % 4 * 8 & 255;
              i3.push(String.fromCharCode(o));
            }
            return i3.join("");
          }, parse: function(n3) {
            for (var t3 = n3.length, r3 = [], e2 = 0; e2 < t3; e2++) r3[e2 >>> 2] |= (255 & n3.charCodeAt(e2)) << 24 - e2 % 4 * 8;
            return new i2.e(r3, t3);
          } };
        }, 4768: function(n22, t2, r2) {
          r2.d(t2, { d: function() {
            return e;
          } });
          var i2 = r2(8702), e = { stringify: function(n3) {
            try {
              return decodeURIComponent(escape(i2.m.stringify(n3)));
            } catch (n4) {
              throw new Error("Malformed UTF-8 data");
            }
          }, parse: function(n3) {
            return i2.m.parse(unescape(encodeURIComponent(n3)));
          } };
        }, 2688: function(n22, t2, r2) {
          r2.d(t2, { Base64: function() {
            return o.D;
          }, EvpKDF: function() {
            return O;
          }, Hex: function() {
            return c.p;
          }, Latin1: function() {
            return f.m;
          }, OpenSSLKDF: function() {
            return l2.s;
          }, PBKDF2: function() {
            return b.E;
          }, Utf16: function() {
            return w;
          }, Utf16BE: function() {
            return s2;
          }, Utf16LE: function() {
            return v;
          }, Utf8: function() {
            return u.d;
          }, Word32Array: function() {
            return i2.e;
          }, Word64: function() {
            return e.r;
          }, Word64Array: function() {
            return e.m;
          } });
          r2(9054);
          var i2 = r2(3354), e = r2(6957), o = (r2(1756), r2(1773)), u = r2(4768), f = r2(8702), c = r2(5720), s2 = { stringify: function(n3) {
            for (var t3 = n3.words, r3 = n3.nSigBytes, i3 = [], e2 = 0; e2 < r3; e2 += 2) {
              var o2 = t3[e2 >>> 2] >>> 16 - e2 % 4 * 8 & 65535;
              i3.push(String.fromCharCode(o2));
            }
            return i3.join("");
          }, parse: function(n3) {
            for (var t3 = n3.length, r3 = [], e2 = 0; e2 < t3; e2++) r3[e2 >>> 1] |= n3.charCodeAt(e2) << 16 - e2 % 2 * 16;
            return new i2.e(r3, 2 * t3);
          } };
          function a(n3) {
            return n3 << 8 & 4278255360 | n3 >>> 8 & 16711935;
          }
          var h, v = { stringify: function(n3) {
            for (var t3 = n3.words, r3 = n3.nSigBytes, i3 = [], e2 = 0; e2 < r3; e2 += 2) {
              var o2 = a(t3[e2 >>> 2] >>> 16 - e2 % 4 * 8 & 65535);
              i3.push(String.fromCharCode(o2));
            }
            return i3.join("");
          }, parse: function(n3) {
            for (var t3 = n3.length, r3 = [], e2 = 0; e2 < t3; e2++) r3[e2 >>> 1] |= a(n3.charCodeAt(e2) << 16 - e2 % 2 * 16);
            return new i2.e(r3, 2 * t3);
          } }, w = s2, l2 = r2(2214), b = r2(7008), d = r2(670), y = r2(9541), p = (h = function(n3, t3) {
            return (h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            h(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), O = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.Sn = 4, r3.Mn = d.MD5, r3.kn = 1, t4 && (r3.Sn = void 0 !== t4.keySize ? t4.keySize : r3.Sn, r3.Mn = void 0 !== t4.Hasher ? t4.Hasher : r3.Mn, r3.kn = void 0 !== t4.iterations ? t4.iterations : r3.kn), r3;
            }
            return p(t3, n3), t3.prototype.compute = function(n4, t4) {
              for (var r3, e2 = new this.Mn(), o2 = new i2.e(), u2 = o2.words, f2 = this.Sn, c2 = this.kn; u2.length < f2; ) {
                r3 && e2.update(r3), r3 = e2.update(n4).finalize(t4), e2.reset();
                for (var s22 = 1; s22 < c2; s22++) r3 = e2.finalize(r3), e2.reset();
                o2.concat(r3);
              }
              return o2.nSigBytes = 4 * f2, o2;
            }, t3.getKey = function(n4, r3, i3) {
              return new t3(i3).compute(n4, r3);
            }, t3;
          }(y._);
        }, 9054: function(n22, t2, r2) {
          r2.d(t2, { M: function() {
            return e;
          } });
          var i2 = r2(1756);
          var e = function() {
            if ("undefined" != typeof window) {
              var n3 = window.crypto || window.msCrypto;
              if (!n3) {
                if ((0, i2.w)("<", 11)) return console.warn("IE <= 10 uses insecure random generator. Please consider to use IE11 or another modern browser"), function() {
                  return Math.floor(512 * Math.random()) % 256;
                };
                throw new Error("Crypto module not found");
              }
              return function() {
                return n3.getRandomValues(new Uint32Array(1))[0];
              };
            }
            return void 0 !== r2.g && r2.g.crypto ? function() {
              return r2.g.crypto.randomBytes(4).readInt32LE();
            } : function() {
              return (init_empty(), __toCommonJS(empty_exports)).randomBytes(4).readInt32LE();
            };
          }();
        }, 3664: function(n22, t2, r2) {
          r2.d(t2, { K: function() {
            return c;
          } });
          var i2, e = r2(1863), o = r2(3354), u = r2(4055), f = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), c = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              r3.Bn = 1;
              var i3 = t4.cipher, e2 = t4.iv;
              if (4 !== i3.blockSize) throw new Error("In CCM, cipher block size must be 128bit");
              if (e2 && (e2.nSigBytes > 13 || e2.nSigBytes < 7)) throw new Error("Byte size of iv must be between 7 and 13");
              return r3.Nn = e2 || new o.e([0, 0], 8), r3.In = 15 - r3.Nn.nSigBytes, r3;
            }
            return f(t3, n3), t3.getB0 = function(n4, t4, r3, i3) {
              if (r3.nSigBytes + i3.nSigBytes !== 15) throw new Error("LEN(Q)+LEN(N) must be 15");
              var e2 = 255 & (0 | (n4 ? 1 : 0) << 6 | (t4 - 2) / 2 << 3 | r3.nSigBytes - 1), u2 = i3.clone().concat(r3);
              return new o.e([e2 << 24], 1).concat(u2);
            }, t3.formatAssociatedDataAndPayload = function(n4, t4) {
              var r3, i3 = n4.nSigBytes;
              if (0 === i3) r3 = new o.e([0], 0);
              else if (i3 < Math.pow(2, 16) - Math.pow(2, 8)) r3 = new o.e([i3 << 16], 2);
              else {
                if (!(i3 < Math.pow(2, 32))) throw new Error("LEN(A) larger than 2**32-1 is not supported");
                r3 = new o.e([4294836224], 2).concat(new o.e([i3], 4));
              }
              for (var e2 = Math.floor(n4.nSigBytes / 4), u2 = 0; u2 < e2; u2++) r3.concat(new o.e([n4.words[u2]], 4));
              n4.nSigBytes % 4 && (r3.concat(new o.e([n4.words[e2]], n4.nSigBytes % 4)), r3.concat(new o.e([0], 4 - n4.nSigBytes % 4))), r3.nSigBytes % 16 && r3.concat(new o.e([0], 16 - r3.nSigBytes % 16));
              var f2 = Math.floor(t4.nSigBytes / 4);
              for (u2 = 0; u2 < f2; u2++) r3.concat(new o.e([t4.words[u2]], 4));
              return t4.nSigBytes % 4 && (r3.concat(new o.e([t4.words[f2]], t4.nSigBytes % 4)), r3.concat(new o.e([0], 4 - t4.nSigBytes % 4))), r3.nSigBytes % 16 && r3.concat(new o.e([0], 16 - r3.nSigBytes % 16)), r3;
            }, t3.genCtr = function(n4, t4, r3) {
              if (t4.nSigBytes + n4 !== 15) throw new Error("LEN(Q)+LEN(N) must be 15");
              for (var i3 = new o.e([(n4 - 1 & 7) << 24], 1), e2 = new o.e([], 0), u2 = Math.floor(n4 / 4), f2 = 0; f2 < u2 - 1; f2++) e2.concat(new o.e([0], 4));
              return n4 % 4 ? n4 > 4 ? (e2.concat(new o.e([0], n4 % 4)), e2.concat(new o.e([r3], 4))) : e2.concat(new o.e([r3 << 32 - 8 * n4], n4)) : e2.concat(new o.e([r3], 4)), i3.concat(t4).concat(e2);
            }, t3.mac = function(n4, r3, i3, e2, f2, c2) {
              var s2 = new n4({ key: r3, iv: i3 });
              if (4 !== s2.blockSize) throw new Error("In CCM, cipher block size must be 128bit");
              if (i3 && (i3.nSigBytes > 13 || i3.nSigBytes < 7)) throw new Error("Byte size of iv must be between 7 and 13");
              var a = i3 || new o.e([0, 0], 8), h = (null == e2 ? void 0 : e2.clone()) || new o.e(), v = h.nSigBytes, w = (null == f2 ? void 0 : f2.clone()) || new o.e(), l2 = w.nSigBytes;
              if (l2 >>> 0 > 4294967295) throw new Error("Byte length of Payload(plainText) larger than 2^32-1 (4,294,967,295byte) is not supported at this time.");
              var b = 15 - a.nSigBytes, d = (0, u.ur)(new o.e([0, l2], 8), b), y = c2 || 16, p = t3.getB0(Boolean(v), y, d, a), O = t3.formatAssociatedDataAndPayload(h, w), j = p.words.slice();
              s2.encryptBlock(j, 0);
              for (var _ = O.nSigBytes / 16, m = O.words, A = j, g = 0; g < _; g++) {
                var E = [m[4 * g] ^ A[0], m[4 * g + 1] ^ A[1], m[4 * g + 2] ^ A[2], m[4 * g + 3] ^ A[3]];
                s2.encryptBlock(E, 0), A = E;
              }
              var S = new o.e(A, y), M = t3.genCtr(b, a, 0);
              s2.encryptBlock(M.words, 0);
              for (g = 0; g < 4; g++) S.words[g] ^= M.words[g];
              return S.clamp(), S;
            }, t3.combineCipherTextAndAuthTag = function(n4, t4) {
              return n4.clone().concat(t4);
            }, t3.splitCipherTextAndAuthTag = function(n4, t4) {
              var r3 = t4 || 16;
              return { cipherText: (0, u.z6)(n4, n4.nSigBytes - r3), authTag: (0, u.ur)(n4, r3) };
            }, t3.createEncryptor = function(n4) {
              return new t3.Encryptor(n4);
            }, t3.createDecryptor = function(n4) {
              return new t3.Decryptor(n4);
            }, t3.Encryptor = function(n4) {
              function r3() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return f(r3, n4), r3.prototype.processBlock = function(n5, r4) {
                var i3 = this.Hn, e2 = i3.blockSize, o2 = t3.genCtr(this.In, this.Nn, this.Bn);
                i3.encryptBlock(o2.words, 0);
                for (var u2 = 0; u2 < e2; u2++) n5[r4 + u2] ^= o2.words[u2];
                this.Bn++;
              }, r3;
            }(t3), t3.Decryptor = function(n4) {
              function r3() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return f(r3, n4), r3.prototype.processBlock = function(n5, r4) {
                var i3 = this.Hn, e2 = i3.blockSize, o2 = t3.genCtr(this.In, this.Nn, this.Bn);
                i3.encryptBlock(o2.words, 0);
                for (var u2 = 0; u2 < e2; u2++) n5[r4 + u2] ^= o2.words[u2];
                this.Bn++;
              }, r3;
            }(t3), t3;
          }(e.T);
        }, 5607: function(n22, t2, r2) {
          r2.d(t2, { V: function() {
            return c;
          } });
          var i2, e = r2(1863), o = r2(3354), u = r2(4055), f = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), c = function(n3) {
            function t3(r3) {
              var i3 = n3.call(this, r3) || this;
              if (i3.zn = [], i3.Dn = [], i3.Un = [], 4 !== r3.cipher.blockSize) throw new Error("In GCM block cipher mode, cipher block size must be 128bit");
              var e2 = r3.cipher, o2 = r3.iv, u2 = [0, 0, 0, 0];
              return e2.encryptBlock(u2, 0), i3.zn = u2, i3.Dn = t3.getJ0(u2, null == o2 ? void 0 : o2.words), i3.Un = i3.Dn.slice(), i3;
            }
            return f(t3, n3), t3.getJ0 = function(n4, r3) {
              var i3;
              if (r3 && 0 !== r3.length) if (3 === r3.length) i3 = [r3[0], r3[1], r3[2], 1];
              else {
                for (var e2 = r3.length % 4 > 0 ? 4 - r3.length % 4 : 0, o2 = r3.slice(), u2 = 0; u2 < e2 + 2; u2++) o2.push(0);
                o2.push(0), o2.push(32 * r3.length), i3 = t3.GHASH(n4, o2);
              }
              else i3 = [0, 0, 0, 1];
              return i3;
            }, t3.inc32 = function(n4) {
              var t4 = n4.slice(), r3 = t4[3] >>> 0, i3 = r3 + 1 >>> 0 < r3;
              if (t4[3] = t4[3] + 1 | 0, i3) {
                var e2 = t4[2] >>> 0, o2 = e2 + 1 >>> 0 < e2;
                t4[2] = t4[2] + 1 | 0, o2 && (t4[1] = t4[1] + 1 | 0);
              }
              return t4;
            }, t3.mul = function(n4, t4) {
              for (var r3 = [3774873600, 0, 0, 0], i3 = [0, 0, 0, 0], e2 = t4.slice(), o2 = 0; o2 < 128; o2++) {
                (n4[o2 >>> 5] >>> 31 - o2 % 32 & 1) > 0 && (i3[0] = i3[0] ^ e2[0], i3[1] = i3[1] ^ e2[1], i3[2] = i3[2] ^ e2[2], i3[3] = i3[3] ^ e2[3]);
                var u2 = (1 & e2[3]) >>> 0, f2 = (1 & e2[0]) >>> 0, c2 = (1 & e2[1]) >>> 0, s2 = (1 & e2[2]) >>> 0;
                e2[0] = e2[0] >>> 1, e2[1] = e2[1] >>> 1 | (f2 ? 2147483648 : 0), e2[2] = e2[2] >>> 1 | (c2 ? 2147483648 : 0), e2[3] = e2[3] >>> 1 | (s2 ? 2147483648 : 0), u2 > 0 && (e2[0] ^= r3[0], e2[1] ^= r3[1], e2[2] ^= r3[2], e2[3] ^= r3[3]);
              }
              return i3;
            }, t3.GHASH = function(n4, r3) {
              if (n4.length % 4 != 0) throw new Error("Length of 32bit word array 'H' must be multiple of 4(128bit)");
              if (r3.length % 4 != 0) throw new Error("Length of 32bit word array 'X' must be multiple of 4(128bit)");
              for (var i3 = r3.length, e2 = [0, 0, 0, 0], o2 = 0; o2 < i3; o2 += 4) e2[0] = e2[0] ^ r3[o2], e2[1] = e2[1] ^ r3[o2 + 1], e2[2] = e2[2] ^ r3[o2 + 2], e2[3] = e2[3] ^ r3[o2 + 3], e2 = t3.mul(e2, n4);
              return e2;
            }, t3.GCTR = function(n4, r3, i3) {
              if (0 === i3.nSigBytes) return i3.clone();
              if (4 !== r3.length) throw new Error("Initial Counter Block size must be 128bit");
              for (var e2 = i3.words, u2 = Math.ceil(i3.nSigBytes / 16), f2 = [r3.slice()], c2 = 1; c2 < u2; c2++) {
                var s2 = t3.inc32(f2[c2 - 1]);
                f2.push(s2);
              }
              var a = new o.e();
              for (c2 = 0; c2 < u2; c2++) {
                n4.encryptBlock(f2[c2], 0);
                var h = i3.nSigBytes % 16;
                if (c2 < u2 - 1 || 0 === h) {
                  var v = e2[4 * c2] ^ f2[c2][0], w = e2[4 * c2 + 1] ^ f2[c2][1], l2 = e2[4 * c2 + 2] ^ f2[c2][2], b = e2[4 * c2 + 3] ^ f2[c2][3], d = new o.e([v, w, l2, b]);
                  a.concat(d);
                } else {
                  for (var y = [], p = 0, O = Math.floor(h / 4), j = 0; j < O; j++) {
                    var _ = e2[4 * c2 + j] ^ f2[c2][j];
                    y.push(_), p += 4;
                  }
                  var m = h % 4;
                  if (m > 0) {
                    var A = e2[4 * c2 + O] << 32 - 8 * m ^ f2[c2][O];
                    y.push(A), p += m;
                  }
                  var g = new o.e(y, p);
                  a.concat(g);
                }
              }
              return a.nSigBytes = i3.nSigBytes, a.clamp(), a;
            }, t3.mac = function(n4, r3, i3, e2, f2, c2) {
              var s2 = new n4({ key: r3, iv: i3 }), a = [0, 0, 0, 0];
              s2.encryptBlock(a, 0);
              var h = t3.getJ0(a, i3.words), v = (null == e2 ? void 0 : e2.clone()) || new o.e(), w = [0, 8 * v.nSigBytes], l2 = (null == f2 ? void 0 : f2.clone()) || new o.e(), b = [0, 8 * l2.nSigBytes], d = c2 || 16;
              (0, u.I4)(v), (0, u.I4)(l2);
              var y = v.words.concat(l2.words).concat(w).concat(b), p = t3.GHASH(a, y), O = t3.GCTR(s2, h, new o.e(p));
              return (0, u.z6)(O, d);
            }, t3.createEncryptor = function(n4) {
              return new t3.Encryptor(n4);
            }, t3.createDecryptor = function(n4) {
              return new t3.Decryptor(n4);
            }, t3.Encryptor = function(n4) {
              function r3() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return f(r3, n4), r3.prototype.processBlock = function(n5, r4) {
                var i3 = this.Hn.blockSize;
                this.Un = t3.inc32(this.Un);
                for (var e2 = new o.e(n5.slice(r4, r4 + i3)), u2 = t3.GCTR(this.Hn, this.Un, e2), f2 = 0; f2 < i3; f2++) n5[r4 + f2] = u2.words[f2];
              }, r3;
            }(t3), t3.Decryptor = function(n4) {
              function r3() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return f(r3, n4), r3.prototype.processBlock = function(n5, r4) {
                var i3 = this.Hn.blockSize;
                this.Un = t3.inc32(this.Un);
                for (var e2 = new o.e(n5.slice(r4, r4 + i3)), u2 = t3.GCTR(this.Hn, this.Un, e2), f2 = 0; f2 < i3; f2++) n5[r4 + f2] = u2.words[f2];
              }, r3;
            }(t3), t3;
          }(e.T);
        } }, t = {};
        function r(i2) {
          var e = t[i2];
          if (void 0 !== e) return e.exports;
          var o = t[i2] = { exports: {} };
          return n2[i2](o, o.exports, r), o.exports;
        }
        r.d = function(n22, t2) {
          for (var i2 in t2) r.o(t2, i2) && !r.o(n22, i2) && Object.defineProperty(n22, i2, { enumerable: true, get: t2[i2] });
        }, r.g = function() {
          if ("object" == typeof globalThis) return globalThis;
          try {
            return this || new Function("return this")();
          } catch (n22) {
            if ("object" == typeof window) return window;
          }
        }(), r.o = function(n22, t2) {
          return Object.prototype.hasOwnProperty.call(n22, t2);
        }, r.r = function(n22) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(n22, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n22, "Ln", { value: true });
        };
        var i = {};
        return function() {
          r.r(i), r.d(i, { AES: function() {
            return A.AES;
          }, Base64: function() {
            return t2.Base64;
          }, CBCMAC: function() {
            return b.CBCMAC;
          }, CipherParams: function() {
            return u.Q;
          }, DES: function() {
            return g.DES;
          }, DES3: function() {
            return E.DES3;
          }, EvpKDF: function() {
            return t2.EvpKDF;
          }, GMAC: function() {
            return l2.GMAC;
          }, Hex: function() {
            return t2.Hex;
          }, Hmac: function() {
            return f.Hmac;
          }, HmacMD5: function() {
            return c.HmacMD5;
          }, HmacSHA1: function() {
            return s2.HmacSHA1;
          }, HmacSHA224: function() {
            return a.HmacSHA224;
          }, HmacSHA256: function() {
            return h.HmacSHA256;
          }, HmacSHA384: function() {
            return v.HmacSHA384;
          }, HmacSHA512: function() {
            return w.HmacSHA512;
          }, Latin1: function() {
            return t2.Latin1;
          }, MD5: function() {
            return d.MD5;
          }, OpenSSLKDF: function() {
            return t2.OpenSSLKDF;
          }, PBKDF2: function() {
            return t2.PBKDF2;
          }, PasswordBasedCipher: function() {
            return o.E;
          }, RC4: function() {
            return k.RC4;
          }, RC4Drop: function() {
            return H.RC4Drop;
          }, RIPEMD160: function() {
            return S.RIPEMD160;
          }, Rabbit: function() {
            return M.Rabbit;
          }, SHA1: function() {
            return y.SHA1;
          }, SHA224: function() {
            return p.SHA224;
          }, SHA256: function() {
            return O.SHA256;
          }, SHA3: function() {
            return m.SHA3;
          }, SHA384: function() {
            return j.SHA384;
          }, SHA512: function() {
            return _.SHA512;
          }, SerializableCipher: function() {
            return e.D;
          }, Utf16: function() {
            return t2.Utf16;
          }, Utf16BE: function() {
            return t2.Utf16BE;
          }, Utf16LE: function() {
            return t2.Utf16LE;
          }, Utf8: function() {
            return t2.Utf8;
          }, Word32Array: function() {
            return t2.Word32Array;
          }, Word64: function() {
            return t2.Word64;
          }, Word64Array: function() {
            return t2.Word64Array;
          }, formatter: function() {
            return Y;
          }, mode: function() {
            return Z;
          }, pad: function() {
            return J;
          } });
          var n22, t2 = r(2688), e = r(9109), o = r(5693), u = r(2505), f = r(6367), c = r(3027), s2 = r(149), a = r(4105), h = r(980), v = r(5838), w = r(9902), l2 = r(7753), b = r(3967), d = r(670), y = r(3173), p = r(766), O = r(5561), j = r(6324), _ = r(7491), m = r(3408), A = r(9691), g = r(9910), E = r(6739), S = r(7104), M = r(5187), k = r(4615), H = r(9639), C = r(4344), B = r(1863), N = (n22 = function(t3, r2) {
            return (n22 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n3, t4) {
              n3.__proto__ = t4;
            } || function(n3, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
            })(t3, r2);
          }, function(t3, r2) {
            function i2() {
              this.constructor = t3;
            }
            n22(t3, r2), t3.prototype = null === r2 ? Object.create(r2) : (i2.prototype = r2.prototype, new i2());
          }), I = function(n3) {
            function t3(t4) {
              var r2 = n3.call(this, t4) || this;
              return r2.Cn = [], r2;
            }
            return N(t3, n3), t3.prototype.generateKeyStreamAndEncrypt = function(n4, t4, r2, i2) {
              var e2, o2 = this.ln;
              o2 ? (e2 = o2.words.slice(0), this.ln = void 0) : e2 = this.Cn, i2.encryptBlock(e2, 0);
              for (var u2 = 0; u2 < r2; u2++) n4[t4 + u2] ^= e2[u2];
            }, t3.createEncryptor = function(n4) {
              return new t3.Encryptor(n4);
            }, t3.createDecryptor = function(n4) {
              return new t3.Decryptor(n4);
            }, t3.Encryptor = function(n4) {
              function t4() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return N(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                this.generateKeyStreamAndEncrypt(n5, t5, this.Hn.blockSize, this.Hn), this.Cn = n5.slice(t5, t5 + this.Hn.blockSize);
              }, t4;
            }(t3), t3.Decryptor = function(n4) {
              function t4() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return N(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                var r2 = n5.slice(t5, t5 + this.Hn.blockSize);
                this.generateKeyStreamAndEncrypt(n5, t5, this.Hn.blockSize, this.Hn), this.Cn = r2;
              }, t4;
            }(t3), t3;
          }(B.T), z = /* @__PURE__ */ function() {
            var n3 = function(t3, r2) {
              return (n3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(t3, r2);
            };
            return function(t3, r2) {
              function i2() {
                this.constructor = t3;
              }
              n3(t3, r2), t3.prototype = null === r2 ? Object.create(r2) : (i2.prototype = r2.prototype, new i2());
            };
          }(), D = function(n3) {
            function t3(t4) {
              var r2 = n3.call(this, t4) || this;
              return r2.Fn = [], r2;
            }
            return z(t3, n3), t3.createEncryptor = function(n4) {
              return new t3.Encryptor(n4);
            }, t3.createDecryptor = function(n4) {
              return new t3.Decryptor(n4);
            }, t3.Encryptor = function(n4) {
              function t4() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return z(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                var r2 = this.Hn, i2 = r2.blockSize, e2 = this.ln, o2 = this.Fn;
                e2 && (o2 = this.Fn = e2.words.slice(0), this.ln = void 0);
                var u2 = o2.slice(0);
                r2.encryptBlock(u2, 0), o2[i2 - 1] = o2[i2 - 1] + 1 | 0;
                for (var f2 = 0; f2 < i2; f2++) n5[t5 + f2] ^= u2[f2];
              }, t4;
            }(t3), t3.Decryptor = t3.Encryptor, t3;
          }(B.T), U = /* @__PURE__ */ function() {
            var n3 = function(t3, r2) {
              return (n3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(t3, r2);
            };
            return function(t3, r2) {
              function i2() {
                this.constructor = t3;
              }
              n3(t3, r2), t3.prototype = null === r2 ? Object.create(r2) : (i2.prototype = r2.prototype, new i2());
            };
          }(), L = function(n3) {
            function t3(t4) {
              return n3.call(this, t4) || this;
            }
            return U(t3, n3), t3.createEncryptor = function(n4) {
              return new t3.Encryptor(n4);
            }, t3.createDecryptor = function(n4) {
              return new t3.Decryptor(n4);
            }, t3.Encryptor = function(n4) {
              function t4() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return U(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                this.Hn.encryptBlock(n5, t5);
              }, t4;
            }(t3), t3.Decryptor = function(n4) {
              function t4() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return U(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                this.Hn.decryptBlock(n5, t5);
              }, t4;
            }(t3), t3;
          }(B.T), F = /* @__PURE__ */ function() {
            var n3 = function(t3, r2) {
              return (n3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(t3, r2);
            };
            return function(t3, r2) {
              function i2() {
                this.constructor = t3;
              }
              n3(t3, r2), t3.prototype = null === r2 ? Object.create(r2) : (i2.prototype = r2.prototype, new i2());
            };
          }(), x = function(n3) {
            function t3(t4) {
              var r2 = n3.call(this, t4) || this;
              return r2.xn = [], r2;
            }
            return F(t3, n3), t3.createEncryptor = function(n4) {
              return new t3.Encryptor(n4);
            }, t3.createDecryptor = function(n4) {
              return new t3.Decryptor(n4);
            }, t3.Encryptor = function(n4) {
              function t4() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return F(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                var r2 = this.Hn, i2 = r2.blockSize, e2 = this.ln, o2 = this.xn;
                e2 && (o2 = this.xn = e2.words.slice(0), this.ln = void 0), r2.encryptBlock(o2, 0);
                for (var u2 = 0; u2 < i2; u2++) n5[t5 + u2] ^= o2[u2];
              }, t4;
            }(t3), t3.Decryptor = t3.Encryptor, t3;
          }(B.T), P = r(5607), R = r(3664);
          var T = { pad: function(n3, t3) {
            var r2 = n3.nSigBytes, i2 = 4 * t3, e2 = i2 - r2 % i2, o2 = r2 + e2 - 1;
            n3.clamp(), n3.words[o2 >>> 2] |= e2 << 24 - o2 % 4 * 8, n3.nSigBytes += e2;
          }, unpad: function(n3) {
            var t3 = 255 & n3.words[n3.nSigBytes - 1 >>> 2];
            n3.nSigBytes -= t3;
          } }, K = r(3354);
          var W = { pad: function(n3, t3) {
            var r2 = 4 * t3, i2 = r2 - n3.nSigBytes % r2;
            n3.concat(K.e.random(i2 - 1)).concat(new K.e([i2 << 24], 1));
          }, unpad: function(n3) {
            var t3 = 255 & n3.words[n3.nSigBytes - 1 >>> 2];
            n3.nSigBytes -= t3;
          } };
          var G = { pad: function(n3, t3) {
            var r2 = 4 * t3;
            n3.clamp(), n3.nSigBytes += r2 - (n3.nSigBytes % r2 || r2);
          }, unpad: function(n3) {
            for (var t3 = n3.words, r2 = n3.nSigBytes - 1; r2 >= 0; r2--) if (t3[r2 >>> 2] >>> 24 - r2 % 4 * 8 & 255) {
              n3.nSigBytes = r2 + 1;
              break;
            }
          } };
          var q = { pad: function(n3, t3) {
            n3.concat(new K.e([2147483648], 1)), G.pad(n3, t3);
          }, unpad: function(n3) {
            G.unpad(n3), n3.nSigBytes -= 1;
          } }, Q = r(7919);
          var X = { pad: function(n3, t3) {
          }, unpad: function(n3) {
          } }, V = r(1232), Z = { CBC: C.n, CFB: I, CTR: D, ECB: L, OFB: x, GCM: P.V, CCM: R.K }, J = { AnsiX923: T, ISO10126: W, ISO97971: q, Pkcs7: Q.l, NoPadding: X, Zero: G }, Y = { OpenSSLFormatter: V.w };
        }(), i;
      }();
    });
  }
});
var require_tokenToHash = __commonJS2({
  "../auth/dist/tokenToHash.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k)) __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenToHash = void 0;
    var JsCrypto = __importStar(require_jscrypto());
    var tokenToHash = ({ secretToken }) => JsCrypto.SHA256.hash(secretToken).toString(JsCrypto.Base64);
    exports2.tokenToHash = tokenToHash;
  }
});
var urlAlphabet;
var init_url_alphabet = __esm2({
  "../../node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/url-alphabet/index.js"() {
    urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  }
});
var index_browser_exports = {};
__export2(index_browser_exports, {
  customAlphabet: () => customAlphabet,
  customRandom: () => customRandom,
  nanoid: () => nanoid,
  random: () => random,
  urlAlphabet: () => urlAlphabet
});
var random;
var customRandom;
var customAlphabet;
var nanoid;
var init_index_browser = __esm2({
  "../../node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/index.browser.js"() {
    init_url_alphabet();
    random = (bytes3) => crypto.getRandomValues(new Uint8Array(bytes3));
    customRandom = (alphabet3, defaultSize, getRandom) => {
      let mask2 = (2 << Math.log(alphabet3.length - 1) / Math.LN2) - 1;
      let step2 = -~(1.6 * mask2 * defaultSize / alphabet3.length);
      return (size5 = defaultSize) => {
        let id = "";
        while (true) {
          let bytes3 = getRandom(step2);
          let j = step2;
          while (j--) {
            id += alphabet3[bytes3[j] & mask2] || "";
            if (id.length === size5) return id;
          }
        }
      };
    };
    customAlphabet = (alphabet3, size5 = 21) => customRandom(alphabet3, size5, random);
    nanoid = (size5 = 21) => crypto.getRandomValues(new Uint8Array(size5)).reduce((id, byte) => {
      byte &= 63;
      if (byte < 36) {
        id += byte.toString(36);
      } else if (byte < 62) {
        id += (byte - 26).toString(36).toUpperCase();
      } else if (byte > 62) {
        id += "-";
      } else {
        id += "_";
      }
      return id;
    }, "");
  }
});
var require_createApplicationClientId = __commonJS2({
  "../auth/dist/createApplicationClientId.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createApplicationClientId = void 0;
    var nanoid_1 = (init_index_browser(), __toCommonJS(index_browser_exports));
    var createApplicationClientId = () => `client_${(0, nanoid_1.nanoid)(20)}`;
    exports2.createApplicationClientId = createApplicationClientId;
  }
});
var require_createPersonalAccessToken = __commonJS2({
  "../auth/dist/createPersonalAccessToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPersonalAccessToken = void 0;
    var nanoid_1 = (init_index_browser(), __toCommonJS(index_browser_exports));
    var createPersonalAccessToken = () => `pat_${(0, nanoid_1.nanoid)(20)}`;
    exports2.createPersonalAccessToken = createPersonalAccessToken;
  }
});
var require_createChallengeToken = __commonJS2({
  "../auth/dist/createChallengeToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createChallengeToken = void 0;
    var nanoid_1 = (init_index_browser(), __toCommonJS(index_browser_exports));
    var createToken_1 = require_createToken();
    var createChallengeToken = async ({ secret }) => (0, createToken_1.createToken)({ payload: { challenge: (0, nanoid_1.nanoid)(20) }, secret, expiration: "10m" });
    exports2.createChallengeToken = createChallengeToken;
  }
});
var require_verifyChallengeToken = __commonJS2({
  "../auth/dist/verifyChallengeToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyChallengeToken = void 0;
    var verifyToken_1 = require_verifyToken();
    var verifyChallengeToken = (args) => (0, verifyToken_1.verifyToken)(args);
    exports2.verifyChallengeToken = verifyChallengeToken;
  }
});
var require_decodeToken = __commonJS2({
  "../auth/dist/decodeToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeToken = void 0;
    var errors_1 = require_dist2();
    var jose_1 = (init_browser(), __toCommonJS(browser_exports));
    var decodeToken = ({ token }) => {
      try {
        return (0, jose_1.decodeJwt)(token);
      } catch {
        throw new errors_1.AuthorizationError();
      }
    };
    exports2.decodeToken = decodeToken;
  }
});
var require_decodeAccessToken = __commonJS2({
  "../auth/dist/decodeAccessToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeAccessToken = void 0;
    var decodeToken_1 = require_decodeToken();
    var decodeAccessToken2 = (args) => (0, decodeToken_1.decodeToken)(args);
    exports2.decodeAccessToken = decodeAccessToken2;
  }
});
var require_constants = __commonJS2({
  "../auth/dist/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.constants = void 0;
    exports2.constants = {
      AUTHORIZATION_HEADER_NAME: "Authorization",
      AUTHORIZATION_BEARER: "Bearer",
      CLIENT_ID_QUERY_STRING_FIELD_NAME: "clientId",
      SDK_CLIENT_TYPE_NAME: "sdk",
      UI_CLIENT_TYPE_NAME: "ui",
      CUSTOM_HEADERS: {
        clientType: "X-Client-Type",
        twoFactorAuthToken: "X-2FA-Token",
        twoFactorRecoveryCode: "X-2FA-Recovery-Code"
      }
    };
  }
});
var require_getTokenFromRequest = __commonJS2({
  "../auth/dist/getTokenFromRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTokenFromRequest = void 0;
    var errors_1 = require_dist2();
    var constants_1 = require_constants();
    var getTokenFromRequest = (request) => {
      const header = request.headers[constants_1.constants.AUTHORIZATION_HEADER_NAME];
      if (!header) {
        throw new errors_1.AuthorizationError();
      }
      return header.replace("Bearer ", "");
    };
    exports2.getTokenFromRequest = getTokenFromRequest;
  }
});
var require_denyAccessFromAuthorizer = __commonJS2({
  "../auth/dist/denyAccessFromAuthorizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.denyAccessFromAuthorizer = void 0;
    var denyAccessFromAuthorizer = ({ methodArn }) => ({
      principalId: "unknown",
      policyDocument: {
        Version: "2012-10-17",
        Statement: [
          {
            Action: "execute-api:Invoke",
            Effect: "Deny",
            Resource: methodArn
          }
        ]
      },
      context: {}
    });
    exports2.denyAccessFromAuthorizer = denyAccessFromAuthorizer;
  }
});
var require_allowAccessFromAuthorizer = __commonJS2({
  "../auth/dist/allowAccessFromAuthorizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.allowAccessFromAuthorizer = void 0;
    var allowAccessFromAuthorizer = ({ principalId, context: context2 }) => ({
      principalId,
      policyDocument: {
        Version: "2012-10-17",
        Statement: [
          {
            Action: "execute-api:Invoke",
            Effect: "Allow",
            Resource: "*"
          }
        ]
      },
      context: context2
    });
    exports2.allowAccessFromAuthorizer = allowAccessFromAuthorizer;
  }
});
var require_generateGithubAppInstallationHash = __commonJS2({
  "../auth/dist/generateGithubAppInstallationHash.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateGithubAppInstallationHash = void 0;
    var nanoid_1 = (init_index_browser(), __toCommonJS(index_browser_exports));
    var generateGithubAppInstallationHash = () => (0, nanoid_1.nanoid)(32);
    exports2.generateGithubAppInstallationHash = generateGithubAppInstallationHash;
  }
});
var require_generateGithubAppInstallationUrl = __commonJS2({
  "../auth/dist/generateGithubAppInstallationUrl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateGithubAppInstallationUrl = void 0;
    var generateGithubAppInstallationUrl = ({ appName, hash, callbackUrl, userId, gitProviderId }) => {
      const stateJson = {
        userId,
        gitProviderId,
        hash
      };
      const stateJsonString = JSON.stringify(stateJson);
      const encodedStateJson = encodeURIComponent(stateJsonString);
      return `https://github.com/apps/${appName}/installations/new?state=${encodedStateJson}&redirect_uri=${encodeURI(callbackUrl)}`;
    };
    exports2.generateGithubAppInstallationUrl = generateGithubAppInstallationUrl;
  }
});
var require_generateGithubAppAuthorizationUrl = __commonJS2({
  "../auth/dist/generateGithubAppAuthorizationUrl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateGithubAppAuthorizationUrl = void 0;
    var generateGithubAppAuthorizationUrl = ({ clientId, userId, gitProviderId, callbackUrl }) => {
      const stateJson = {
        userId,
        gitProviderId
      };
      const stateJsonString = JSON.stringify(stateJson);
      const encodedStateJson = encodeURIComponent(stateJsonString);
      return `https://github.com/login/oauth/authorize?client_id=${clientId}&state=${encodedStateJson}&redirect_uri=${encodeURI(callbackUrl)}`;
    };
    exports2.generateGithubAppAuthorizationUrl = generateGithubAppAuthorizationUrl;
  }
});
var require_verifyAssetsAccessToken = __commonJS2({
  "../auth/dist/verifyAssetsAccessToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyAssetsAccessToken = void 0;
    var verifyToken_1 = require_verifyToken();
    var verifyAssetsAccessToken = (args) => (0, verifyToken_1.verifyToken)(args);
    exports2.verifyAssetsAccessToken = verifyAssetsAccessToken;
  }
});
var require_permissions = __commonJS2({
  "../auth/dist/permissions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Permissions = void 0;
    var errors_1 = require_dist2();
    var permissionScopes = [
      // Project permissions
      "PROJECT_EDIT_NAME",
      "PROJECT_EDIT_AVATAR",
      "PROJECT_EDIT_ACCESS_FROM_OFAC_COUNTRIES",
      "PROJECT_DELETE",
      // Storage permissions
      "STORAGE_EDIT_SETTINGS",
      "STORAGE_UPLOAD",
      "STORAGE_EDIT_NAME",
      "STORAGE_DELETE",
      "STORAGE_VIEW_INFORMATION",
      "STORAGE_VIEW_LIST",
      // Private gateway permissions
      "PRIVATE_GATEWAY_CREATE",
      "PRIVATE_GATEWAY_UPDATE_NAME",
      "PRIVATE_GATEWAY_DELETE",
      "PRIVATE_GATEWAY_ADD_AND_VERIFY_DOMAIN",
      "PRIVATE_GATEWAY_CHANGE_PRIMARY_DOMAIN",
      "PRIVATE_GATEWAY_DELETE_DOMAIN",
      "PRIVATE_GATEWAY_VIEW",
      // Site permissions
      "SITE_CREATE",
      "SITE_DEPLOY",
      "SITE_VIEW_OVERVIEW",
      "SITE_VIEW_BUILD_SETTINGS",
      "SITE_EDIT_BUILD_SETTINGS",
      "SITE_VIEW_ENV_VARIABLES",
      "SITE_EDIT_ENV_VARIABLES",
      "SITE_VIEW_DEPLOYMENTS",
      "SITE_VIEW_ANALYTICS",
      "SITE_EDIT_NAME",
      "SITE_EDIT_SLUG",
      "SITE_EDIT_AVATAR",
      "SITE_PURGE_CACHE",
      "SITE_DELETE",
      "SITE_ADD_AND_VERIFY_DOMAIN",
      "SITE_CHANGE_PRIMARY_DOMAIN",
      "SITE_DELETE_DOMAIN",
      "SITE_ADD_AND_VERIFY_ENS",
      "SITE_DELETE_ENS",
      "SITE_ADD_GIT_INTEGRATION",
      "SITE_REMOVE_GIT_INTEGRATION",
      // Function permissions
      "FUNCTION_CREATE",
      "FUNCTION_DEPLOY",
      "FUNCTION_EDIT_SETTINGS",
      "FUNCTION_DELETE",
      "FUNCTION_VIEW",
      "FUNCTION_VIEW_DEPLOYMENT",
      // IPNS permissions
      "IPNS_CREATE_RECORD",
      "IPNS_PUBLISH_RECORD",
      "IPNS_DELETE_RECORD",
      "IPNS_VIEW",
      // Billing permissions
      "BILLING_VIEW",
      "BILLING_MANAGE",
      // Application permissions
      "APPLICATION_VIEW",
      "APPLICATION_CREATE",
      "APPLICATION_EDIT",
      // Member permissions
      "MEMBER_TEAM_VIEW",
      "MEMBER_INVITE",
      "MEMBER_CHANGE_PERMISSIONS",
      "MEMBER_ASSIGN_OWNER",
      "MEMBER_DELETE_OTHERS",
      // Template permissions
      "TEMPLATE_CREATE"
    ];
    var Permissions = class _Permissions {
      static parse(permissions) {
        const scopes = permissions ? permissions.split(",") : [];
        for (const scope of scopes) {
          if (!permissionScopes.includes(scope)) {
            throw new errors_1.PermissionScopeError({ scope });
          }
        }
        return new _Permissions(scopes);
      }
      constructor(scopes) {
        this.scopes = new Set(scopes);
      }
      add(scope) {
        this.scopes.add(scope);
      }
      has(scope) {
        return this.scopes.has(scope);
      }
      delete(scope) {
        this.scopes.delete(scope);
      }
      toString() {
        return [...this.scopes].join(",");
      }
      toArray() {
        return [...this.scopes];
      }
    };
    exports2.Permissions = Permissions;
  }
});
var require_admin = __commonJS2({
  "../auth/dist/predefinedPermissionGroups/admin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.admin = void 0;
    var permissions_1 = require_permissions();
    exports2.admin = new permissions_1.Permissions([
      "PROJECT_EDIT_NAME",
      "PROJECT_EDIT_AVATAR",
      "PROJECT_EDIT_ACCESS_FROM_OFAC_COUNTRIES",
      "STORAGE_EDIT_SETTINGS",
      "STORAGE_UPLOAD",
      "STORAGE_EDIT_NAME",
      "STORAGE_DELETE",
      "STORAGE_VIEW_INFORMATION",
      "STORAGE_VIEW_LIST",
      "PRIVATE_GATEWAY_CREATE",
      "PRIVATE_GATEWAY_UPDATE_NAME",
      "PRIVATE_GATEWAY_DELETE",
      "PRIVATE_GATEWAY_ADD_AND_VERIFY_DOMAIN",
      "PRIVATE_GATEWAY_CHANGE_PRIMARY_DOMAIN",
      "PRIVATE_GATEWAY_DELETE_DOMAIN",
      "PRIVATE_GATEWAY_VIEW",
      "SITE_CREATE",
      "SITE_DEPLOY",
      "SITE_VIEW_OVERVIEW",
      "SITE_VIEW_BUILD_SETTINGS",
      "SITE_EDIT_BUILD_SETTINGS",
      "SITE_VIEW_ENV_VARIABLES",
      "SITE_EDIT_ENV_VARIABLES",
      "SITE_VIEW_DEPLOYMENTS",
      "SITE_VIEW_ANALYTICS",
      "SITE_EDIT_NAME",
      "SITE_EDIT_SLUG",
      "SITE_EDIT_AVATAR",
      "SITE_PURGE_CACHE",
      "SITE_DELETE",
      "SITE_ADD_AND_VERIFY_DOMAIN",
      "SITE_CHANGE_PRIMARY_DOMAIN",
      "SITE_DELETE_DOMAIN",
      "SITE_ADD_AND_VERIFY_ENS",
      "SITE_DELETE_ENS",
      "SITE_ADD_GIT_INTEGRATION",
      "SITE_REMOVE_GIT_INTEGRATION",
      "FUNCTION_CREATE",
      "FUNCTION_DEPLOY",
      "FUNCTION_EDIT_SETTINGS",
      "FUNCTION_DELETE",
      "FUNCTION_VIEW",
      "FUNCTION_VIEW_DEPLOYMENT",
      "IPNS_CREATE_RECORD",
      "IPNS_PUBLISH_RECORD",
      "IPNS_DELETE_RECORD",
      "IPNS_VIEW",
      "BILLING_VIEW",
      "APPLICATION_VIEW",
      "APPLICATION_CREATE",
      "APPLICATION_EDIT",
      "MEMBER_TEAM_VIEW",
      "MEMBER_INVITE",
      "MEMBER_CHANGE_PERMISSIONS",
      "MEMBER_DELETE_OTHERS",
      "TEMPLATE_CREATE"
    ]);
  }
});
var require_member = __commonJS2({
  "../auth/dist/predefinedPermissionGroups/member.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.member = void 0;
    var permissions_1 = require_permissions();
    exports2.member = new permissions_1.Permissions([
      "PROJECT_EDIT_NAME",
      "PROJECT_EDIT_AVATAR",
      "STORAGE_UPLOAD",
      "STORAGE_EDIT_NAME",
      "STORAGE_DELETE",
      "STORAGE_VIEW_INFORMATION",
      "STORAGE_VIEW_LIST",
      "PRIVATE_GATEWAY_CREATE",
      "PRIVATE_GATEWAY_UPDATE_NAME",
      "PRIVATE_GATEWAY_ADD_AND_VERIFY_DOMAIN",
      "PRIVATE_GATEWAY_CHANGE_PRIMARY_DOMAIN",
      "PRIVATE_GATEWAY_DELETE_DOMAIN",
      "PRIVATE_GATEWAY_DELETE",
      "PRIVATE_GATEWAY_VIEW",
      "SITE_CREATE",
      "SITE_DEPLOY",
      "SITE_VIEW_OVERVIEW",
      "SITE_EDIT_NAME",
      "SITE_EDIT_SLUG",
      "SITE_EDIT_AVATAR",
      "SITE_VIEW_BUILD_SETTINGS",
      "SITE_EDIT_BUILD_SETTINGS",
      "SITE_VIEW_ENV_VARIABLES",
      "SITE_EDIT_ENV_VARIABLES",
      "SITE_VIEW_DEPLOYMENTS",
      "SITE_VIEW_ANALYTICS",
      "SITE_PURGE_CACHE",
      "SITE_ADD_AND_VERIFY_DOMAIN",
      "SITE_CHANGE_PRIMARY_DOMAIN",
      "SITE_DELETE_DOMAIN",
      "SITE_ADD_AND_VERIFY_ENS",
      "SITE_ADD_GIT_INTEGRATION",
      "SITE_DELETE_ENS",
      "FUNCTION_CREATE",
      "FUNCTION_DEPLOY",
      "FUNCTION_EDIT_SETTINGS",
      "FUNCTION_VIEW",
      "FUNCTION_VIEW_DEPLOYMENT",
      "FUNCTION_DELETE",
      "IPNS_CREATE_RECORD",
      "IPNS_PUBLISH_RECORD",
      "IPNS_DELETE_RECORD",
      "IPNS_VIEW",
      "APPLICATION_VIEW",
      "APPLICATION_CREATE",
      "APPLICATION_EDIT",
      "MEMBER_TEAM_VIEW",
      "TEMPLATE_CREATE"
    ]);
  }
});
var require_owner = __commonJS2({
  "../auth/dist/predefinedPermissionGroups/owner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.owner = void 0;
    var permissions_1 = require_permissions();
    exports2.owner = new permissions_1.Permissions([
      "PROJECT_EDIT_NAME",
      "PROJECT_EDIT_AVATAR",
      "PROJECT_DELETE",
      "PROJECT_EDIT_ACCESS_FROM_OFAC_COUNTRIES",
      "STORAGE_EDIT_SETTINGS",
      "STORAGE_UPLOAD",
      "STORAGE_EDIT_NAME",
      "STORAGE_DELETE",
      "STORAGE_VIEW_INFORMATION",
      "STORAGE_VIEW_LIST",
      "PRIVATE_GATEWAY_CREATE",
      "PRIVATE_GATEWAY_UPDATE_NAME",
      "PRIVATE_GATEWAY_DELETE",
      "PRIVATE_GATEWAY_ADD_AND_VERIFY_DOMAIN",
      "PRIVATE_GATEWAY_CHANGE_PRIMARY_DOMAIN",
      "PRIVATE_GATEWAY_DELETE_DOMAIN",
      "PRIVATE_GATEWAY_VIEW",
      "SITE_CREATE",
      "SITE_DEPLOY",
      "SITE_VIEW_OVERVIEW",
      "SITE_VIEW_BUILD_SETTINGS",
      "SITE_EDIT_BUILD_SETTINGS",
      "SITE_VIEW_ENV_VARIABLES",
      "SITE_EDIT_ENV_VARIABLES",
      "SITE_VIEW_DEPLOYMENTS",
      "SITE_VIEW_ANALYTICS",
      "SITE_EDIT_NAME",
      "SITE_EDIT_SLUG",
      "SITE_EDIT_AVATAR",
      "SITE_PURGE_CACHE",
      "SITE_DELETE",
      "SITE_ADD_AND_VERIFY_DOMAIN",
      "SITE_CHANGE_PRIMARY_DOMAIN",
      "SITE_DELETE_DOMAIN",
      "SITE_ADD_AND_VERIFY_ENS",
      "SITE_DELETE_ENS",
      "SITE_ADD_GIT_INTEGRATION",
      "SITE_REMOVE_GIT_INTEGRATION",
      "FUNCTION_CREATE",
      "FUNCTION_DEPLOY",
      "FUNCTION_EDIT_SETTINGS",
      "FUNCTION_DELETE",
      "FUNCTION_VIEW",
      "FUNCTION_VIEW_DEPLOYMENT",
      "IPNS_CREATE_RECORD",
      "IPNS_PUBLISH_RECORD",
      "IPNS_DELETE_RECORD",
      "IPNS_VIEW",
      "IPNS_CREATE_RECORD",
      "IPNS_PUBLISH_RECORD",
      "IPNS_DELETE_RECORD",
      "IPNS_VIEW",
      "BILLING_VIEW",
      "BILLING_MANAGE",
      "APPLICATION_VIEW",
      "APPLICATION_CREATE",
      "APPLICATION_EDIT",
      "MEMBER_TEAM_VIEW",
      "MEMBER_INVITE",
      "MEMBER_CHANGE_PERMISSIONS",
      "MEMBER_ASSIGN_OWNER",
      "MEMBER_DELETE_OTHERS",
      "TEMPLATE_CREATE"
    ]);
  }
});
var require_readOnly = __commonJS2({
  "../auth/dist/predefinedPermissionGroups/readOnly.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readOnly = void 0;
    var permissions_1 = require_permissions();
    exports2.readOnly = new permissions_1.Permissions([
      "STORAGE_VIEW_INFORMATION",
      "STORAGE_VIEW_LIST",
      "SITE_VIEW_OVERVIEW",
      "SITE_VIEW_DEPLOYMENTS",
      "SITE_VIEW_BUILD_SETTINGS",
      "SITE_VIEW_ENV_VARIABLES",
      "SITE_VIEW_ANALYTICS",
      "FUNCTION_VIEW",
      "FUNCTION_VIEW_DEPLOYMENT",
      "IPNS_VIEW",
      "PRIVATE_GATEWAY_VIEW",
      "APPLICATION_VIEW"
    ]);
  }
});
var require_dist22 = __commonJS2({
  "../auth/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports22) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports22, p)) __createBinding(exports22, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.predefinedPermissionGroups = void 0;
    __exportStar(require_createAccessToken(), exports2);
    __exportStar(require_createAssetsAccessToken(), exports2);
    __exportStar(require_createMigrationToken(), exports2);
    __exportStar(require_verifyAccessToken(), exports2);
    __exportStar(require_verifyMigrationToken(), exports2);
    __exportStar(require_tokenToHash(), exports2);
    __exportStar(require_createApplicationClientId(), exports2);
    __exportStar(require_createPersonalAccessToken(), exports2);
    __exportStar(require_createChallengeToken(), exports2);
    __exportStar(require_verifyChallengeToken(), exports2);
    __exportStar(require_decodeAccessToken(), exports2);
    __exportStar(require_getTokenFromRequest(), exports2);
    __exportStar(require_denyAccessFromAuthorizer(), exports2);
    __exportStar(require_allowAccessFromAuthorizer(), exports2);
    __exportStar(require_generateGithubAppInstallationHash(), exports2);
    __exportStar(require_generateGithubAppInstallationUrl(), exports2);
    __exportStar(require_generateGithubAppAuthorizationUrl(), exports2);
    __exportStar(require_constants(), exports2);
    __exportStar(require_verifyAssetsAccessToken(), exports2);
    __exportStar(require_permissions(), exports2);
    var admin_1 = require_admin();
    var member_1 = require_member();
    var owner_1 = require_owner();
    var readOnly_1 = require_readOnly();
    exports2.predefinedPermissionGroups = { owner: owner_1.owner, admin: admin_1.admin, member: member_1.member, readOnly: readOnly_1.readOnly };
  }
});
var require_index_browser = __commonJS2({
  "../../node_modules/.pnpm/files-from-path@1.0.4/node_modules/files-from-path/cjs/src/index.browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    async function filesFromPaths3() {
      throw new Error("Unsupported in this environment");
    }
    exports2.filesFromPaths = filesFromPaths3;
  }
});
var import_auth3 = __toESM2(require_dist22());
var import_errors50 = __toESM2(require_dist2());
var GenqlError = class extends Error {
  constructor(errors2, data) {
    let message2 = Array.isArray(errors2) ? errors2.map((x) => x?.message || "").join("\n") : "";
    if (!message2) {
      message2 = "GraphQL error";
    }
    super(message2);
    this.errors = [];
    this.errors = errors2;
    this.data = data;
  }
};
function dispatchQueueBatch(client, queue) {
  let batchedQuery = queue.map((item) => item.request);
  if (batchedQuery.length === 1) {
    batchedQuery = batchedQuery[0];
  }
  (() => {
    try {
      return client.fetcher(batchedQuery);
    } catch (e) {
      return Promise.reject(e);
    }
  })().then((responses) => {
    if (queue.length === 1 && !Array.isArray(responses)) {
      if (responses.errors && responses.errors.length) {
        queue[0].reject(
          new GenqlError(responses.errors, responses.data)
        );
        return;
      }
      queue[0].resolve(responses);
      return;
    } else if (responses.length !== queue.length) {
      throw new Error("response length did not match query length");
    }
    for (let i = 0; i < queue.length; i++) {
      if (responses[i].errors && responses[i].errors.length) {
        queue[i].reject(
          new GenqlError(responses[i].errors, responses[i].data)
        );
      } else {
        queue[i].resolve(responses[i]);
      }
    }
  }).catch((e) => {
    for (let i = 0; i < queue.length; i++) {
      queue[i].reject(e);
    }
  });
}
function dispatchQueue(client, options) {
  const queue = client._queue;
  const maxBatchSize = options.maxBatchSize || 0;
  client._queue = [];
  if (maxBatchSize > 0 && maxBatchSize < queue.length) {
    for (let i = 0; i < queue.length / maxBatchSize; i++) {
      dispatchQueueBatch(
        client,
        queue.slice(i * maxBatchSize, (i + 1) * maxBatchSize)
      );
    }
  } else {
    dispatchQueueBatch(client, queue);
  }
}
var QueryBatcher = class _QueryBatcher {
  constructor(fetcher, {
    batchInterval = 6,
    shouldBatch = true,
    maxBatchSize = 0
  } = {}) {
    this.fetcher = fetcher;
    this._options = {
      batchInterval,
      shouldBatch,
      maxBatchSize
    };
    this._queue = [];
  }
  /**
   * Fetch will send a graphql request and return the parsed json.
   * @param {string}      query          - the graphql query.
   * @param {Variables}   variables      - any variables you wish to inject as key/value pairs.
   * @param {[string]}    operationName  - the graphql operationName.
   * @param {Options}     overrides      - the client options overrides.
   *
   * @return {promise} resolves to parsed json of server response
   *
   * @example
   * client.fetch(`
   *    query getHuman($id: ID!) {
   *      human(id: $id) {
   *        name
   *        height
   *      }
   *    }
   * `, { id: "1001" }, 'getHuman')
   *    .then(human => {
   *      // do something with human
   *      console.log(human);
   *    });
   */
  fetch(query, variables, operationName, overrides = {}) {
    const request = {
      query
    };
    const options = Object.assign({}, this._options, overrides);
    if (variables) {
      request.variables = variables;
    }
    if (operationName) {
      request.operationName = operationName;
    }
    const promise = new Promise((resolve2, reject) => {
      this._queue.push({
        request,
        resolve: resolve2,
        reject
      });
      if (this._queue.length === 1) {
        if (options.shouldBatch) {
          setTimeout(
            () => dispatchQueue(this, options),
            options.batchInterval
          );
        } else {
          dispatchQueue(this, options);
        }
      }
    });
    return promise;
  }
  /**
   * Fetch will send a graphql request and return the parsed json.
   * @param {string}      query          - the graphql query.
   * @param {Variables}   variables      - any variables you wish to inject as key/value pairs.
   * @param {[string]}    operationName  - the graphql operationName.
   * @param {Options}     overrides      - the client options overrides.
   *
   * @return {Promise<Array<Result>>} resolves to parsed json of server response
   *
   * @example
   * client.forceFetch(`
   *    query getHuman($id: ID!) {
   *      human(id: $id) {
   *        name
   *        height
   *      }
   *    }
   * `, { id: "1001" }, 'getHuman')
   *    .then(human => {
   *      // do something with human
   *      console.log(human);
   *    });
   */
  forceFetch(query, variables, operationName, overrides = {}) {
    const request = {
      query
    };
    const options = Object.assign({}, this._options, overrides, {
      shouldBatch: false
    });
    if (variables) {
      request.variables = variables;
    }
    if (operationName) {
      request.operationName = operationName;
    }
    const promise = new Promise((resolve2, reject) => {
      const client = new _QueryBatcher(this.fetcher, this._options);
      client._queue = [
        {
          request,
          resolve: resolve2,
          reject
        }
      ];
      dispatchQueue(client, options);
    });
    return promise;
  }
};
var DEFAULT_BATCH_OPTIONS = {
  maxBatchSize: 10,
  batchInterval: 40
};
var createFetcher = ({
  url: url2,
  headers = {},
  fetcher,
  fetch: _fetch,
  batch: batch2 = false,
  ...rest
}) => {
  if (!url2 && !fetcher) {
    throw new Error("url or fetcher is required");
  }
  fetcher = fetcher || (async (body) => {
    let headersObject = typeof headers == "function" ? await headers() : headers;
    headersObject = headersObject || {};
    if (typeof fetch === "undefined" && !_fetch) {
      throw new Error(
        "Global `fetch` function is not available, pass a fetch polyfill to Genql `createClient`"
      );
    }
    let fetchImpl = _fetch || fetch;
    const res = await fetchImpl(url2, {
      headers: {
        "Content-Type": "application/json",
        ...headersObject
      },
      method: "POST",
      body: JSON.stringify(body),
      ...rest
    });
    if (!res.ok) {
      throw new Error(`${res.statusText}: ${await res.text()}`);
    }
    const json = await res.json();
    return json;
  });
  if (!batch2) {
    return async (body) => {
      const json = await fetcher(body);
      if (Array.isArray(json)) {
        return json.map((json2) => {
          if (json2?.errors?.length) {
            throw new GenqlError(json2.errors || [], json2.data);
          }
          return json2.data;
        });
      } else {
        if (json?.errors?.length) {
          throw new GenqlError(json.errors || [], json.data);
        }
        return json.data;
      }
    };
  }
  const batcher = new QueryBatcher(
    async (batchedQuery) => {
      const json = await fetcher(batchedQuery);
      return json;
    },
    batch2 === true ? DEFAULT_BATCH_OPTIONS : batch2
  );
  return async ({ query, variables }) => {
    const json = await batcher.fetch(query, variables);
    if (json?.data) {
      return json.data;
    }
    throw new Error(
      "Genql batch fetcher returned unexpected result " + JSON.stringify(json)
    );
  };
};
var parseRequest = (request, ctx, path) => {
  if (typeof request === "object" && "__args" in request) {
    const args = request.__args;
    let fields = { ...request };
    delete fields.__args;
    const argNames = Object.keys(args);
    if (argNames.length === 0) {
      return parseRequest(fields, ctx, path);
    }
    const field = getFieldFromPath(ctx.root, path);
    const argStrings = argNames.map((argName) => {
      ctx.varCounter++;
      const varName = `v${ctx.varCounter}`;
      const typing = field.args && field.args[argName];
      if (!typing) {
        throw new Error(
          `no typing defined for argument \`${argName}\` in path \`${path.join(
            "."
          )}\``
        );
      }
      ctx.variables[varName] = {
        value: args[argName],
        typing
      };
      return `${argName}:$${varName}`;
    });
    return `(${argStrings})${parseRequest(fields, ctx, path)}`;
  } else if (typeof request === "object" && Object.keys(request).length > 0) {
    const fields = request;
    const fieldNames = Object.keys(fields).filter((k) => Boolean(fields[k]));
    if (fieldNames.length === 0) {
      throw new Error(
        `field selection should not be empty: ${path.join(".")}`
      );
    }
    const type2 = path.length > 0 ? getFieldFromPath(ctx.root, path).type : ctx.root;
    const scalarFields = type2.scalar;
    let scalarFieldsFragment;
    if (fieldNames.includes("__scalar")) {
      const falsyFieldNames = new Set(
        Object.keys(fields).filter((k) => !Boolean(fields[k]))
      );
      if (scalarFields?.length) {
        ctx.fragmentCounter++;
        scalarFieldsFragment = `f${ctx.fragmentCounter}`;
        ctx.fragments.push(
          `fragment ${scalarFieldsFragment} on ${type2.name}{${scalarFields.filter((f) => !falsyFieldNames.has(f)).join(",")}}`
        );
      }
    }
    const fieldsSelection = fieldNames.filter((f) => !["__scalar", "__name"].includes(f)).map((f) => {
      const parsed = parseRequest(fields[f], ctx, [...path, f]);
      if (f.startsWith("on_")) {
        ctx.fragmentCounter++;
        const implementationFragment = `f${ctx.fragmentCounter}`;
        const typeMatch = f.match(/^on_(.+)/);
        if (!typeMatch || !typeMatch[1])
          throw new Error("match failed");
        ctx.fragments.push(
          `fragment ${implementationFragment} on ${typeMatch[1]}${parsed}`
        );
        return `...${implementationFragment}`;
      } else {
        return `${f}${parsed}`;
      }
    }).concat(scalarFieldsFragment ? [`...${scalarFieldsFragment}`] : []).join(",");
    return `{${fieldsSelection}}`;
  } else {
    return "";
  }
};
var generateGraphqlOperation = (operation, root2, fields) => {
  const ctx = {
    root: root2,
    varCounter: 0,
    variables: {},
    fragmentCounter: 0,
    fragments: []
  };
  const result = parseRequest(fields, ctx, []);
  const varNames = Object.keys(ctx.variables);
  const varsString = varNames.length > 0 ? `(${varNames.map((v) => {
    const variableType = ctx.variables[v].typing[1];
    return `$${v}:${variableType}`;
  })})` : "";
  const operationName = fields?.__name || "";
  return {
    query: [
      `${operation} ${operationName}${varsString}${result}`,
      ...ctx.fragments
    ].join(","),
    variables: Object.keys(ctx.variables).reduce(
      (r, v) => {
        r[v] = ctx.variables[v].value;
        return r;
      },
      {}
    ),
    ...operationName ? { operationName: operationName.toString() } : {}
  };
};
var getFieldFromPath = (root2, path) => {
  let current2;
  if (!root2) throw new Error("root type is not provided");
  if (path.length === 0) throw new Error(`path is empty`);
  path.forEach((f) => {
    const type2 = current2 ? current2.type : root2;
    if (!type2.fields)
      throw new Error(`type \`${type2.name}\` does not have fields`);
    const possibleTypes = Object.keys(type2.fields).filter((i) => i.startsWith("on_")).reduce(
      (types2, fieldName) => {
        const field2 = type2.fields && type2.fields[fieldName];
        if (field2) types2.push(field2.type);
        return types2;
      },
      [type2]
    );
    let field = null;
    possibleTypes.forEach((type22) => {
      const found = type22.fields && type22.fields[f];
      if (found) field = found;
    });
    if (!field)
      throw new Error(
        `type \`${type2.name}\` does not have a field \`${f}\``
      );
    current2 = field;
  });
  return current2;
};
var createClient = ({
  queryRoot,
  mutationRoot,
  subscriptionRoot,
  ...options
}) => {
  const fetcher = createFetcher(options);
  const client = {};
  if (queryRoot) {
    client.query = (request) => {
      if (!queryRoot) throw new Error("queryRoot argument is missing");
      const resultPromise = fetcher(
        generateGraphqlOperation("query", queryRoot, request)
      );
      return resultPromise;
    };
  }
  if (mutationRoot) {
    client.mutation = (request) => {
      if (!mutationRoot)
        throw new Error("mutationRoot argument is missing");
      const resultPromise = fetcher(
        generateGraphqlOperation("mutation", mutationRoot, request)
      );
      return resultPromise;
    };
  }
  return client;
};
var linkTypeMap = (typeMap2) => {
  const indexToName = Object.assign(
    {},
    ...Object.keys(typeMap2.types).map((k, i) => ({ [i]: k }))
  );
  let intermediaryTypeMap = Object.assign(
    {},
    ...Object.keys(typeMap2.types || {}).map(
      (k) => {
        const type2 = typeMap2.types[k];
        const fields = type2 || {};
        return {
          [k]: {
            name: k,
            // type scalar properties
            scalar: Object.keys(fields).filter((f) => {
              const [type22] = fields[f] || [];
              const isScalar = type22 && typeMap2.scalars.includes(type22);
              if (!isScalar) {
                return false;
              }
              const args = fields[f]?.[1];
              const argTypes = Object.values(args || {}).map((x) => x?.[1]).filter(Boolean);
              const hasRequiredArgs = argTypes.some(
                (str) => str && str.endsWith("!")
              );
              if (hasRequiredArgs) {
                return false;
              }
              return true;
            }),
            // fields with corresponding `type` and `args`
            fields: Object.assign(
              {},
              ...Object.keys(fields).map(
                (f) => {
                  const [typeIndex, args] = fields[f] || [];
                  if (typeIndex == null) {
                    return {};
                  }
                  return {
                    [f]: {
                      // replace index with type name
                      type: indexToName[typeIndex],
                      args: Object.assign(
                        {},
                        ...Object.keys(args || {}).map(
                          (k2) => {
                            if (!args || !args[k2]) {
                              return;
                            }
                            const [
                              argTypeName,
                              argTypeString
                            ] = args[k2];
                            return {
                              [k2]: [
                                indexToName[argTypeName],
                                argTypeString || indexToName[argTypeName]
                              ]
                            };
                          }
                        )
                      )
                    }
                  };
                }
              )
            )
          }
        };
      }
    )
  );
  const res = resolveConcreteTypes(intermediaryTypeMap);
  return res;
};
var resolveConcreteTypes = (linkedTypeMap) => {
  Object.keys(linkedTypeMap).forEach((typeNameFromKey) => {
    const type2 = linkedTypeMap[typeNameFromKey];
    if (!type2.fields) {
      return;
    }
    const fields = type2.fields;
    Object.keys(fields).forEach((f) => {
      const field = fields[f];
      if (field.args) {
        const args = field.args;
        Object.keys(args).forEach((key) => {
          const arg = args[key];
          if (arg) {
            const [typeName2] = arg;
            if (typeof typeName2 === "string") {
              if (!linkedTypeMap[typeName2]) {
                linkedTypeMap[typeName2] = { name: typeName2 };
              }
              arg[0] = linkedTypeMap[typeName2];
            }
          }
        });
      }
      const typeName = field.type;
      if (typeof typeName === "string") {
        if (!linkedTypeMap[typeName]) {
          linkedTypeMap[typeName] = { name: typeName };
        }
        field.type = linkedTypeMap[typeName];
      }
    });
  });
  return linkedTypeMap;
};
var types_default = {
  "scalars": [
    1,
    3,
    8,
    9,
    14,
    16,
    18,
    23,
    24,
    26,
    27,
    28,
    30,
    38,
    39,
    73,
    95,
    96,
    105,
    106,
    110,
    123,
    131,
    145,
    163,
    180,
    194,
    204,
    210,
    212,
    256,
    262,
    263,
    264,
    274,
    284,
    285,
    287,
    288,
    295,
    305,
    344,
    345,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360
  ],
  "types": {
    "AcceptInvitationWhereInput": {
      "hash": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "ID": {},
    "Application": {
      "clientId": [
        3
      ],
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "updatedAt": [
        73
      ],
      "whiteLabelDomains": [
        6
      ],
      "whiteLabelDomainsPaginated": [
        7,
        {
          "filter": [
            215
          ]
        }
      ],
      "whitelistDomains": [
        10
      ],
      "__typename": [
        3
      ]
    },
    "String": {},
    "ApplicationNameAvailabilityWhereInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "ApplicationWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "ApplicationWhiteLabelDomain": {
      "createdAt": [
        73
      ],
      "hostname": [
        3
      ],
      "id": [
        1
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "ApplicationWhiteLabelDomainsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        6
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "Int": {},
    "Boolean": {},
    "ApplicationWhitelistDomain": {
      "createdAt": [
        73
      ],
      "hostname": [
        3
      ],
      "id": [
        1
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "ApplicationsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "ApplicationsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        2
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "ArweavePin": {
      "bundlrId": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "BigInt": {},
    "BillingCycle": {
      "billingCycleUsages": [
        17
      ],
      "billingPartnerTransactionId": [
        3
      ],
      "createdAt": [
        73
      ],
      "endDate": [
        73
      ],
      "id": [
        1
      ],
      "project": [
        238
      ],
      "projectId": [
        3
      ],
      "startDate": [
        73
      ],
      "status": [
        16
      ],
      "subscription": [
        34
      ],
      "subscriptionId": [
        3
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "BillingCycleStatus": {},
    "BillingCycleUsage": {
      "amount": [
        18
      ],
      "billingCycle": [
        15
      ],
      "billingCycleId": [
        3
      ],
      "billingPlanOverageRule": [
        25
      ],
      "billingPlanOverageRuleId": [
        3
      ],
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "Float": {},
    "BillingCycleUsagesPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "BillingCycleUsagesWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        17
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "BillingPlan": {
      "billingPartnerId": [
        3
      ],
      "billingPlanEnablementRules": [
        22
      ],
      "billingPlanOverageRules": [
        25
      ],
      "billingPlanTierRules": [
        29
      ],
      "createdAt": [
        73
      ],
      "disabledAt": [
        73
      ],
      "id": [
        1
      ],
      "isActive": [
        9
      ],
      "isPublicPlan": [
        9
      ],
      "name": [
        3
      ],
      "planLevel": [
        24
      ],
      "price": [
        18
      ],
      "updatedAt": [
        73
      ],
      "version": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "BillingPlanEnablementRule": {
      "billingPlan": [
        21
      ],
      "billingPlanId": [
        3
      ],
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "isIncluded": [
        9
      ],
      "name": [
        3
      ],
      "type": [
        23
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "BillingPlanEnablementRuleType": {},
    "BillingPlanLevel": {},
    "BillingPlanOverageRule": {
      "billingPlanId": [
        1
      ],
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "includedAmount": [
        8
      ],
      "name": [
        3
      ],
      "overageBucketSize": [
        8
      ],
      "overagePrice": [
        18
      ],
      "overageType": [
        27
      ],
      "type": [
        26
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "BillingPlanOverageRuleType": {},
    "BillingPlanOverageType": {},
    "BillingPlanStatus": {},
    "BillingPlanTierRule": {
      "billingPlan": [
        21
      ],
      "billingPlanId": [
        3
      ],
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "type": [
        3
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "BillingPlanTierRuleType": {},
    "BillingPlanWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "BillingPlansPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "BillingPlansWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        21
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "BillingSubscription": {
      "billingPartnerSubscriptionId": [
        3
      ],
      "createdAt": [
        73
      ],
      "endDate": [
        73
      ],
      "id": [
        1
      ],
      "isActive": [
        9
      ],
      "project": [
        238
      ],
      "projectId": [
        3
      ],
      "startDate": [
        73
      ],
      "type": [
        288
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "Build": {
      "baseDirectory": [
        3
      ],
      "buildCommand": [
        3
      ],
      "distDirectory": [
        3
      ],
      "dockerImage": [
        3
      ],
      "id": [
        1
      ],
      "logs": [
        36
      ],
      "logsPaginated": [
        37,
        {
          "filter": [
            215
          ]
        }
      ],
      "status": [
        38
      ],
      "__typename": [
        3
      ]
    },
    "BuildLog": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "text": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "BuildLogsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        36
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "BuildStatus": {},
    "CID": {},
    "CreateApplicationDataInput": {
      "name": [
        3
      ],
      "whiteLabelDomains": [
        3
      ],
      "whitelistDomains": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateBillingCycleUsageDataInput": {
      "amount": [
        18
      ],
      "billingCycleId": [
        1
      ],
      "billingPlanOverageRuleId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateBillingPlanDataInput": {
      "billingPartnerId": [
        1
      ],
      "description": [
        3
      ],
      "isActive": [
        9
      ],
      "isPublicPlan": [
        9
      ],
      "name": [
        3
      ],
      "planLevel": [
        24
      ],
      "price": [
        18
      ],
      "version": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "CreateCustomIpfsDeploymentDataInput": {
      "cid": [
        39
      ],
      "siteId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateDnsConfigDataInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateDnsConfigWhereInput": {
      "domainId": [
        1
      ],
      "siteId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateDomainDataInput": {
      "hostname": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateDomainWhereInput": {
      "zoneId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateEnsRecordDataInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateEnsRecordWhereInput": {
      "ipnsRecordId": [
        1
      ],
      "siteId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateFleekFunctionDataInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateFolderDataInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateFolderWhereInput": {
      "parentFolderId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateGithubAppAuthorizationUrlWhereInput": {
      "gitProviderId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateGithubAppInstallationUrlWhereInput": {
      "gitProviderId": [
        1
      ],
      "projectId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateGithubIntegrationForProjectDataInput": {
      "projectId": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateGithubRepoFromTemplateDataInput": {
      "isPrivate": [
        9
      ],
      "repoName": [
        3
      ],
      "repoOwner": [
        3
      ],
      "templateOwner": [
        3
      ],
      "templateRepo": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateGithubRepoFromTemplateWhereInput": {
      "gitIntegrationId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateInvitationDataInput": {
      "email": [
        3
      ],
      "permissionGroupId": [
        1
      ],
      "role": [
        256
      ],
      "__typename": [
        3
      ]
    },
    "CreateIpnsRecordForSiteWhereInput": {
      "siteId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateLoginVerificationSessionWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateMigrationRequestsFromTokenDataInput": {
      "token": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateMigrationTokenDataInput": {
      "teamIds": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreatePersonalAccessTokenFromVerificationSessionDataInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreatePersonalAccessTokenFromVerificationSessionWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreatePrivateGatewayDataInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreatePrivateGatewayWhereInput": {
      "zoneId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateProjectDataInput": {
      "name": [
        3
      ],
      "planId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateSalesContactRequestDataInput": {
      "description": [
        3
      ],
      "email": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateSecretDataInput": {
      "groupId": [
        1
      ],
      "key": [
        3
      ],
      "value": [
        3
      ],
      "visibility": [
        264
      ],
      "__typename": [
        3
      ]
    },
    "CreateSiteDataInput": {
      "baseDirectory": [
        3
      ],
      "buildCommand": [
        3
      ],
      "distDirectory": [
        3
      ],
      "dockerImage": [
        3
      ],
      "enablePreviews": [
        9
      ],
      "frameworkId": [
        1
      ],
      "gitIntegrationId": [
        1
      ],
      "githubInstallationId": [
        8
      ],
      "name": [
        3
      ],
      "sourceBranch": [
        3
      ],
      "sourceProvider": [
        285
      ],
      "sourceRepositoryId": [
        3
      ],
      "sourceRepositoryName": [
        3
      ],
      "sourceRepositoryOwner": [
        3
      ],
      "templateId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateTemplateDataInput": {
      "banner": [
        131
      ],
      "description": [
        3
      ],
      "name": [
        3
      ],
      "siteId": [
        1
      ],
      "templateCategoryId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateZoneForSiteWhereInput": {
      "siteId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "Date": {},
    "DeclineInvitationWhereInput": {
      "hash": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "DeleteApplicationWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteDomainWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteEnsRecordWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteFleekFunctionWhereInput": {
      "id": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "DeleteFolderWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteInvitationWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteIpnsRecordWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteMembershipWhereInput": {
      "projectId": [
        1
      ],
      "userId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeletePersonalAccessTokenWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeletePinWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeletePrivateGatewayWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteProjectWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteRecoveryCodesWhereInput": {
      "secretKeyId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteSecretKeyWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteSecretWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteSiteWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteTemplateWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteUserWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteZoneWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "Deployment": {
      "build": [
        35
      ],
      "cid": [
        3
      ],
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "previewImageUrl": [
        3
      ],
      "previewOnly": [
        9
      ],
      "previewUrlSlug": [
        3
      ],
      "siteId": [
        1
      ],
      "sourceAuthor": [
        3
      ],
      "sourceBranch": [
        3
      ],
      "sourceMessage": [
        3
      ],
      "sourceProvider": [
        285
      ],
      "sourceRef": [
        3
      ],
      "sourceRepositoryId": [
        3
      ],
      "sourceRepositoryName": [
        3
      ],
      "sourceRepositoryOwner": [
        3
      ],
      "startedAt": [
        73
      ],
      "status": [
        96
      ],
      "storageType": [
        287
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "DeploymentMode": {},
    "DeploymentStatus": {},
    "DeploymentWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeploymentsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        349
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "DeploymentsQueueLimitWhereInput": {
      "siteId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeploymentsWhereInput": {
      "branch": [
        3
      ],
      "deploymentMode": [
        95
      ],
      "endDate": [
        73
      ],
      "siteId": [
        1
      ],
      "startDate": [
        73
      ],
      "status": [
        96
      ],
      "statuses": [
        96
      ],
      "__typename": [
        3
      ]
    },
    "DeploymentsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        94
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "DeploymentsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        94
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "DisableTwoFactorProtectedActionWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DnsConfig": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "type": [
        105
      ],
      "updatedAt": [
        73
      ],
      "value": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "DnsConfigType": {},
    "DnslinkStatus": {},
    "Domain": {
      "createdAt": [
        73
      ],
      "dnsConfigs": [
        104
      ],
      "dnslinkStatus": [
        106
      ],
      "errorMessage": [
        3
      ],
      "hostname": [
        3
      ],
      "id": [
        1
      ],
      "isVerified": [
        9
      ],
      "project": [
        238
      ],
      "status": [
        110
      ],
      "updatedAt": [
        73
      ],
      "zone": [
        343
      ],
      "__typename": [
        3
      ]
    },
    "DomainAvailabilityWhereInput": {
      "hostname": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "DomainByHostnameWhereInput": {
      "hostname": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "DomainStatus": {},
    "DomainWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DomainsByZoneIdPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "DomainsByZoneIdWhereInput": {
      "zoneId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DomainsByZoneIdWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        107
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "DomainsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "DomainsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        107
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "DomainsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        107
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "EmailAvailabilityWhereInput": {
      "email": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "EnableTwoFactorProtectedActionWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "EnsNameAvailabilityWhereInput": {
      "name": [
        3
      ],
      "siteId": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "EnsRecord": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "ipnsRecord": [
        175
      ],
      "name": [
        3
      ],
      "site": [
        267
      ],
      "status": [
        123
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "EnsRecordByNameWhereInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "EnsRecordStatus": {},
    "EnsRecordWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "EnsRecordsByIpnsIdPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "EnsRecordsByIpnsIdWhereInput": {
      "ipnsRecordId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "EnsRecordsByIpnsIdWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        121
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "EnsRecordsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "EnsRecordsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        121
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "EnsRecordsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        121
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "File": {},
    "FilecoinDeal": {
      "activation": [
        73
      ],
      "cid": [
        3
      ],
      "created": [
        73
      ],
      "dataModelSelector": [
        3
      ],
      "dealId": [
        8
      ],
      "expiration": [
        73
      ],
      "pieceCid": [
        3
      ],
      "status": [
        3
      ],
      "storageProvider": [
        3
      ],
      "updated": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "FilecoinDealsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        350
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "FilecoinDealsWhereInput": {
      "cid": [
        39
      ],
      "__typename": [
        3
      ]
    },
    "FilecoinDealsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        132
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "FilecoinDealsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        132
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "FilecoinPin": {
      "cid": [
        3
      ],
      "deals": [
        132
      ],
      "dealsPaginated": [
        136,
        {
          "filter": [
            215
          ]
        }
      ],
      "__typename": [
        3
      ]
    },
    "FleekFunction": {
      "createdAt": [
        73
      ],
      "currentDeployment": [
        140
      ],
      "currentDeploymentId": [
        3
      ],
      "deployments": [
        140
      ],
      "id": [
        1
      ],
      "invokeUrl": [
        3
      ],
      "name": [
        3
      ],
      "projectId": [
        3
      ],
      "slug": [
        3
      ],
      "status": [
        145
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "FleekFunctionByNameWhereInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "FleekFunctionDeployment": {
      "blake3Hash": [
        3
      ],
      "cid": [
        3
      ],
      "createdAt": [
        73
      ],
      "fleekFunctionId": [
        3
      ],
      "id": [
        1
      ],
      "projectId": [
        3
      ],
      "sgx": [
        9
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "FleekFunctionDeploymentWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "FleekFunctionDeploymentsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "FleekFunctionDeploymentsWhereInput": {
      "fleekFunctionId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "FleekFunctionDeploymentsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        140
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "FleekFunctionStatus": {},
    "FleekFunctionsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "FleekFunctionsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        138
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "Folder": {
      "createdAt": [
        73
      ],
      "folderCount": [
        8
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "path": [
        3
      ],
      "pinCount": [
        8
      ],
      "sizeBigInt": [
        14
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "FolderOrPin": {
      "on_Folder": [
        148
      ],
      "on_Pin": [
        222
      ],
      "__typename": [
        3
      ]
    },
    "FolderWhereInput": {
      "id": [
        1
      ],
      "path": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "GenerateRecoveryCodesWhereInput": {
      "secretKeyId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "GitApiBranch": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "GitApiBranchesWhereInput": {
      "gitProviderId": [
        1
      ],
      "sourceRepositoryName": [
        3
      ],
      "sourceRepositoryOwner": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "GitApiInsatallation": {
      "avatar": [
        3
      ],
      "installationId": [
        8
      ],
      "isOrganization": [
        9
      ],
      "name": [
        3
      ],
      "repos": [
        157
      ],
      "__typename": [
        3
      ]
    },
    "GitApiInstallationsWhereInput": {
      "gitProviderId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "GitApiIsRepoNameAvailableWhereInput": {
      "gitProviderId": [
        1
      ],
      "owner": [
        3
      ],
      "repo": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "GitApiRepo": {
      "defaultBranch": [
        3
      ],
      "id": [
        8
      ],
      "installationId": [
        8
      ],
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "GitApiTree": {
      "mode": [
        3
      ],
      "path": [
        3
      ],
      "sha": [
        3
      ],
      "size": [
        8
      ],
      "type": [
        3
      ],
      "url": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "GitApiTreeWhereInput": {
      "gitProviderId": [
        1
      ],
      "sourceBranch": [
        3
      ],
      "sourceRepositoryName": [
        3
      ],
      "sourceRepositoryOwner": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "GitIntegration": {
      "createdAt": [
        73
      ],
      "gitProvider": [
        162
      ],
      "githubAppInstallation": [
        166
      ],
      "id": [
        1
      ],
      "projectId": [
        3
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "GitIntegrationWhereInput": {
      "gitProviderId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "GitProvider": {
      "createdAt": [
        73
      ],
      "enabled": [
        9
      ],
      "gitUserAccessTokens": [
        165
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "sourceProvider": [
        285
      ],
      "tags": [
        180
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "GitProviderTags": {},
    "GitProviderWhereInput": {
      "tag": [
        163
      ],
      "__typename": [
        3
      ]
    },
    "GitUserAccessToken": {
      "createdAt": [
        73
      ],
      "gitProviderId": [
        3
      ],
      "id": [
        1
      ],
      "token": [
        3
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "GithubAppInstallation": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "installationId": [
        3
      ],
      "projectId": [
        3
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "GithubAppInstallationsWhereInput": {
      "gitProviderId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "GithubRepo": {
      "defaultBranch": [
        3
      ],
      "isPrivate": [
        9
      ],
      "name": [
        3
      ],
      "repositoryId": [
        8
      ],
      "url": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "Invitation": {
      "createdAt": [
        73
      ],
      "createdBy": [
        334
      ],
      "email": [
        3
      ],
      "id": [
        1
      ],
      "permissionGroup": [
        216
      ],
      "role": [
        256
      ],
      "__typename": [
        3
      ]
    },
    "InvitationDetail": {
      "hash": [
        3
      ],
      "permissionGroup": [
        216
      ],
      "projectAvatar": [
        131
      ],
      "projectId": [
        3
      ],
      "projectName": [
        3
      ],
      "role": [
        256
      ],
      "__typename": [
        3
      ]
    },
    "InvitationDetailsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        170
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "InvitationWhereInput": {
      "hash": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "InvitationsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        351
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "InvitationsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        169
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "IpnsRecord": {
      "createdAt": [
        73
      ],
      "ensRecords": [
        121
      ],
      "ensRecordsPaginated": [
        130,
        {
          "filter": [
            215
          ]
        }
      ],
      "hash": [
        3
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "IpnsRecordWhereInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "IpnsRecordsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "IpnsRecordsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        175
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "IpnsRecordsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        175
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "JSON": {},
    "LeaveProjectWhereInput": {
      "projectId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "LinkPublicKeyDataInput": {
      "message": [
        3
      ],
      "signature": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "ListDeploymentBranchesWhereInput": {
      "deploymentMode": [
        95
      ],
      "endDate": [
        73
      ],
      "siteId": [
        1
      ],
      "startDate": [
        73
      ],
      "statuses": [
        96
      ],
      "__typename": [
        3
      ]
    },
    "ListFolderPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        352
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "ListFolderWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "ListFolderWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        149
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "LoginWithAdminAccessTokenDataInput": {
      "adminAccessToken": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "LoginWithDynamicDataInput": {
      "authToken": [
        3
      ],
      "projectId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "LoginWithPersonalAccessTokenDataInput": {
      "personalAccessToken": [
        3
      ],
      "projectId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "MarkNotificationsAsReadWhereInput": {
      "ids": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "Membership": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "permissionGroup": [
        216
      ],
      "role": [
        256
      ],
      "updatedAt": [
        73
      ],
      "user": [
        334
      ],
      "__typename": [
        3
      ]
    },
    "MembershipsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        191
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "MigrationFailedEntity": {
      "id": [
        1
      ],
      "name": [
        3
      ],
      "type": [
        194
      ],
      "__typename": [
        3
      ]
    },
    "MigrationFailedEntityType": {},
    "MigrationLog": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "text": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "MigrationLogsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        195
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "MigrationRequest": {
      "createdAt": [
        73
      ],
      "failedEntities": [
        193
      ],
      "id": [
        1
      ],
      "logs": [
        196,
        {
          "filter": [
            215
          ]
        }
      ],
      "status": [
        204
      ],
      "teamId": [
        3
      ],
      "teamInfo": [
        206
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "MigrationRequestWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "MigrationRequestsByTokenWhereInput": {
      "token": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "MigrationRequestsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        353
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "MigrationRequestsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        197
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "MigrationScheduledRequest": {
      "status": [
        204
      ],
      "teamId": [
        3
      ],
      "triggerAfter": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "MigrationScheduledRequestWhereInput": {
      "teamId": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "MigrationStatus": {},
    "MigrationStatusByTeamIdWhereInput": {
      "teamId": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "MigrationTeamInfo": {
      "filesCount": [
        8
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "sitesCount": [
        8
      ],
      "usersCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "MigrationTeamInfosFromTokenWhereInput": {
      "token": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "Mutation": {
      "acceptInvitation": [
        191,
        {
          "where": [
            0,
            "AcceptInvitationWhereInput!"
          ]
        }
      ],
      "createApplication": [
        2,
        {
          "data": [
            40,
            "CreateApplicationDataInput!"
          ]
        }
      ],
      "createBillingCycleUsage": [
        17,
        {
          "data": [
            41,
            "CreateBillingCycleUsageDataInput!"
          ]
        }
      ],
      "createBillingPlan": [
        21,
        {
          "data": [
            42,
            "CreateBillingPlanDataInput!"
          ]
        }
      ],
      "createCustomIpfsDeployment": [
        94,
        {
          "data": [
            43,
            "CreateCustomIpfsDeploymentDataInput!"
          ]
        }
      ],
      "createDnsConfig": [
        104,
        {
          "data": [
            44,
            "CreateDnsConfigDataInput!"
          ],
          "where": [
            45,
            "CreateDnsConfigWhereInput!"
          ]
        }
      ],
      "createDomain": [
        107,
        {
          "data": [
            46,
            "CreateDomainDataInput!"
          ],
          "where": [
            47,
            "CreateDomainWhereInput!"
          ]
        }
      ],
      "createEnsRecord": [
        121,
        {
          "data": [
            48,
            "CreateEnsRecordDataInput!"
          ],
          "where": [
            49,
            "CreateEnsRecordWhereInput!"
          ]
        }
      ],
      "createFleekFunction": [
        138,
        {
          "data": [
            50,
            "CreateFleekFunctionDataInput!"
          ]
        }
      ],
      "createFolder": [
        148,
        {
          "data": [
            51,
            "CreateFolderDataInput!"
          ],
          "where": [
            52,
            "CreateFolderWhereInput!"
          ]
        }
      ],
      "createGithubAppAuthorizationUrl": [
        3,
        {
          "where": [
            53,
            "CreateGithubAppAuthorizationUrlWhereInput!"
          ]
        }
      ],
      "createGithubAppInstallationUrl": [
        3,
        {
          "where": [
            54,
            "CreateGithubAppInstallationUrlWhereInput!"
          ]
        }
      ],
      "createGithubIntegrationForProject": [
        9,
        {
          "data": [
            55,
            "CreateGithubIntegrationForProjectDataInput!"
          ]
        }
      ],
      "createGithubRepoFromTemplate": [
        168,
        {
          "data": [
            56,
            "CreateGithubRepoFromTemplateDataInput!"
          ],
          "where": [
            57,
            "CreateGithubRepoFromTemplateWhereInput!"
          ]
        }
      ],
      "createInvitation": [
        3,
        {
          "data": [
            58,
            "CreateInvitationDataInput!"
          ]
        }
      ],
      "createIpnsRecord": [
        175
      ],
      "createIpnsRecordForSite": [
        175,
        {
          "where": [
            59,
            "CreateIpnsRecordForSiteWhereInput!"
          ]
        }
      ],
      "createLoginVerificationSession": [
        9,
        {
          "where": [
            60,
            "CreateLoginVerificationSessionWhereInput!"
          ]
        }
      ],
      "createMigrationRequestsFromToken": [
        197,
        {
          "data": [
            61,
            "CreateMigrationRequestsFromTokenDataInput!"
          ]
        }
      ],
      "createMigrationToken": [
        3,
        {
          "data": [
            62,
            "CreateMigrationTokenDataInput!"
          ]
        }
      ],
      "createPersonalAccessTokenFromVerificationSession": [
        3,
        {
          "data": [
            63,
            "CreatePersonalAccessTokenFromVerificationSessionDataInput!"
          ],
          "where": [
            64,
            "CreatePersonalAccessTokenFromVerificationSessionWhereInput!"
          ]
        }
      ],
      "createPrivateGateway": [
        232,
        {
          "data": [
            65,
            "CreatePrivateGatewayDataInput!"
          ],
          "where": [
            66,
            "CreatePrivateGatewayWhereInput!"
          ]
        }
      ],
      "createProject": [
        238,
        {
          "data": [
            67,
            "CreateProjectDataInput!"
          ]
        }
      ],
      "createPublicKeyChallenge": [
        3
      ],
      "createSalesContactRequest": [
        257,
        {
          "data": [
            68,
            "CreateSalesContactRequestDataInput!"
          ]
        }
      ],
      "createSecret": [
        258,
        {
          "data": [
            69,
            "CreateSecretDataInput!"
          ]
        }
      ],
      "createSite": [
        267,
        {
          "data": [
            70,
            "CreateSiteDataInput!"
          ]
        }
      ],
      "createTemplate": [
        289,
        {
          "data": [
            71,
            "CreateTemplateDataInput!"
          ]
        }
      ],
      "createZoneForPrivateGateway": [
        343
      ],
      "createZoneForSite": [
        343,
        {
          "where": [
            72,
            "CreateZoneForSiteWhereInput!"
          ]
        }
      ],
      "declineInvitation": [
        9,
        {
          "where": [
            74,
            "DeclineInvitationWhereInput!"
          ]
        }
      ],
      "deleteApplication": [
        2,
        {
          "where": [
            75,
            "DeleteApplicationWhereInput!"
          ]
        }
      ],
      "deleteDomain": [
        107,
        {
          "where": [
            76,
            "DeleteDomainWhereInput!"
          ]
        }
      ],
      "deleteEnsRecord": [
        121,
        {
          "where": [
            77,
            "DeleteEnsRecordWhereInput!"
          ]
        }
      ],
      "deleteFleekFunction": [
        138,
        {
          "where": [
            78,
            "DeleteFleekFunctionWhereInput!"
          ]
        }
      ],
      "deleteFolder": [
        148,
        {
          "where": [
            79,
            "DeleteFolderWhereInput!"
          ]
        }
      ],
      "deleteInvitation": [
        169,
        {
          "where": [
            80,
            "DeleteInvitationWhereInput!"
          ]
        }
      ],
      "deleteIpnsRecord": [
        175,
        {
          "where": [
            81,
            "DeleteIpnsRecordWhereInput!"
          ]
        }
      ],
      "deleteMembership": [
        191,
        {
          "where": [
            82,
            "DeleteMembershipWhereInput!"
          ]
        }
      ],
      "deletePersonalAccessToken": [
        219,
        {
          "where": [
            83,
            "DeletePersonalAccessTokenWhereInput!"
          ]
        }
      ],
      "deletePin": [
        222,
        {
          "where": [
            84,
            "DeletePinWhereInput!"
          ]
        }
      ],
      "deletePrivateGateway": [
        232,
        {
          "where": [
            85,
            "DeletePrivateGatewayWhereInput!"
          ]
        }
      ],
      "deleteProject": [
        238,
        {
          "where": [
            86,
            "DeleteProjectWhereInput!"
          ]
        }
      ],
      "deleteRecoveryCodes": [
        9,
        {
          "where": [
            87,
            "DeleteRecoveryCodesWhereInput!"
          ]
        }
      ],
      "deleteSecret": [
        258,
        {
          "where": [
            89,
            "DeleteSecretWhereInput!"
          ]
        }
      ],
      "deleteSecretKey": [
        9,
        {
          "where": [
            88,
            "DeleteSecretKeyWhereInput!"
          ]
        }
      ],
      "deleteSite": [
        267,
        {
          "where": [
            90,
            "DeleteSiteWhereInput!"
          ]
        }
      ],
      "deleteTemplate": [
        289,
        {
          "where": [
            91,
            "DeleteTemplateWhereInput!"
          ]
        }
      ],
      "deleteUser": [
        334,
        {
          "where": [
            92,
            "DeleteUserWhereInput!"
          ]
        }
      ],
      "deleteZone": [
        343,
        {
          "where": [
            93,
            "DeleteZoneWhereInput!"
          ]
        }
      ],
      "disableTwoFactorProtectedAction": [
        9,
        {
          "where": [
            103,
            "DisableTwoFactorProtectedActionWhereInput!"
          ]
        }
      ],
      "enableTwoFactorProtectedAction": [
        9,
        {
          "where": [
            119,
            "EnableTwoFactorProtectedActionWhereInput!"
          ]
        }
      ],
      "generateRecoveryCodes": [
        251,
        {
          "where": [
            151,
            "GenerateRecoveryCodesWhereInput!"
          ]
        }
      ],
      "generateTwoFactorSecretKey": [
        261
      ],
      "leaveProject": [
        191,
        {
          "where": [
            181,
            "LeaveProjectWhereInput!"
          ]
        }
      ],
      "linkPublicKey": [
        243,
        {
          "data": [
            182,
            "LinkPublicKeyDataInput!"
          ]
        }
      ],
      "loginWithAdminAccessToken": [
        3,
        {
          "data": [
            187,
            "LoginWithAdminAccessTokenDataInput!"
          ]
        }
      ],
      "loginWithDynamic": [
        3,
        {
          "data": [
            188,
            "LoginWithDynamicDataInput!"
          ]
        }
      ],
      "loginWithPersonalAccessToken": [
        3,
        {
          "data": [
            189,
            "LoginWithPersonalAccessTokenDataInput!"
          ]
        }
      ],
      "markNotificationsAsRead": [
        9,
        {
          "where": [
            190,
            "MarkNotificationsAsReadWhereInput!"
          ]
        }
      ],
      "promoteDeployment": [
        9,
        {
          "where": [
            242,
            "PromoteDeploymentWhereInput!"
          ]
        }
      ],
      "publishIpnsRecord": [
        175,
        {
          "data": [
            245,
            "PublishIpnsRecordDataInput!"
          ],
          "where": [
            246,
            "PublishIpnsRecordWhereInput!"
          ]
        }
      ],
      "publishSignedIpnsName": [
        3,
        {
          "data": [
            247,
            "PublishSignedIpnsNameDataInput!"
          ]
        }
      ],
      "purgeSiteCache": [
        267,
        {
          "where": [
            248,
            "PurgeSiteCacheWhereInput!"
          ]
        }
      ],
      "retryDeployment": [
        94,
        {
          "where": [
            253,
            "RetryDeploymentWhereInput!"
          ]
        }
      ],
      "retryMigrationRequest": [
        197,
        {
          "data": [
            254,
            "RetryMigrationRequestDataInput!"
          ],
          "where": [
            255,
            "RetryMigrationRequestWhereInput!"
          ]
        }
      ],
      "selectPrimaryDomain": [
        107,
        {
          "where": [
            266,
            "SelectPrimaryDomainWhereInput!"
          ]
        }
      ],
      "siteDeploymentRequirements": [
        271,
        {
          "where": [
            272,
            "SiteDeploymentRequirementsWhereInput!"
          ]
        }
      ],
      "stopDeployment": [
        9,
        {
          "where": [
            286,
            "StopDeploymentWhereInput!"
          ]
        }
      ],
      "triggerDeployment": [
        94,
        {
          "where": [
            301,
            "TriggerDeploymentWhereInput!"
          ]
        }
      ],
      "triggerFleekFunctionDeployment": [
        140,
        {
          "data": [
            302
          ],
          "where": [
            303,
            "TriggerFleekFunctionDeploymentWhereInput!"
          ]
        }
      ],
      "updateApplication": [
        2,
        {
          "data": [
            308,
            "UpdateApplicationDataInput!"
          ],
          "where": [
            309,
            "UpdateApplicationWhereInput!"
          ]
        }
      ],
      "updateBillingPlan": [
        21,
        {
          "data": [
            310,
            "UpdateBillingPlanDataInput!"
          ],
          "where": [
            311,
            "UpdateBillingPlanWhereInput!"
          ]
        }
      ],
      "updateFleekFunction": [
        138,
        {
          "data": [
            312,
            "UpdateFleekFunctionDataInput!"
          ],
          "where": [
            313,
            "UpdateFleekFunctionWhereInput!"
          ]
        }
      ],
      "updateFolder": [
        148,
        {
          "data": [
            314,
            "UpdateFolderDataInput!"
          ],
          "where": [
            315,
            "UpdateFolderWhereInput!"
          ]
        }
      ],
      "updateMembership": [
        191,
        {
          "data": [
            316,
            "UpdateMembershipDataInput!"
          ],
          "where": [
            317,
            "UpdateMembershipWhereInput!"
          ]
        }
      ],
      "updateNotificationSettings": [
        9,
        {
          "data": [
            318,
            "UpdateNotificationSettingsDataInput!"
          ]
        }
      ],
      "updatePin": [
        222,
        {
          "data": [
            319,
            "UpdatePinDataInput!"
          ],
          "where": [
            320,
            "UpdatePinWhereInput!"
          ]
        }
      ],
      "updatePrivateGateway": [
        232,
        {
          "data": [
            321,
            "UpdatePrivateGatewayDataInput!"
          ],
          "where": [
            322,
            "UpdatePrivateGatewayWhereInput!"
          ]
        }
      ],
      "updateProject": [
        238,
        {
          "data": [
            323,
            "UpdateProjectDataInput!"
          ],
          "where": [
            324,
            "UpdateProjectWhereInput!"
          ]
        }
      ],
      "updateSecret": [
        258,
        {
          "data": [
            325,
            "UpdateSecretDataInput!"
          ],
          "where": [
            326,
            "UpdateSecretWhereInput!"
          ]
        }
      ],
      "updateSite": [
        267,
        {
          "data": [
            327,
            "UpdateSiteDataInput!"
          ],
          "where": [
            328,
            "UpdateSiteWhereInput!"
          ]
        }
      ],
      "updateTemplate": [
        289,
        {
          "data": [
            329,
            "UpdateTemplateDataInput!"
          ],
          "where": [
            330,
            "UpdateTemplateWhereInput!"
          ]
        }
      ],
      "updateTwoFactorSecretKey": [
        261,
        {
          "data": [
            331,
            "UpdateTwoFactorSecretKeyDataInput!"
          ],
          "where": [
            332,
            "UpdateTwoFactorSecretKeyWhereInput!"
          ]
        }
      ],
      "updateUser": [
        334,
        {
          "data": [
            333,
            "UpdateUserDataInput!"
          ]
        }
      ],
      "verifyDnslink": [
        107,
        {
          "where": [
            336,
            "VerifyDnslinkWhereInput!"
          ]
        }
      ],
      "verifyDomain": [
        107,
        {
          "data": [
            337
          ],
          "where": [
            338,
            "VerifyDomainWhereInput!"
          ]
        }
      ],
      "verifyEnsRecord": [
        121,
        {
          "where": [
            339,
            "VerifyEnsRecordWhereInput!"
          ]
        }
      ],
      "verifyTwoFactorSecretKey": [
        261,
        {
          "data": [
            340,
            "VerifyTwoFactorSecretKeyDataInput!"
          ],
          "where": [
            341,
            "VerifyTwoFactorSecretKeyWhereInput!"
          ]
        }
      ],
      "__typename": [
        3
      ]
    },
    "Notification": {
      "content": [
        3
      ],
      "createdAt": [
        73
      ],
      "data": [
        180
      ],
      "id": [
        1
      ],
      "isRead": [
        9
      ],
      "title": [
        3
      ],
      "type": [
        212
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "NotificationChannel": {},
    "NotificationSettings": {
      "isEnabled": [
        9
      ],
      "notificationChannel": [
        210
      ],
      "notificationType": [
        212
      ],
      "__typename": [
        3
      ]
    },
    "NotificationType": {},
    "NotificationsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "NotificationsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        209
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PaginationInput": {
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PermissionGroup": {
      "createdAt": [
        73
      ],
      "description": [
        3
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "permissions": [
        3
      ],
      "systemRole": [
        256
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "PermissionGroupsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PermissionGroupsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        216
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PersonalAccessToken": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "maskedToken": [
        3
      ],
      "name": [
        3
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "PersonalAccessTokensPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        354
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PersonalAccessTokensWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        219
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "Pin": {
      "arweavePin": [
        13
      ],
      "cid": [
        1
      ],
      "createdAt": [
        73
      ],
      "deployments": [
        94
      ],
      "deploymentsPaginated": [
        102,
        {
          "filter": [
            215
          ]
        }
      ],
      "extension": [
        3
      ],
      "filecoinPin": [
        137
      ],
      "filename": [
        3
      ],
      "id": [
        1
      ],
      "pathInFolder": [
        3
      ],
      "projectId": [
        3
      ],
      "size": [
        8
      ],
      "sizeBigInt": [
        14
      ],
      "storedOnArweave": [
        9
      ],
      "storedOnFilecoin": [
        9
      ],
      "storedOnS3": [
        9
      ],
      "__typename": [
        3
      ]
    },
    "PinNameAvailabilityInParentFolderDataInput": {
      "extension": [
        3
      ],
      "filename": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "PinNameAvailabilityInParentFolderWhereInput": {
      "parentFolderId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "PinWhereInput": {
      "cid": [
        39
      ],
      "__typename": [
        3
      ]
    },
    "PinsByFilenamePaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        355
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PinsByFilenameWhereInput": {
      "extension": [
        3
      ],
      "filename": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "PinsByFilenameWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        222
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PinsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        356
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PinsWhereInput": {
      "storedOnArweave": [
        9
      ],
      "storedOnFilecoin": [
        9
      ],
      "__typename": [
        3
      ]
    },
    "PinsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        222
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PrivateGateway": {
      "createdAt": [
        73
      ],
      "domains": [
        107
      ],
      "domainsPaginated": [
        117,
        {
          "filter": [
            215
          ]
        }
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "primaryDomain": [
        107
      ],
      "project": [
        238
      ],
      "slug": [
        3
      ],
      "updatedAt": [
        73
      ],
      "zone": [
        343
      ],
      "__typename": [
        3
      ]
    },
    "PrivateGatewayBySlugWhereInput": {
      "slug": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "PrivateGatewayNameAvailabilityWhereInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "PrivateGatewayWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "PrivateGatewaysPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PrivateGatewaysWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        232
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "Project": {
      "allowAccessFromOfacCountries": [
        9
      ],
      "avatar": [
        131
      ],
      "backupStorageOnArweave": [
        9
      ],
      "backupStorageOnFilecoin": [
        9
      ],
      "createdAt": [
        73
      ],
      "currentUserMembership": [
        191
      ],
      "id": [
        1
      ],
      "memberships": [
        191
      ],
      "membershipsPaginated": [
        192,
        {
          "filter": [
            215
          ]
        }
      ],
      "name": [
        3
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "ProjectWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "ProjectsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        357
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "ProjectsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        238
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PromoteDeploymentWhereInput": {
      "deploymentId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "PublicKey": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "publicKey": [
        3
      ],
      "type": [
        3
      ],
      "updatedAt": [
        73
      ],
      "user": [
        334
      ],
      "__typename": [
        3
      ]
    },
    "PublicKeysWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        243
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PublishIpnsRecordDataInput": {
      "hash": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "PublishIpnsRecordWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "PublishSignedIpnsNameDataInput": {
      "input": [
        3
      ],
      "key": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "PurgeSiteCacheWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "Query": {
      "application": [
        2,
        {
          "where": [
            5,
            "ApplicationWhereInput!"
          ]
        }
      ],
      "applicationNameAvailability": [
        9,
        {
          "where": [
            4,
            "ApplicationNameAvailabilityWhereInput!"
          ]
        }
      ],
      "applications": [
        12,
        {
          "filter": [
            11
          ]
        }
      ],
      "billingCycleUsages": [
        20,
        {
          "filter": [
            19
          ]
        }
      ],
      "billingPlan": [
        21,
        {
          "where": [
            31,
            "BillingPlanWhereInput!"
          ]
        }
      ],
      "billingPlans": [
        33,
        {
          "filter": [
            32
          ]
        }
      ],
      "deployment": [
        94,
        {
          "where": [
            97,
            "DeploymentWhereInput!"
          ]
        }
      ],
      "deployments": [
        101,
        {
          "filter": [
            98
          ],
          "where": [
            100,
            "DeploymentsWhereInput!"
          ]
        }
      ],
      "deploymentsQueueLimit": [
        9,
        {
          "where": [
            99,
            "DeploymentsQueueLimitWhereInput!"
          ]
        }
      ],
      "domain": [
        107,
        {
          "where": [
            111,
            "DomainWhereInput!"
          ]
        }
      ],
      "domainAvailability": [
        9,
        {
          "where": [
            108,
            "DomainAvailabilityWhereInput!"
          ]
        }
      ],
      "domainByHostname": [
        107,
        {
          "where": [
            109,
            "DomainByHostnameWhereInput!"
          ]
        }
      ],
      "domains": [
        116,
        {
          "filter": [
            115
          ]
        }
      ],
      "domainsByZoneId": [
        114,
        {
          "filter": [
            112
          ],
          "where": [
            113,
            "DomainsByZoneIdWhereInput!"
          ]
        }
      ],
      "emailAvailability": [
        9,
        {
          "where": [
            118,
            "EmailAvailabilityWhereInput!"
          ]
        }
      ],
      "ensNameAvailability": [
        9,
        {
          "where": [
            120,
            "EnsNameAvailabilityWhereInput!"
          ]
        }
      ],
      "ensRecord": [
        121,
        {
          "where": [
            124,
            "EnsRecordWhereInput!"
          ]
        }
      ],
      "ensRecordByName": [
        121,
        {
          "where": [
            122,
            "EnsRecordByNameWhereInput!"
          ]
        }
      ],
      "ensRecords": [
        129,
        {
          "filter": [
            128
          ]
        }
      ],
      "ensRecordsByIpnsId": [
        127,
        {
          "filter": [
            125
          ],
          "where": [
            126,
            "EnsRecordsByIpnsIdWhereInput!"
          ]
        }
      ],
      "filecoinDeals": [
        135,
        {
          "filter": [
            133
          ],
          "where": [
            134,
            "FilecoinDealsWhereInput!"
          ]
        }
      ],
      "fleekFunctionByName": [
        138,
        {
          "where": [
            139,
            "FleekFunctionByNameWhereInput!"
          ]
        }
      ],
      "fleekFunctionDeployment": [
        140,
        {
          "where": [
            141,
            "FleekFunctionDeploymentWhereInput!"
          ]
        }
      ],
      "fleekFunctionDeployments": [
        144,
        {
          "filter": [
            142
          ],
          "where": [
            143,
            "FleekFunctionDeploymentsWhereInput!"
          ]
        }
      ],
      "fleekFunctions": [
        147,
        {
          "filter": [
            146
          ]
        }
      ],
      "folder": [
        148,
        {
          "where": [
            150,
            "FolderWhereInput!"
          ]
        }
      ],
      "gitApiBranches": [
        152,
        {
          "where": [
            153,
            "GitApiBranchesWhereInput!"
          ]
        }
      ],
      "gitApiInstallations": [
        154,
        {
          "where": [
            155,
            "GitApiInstallationsWhereInput!"
          ]
        }
      ],
      "gitApiIsRepoNameAvailable": [
        9,
        {
          "where": [
            156,
            "GitApiIsRepoNameAvailableWhereInput!"
          ]
        }
      ],
      "gitApiTree": [
        158,
        {
          "where": [
            159,
            "GitApiTreeWhereInput!"
          ]
        }
      ],
      "gitIntegration": [
        160,
        {
          "where": [
            161,
            "GitIntegrationWhereInput!"
          ]
        }
      ],
      "gitProvider": [
        162,
        {
          "where": [
            164,
            "GitProviderWhereInput!"
          ]
        }
      ],
      "gitProviders": [
        162
      ],
      "githubAppInstallations": [
        166,
        {
          "where": [
            167,
            "GithubAppInstallationsWhereInput!"
          ]
        }
      ],
      "invitation": [
        170,
        {
          "where": [
            172,
            "InvitationWhereInput!"
          ]
        }
      ],
      "invitations": [
        174,
        {
          "filter": [
            173
          ]
        }
      ],
      "ipnsRecord": [
        175,
        {
          "where": [
            176,
            "IpnsRecordWhereInput!"
          ]
        }
      ],
      "ipnsRecords": [
        178,
        {
          "filter": [
            177
          ]
        }
      ],
      "listDeploymentBranches": [
        3,
        {
          "where": [
            183,
            "ListDeploymentBranchesWhereInput!"
          ]
        }
      ],
      "listFolder": [
        186,
        {
          "filter": [
            184
          ],
          "where": [
            185,
            "ListFolderWhereInput!"
          ]
        }
      ],
      "migrationRequest": [
        197,
        {
          "where": [
            198,
            "MigrationRequestWhereInput!"
          ]
        }
      ],
      "migrationRequests": [
        201,
        {
          "filter": [
            200
          ]
        }
      ],
      "migrationRequestsByToken": [
        197,
        {
          "where": [
            199,
            "MigrationRequestsByTokenWhereInput!"
          ]
        }
      ],
      "migrationScheduledRequest": [
        202,
        {
          "where": [
            203,
            "MigrationScheduledRequestWhereInput!"
          ]
        }
      ],
      "migrationStatusByTeamId": [
        204,
        {
          "where": [
            205,
            "MigrationStatusByTeamIdWhereInput!"
          ]
        }
      ],
      "migrationTeamInfosFromToken": [
        206,
        {
          "where": [
            207,
            "MigrationTeamInfosFromTokenWhereInput!"
          ]
        }
      ],
      "notificationSettings": [
        211
      ],
      "notifications": [
        214,
        {
          "filter": [
            213
          ]
        }
      ],
      "permissionGroups": [
        218,
        {
          "filter": [
            217
          ]
        }
      ],
      "personalAccessTokens": [
        221,
        {
          "filter": [
            220
          ]
        }
      ],
      "pin": [
        222,
        {
          "where": [
            225,
            "PinWhereInput!"
          ]
        }
      ],
      "pinNameAvailabilityInParentFolder": [
        9,
        {
          "data": [
            223,
            "PinNameAvailabilityInParentFolderDataInput!"
          ],
          "where": [
            224,
            "PinNameAvailabilityInParentFolderWhereInput!"
          ]
        }
      ],
      "pins": [
        231,
        {
          "filter": [
            229
          ],
          "where": [
            230
          ]
        }
      ],
      "pinsByFilename": [
        228,
        {
          "filter": [
            226
          ],
          "where": [
            227,
            "PinsByFilenameWhereInput!"
          ]
        }
      ],
      "privateGateway": [
        232,
        {
          "where": [
            235,
            "PrivateGatewayWhereInput!"
          ]
        }
      ],
      "privateGatewayBySlug": [
        232,
        {
          "where": [
            233,
            "PrivateGatewayBySlugWhereInput!"
          ]
        }
      ],
      "privateGatewayNameAvailability": [
        9,
        {
          "where": [
            234,
            "PrivateGatewayNameAvailabilityWhereInput!"
          ]
        }
      ],
      "privateGateways": [
        237,
        {
          "filter": [
            236
          ]
        }
      ],
      "project": [
        238,
        {
          "where": [
            239,
            "ProjectWhereInput!"
          ]
        }
      ],
      "projects": [
        241,
        {
          "filter": [
            240
          ]
        }
      ],
      "resolveIpnsName": [
        3,
        {
          "where": [
            252,
            "ResolveIpnsNameWhereInput!"
          ]
        }
      ],
      "secretAvailability": [
        9,
        {
          "where": [
            259,
            "SecretAvailabilityWhereInput!"
          ]
        }
      ],
      "site": [
        267,
        {
          "where": [
            277,
            "SiteWhereInput!"
          ]
        }
      ],
      "siteBuildSettings": [
        268,
        {
          "where": [
            269,
            "SiteBuildSettingsWhereInput!"
          ]
        }
      ],
      "siteBySlug": [
        267,
        {
          "where": [
            270,
            "SiteBySlugWhereInput!"
          ]
        }
      ],
      "siteFramework": [
        273,
        {
          "where": [
            275,
            "SiteFrameworkWhereInput!"
          ]
        }
      ],
      "siteFrameworks": [
        273
      ],
      "siteNameAvailability": [
        9,
        {
          "where": [
            276,
            "SiteNameAvailabilityWhereInput!"
          ]
        }
      ],
      "sites": [
        282,
        {
          "filter": [
            280
          ],
          "where": [
            281,
            "SitesWhereInput!"
          ]
        }
      ],
      "slugAvailability": [
        9,
        {
          "where": [
            283,
            "SlugAvailabilityWhereInput!"
          ]
        }
      ],
      "template": [
        289,
        {
          "where": [
            296,
            "TemplateWhereInput!"
          ]
        }
      ],
      "templateCategories": [
        291,
        {
          "filter": [
            290
          ]
        }
      ],
      "templateCategory": [
        292,
        {
          "where": [
            293,
            "TemplateCategoryWhereInput!"
          ]
        }
      ],
      "templateNameAvailability": [
        9,
        {
          "where": [
            294,
            "TemplateNameAvailabilityWhereInput!"
          ]
        }
      ],
      "templates": [
        299,
        {
          "filter": [
            297
          ],
          "where": [
            298,
            "TemplatesWhereInput!"
          ]
        }
      ],
      "twoFactorProtectedActions": [
        307,
        {
          "filter": [
            306
          ]
        }
      ],
      "user": [
        334
      ],
      "usernameAvailability": [
        9,
        {
          "where": [
            335,
            "UsernameAvailabilityWhereInput!"
          ]
        }
      ],
      "version": [
        342
      ],
      "zone": [
        343,
        {
          "where": [
            346,
            "ZoneWhereInput!"
          ]
        }
      ],
      "zones": [
        348,
        {
          "filter": [
            347
          ]
        }
      ],
      "__typename": [
        3
      ]
    },
    "RecoveryCode": {
      "code": [
        3
      ],
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "isUsed": [
        9
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "RecoveryCodes": {
      "recoveryCodes": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "ResolveIpnsNameWhereInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "RetryDeploymentWhereInput": {
      "deploymentId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "RetryMigrationRequestDataInput": {
      "skipFailedEntities": [
        9
      ],
      "__typename": [
        3
      ]
    },
    "RetryMigrationRequestWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "Role": {},
    "SalesContactRequest": {
      "createdAt": [
        73
      ],
      "description": [
        3
      ],
      "email": [
        3
      ],
      "id": [
        1
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "Secret": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "key": [
        3
      ],
      "updatedAt": [
        73
      ],
      "value": [
        3
      ],
      "visibility": [
        264
      ],
      "__typename": [
        3
      ]
    },
    "SecretAvailabilityWhereInput": {
      "key": [
        3
      ],
      "siteId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "SecretGroup": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "secrets": [
        258
      ],
      "secretsPaginated": [
        265,
        {
          "filter": [
            215
          ]
        }
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "SecretKey": {
      "algorithm": [
        262
      ],
      "createdAt": [
        73
      ],
      "digits": [
        8
      ],
      "id": [
        1
      ],
      "isActive": [
        9
      ],
      "isVerified": [
        9
      ],
      "key": [
        3
      ],
      "period": [
        8
      ],
      "recoveryCodes": [
        250
      ],
      "type": [
        263
      ],
      "updatedAt": [
        73
      ],
      "verifiedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "SecretKeyAlgorithm": {},
    "SecretKeyType": {},
    "SecretVisibility": {},
    "SecretsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        258
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "SelectPrimaryDomainWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "Site": {
      "avatar": [
        131
      ],
      "baseDirectory": [
        3
      ],
      "buildCommand": [
        3
      ],
      "buildDurationLimitSeconds": [
        8
      ],
      "cpuLimit": [
        3
      ],
      "currentDeployment": [
        94
      ],
      "deployments": [
        94
      ],
      "deploymentsPaginated": [
        102,
        {
          "filter": [
            215
          ]
        }
      ],
      "distDirectory": [
        3
      ],
      "dockerImage": [
        3
      ],
      "domains": [
        107
      ],
      "domainsPaginated": [
        117,
        {
          "filter": [
            215
          ]
        }
      ],
      "enablePreviews": [
        9
      ],
      "framework": [
        273
      ],
      "gitIntegration": [
        160
      ],
      "githubInstallationId": [
        8
      ],
      "id": [
        1
      ],
      "ipnsRecords": [
        175
      ],
      "ipnsRecordsPaginated": [
        179,
        {
          "filter": [
            215
          ]
        }
      ],
      "lastDeployment": [
        94
      ],
      "memoryLimit": [
        3
      ],
      "name": [
        3
      ],
      "primaryDomain": [
        107
      ],
      "secretGroup": [
        260
      ],
      "slug": [
        3
      ],
      "sourceBranch": [
        3
      ],
      "sourceProvider": [
        285
      ],
      "sourceRepositoryId": [
        3
      ],
      "sourceRepositoryName": [
        3
      ],
      "sourceRepositoryOwner": [
        3
      ],
      "zones": [
        278
      ],
      "zonesPaginated": [
        279,
        {
          "filter": [
            215
          ]
        }
      ],
      "__typename": [
        3
      ]
    },
    "SiteBuildSettings": {
      "buildCommand": [
        3
      ],
      "dockerImage": [
        3
      ],
      "envVars": [
        180
      ],
      "frameworkId": [
        3
      ],
      "publishDirectory": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "SiteBuildSettingsWhereInput": {
      "baseDirectory": [
        3
      ],
      "gitProviderId": [
        1
      ],
      "sourceBranch": [
        3
      ],
      "sourceRepositoryName": [
        3
      ],
      "sourceRepositoryOwner": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "SiteBySlugWhereInput": {
      "slug": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "SiteDeploymentRequirements": {
      "authorizationUrl": [
        3
      ],
      "installationUrl": [
        3
      ],
      "shouldAuthenticate": [
        9
      ],
      "shouldInstall": [
        9
      ],
      "__typename": [
        3
      ]
    },
    "SiteDeploymentRequirementsWhereInput": {
      "gitProviderId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "SiteFramework": {
      "avatar": [
        131
      ],
      "buildScript": [
        3
      ],
      "createdAt": [
        73
      ],
      "dockerImage": [
        3
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "publishDirectory": [
        3
      ],
      "recognitionArgument": [
        3
      ],
      "recognitionStrategy": [
        274
      ],
      "slug": [
        3
      ],
      "templatesCount": [
        8
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "SiteFrameworkRecognitionStrategy": {},
    "SiteFrameworkWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "SiteNameAvailabilityWhereInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "SiteWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "SiteZone": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "status": [
        344
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "SiteZonesWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        278
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "SitesPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        358
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "SitesWhereInput": {
      "hasSourceProvider": [
        9
      ],
      "isDeployed": [
        9
      ],
      "isTemplate": [
        9
      ],
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "SitesWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        267
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "SlugAvailabilityWhereInput": {
      "slug": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "SortOrder": {},
    "SourceProvider": {},
    "StopDeploymentWhereInput": {
      "deploymentId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "StorageType": {},
    "SubscriptionType": {},
    "Template": {
      "banner": [
        131
      ],
      "category": [
        292
      ],
      "createdAt": [
        73
      ],
      "creator": [
        334
      ],
      "deployment": [
        94
      ],
      "description": [
        3
      ],
      "framework": [
        273
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "reviewComment": [
        3
      ],
      "reviewStatus": [
        295
      ],
      "reviewedAt": [
        73
      ],
      "site": [
        267
      ],
      "siteAvatar": [
        131
      ],
      "siteId": [
        3
      ],
      "siteSlug": [
        3
      ],
      "updatedAt": [
        73
      ],
      "usageCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "TemplateCategoriesPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        359
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "TemplateCategoriesWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        292
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "TemplateCategory": {
      "id": [
        1
      ],
      "name": [
        3
      ],
      "slug": [
        3
      ],
      "templates": [
        289
      ],
      "templatesCount": [
        8
      ],
      "templatesPaginated": [
        300,
        {
          "filter": [
            215
          ]
        }
      ],
      "__typename": [
        3
      ]
    },
    "TemplateCategoryWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "TemplateNameAvailabilityWhereInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "TemplateReviewStatus": {},
    "TemplateWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "TemplatesPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        360
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "TemplatesWhereInput": {
      "categoryId": [
        1
      ],
      "createdById": [
        1
      ],
      "frameworkId": [
        1
      ],
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "TemplatesWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        289
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "TemplatesWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        289
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "TriggerDeploymentWhereInput": {
      "siteId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "TriggerFleekFunctionDeploymentDataInput": {
      "blake3Hash": [
        3
      ],
      "sgx": [
        9
      ],
      "__typename": [
        3
      ]
    },
    "TriggerFleekFunctionDeploymentWhereInput": {
      "cid": [
        3
      ],
      "functionId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "TwoFactorProtectedAction": {
      "createdAt": [
        73
      ],
      "enabled": [
        9
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "type": [
        305
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "TwoFactorProtectedActionType": {},
    "TwoFactorProtectedActionsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "TwoFactorProtectedActionsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        304
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "UpdateApplicationDataInput": {
      "name": [
        3
      ],
      "whiteLabelDomains": [
        3
      ],
      "whitelistDomains": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "UpdateApplicationWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateBillingPlanDataInput": {
      "isActive": [
        9
      ],
      "price": [
        18
      ],
      "__typename": [
        3
      ]
    },
    "UpdateBillingPlanWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateFleekFunctionDataInput": {
      "name": [
        3
      ],
      "slug": [
        3
      ],
      "status": [
        145
      ],
      "__typename": [
        3
      ]
    },
    "UpdateFleekFunctionWhereInput": {
      "id": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "UpdateFolderDataInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "UpdateFolderWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateMembershipDataInput": {
      "permissionGroupId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateMembershipWhereInput": {
      "id": [
        1
      ],
      "userId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateNotificationSettingsDataInput": {
      "isEnabled": [
        9
      ],
      "notificationChannel": [
        210
      ],
      "notificationType": [
        212
      ],
      "__typename": [
        3
      ]
    },
    "UpdatePinDataInput": {
      "filename": [
        3
      ],
      "moveToRoot": [
        9
      ],
      "parentFolderId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdatePinWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdatePrivateGatewayDataInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "UpdatePrivateGatewayWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateProjectDataInput": {
      "allowAccessFromOfacCountries": [
        9
      ],
      "avatar": [
        131
      ],
      "backupStorageOnArweave": [
        9
      ],
      "backupStorageOnFilecoin": [
        9
      ],
      "name": [
        3
      ],
      "planId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateProjectWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateSecretDataInput": {
      "value": [
        3
      ],
      "visibility": [
        264
      ],
      "__typename": [
        3
      ]
    },
    "UpdateSecretWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateSiteDataInput": {
      "avatar": [
        131
      ],
      "baseDirectory": [
        3
      ],
      "buildCommand": [
        3
      ],
      "distDirectory": [
        3
      ],
      "dockerImage": [
        3
      ],
      "enablePreviews": [
        9
      ],
      "frameworkId": [
        1
      ],
      "githubInstallationId": [
        8
      ],
      "name": [
        3
      ],
      "slug": [
        3
      ],
      "sourceBranch": [
        3
      ],
      "sourceProvider": [
        285
      ],
      "sourceRepositoryId": [
        3
      ],
      "sourceRepositoryName": [
        3
      ],
      "sourceRepositoryOwner": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "UpdateSiteWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateTemplateDataInput": {
      "banner": [
        131
      ],
      "description": [
        3
      ],
      "name": [
        3
      ],
      "templateCategoryId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateTemplateWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateTwoFactorSecretKeyDataInput": {
      "isActive": [
        9
      ],
      "key": [
        9
      ],
      "__typename": [
        3
      ]
    },
    "UpdateTwoFactorSecretKeyWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateUserDataInput": {
      "avatar": [
        131
      ],
      "email": [
        3
      ],
      "firstName": [
        3
      ],
      "lastName": [
        3
      ],
      "username": [
        3
      ],
      "walletAddress": [
        3
      ],
      "walletChain": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "User": {
      "avatar": [
        131
      ],
      "createdAt": [
        73
      ],
      "email": [
        3
      ],
      "firstName": [
        3
      ],
      "gitUserAccessTokens": [
        165
      ],
      "githubUserAccessToken": [
        3
      ],
      "id": [
        1
      ],
      "lastName": [
        3
      ],
      "pendingInvitations": [
        170
      ],
      "pendingInvitationsPaginated": [
        171,
        {
          "filter": [
            215
          ]
        }
      ],
      "project": [
        238
      ],
      "publicKeys": [
        243
      ],
      "publicKeysPaginated": [
        244,
        {
          "filter": [
            215
          ]
        }
      ],
      "secretKeys": [
        261
      ],
      "updatedAt": [
        73
      ],
      "username": [
        3
      ],
      "walletAddress": [
        3
      ],
      "walletChain": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "UsernameAvailabilityWhereInput": {
      "username": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "VerifyDnslinkWhereInput": {
      "domainId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "VerifyDomainDataInput": {
      "placeholder": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "VerifyDomainWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "VerifyEnsRecordWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "VerifyTwoFactorSecretKeyDataInput": {
      "token": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "VerifyTwoFactorSecretKeyWhereInput": {
      "secretKeyId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "Version": {
      "commitHash": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "Zone": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "originUrl": [
        3
      ],
      "originUrlChangedAt": [
        73
      ],
      "originUrlChangedBy": [
        334
      ],
      "project": [
        238
      ],
      "status": [
        344
      ],
      "type": [
        345
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "ZoneStatus": {},
    "ZoneType": {},
    "ZoneWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "ZonesPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "ZonesWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        343
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "deploymentsSortableFields": {},
    "filecoinDealsSortableFields": {},
    "invitationsSortableFields": {},
    "listFolderSortableFields": {},
    "migrationRequestsSortableFields": {},
    "personalAccessTokensSortableFields": {},
    "pinsByFilenameSortableFields": {},
    "pinsSortableFields": {},
    "projectsSortableFields": {},
    "sitesSortableFields": {},
    "templateCategoriesSortableFields": {},
    "templatesSortableFields": {}
  }
};
var typeMap = linkTypeMap(types_default);
var createClient2 = function(options) {
  return createClient({
    url: void 0,
    ...options,
    queryRoot: typeMap.Query,
    mutationRoot: typeMap.Mutation,
    subscriptionRoot: typeMap.Subscription
  });
};
var _ApplicationsClient = class _ApplicationsClient2 {
  constructor(options) {
    this.get = async ({ id }) => {
      const response = await this.graphqlClient.query({
        application: {
          __args: {
            where: {
              id
            }
          },
          ..._ApplicationsClient2.APPLICATION_MAPPED_PROPERTIES
        }
      });
      return response.application;
    };
    this.list = async () => {
      const response = await this.graphqlClient.query({
        applications: { data: _ApplicationsClient2.APPLICATION_MAPPED_PROPERTIES }
      });
      return response.applications.data;
    };
    this.create = async ({ name: name15, whitelistDomains }) => {
      const response = await this.graphqlClient.mutation({
        createApplication: {
          __args: {
            data: {
              name: name15,
              whitelistDomains,
              // Warning: The whiteLabelDomains has been deprecated
              // providing ephemeral retroactivity
              whiteLabelDomains: [
                ...whitelistDomains
              ]
            }
          },
          ..._ApplicationsClient2.APPLICATION_MAPPED_PROPERTIES
        }
      });
      return response.createApplication;
    };
    this.update = async ({ id, name: name15, whitelistDomains }) => {
      const response = await this.graphqlClient.mutation({
        updateApplication: {
          __args: {
            where: { id },
            data: {
              name: name15,
              whitelistDomains,
              // Warning: The whiteLabelDomains has been deprecated
              // providing ephemeral retroactivity
              whiteLabelDomains: whitelistDomains ? [...whitelistDomains] : []
            }
          },
          ..._ApplicationsClient2.APPLICATION_MAPPED_PROPERTIES
        }
      });
      return response.updateApplication;
    };
    this.delete = async ({ id }) => {
      const response = await this.graphqlClient.mutation({
        deleteApplication: {
          __args: {
            where: {
              id
            }
          },
          ..._ApplicationsClient2.APPLICATION_MAPPED_PROPERTIES
        }
      });
      return response.deleteApplication;
    };
    this.graphqlClient = options.graphqlClient;
  }
};
_ApplicationsClient.WHITE_LIST_DOMAIN_MAPPED_PROPERTIES = {
  id: true,
  hostname: true
};
_ApplicationsClient.APPLICATION_MAPPED_PROPERTIES = {
  id: true,
  name: true,
  clientId: true,
  whitelistDomains: _ApplicationsClient.WHITE_LIST_DOMAIN_MAPPED_PROPERTIES,
  whiteLabelDomains: _ApplicationsClient.WHITE_LIST_DOMAIN_MAPPED_PROPERTIES,
  updatedAt: true,
  createdAt: true
};
var ApplicationsClient = _ApplicationsClient;
var import_errors39 = __toESM2(require_dist2());
var requiredByCategory = {
  Deployment: {
    keys: ["cid", "siteId"],
    typename: "Deployment"
  },
  PrivateGateway: {
    keys: ["primaryDomain", "slug"],
    typename: "PrivateGateway"
  },
  Domain: {
    keys: ["id", "hostname"],
    typename: "Domain"
  },
  Site: {
    keys: ["id", "slug"],
    typename: "Site"
  },
  Pin: {
    keys: ["cid", "filename"],
    typename: "Pin"
  },
  FilecoinDeal: {
    keys: ["cid", "dealId"],
    typename: "FilecoinDeal"
  }
};
var isDeploymentResponseQuery = (response) => isQueryTypename({
  obj: response,
  typename: "Deployment"
});
var isPrivateGatewayResponseQuery = (response) => isQueryTypename({
  obj: response,
  typename: "PrivateGateway"
});
var isPrivateGatewaysResponseQuery = (response) => response.every((obj) => isQueryTypename({
  obj,
  typename: "PrivateGateway"
}));
var isDomainResponseQuery = (response) => isQueryTypename({
  obj: response,
  typename: "Domain"
});
var isDomainsResponseQuery = (response) => response.every((obj) => isQueryTypename({
  obj,
  typename: "Domain"
}));
var isSiteResponseQuery = (response) => isQueryTypename({
  obj: response,
  typename: "Site"
});
var isSitesResponseQuery = (response) => response.every((obj) => isQueryTypename({
  obj,
  typename: "Site"
}));
var isPinResponseQuery = (response) => isQueryTypename({
  obj: response,
  typename: "Pin"
});
var isPinsResponseQuery = (response) => response.every((obj) => isQueryTypename({
  obj,
  typename: "Pin"
}));
var isFilecoinDealsResponseQuery = (response) => response.every((obj) => isQueryTypename({
  obj,
  typename: "FilecoinDeal"
}));
var isQueryTypename = ({
  obj,
  typename
}) => {
  if (!obj) {
    return false;
  }
  return obj.__typename === requiredByCategory?.[typename].typename && requiredByCategory?.[typename].keys.every((key) => key in obj);
};
var _DomainsClient = class _DomainsClient2 {
  constructor(options) {
    this.list = async () => {
      const response = await this.graphqlClient.query({
        domains: {
          data: {
            ..._DomainsClient2.DOMAIN_MAPPED_PROPERTIES
          },
          __typename: true
        }
      });
      if (!isDomainsResponseQuery(response.domains?.data)) {
        throw new import_errors39.DomainsNotFoundError();
      }
      return response.domains.data;
    };
    this.get = async ({ domainId }) => {
      const response = await this.graphqlClient.query({
        domain: {
          __args: {
            where: {
              id: domainId
            }
          },
          ..._DomainsClient2.DOMAIN_MAPPED_PROPERTIES
        }
      });
      if (!isDomainResponseQuery(response.domain)) {
        throw new import_errors39.DomainNotFoundError({ domain: { id: domainId } });
      }
      return response.domain;
    };
    this.getByHostname = async ({ hostname }) => {
      const response = await this.graphqlClient.query({
        domainByHostname: {
          __args: {
            where: {
              hostname
            }
          },
          ..._DomainsClient2.DOMAIN_MAPPED_PROPERTIES
        }
      });
      if (!isDomainResponseQuery(response.domainByHostname)) {
        throw new import_errors39.DomainNotFoundError({ domain: { hostname } });
      }
      return response.domainByHostname;
    };
    this.listByZoneId = async ({ zoneId }) => {
      const response = await this.graphqlClient.query({
        domainsByZoneId: {
          __args: {
            where: {
              zoneId
            }
          },
          data: {
            ..._DomainsClient2.DOMAIN_MAPPED_PROPERTIES
          },
          __typename: true
        }
      });
      if (!isDomainsResponseQuery(response.domainsByZoneId?.data)) {
        throw new import_errors39.DomainsNotFoundError();
      }
      return response.domainsByZoneId.data;
    };
    this.createDomain = async ({ zoneId, hostname }) => {
      const response = await this.graphqlClient.mutation({
        createDomain: {
          __args: {
            where: {
              zoneId
            },
            data: {
              hostname
            }
          },
          // TODO: The `DOMAIN_MAPPED_PROPERTIES` when used here
          // seem to break the query. Thus, using `__scalar` true.
          // Ideally, check what cause need for this change.
          __scalar: true
        }
      });
      return response.createDomain;
    };
    this.deleteDomain = async ({ domainId }) => {
      const response = await this.graphqlClient.mutation({
        deleteDomain: {
          __args: {
            where: {
              id: domainId
            }
          },
          ..._DomainsClient2.DOMAIN_MAPPED_PROPERTIES
        }
      });
      return response.deleteDomain;
    };
    this.verifyDomain = async ({ domainId }) => {
      const response = await this.graphqlClient.mutation({
        verifyDomain: {
          __args: {
            where: {
              id: domainId
            }
          },
          ..._DomainsClient2.DOMAIN_MAPPED_PROPERTIES
        }
      });
      return response.verifyDomain;
    };
    this.listZones = async () => {
      const response = await this.graphqlClient.query({ zones: { data: _DomainsClient2.ZONE_MAPPED_PROPERTIES } });
      return response.zones.data;
    };
    this.getZone = async ({ id }) => {
      const response = await this.graphqlClient.query({
        zone: {
          __args: {
            where: {
              id
            }
          },
          ..._DomainsClient2.ZONE_MAPPED_PROPERTIES
        }
      });
      return response.zone;
    };
    this.createZoneForSite = async ({ siteId }) => {
      const response = await this.graphqlClient.mutation({
        createZoneForSite: {
          __args: {
            where: {
              siteId
            }
          },
          // TODO: Investigate why the previous fields
          // would now throw> Error: type `Zone` does not have a field `zone`
          // ...DomainsClient.DOMAIN_MAPPED_PROPERTIES,
          __scalar: true
        }
      });
      return response.createZoneForSite;
    };
    this.createZoneForPrivateGateway = async () => {
      const response = await this.graphqlClient.mutation({ createZoneForPrivateGateway: _DomainsClient2.ZONE_MAPPED_PROPERTIES });
      return response.createZoneForPrivateGateway;
    };
    this.deleteZone = async ({ id }) => {
      const response = await this.graphqlClient.mutation({
        deleteZone: {
          __args: {
            where: {
              id
            }
          },
          ..._DomainsClient2.ZONE_MAPPED_PROPERTIES
        }
      });
      return response.deleteZone;
    };
    this.graphqlClient = options.graphqlClient;
  }
};
_DomainsClient.DOMAIN_MAPPED_PROPERTIES = {
  id: true,
  zone: { id: true, __typename: true },
  hostname: true,
  isVerified: true,
  updatedAt: true,
  createdAt: true,
  dnsConfigs: { id: true, type: true, name: true, value: true, createdAt: true, updatedAt: true, __typename: true },
  status: true,
  __typename: true
};
_DomainsClient.ZONE_MAPPED_PROPERTIES = {
  id: true,
  originUrl: true,
  createdAt: true,
  updatedAt: true,
  type: true,
  status: true,
  __typename: true
};
var DomainsClient = _DomainsClient;
var _EnsClient = class _EnsClient2 {
  constructor(options) {
    this.create = async ({ name: name15, siteId, ipnsRecordId }) => {
      const response = await this.graphqlClient.mutation({
        createEnsRecord: {
          __args: {
            where: {
              ipnsRecordId,
              siteId
            },
            data: {
              name: name15
            }
          },
          ..._EnsClient2.ENS_MAPPED_PROPERTIES
        }
      });
      return response.createEnsRecord;
    };
    this.get = async ({ id }) => {
      const response = await this.graphqlClient.query({
        ensRecord: {
          __args: {
            where: {
              id
            }
          },
          ..._EnsClient2.ENS_MAPPED_PROPERTIES
        }
      });
      return response.ensRecord;
    };
    this.getByName = async ({ name: name15 }) => {
      const response = await this.graphqlClient.query({
        ensRecordByName: {
          __args: {
            where: {
              name: name15
            }
          },
          ..._EnsClient2.ENS_MAPPED_PROPERTIES
        }
      });
      return response.ensRecordByName;
    };
    this.verify = async ({ id }) => {
      const response = await this.graphqlClient.mutation({
        verifyEnsRecord: {
          __args: {
            where: {
              id
            }
          },
          ..._EnsClient2.ENS_MAPPED_PROPERTIES
        }
      });
      return response.verifyEnsRecord;
    };
    this.delete = async ({ id }) => {
      const response = await this.graphqlClient.mutation({
        deleteEnsRecord: {
          __args: {
            where: {
              id
            }
          },
          ..._EnsClient2.ENS_MAPPED_PROPERTIES
        }
      });
      return response.deleteEnsRecord;
    };
    this.list = async () => {
      const response = await this.graphqlClient.query({
        ensRecords: {
          data: {
            ..._EnsClient2.ENS_MAPPED_PROPERTIES
          }
        }
      });
      return response.ensRecords.data;
    };
    this.listByIpnsRecordId = async ({ ipnsRecordId }) => {
      const response = await this.graphqlClient.query({
        ensRecordsByIpnsId: {
          __args: {
            where: {
              ipnsRecordId
            }
          },
          data: {
            ..._EnsClient2.ENS_MAPPED_PROPERTIES
          }
        }
      });
      return response.ensRecordsByIpnsId.data;
    };
    this.graphqlClient = options.graphqlClient;
  }
};
_EnsClient.ENS_MAPPED_PROPERTIES = {
  id: true,
  name: true,
  updatedAt: true,
  createdAt: true,
  status: true,
  site: {
    id: true
  },
  ipnsRecord: {
    name: true,
    id: true,
    hash: true
  }
};
var EnsClient = _EnsClient;
var _FunctionsClient = class _FunctionsClient2 {
  constructor(options) {
    this.get = async ({ name: name15 }) => {
      const response = await this.graphqlClient.query({
        fleekFunctionByName: {
          __args: {
            where: {
              name: name15
            }
          },
          ..._FunctionsClient2.FleekFunction_MAPPED_PROPERTIES
        }
      });
      return response.fleekFunctionByName;
    };
    this.list = async () => {
      const response = await this.graphqlClient.query({
        fleekFunctions: {
          __args: {},
          data: {
            ..._FunctionsClient2.FleekFunction_MAPPED_PROPERTIES
          }
        }
      });
      return response.fleekFunctions.data;
    };
    this.listDeployments = async ({ functionId }) => {
      const response = await this.graphqlClient.query({
        fleekFunctionDeployments: {
          __args: {
            where: {
              fleekFunctionId: functionId
            }
          },
          data: {
            ..._FunctionsClient2.Deployment_MAPPED_PROPERTIES
          }
        }
      });
      return response.fleekFunctionDeployments.data;
    };
    this.create = async ({ name: name15 }) => {
      const response = await this.graphqlClient.mutation({
        createFleekFunction: {
          __args: {
            data: {
              name: name15
            }
          },
          ..._FunctionsClient2.FleekFunction_MAPPED_PROPERTIES
        }
      });
      return response.createFleekFunction;
    };
    this.deploy = async ({ functionId, cid, sgx, blake3Hash }) => {
      const response = await this.graphqlClient.mutation({
        triggerFleekFunctionDeployment: {
          __args: {
            where: {
              functionId,
              cid
            },
            data: { sgx, blake3Hash }
          },
          ..._FunctionsClient2.Deployment_MAPPED_PROPERTIES
        }
      });
      return response.triggerFleekFunctionDeployment;
    };
    this.delete = async ({ id }) => {
      const response = await this.graphqlClient.mutation({
        deleteFleekFunction: {
          __args: {
            where: {
              id
            }
          },
          ..._FunctionsClient2.FleekFunction_MAPPED_PROPERTIES
        }
      });
      return response.deleteFleekFunction;
    };
    this.update = async ({ id, slug, name: name15, status }) => {
      const response = await this.graphqlClient.mutation({
        updateFleekFunction: {
          __args: {
            where: {
              id
            },
            data: {
              slug,
              name: name15,
              status
            }
          },
          ..._FunctionsClient2.FleekFunction_MAPPED_PROPERTIES
        }
      });
      return response.updateFleekFunction;
    };
    this.graphqlClient = options.graphqlClient;
  }
};
_FunctionsClient.Deployment_MAPPED_PROPERTIES = {
  id: true,
  fleekFunctionId: true,
  cid: true,
  updatedAt: true,
  createdAt: true
};
_FunctionsClient.FleekFunction_MAPPED_PROPERTIES = {
  id: true,
  name: true,
  slug: true,
  invokeUrl: true,
  projectId: true,
  currentDeploymentId: true,
  currentDeployment: {
    cid: true
  },
  status: true
};
var FunctionsClient = _FunctionsClient;
var import_auth = __toESM2(require_dist22());
var import_errors42 = __toESM2(require_dist2());
var import_files_from_path = __toESM2(require_index_browser());
var import_errors40 = __toESM2(require_dist2());
var isNode = typeof window === "undefined" || process?.env?.IS_NODE;
var requireNodeEnv = () => {
  if (isNode) {
    return;
  }
  throw new import_errors40.SdkRequiredNodeRuntimeError();
};
var import_errors41 = __toESM2(require_dist2());
var writeFilesFromStream = async (fileStreams) => {
  if (!isNode) {
    throw new import_errors41.SdkRequiredNodeRuntimeError();
  }
  try {
    const fs = await Promise.resolve().then(() => (init_empty_DDVBHZPM(), empty_DDVBHZPM_exports));
    const path = await Promise.resolve().then(() => (init_empty_DDVBHZPM(), empty_DDVBHZPM_exports));
    const { pipeline } = await Promise.resolve().then(() => (init_empty_DDVBHZPM(), empty_DDVBHZPM_exports));
    const { promisify } = await Promise.resolve().then(() => (init_empty_DDVBHZPM(), empty_DDVBHZPM_exports));
    const pipelineAsync = promisify(pipeline);
    await Promise.all(
      fileStreams.map(async ({ readStream: readStream2, outputPath }) => {
        const dir = path.dirname(outputPath);
        await fs.promises.mkdir(dir, { recursive: true });
        const writeStream = fs.createWriteStream(outputPath);
        return pipelineAsync(readStream2, writeStream);
      })
    );
  } catch (error3) {
    throw new import_errors41.WriteFileFromStreamError();
  }
};
var IpfsClient = class {
  constructor(options) {
    this.getClient = async () => {
      if (!this.client) {
        const { create: create19 } = await Promise.resolve().then(() => (init_src_VT7VWDLR(), src_VT7VWDLR_exports));
        this.client = create19({
          url: this.ipfsStorageApiUrl
        });
      }
      return this.client;
    };
    this.pinToUploadResult = async (pin, path) => {
      const { CID: CID5 } = await Promise.resolve().then(() => (init_src_VT7VWDLR(), src_VT7VWDLR_exports));
      return {
        cid: CID5.parse(pin.cid),
        size: pin.size,
        path
      };
    };
    this.add = async (file) => {
      const nodePath = await Promise.resolve().then(() => (init_empty_DDVBHZPM(), empty_DDVBHZPM_exports));
      const path = file.path ? nodePath.basename(file.path) : "";
      const blob3 = new Blob([file.content]);
      const { UnixFS } = await Promise.resolve().then(() => (init_src_VATP7N4C(), src_VATP7N4C_exports));
      const getStream = () => UnixFS.createFileEncoderStream({ stream: () => blob3.stream() });
      try {
        const { pin } = await this.uploadProxyClient.uploadContent({ getStream, basename: path });
        return this.pinToUploadResult(pin, path);
      } catch {
        throw new import_errors42.StorageIpfsUploadFailedError();
      }
    };
    this.addAll = async (files, options2 = {}) => {
      const added = [];
      try {
        if (Array.isArray(files)) {
          const pins = await Promise.all(files.map(async (file) => await this.add(file)));
          added.push(...pins);
        } else {
          requireNodeEnv();
          const fileStreams = [];
          const basename = options2.basename ?? "wrapped";
          const { randomBytes } = await Promise.resolve().then(() => (init_empty_DDVBHZPM(), empty_DDVBHZPM_exports));
          const wrappedRandomDir = `wrapped_${randomBytes(10).toString("hex")}`;
          const wrapped = `${wrappedRandomDir}/${basename}`;
          const path = await Promise.resolve().then(() => (init_empty_DDVBHZPM(), empty_DDVBHZPM_exports));
          for await (const file of files) {
            if (file.content === void 0) {
              continue;
            }
            fileStreams.push({
              readStream: file.content,
              outputPath: path.join(wrapped, file.path.slice(1))
            });
          }
          await writeFilesFromStream(fileStreams);
          const filesFromPath = await (0, import_files_from_path.filesFromPaths)([wrapped]);
          const { UnixFS } = await Promise.resolve().then(() => (init_src_VATP7N4C(), src_VATP7N4C_exports));
          if (options2.wrapWithDirectory) {
            const getStream = () => UnixFS.createDirectoryEncoderStream(filesFromPath);
            const { pin } = await this.uploadProxyClient.uploadContent({ getStream, basename });
            const uploadResult = await this.pinToUploadResult(pin, basename);
            added.push(uploadResult);
          } else {
            const pins = await Promise.all(
              filesFromPath.map(async (path2) => {
                const getStream = () => UnixFS.createDirectoryEncoderStream([path2]);
                const { pin } = await this.uploadProxyClient.uploadContent({ getStream, basename: path2.name });
                return this.pinToUploadResult(pin, path2.name);
              })
            );
            added.push(...pins);
          }
          const { promises: fs } = await Promise.resolve().then(() => (init_empty_DDVBHZPM(), empty_DDVBHZPM_exports));
          await fs.rm(wrappedRandomDir, { recursive: true, force: true });
        }
        return added;
      } catch (err) {
        console.log(err);
        throw new import_errors42.StorageIpfsUploadFailedError();
      }
    };
    this.addFromPath = async (path, _options2 = {}) => {
      requireNodeEnv();
      const nodePath = await Promise.resolve().then(() => (init_empty_DDVBHZPM(), empty_DDVBHZPM_exports));
      const basename = nodePath.basename(path);
      const { promises: fs } = await Promise.resolve().then(() => (init_empty_DDVBHZPM(), empty_DDVBHZPM_exports));
      const stat = await fs.stat(path);
      const { UnixFS } = await Promise.resolve().then(() => (init_src_VATP7N4C(), src_VATP7N4C_exports));
      if (!stat.isDirectory()) {
        const fileFromPath = await (0, import_files_from_path.filesFromPaths)([path]);
        const getStream2 = () => UnixFS.createFileEncoderStream(fileFromPath[0]);
        const { pin: pin2 } = await this.uploadProxyClient.uploadContent({ getStream: getStream2, basename });
        return [this.pinToUploadResult(pin2, basename)];
      }
      const filesfromPath = await (0, import_files_from_path.filesFromPaths)([path]);
      const getStream = () => UnixFS.createDirectoryEncoderStream(filesfromPath);
      const { pin } = await this.uploadProxyClient.uploadContent({ getStream, basename });
      return [this.pinToUploadResult(pin, basename)];
    };
    this.addSitesToIpfs = async (path, options2 = {}) => {
      requireNodeEnv();
      const accessToken = await this.accessTokenService.getAccessToken();
      if (!accessToken) {
        throw new import_errors42.AuthorizationError();
      }
      try {
        const globSource2 = (await Promise.resolve().then(() => (init_src_VT7VWDLR(), src_VT7VWDLR_exports))).globSource;
        const client = await this.getClient();
        const iterable = client.addAll(globSource2(path, "**/*"), {
          headers: {
            [import_auth.constants.AUTHORIZATION_HEADER_NAME]: `Bearer ${accessToken}`
          },
          ...options2,
          wrapWithDirectory: true
        });
        const added = [];
        for await (const file of iterable) {
          added.push(file);
        }
        return added;
      } catch (err) {
        throw new import_errors42.StorageIpfsUploadFailedError();
      }
    };
    if (!isNode) {
      throw new import_errors42.SdkRequiredNodeRuntimeError();
    }
    this.uploadProxyClient = options.uploadProxyClient;
    this.ipfsStorageApiUrl = options.ipfsStorageApiUrl;
    this.accessTokenService = options.accessTokenService;
  }
};
var _IpnsClient = class _IpnsClient2 {
  constructor(options) {
    this.publishSignedName = async ({ key, input: input10 }) => {
      const response = await this.graphqlClient.mutation({
        publishSignedIpnsName: {
          __args: {
            data: {
              input: input10,
              key
            }
          }
        }
      });
      return response.publishSignedIpnsName;
    };
    this.resolveName = async ({ name: name15 }) => {
      const response = await this.graphqlClient.query({
        resolveIpnsName: {
          __args: {
            where: {
              name: name15
            }
          }
        }
      });
      return response.resolveIpnsName;
    };
    this.publishRecord = async ({ hash, id }) => {
      const response = await this.graphqlClient.mutation({
        publishIpnsRecord: {
          __args: {
            where: {
              id
            },
            data: {
              hash
            }
          },
          ..._IpnsClient2.RECORD_MAPPED_PROPERTIES
        }
      });
      return response.publishIpnsRecord;
    };
    this.createRecord = async () => {
      const response = await this.graphqlClient.mutation({
        createIpnsRecord: _IpnsClient2.RECORD_MAPPED_PROPERTIES
      });
      return response.createIpnsRecord;
    };
    this.createRecordForSite = async ({ siteId }) => {
      const response = await this.graphqlClient.mutation({
        createIpnsRecordForSite: {
          __args: {
            where: {
              siteId
            }
          },
          ..._IpnsClient2.RECORD_MAPPED_PROPERTIES
        }
      });
      return response.createIpnsRecordForSite;
    };
    this.deleteRecord = async ({ id }) => {
      const response = await this.graphqlClient.mutation({
        deleteIpnsRecord: {
          __args: {
            where: {
              id
            }
          },
          ..._IpnsClient2.RECORD_MAPPED_PROPERTIES
        }
      });
      return response.deleteIpnsRecord;
    };
    this.listRecords = async () => {
      const response = await this.graphqlClient.query({
        ipnsRecords: { data: _IpnsClient2.RECORD_MAPPED_PROPERTIES }
      });
      return response.ipnsRecords.data;
    };
    this.getRecord = async ({ name: name15 }) => {
      const response = await this.graphqlClient.query({
        ipnsRecord: {
          __args: {
            where: {
              name: name15
            }
          },
          ..._IpnsClient2.RECORD_MAPPED_PROPERTIES
        }
      });
      return response.ipnsRecord;
    };
    this.graphqlClient = options.graphqlClient;
  }
};
_IpnsClient.RECORD_MAPPED_PROPERTIES = {
  id: true,
  name: true,
  hash: true,
  ensRecords: { id: true }
};
var IpnsClient = _IpnsClient;
var import_errors43 = __toESM2(require_dist2());
var _PrivateGatewayClient = class _PrivateGatewayClient2 {
  constructor(options) {
    this.get = async ({ id }) => {
      const response = await this.graphqlClient.query({
        privateGateway: {
          __args: {
            where: {
              id
            }
          },
          ..._PrivateGatewayClient2.PRIVATE_GATEWAY_MAPPED_PROPERTIES
        }
      });
      if (!isPrivateGatewayResponseQuery(response.privateGateway)) {
        throw new import_errors43.PrivateGatewayNotFoundError({ privateGateway: { id } });
      }
      return response.privateGateway;
    };
    this.getBySlug = async ({ slug }) => {
      const response = await this.graphqlClient.query({
        privateGatewayBySlug: {
          __args: {
            where: {
              slug
            }
          },
          ..._PrivateGatewayClient2.PRIVATE_GATEWAY_MAPPED_PROPERTIES
        }
      });
      if (!isPrivateGatewayResponseQuery(response.privateGatewayBySlug)) {
        throw new import_errors43.PrivateGatewayNotFoundError({ privateGateway: { slug } });
      }
      return response.privateGatewayBySlug;
    };
    this.list = async () => {
      const response = await this.graphqlClient.query({
        privateGateways: {
          data: {
            ..._PrivateGatewayClient2.PRIVATE_GATEWAY_MAPPED_PROPERTIES
          },
          __typename: true
        }
      });
      if (!isPrivateGatewaysResponseQuery(response.privateGateways.data)) {
        throw new import_errors43.PrivateGatewaysNotFoundError({});
      }
      return response.privateGateways.data;
    };
    this.create = async ({ name: name15, zoneId }) => {
      const response = await this.graphqlClient.mutation({
        createPrivateGateway: {
          __args: {
            where: {
              zoneId
            },
            data: {
              name: name15
            }
          },
          ..._PrivateGatewayClient2.PRIVATE_GATEWAY_MAPPED_PROPERTIES
        }
      });
      return response.createPrivateGateway;
    };
    this.delete = async ({ id }) => {
      const response = await this.graphqlClient.mutation({
        deletePrivateGateway: {
          __args: {
            where: {
              id
            }
          },
          ..._PrivateGatewayClient2.PRIVATE_GATEWAY_MAPPED_PROPERTIES
        }
      });
      return response.deletePrivateGateway;
    };
    this.update = async ({ id, name: name15 }) => {
      const response = await this.graphqlClient.mutation({
        updatePrivateGateway: {
          __args: {
            where: {
              id
            },
            data: {
              name: name15
            }
          },
          ..._PrivateGatewayClient2.PRIVATE_GATEWAY_MAPPED_PROPERTIES
        }
      });
      return response.updatePrivateGateway;
    };
    this.graphqlClient = options.graphqlClient;
  }
};
_PrivateGatewayClient.PRIVATE_GATEWAY_MAPPED_PROPERTIES = {
  id: true,
  slug: true,
  primaryDomain: { id: true, __typename: true },
  name: true,
  project: { id: true, __typename: true },
  zone: { id: true, __typename: true },
  updatedAt: true,
  createdAt: true,
  __typename: true
};
var PrivateGatewayClient = _PrivateGatewayClient;
var _ProjectsClient = class _ProjectsClient2 {
  constructor(options) {
    this.create = async ({ name: name15 }) => {
      const response = await this.graphqlClient.mutation({
        createProject: {
          __args: {
            data: {
              name: name15
            }
          },
          ..._ProjectsClient2.PROJECT_MAPPED_PROPERTIES
        }
      });
      return response.createProject;
    };
    this.update = async ({ where, data }) => {
      const response = await this.graphqlClient.mutation({
        updateProject: {
          __args: {
            where,
            data
          },
          ..._ProjectsClient2.PROJECT_MAPPED_PROPERTIES
        }
      });
      return response.updateProject;
    };
    this.get = async ({ id }) => {
      const response = await this.graphqlClient.query({
        project: {
          __args: {
            where: {
              id
            }
          },
          ..._ProjectsClient2.PROJECT_MAPPED_PROPERTIES
        }
      });
      return response.project;
    };
    this.list = async () => {
      const response = await this.graphqlClient.query({ projects: { data: _ProjectsClient2.PROJECT_MAPPED_PROPERTIES } });
      return response.projects.data;
    };
    this.graphqlClient = options.graphqlClient;
  }
};
_ProjectsClient.PROJECT_MAPPED_PROPERTIES = {
  id: true,
  name: true,
  avatar: true,
  backupStorageOnArweave: true,
  backupStorageOnFilecoin: true,
  createdAt: true
};
var ProjectsClient = _ProjectsClient;
var import_errors44 = __toESM2(require_dist2());
var _SitesClient = class _SitesClient2 {
  constructor(options) {
    this.get = async ({ id }) => {
      const response = await this.graphqlClient.query({
        site: {
          __args: {
            where: {
              id
            }
          },
          ..._SitesClient2.SITE_MAPPED_PROPERTIES
        }
      });
      if (!isSiteResponseQuery(response.site)) {
        throw new import_errors44.SiteNotFoundError({ site: { id } });
      }
      return this.adapt(response.site);
    };
    this.getBySlug = async ({ slug }) => {
      const response = await this.graphqlClient.query({
        siteBySlug: {
          __args: {
            where: {
              slug
            }
          },
          ..._SitesClient2.SITE_MAPPED_PROPERTIES
        }
      });
      if (!isSiteResponseQuery(response.siteBySlug)) {
        throw new import_errors44.SiteNotFoundError({ site: { slug } });
      }
      return this.adapt(response.siteBySlug);
    };
    this.list = async () => {
      const response = await this.graphqlClient.query({
        sites: {
          __args: {
            where: {}
          },
          data: {
            ..._SitesClient2.SITE_MAPPED_PROPERTIES
          },
          __typename: true
        }
      });
      if (!isSitesResponseQuery(response.sites.data)) {
        throw new import_errors44.SitesNotFoundError();
      }
      return response.sites.data.map(this.adapt);
    };
    this.create = async ({ name: name15 }) => {
      const response = await this.graphqlClient.mutation({
        createSite: {
          __args: {
            data: {
              name: name15
            }
          },
          ..._SitesClient2.SITE_MAPPED_PROPERTIES
        }
      });
      if (!isSiteResponseQuery(response.createSite)) {
        throw new import_errors44.SiteCreationFailedError();
      }
      return this.adapt(response.createSite);
    };
    this.delete = async ({ id }) => {
      const response = await this.graphqlClient.mutation({
        deleteSite: {
          __args: {
            where: {
              id
            }
          },
          ..._SitesClient2.SITE_MAPPED_PROPERTIES
        }
      });
      if (!isSiteResponseQuery(response.deleteSite)) {
        throw new import_errors44.SiteNotFoundError({ site: { id } });
      }
      return this.adapt(response.deleteSite);
    };
    this.createCustomIpfsDeployment = async ({ siteId, cid }) => {
      const response = await this.graphqlClient.mutation({
        createCustomIpfsDeployment: {
          __args: {
            data: {
              siteId,
              cid
            }
          },
          ..._SitesClient2.DEPLOYMENT_MAPPED_PROPERTIES
        }
      });
      return response.createCustomIpfsDeployment;
    };
    this.getDeployment = async ({ id }) => {
      const response = await this.graphqlClient.query({
        deployment: {
          __args: {
            where: {
              id
            }
          },
          ..._SitesClient2.DEPLOYMENT_MAPPED_PROPERTIES
        }
      });
      if (!isDeploymentResponseQuery(response.deployment)) {
        throw new import_errors44.SiteDeploymentNotFoundError({ deployment: { id } });
      }
      return response.deployment;
    };
    this.graphqlClient = options.graphqlClient;
  }
  adapt(site) {
    return {
      id: site.id,
      name: site.name,
      slug: site.slug,
      ipnsRecords: site.ipnsRecords,
      domains: site.domains,
      zones: site.zones,
      deployments: site.deployments
    };
  }
};
_SitesClient.DEPLOYMENT_MAPPED_PROPERTIES = {
  id: true,
  status: true,
  storageType: true,
  siteId: true,
  cid: true,
  updatedAt: true,
  createdAt: true,
  __typename: true
};
_SitesClient.SITE_MAPPED_PROPERTIES = {
  id: true,
  name: true,
  slug: true,
  domains: { id: true, hostname: true, __typename: true },
  zones: { id: true, status: true, __typename: true },
  primaryDomain: { id: true, hostname: true, __typename: true },
  ipnsRecords: { id: true, __typename: true },
  deployments: _SitesClient.DEPLOYMENT_MAPPED_PROPERTIES,
  __typename: true
};
var SitesClient = _SitesClient;
var import_errors46 = __toESM2(require_dist2());
var import_files_from_path2 = __toESM2(require_index_browser());
var import_errors45 = __toESM2(require_dist2());
var createFileHash = async (opts) => {
  if (!isNode) {
    throw new import_errors45.SdkRequiredNodeRuntimeError();
  }
  const { createHash } = await Promise.resolve().then(() => (init_empty_DDVBHZPM(), empty_DDVBHZPM_exports));
  const { file, algorithm: algorithm2 } = opts;
  switch (algorithm2) {
    case "blake3":
      return `${algorithm2}-${Buffer.from(blake3(file)).toString("base64")}`;
    case "sha256":
    case "sha512":
      return `${algorithm2}-${createHash(algorithm2).update(file).digest("base64")}`;
    default:
      return `sha256-${createHash("sha256").update(file).digest("base64")}`;
  }
};
var _StorageClient = class _StorageClient2 {
  constructor(options) {
    this.uploadDirectory = async ({ path, parentFolderId, options: options2, onUploadProgress }) => {
      requireNodeEnv();
      const { promises } = await Promise.resolve().then(() => (init_empty_DDVBHZPM(), empty_DDVBHZPM_exports));
      const stat = await promises.stat(path);
      if (!stat.isDirectory()) {
        throw new import_errors46.PathIsNotADirectoryError({ path });
      }
      if (options2?.siteId) {
        this.checkSiteInDb(options2?.siteId);
      }
      if (options2?.functionName) {
        await this.checkFunctionInDb(options2?.functionName);
      }
      const { basename: getBasename } = await Promise.resolve().then(() => (init_empty_DDVBHZPM(), empty_DDVBHZPM_exports));
      const basename = getBasename(path);
      const files = await (0, import_files_from_path2.filesFromPaths)([path]);
      const getStream = () => unixfs_exports3.createDirectoryEncoderStream(files);
      return this.uploadProxyClient.uploadContent({ getStream, basename, parentFolderId, options: options2, onUploadProgress });
    };
    this.uploadVirtualDirectory = async ({
      files,
      directoryName,
      parentFolderId,
      onUploadProgress
    }) => {
      const getStream = () => unixfs_exports3.createDirectoryEncoderStream(files, {});
      return this.uploadProxyClient.uploadContent({ getStream, basename: directoryName, parentFolderId, onUploadProgress });
    };
    this.uploadPrivateFile = async ({
      filePath,
      hashingAlhorithm,
      onUploadProgress
    }) => {
      const { promises } = await Promise.resolve().then(() => (init_empty_DDVBHZPM(), empty_DDVBHZPM_exports));
      const stat = await promises.stat(filePath);
      if (!stat.isFile()) {
        throw new import_errors46.PathIsNotAFileError({ path: filePath });
      }
      const buffer3 = await promises.readFile(filePath, "binary");
      const fileHash = await createFileHash({ file: buffer3, algorithm: hashingAlhorithm ?? "sha256" });
      const path = await Promise.resolve().then(() => (init_empty_DDVBHZPM(), empty_DDVBHZPM_exports));
      const file = new File3([buffer3], path.basename(filePath));
      return this.uploadProxyClient.uploadPrivateContent({ file, fileHash, onUploadProgress });
    };
    this.uploadFile = async ({ file, parentFolderId, options: options2, onUploadProgress }) => {
      if (options2?.siteId) {
        this.checkSiteInDb(options2?.siteId);
      }
      if (options2?.functionName) {
        await this.checkFunctionInDb(options2?.functionName);
      }
      const getStream = () => unixfs_exports3.createFileEncoderStream(file);
      return this.uploadProxyClient.uploadContent({ getStream, basename: file.name, parentFolderId, options: options2, onUploadProgress });
    };
    this.get = async ({ cid }) => {
      const response = await this.graphqlClient.query({
        pin: {
          __args: {
            where: { cid }
          },
          ..._StorageClient2.STORAGE_MAPPED_PROPERTIES
        }
      });
      if (!isPinResponseQuery(response.pin)) {
        throw new import_errors46.PinNotFoundError({ pin: { cid } });
      }
      const { filecoinDeals } = await this.graphqlClient.query({
        filecoinDeals: {
          __args: {
            where: { cid }
          },
          data: {
            dealId: true,
            __typename: true
          },
          __typename: true
        }
      });
      if (!isFilecoinDealsResponseQuery(filecoinDeals.data)) {
        throw new import_errors46.PinNotFoundError({ pin: { cid } });
      }
      return {
        ...response.pin,
        arweaveId: response.pin.arweavePin?.bundlrId,
        filecoinDealIds: filecoinDeals.data.map((deal) => deal.dealId).join(",")
      };
    };
    this.getByFilename = async ({ filename, extension }) => {
      const response = await this.graphqlClient.query({
        pinsByFilename: {
          __args: {
            where: { filename, extension }
          },
          ..._StorageClient2.STORAGE_WITH_AGGREGATION_MAPPED_PROPERTIES
        }
      });
      if (!isPinsResponseQuery(response.pinsByFilename?.data)) {
        throw new import_errors46.PinsNotFoundError({ filename });
      }
      return await Promise.all(
        response.pinsByFilename.data.map(async (pin) => {
          const res = await this.graphqlClient.query({
            filecoinDeals: {
              __args: {
                where: { cid: pin.cid }
              },
              data: {
                dealId: true
              }
            }
          });
          return {
            ...pin,
            arweaveId: pin.arweavePin?.bundlrId,
            filecoinDealIds: res.filecoinDeals.data.map((deal) => deal.dealId).join(",")
          };
        })
      );
    };
    this.list = async () => {
      const response = await this.graphqlClient.query({
        pins: {
          __args: {},
          data: {
            ..._StorageClient2.STORAGE_MAPPED_PROPERTIES
          },
          __typename: true
        }
      });
      if (!isPinsResponseQuery(response.pins?.data)) {
        throw new import_errors46.PinNotFoundError({ pin: { cid: response.pins.data[0].cid } });
      }
      return await Promise.all(
        response.pins.data.map(async (pin) => {
          const res = await this.graphqlClient.query({
            filecoinDeals: {
              __args: {
                where: { cid: pin.cid }
              },
              data: {
                dealId: true,
                __typename: true
              },
              __typename: true
            }
          });
          return {
            ...pin,
            arweaveId: pin.arweavePin?.bundlrId,
            filecoinDealIds: res.filecoinDeals.data.map((deal) => deal.dealId).join(",")
          };
        })
      );
    };
    this.delete = async ({ cid }) => {
      const response = await this.uploadProxyClient.delete(cid);
      return {
        status: response.status,
        body: await response.json()
      };
    };
    this.checkFunctionInDb = async (name15) => {
      try {
        await this.graphqlClient.query({
          fleekFunctionByName: {
            __args: {
              where: { name: name15 }
            },
            id: true
          }
        });
      } catch (_err) {
        throw new import_errors46.FleekFunctionNotFoundError({ function: { name: name15 } });
      }
    };
    this.checkSiteInDb = async (id) => {
      try {
        await this.graphqlClient.query({
          site: {
            __args: {
              where: { id }
            },
            data: {
              cid: true,
              filename: true,
              extension: true,
              arweavePin: {
                bundlrId: true
              }
            }
          }
        });
      } catch {
        throw new import_errors46.SiteNotFoundError({ site: { id } });
      }
    };
    this.graphqlClient = options.graphqlClient;
    this.uploadProxyClient = options.uploadProxyClient;
  }
};
_StorageClient.SITE_MAPPED_PROPERTIES = { id: true };
_StorageClient.FUNCTION_MAPPED_PROPERTIES = { id: true };
_StorageClient.STORAGE_MAPPED_PROPERTIES = {
  cid: true,
  filename: true,
  extension: true,
  arweavePin: {
    bundlrId: true,
    __typename: true
  },
  __typename: true
};
_StorageClient.STORAGE_WITH_AGGREGATION_MAPPED_PROPERTIES = {
  data: _StorageClient.STORAGE_MAPPED_PROPERTIES,
  __typename: true
};
var StorageClient = _StorageClient;
var import_auth2 = __toESM2(require_dist22());
var import_errors48 = __toESM2(require_dist2());
var import_errors47 = __toESM2(require_dist2());
var retry = async ({ fn, tries, intervalMs }) => {
  let n2 = 1;
  while (true) {
    try {
      return await fn();
    } catch (error3) {
      if (error3 instanceof import_errors47.FleekError) {
        console.warn(error3.toString(), `Attempt ${n2} of ${tries}. Retrying in ${intervalMs / 1e3}s...`);
      }
      if (n2 === tries) {
        throw error3;
      }
      await new Promise((resolve2) => setTimeout(resolve2, intervalMs));
      n2++;
    }
  }
};
var shardSize = 10485760;
var uploadConcurrency = 3;
var fetchWithValidStatus = async ({
  request,
  parentFolderId,
  validStatuses = [200]
}) => {
  const response = await fetch(request);
  if (!validStatuses.includes(response.status)) {
    if (response.status === 429) {
      const error3 = await response.json()?.then((res) => res.errors[0]).catch((err) => {
        console.warn("Unexpected response with 429 status", err);
        throw new import_errors48.UnknownError();
      });
      if (error3.code === "DailyUploadedTotalSizeQuotaExceeded") {
        throw new import_errors48.StorageUploadTotalSizeQuotaExceededError();
      } else if (error3.code === "DailyUploadedFilesQuotaExceeded") {
        throw new import_errors48.StorageUploadFileCountQuotaExceededError();
      } else if (error3.code === "FolderNotFoundError" && parentFolderId) {
        throw new import_errors48.FolderNotFoundError({ folder: { id: parentFolderId } });
      } else {
        throw new import_errors48.UnknownError();
      }
    } else {
      throw new import_errors48.StorageIpfsUploadFailedError();
    }
  }
  return response;
};
var UploadProxyClient = class {
  constructor(options) {
    this.uploadPrivateContent = async ({ file, fileHash, onUploadProgress }) => {
      const formData = new FormData3();
      formData.append("hash", fileHash);
      formData.append("file", file);
      const accessToken = await this.accessTokenService.getAccessToken();
      try {
        const response = await axios_default.post(`${this.uploadProxyApiUrl}/upload/private`, formData, {
          headers: {
            "Content-Type": "multipart/form-data",
            [import_auth2.constants.AUTHORIZATION_HEADER_NAME]: `${import_auth2.constants.AUTHORIZATION_BEARER} ${accessToken}`
          },
          onUploadProgress: (progressEvent) => {
            if (progressEvent.lengthComputable && onUploadProgress) {
              onUploadProgress({
                loadedSize: progressEvent.loaded,
                totalSize: progressEvent.total
              });
            }
          }
        });
        if (response.status !== 201 || !response.data?.cid) {
          throw new import_errors48.StorageIpfsUploadFailedError();
        }
        return { pin: { cid: response.data.cid, size: file.size }, duplicate: false };
      } catch (error3) {
        throw new import_errors48.StorageIpfsUploadFailedError();
      }
    };
    this.uploadContent = async ({
      getStream,
      basename,
      parentFolderId,
      options: options2,
      onUploadProgress
    }) => {
      const { cid, totalSize } = await this.getStreamCidAndTotalSize({ getStream });
      const isDuplicity = parentFolderId ? await this.checkPinDuplicityByParentFolderAndBasename({ parentFolderId, basename }) : await this.checkPinDuplicityByCid({ cid });
      if (isDuplicity) {
        return { pin: { cid, size: totalSize }, duplicate: true };
      }
      if (onUploadProgress) {
        onUploadProgress({ totalSize, loadedSize: 0 });
      }
      let loadedSize = 0;
      const shardCids = [];
      const { ShardingStream: ShardingStream2 } = await Promise.resolve().then(() => (init_src_VATP7N4C(), src_VATP7N4C_exports));
      const { Parallel: Parallel2 } = await Promise.resolve().then(() => (init_parallel_transform_web(), parallel_transform_web_exports));
      await getStream().pipeThrough(new ShardingStream2({ shardSize })).pipeThrough(
        new Parallel2(uploadConcurrency, async (car) => {
          const url22 = new URL(this.uploadProxyApiUrl);
          url22.pathname = "store";
          const accessToken2 = await this.accessTokenService.getAccessToken();
          const body2 = new Uint8Array(await car.arrayBuffer());
          try {
            const response = await retry({
              fn: async () => fetchWithValidStatus({
                request: new Request(url22, {
                  method: "POST",
                  body: body2,
                  headers: {
                    "Content-Type": "application/vnd.ipld.car",
                    [import_auth2.constants.AUTHORIZATION_HEADER_NAME]: `${import_auth2.constants.AUTHORIZATION_BEARER} ${accessToken2}`
                  }
                }),
                parentFolderId
              }),
              tries: 3,
              intervalMs: 3e3
            });
            return { cid: await response.text(), size: body2.byteLength };
          } catch {
            throw new import_errors48.UploadProxyStoreAsCarError();
          }
        })
      ).pipeTo(
        new WritableStream({
          write: async ({ cid: cid2, size: size5 }) => {
            shardCids.push(cid2);
            if (onUploadProgress) {
              loadedSize += size5;
              onUploadProgress({ totalSize, loadedSize });
            }
          }
        })
      );
      const url2 = new URL(this.uploadProxyApiUrl);
      url2.pathname = "upload";
      if (options2?.siteId) {
        url2.searchParams.append("sites", "true");
      }
      if (options2?.functionName) {
        url2.searchParams.append("function", "true");
      }
      const accessToken = await this.accessTokenService.getAccessToken();
      const body = JSON.stringify({ basename, parentFolderId, totalSize, rootCid: cid, shardCids });
      try {
        await retry({
          fn: async () => fetchWithValidStatus({
            request: new Request(url2, {
              method: "POST",
              body,
              headers: {
                "Content-Type": "application/json",
                [import_auth2.constants.AUTHORIZATION_HEADER_NAME]: `${import_auth2.constants.AUTHORIZATION_BEARER} ${accessToken}`
              }
            }),
            parentFolderId
          }),
          tries: 3,
          intervalMs: 3e3
        });
      } catch {
        throw new import_errors48.UploadProxyUploadFileError();
      }
      return { pin: { cid, size: totalSize }, duplicate: false };
    };
    this.delete = async (cid) => {
      const accessToken = await this.accessTokenService.getAccessToken();
      const url2 = new URL(this.uploadProxyApiUrl);
      url2.pathname = `delete/${cid}`;
      return fetch(url2, {
        method: "DELETE",
        headers: {
          [import_auth2.constants.AUTHORIZATION_HEADER_NAME]: `${import_auth2.constants.AUTHORIZATION_BEARER} ${accessToken}`
        }
      });
    };
    this.getStreamCidAndTotalSize = async ({ getStream }) => {
      let totalSize = 0;
      let cid;
      const { ShardingStream: ShardingStream2 } = await Promise.resolve().then(() => (init_src_VATP7N4C(), src_VATP7N4C_exports));
      await getStream().pipeThrough(new ShardingStream2({ shardSize })).pipeTo(
        new WritableStream({
          write: (car) => {
            if (car.roots[0]) {
              cid = car.roots[0].toV1().toString(base323);
            }
            totalSize += car.size;
          }
        })
      );
      if (!cid) {
        throw new import_errors48.StorageIpfsUploadFailedError();
      }
      return { cid, totalSize };
    };
    this.checkPinDuplicityByCid = async ({ cid }) => {
      const url2 = new URL(this.uploadProxyApiUrl);
      url2.pathname = `duplicity/${cid}`;
      return this.checkPinDuplicty({ url: url2 });
    };
    this.checkPinDuplicityByParentFolderAndBasename = async ({
      parentFolderId,
      basename
    }) => {
      const url2 = new URL(this.uploadProxyApiUrl);
      url2.pathname = `/folder/${parentFolderId}/duplicity/${basename}`;
      return this.checkPinDuplicty({ url: url2 });
    };
    this.checkPinDuplicty = async ({ url: url2 }) => {
      const accessToken = await this.accessTokenService.getAccessToken();
      const response = await fetch(url2, {
        method: "GET",
        headers: {
          [import_auth2.constants.AUTHORIZATION_HEADER_NAME]: `${import_auth2.constants.AUTHORIZATION_BEARER} ${accessToken}`
        }
      });
      return response.status === 409;
    };
    this.accessTokenService = options.accessTokenService;
    this.uploadProxyApiUrl = options.uploadProxyApiUrl;
  }
};
var UserClient = class {
  constructor(options) {
    this.listPersonalAccessTokens = async () => {
      const response = await this.graphqlClient.query({
        personalAccessTokens: {
          data: {
            id: true,
            createdAt: true,
            name: true,
            maskedToken: true
          }
        }
      });
      return response.personalAccessTokens.data;
    };
    this.deletePersonalAccessToken = async ({ id }) => {
      const response = await this.graphqlClient.mutation({
        deletePersonalAccessToken: {
          __args: {
            where: {
              id
            }
          },
          __scalar: true
        }
      });
      return response.deletePersonalAccessToken;
    };
    this.graphqlClient = options.graphqlClient;
  }
};
var defined = {
  SDK__AUTH_APPS_URL: "https://auth-apps.service.fleek.xyz",
  SDK__IPFS__STORAGE_API_URL: "https://storage-ipfs.service.fleek.xyz/",
  SDK__GRAPHQL_API_URL: "https://graphql.service.fleek.xyz/graphql",
  SDK__UPLOAD_PROXY_API_URL: "https://uploads.service.fleek.xyz"
};
var override_env_var_prefix = "";
var getDefined = (key) => process?.env?.[`${override_env_var_prefix}${key}`] || defined[key];
var import_errors49 = __toESM2(require_dist2());
var errors = __toESM2(require_dist2());
var graphqlFetcher = async ({ endpoint, headers, operation }) => {
  const map = [];
  const files = [];
  (0, import_object_traversal.traverse)(operation, ({ parent, key, value, meta }) => {
    if (parent && key && meta.nodePath && Object.prototype.toString.call(value) === "[object File]") {
      map.push(meta.nodePath);
      files.push(value);
      parent[key] = null;
    }
  });
  const body = new FormData3();
  body.append("operations", JSON.stringify(operation));
  body.append("map", JSON.stringify(Object.fromEntries(map.map((path, index2) => [`${index2}`, [path]]))));
  files.forEach((file, index2) => body.append(`${index2}`, file));
  const fetchHandler = !isNode ? (await Promise.resolve().then(() => __toESM(require_node_ponyfill()))).default : fetch;
  const response = await fetchHandler(endpoint, {
    method: "POST",
    headers: {
      Accept: "application/json",
      ...headers
    },
    body
  });
  if (!response.ok) {
    if (response.status === 401) {
      throw new import_errors49.UnauthorizedError({});
    }
    throw new import_errors49.UnknownError();
  }
  const data = await response.json();
  const error3 = data?.errors?.[0];
  if (!error3) {
    return data;
  }
  if ("extensions" in error3) {
    const errorClass = errors?.[error3.extensions.name];
    if (errorClass) {
      throw new errorClass(error3.extensions.data);
    }
  }
  throw new import_errors49.UnknownError();
};
var FleekSdk = class {
  constructor({
    graphqlServiceApiUrl = getDefined("SDK__GRAPHQL_API_URL"),
    ipfsStorageApiUrl = getDefined("SDK__IPFS__STORAGE_API_URL"),
    uploadProxyApiUrl = getDefined("SDK__UPLOAD_PROXY_API_URL"),
    accessTokenService
  }) {
    this.getVersion = async () => {
      const response = await this.graphqlClient.query({ version: { __scalar: true } });
      return response;
    };
    this.user = () => {
      if (!this.userClient) {
        this.userClient = new UserClient({ graphqlClient: this.graphqlClient });
      }
      return this.userClient;
    };
    this.ipns = () => {
      if (!this.ipnsClient) {
        this.ipnsClient = new IpnsClient({ graphqlClient: this.graphqlClient });
      }
      return this.ipnsClient;
    };
    this.ipfs = () => {
      if (!isNode) {
        throw new import_errors50.SdkRequiredNodeRuntimeError();
      }
      if (!this.ipfsClient) {
        this.ipfsClient = new IpfsClient({
          uploadProxyClient: this.uploadProxyClient,
          accessTokenService: this.accessTokenService,
          ipfsStorageApiUrl: this.ipfsStorageApiUrl
        });
      }
      console.warn("Warning: The `ipfs` service in Fleek SDK will be deprecated. Please use `storage` service instead");
      return this.ipfsClient;
    };
    this.sites = () => {
      if (!this.sitesClient) {
        this.sitesClient = new SitesClient({ graphqlClient: this.graphqlClient });
      }
      return this.sitesClient;
    };
    this.projects = () => {
      if (!this.projectsClient) {
        this.projectsClient = new ProjectsClient({ graphqlClient: this.graphqlClient });
      }
      return this.projectsClient;
    };
    this.domains = () => {
      if (!this.domainsClient) {
        this.domainsClient = new DomainsClient({ graphqlClient: this.graphqlClient });
      }
      return this.domainsClient;
    };
    this.applications = () => {
      if (!this.applicationsClient) {
        this.applicationsClient = new ApplicationsClient({ graphqlClient: this.graphqlClient });
      }
      return this.applicationsClient;
    };
    this.ens = () => {
      if (!this.ensClient) {
        this.ensClient = new EnsClient({ graphqlClient: this.graphqlClient });
      }
      return this.ensClient;
    };
    this.privateGateways = () => {
      if (!this.privateGatewayClient) {
        this.privateGatewayClient = new PrivateGatewayClient({ graphqlClient: this.graphqlClient });
      }
      return this.privateGatewayClient;
    };
    this.storage = () => {
      if (!this.storageClient) {
        this.storageClient = new StorageClient({
          graphqlClient: this.graphqlClient,
          uploadProxyClient: this.uploadProxyClient
        });
      }
      return this.storageClient;
    };
    this.functions = () => {
      if (!this.functionsClient) {
        this.functionsClient = new FunctionsClient({ graphqlClient: this.graphqlClient });
      }
      return this.functionsClient;
    };
    this.getAuthenticationHeaders = async () => {
      try {
        const accessToken = await this.accessTokenService.getAccessToken();
        if (!accessToken) {
          return {};
        }
        const headers = {
          [import_auth3.constants.AUTHORIZATION_HEADER_NAME]: `Bearer ${accessToken}`
        };
        return headers;
      } catch {
        return {};
      }
    };
    this.getCustomHeaders = () => {
      const headers = {
        [import_auth3.constants.CUSTOM_HEADERS.clientType]: import_auth3.constants.SDK_CLIENT_TYPE_NAME
      };
      return headers;
    };
    if (!accessTokenService) {
      throw new import_errors50.AuthorizationError();
    }
    this.accessTokenService = accessTokenService;
    this.graphqlClient = createClient2({
      fetcher: async (operation) => graphqlFetcher({
        operation,
        headers: { ...await this.getAuthenticationHeaders(), ...this.getCustomHeaders() },
        endpoint: this.graphqlServiceApiUrl
      })
    });
    this.graphqlServiceApiUrl = graphqlServiceApiUrl ?? getDefined("SDK__GRAPHQL_API_URL");
    this.ipfsStorageApiUrl = ipfsStorageApiUrl ?? getDefined("SDK__IPFS__STORAGE_API_URL");
    this.uploadProxyApiUrl = uploadProxyApiUrl ?? getDefined("SDK__UPLOAD_PROXY_API_URL");
    this.uploadProxyClient = new UploadProxyClient({
      uploadProxyApiUrl: this.uploadProxyApiUrl,
      accessTokenService: this.accessTokenService
    });
  }
};
var import_errors51 = __toESM2(require_dist2());
var AccessTokenService = class {
};
var PersonalAccessTokenService = class extends AccessTokenService {
  constructor({
    personalAccessToken,
    projectId,
    graphqlServiceApiUrl = getDefined("SDK__GRAPHQL_API_URL")
  }) {
    requireNodeEnv();
    if (!personalAccessToken) {
      throw new import_errors51.AuthorizationError();
    }
    super();
    this.setAccessToken = async ({ token, expiration = 60 * 8 * 1e3 }) => {
      this.accessToken = token;
      if (this.accessTokenTimeout) {
        clearTimeout(this.accessTokenTimeout);
      }
      this.accessTokenTimeout = setTimeout(() => {
        this.accessToken = void 0;
      }, expiration);
    };
    this.loginWithPersonalAccessToken = async () => {
      const { loginWithPersonalAccessToken } = await this.client.mutation({
        loginWithPersonalAccessToken: {
          __args: {
            data: {
              personalAccessToken: this.personalAccessToken,
              projectId: this.projectId
            }
          }
        }
      });
      this.setAccessToken({ token: loginWithPersonalAccessToken });
    };
    this.getAccessToken = async () => {
      if (!this.accessToken) {
        await this.loginWithPersonalAccessToken();
      }
      return this.accessToken;
    };
    this.close = () => {
      clearTimeout(this.accessTokenTimeout);
      this.accessToken = void 0;
    };
    this.personalAccessToken = personalAccessToken;
    this.projectId = projectId;
    this.client = createClient2({
      fetcher: async (operation) => graphqlFetcher({
        operation,
        headers: {},
        endpoint: graphqlServiceApiUrl
      })
    });
  }
};
var import_errors52 = __toESM2(require_dist2());
var import_auth4 = __toESM2(require_dist22());

// test.js
var import_dotenv = __toESM(require_main(), 1);
import_dotenv.default.config();
var pat = process.env.PAT || "";
var project_id = process.env.PROJECT_ID || "";
var patService = new PersonalAccessTokenService({
  personalAccessToken: pat,
  projectId: project_id
});
var fleekSdk = new FleekSdk({ accessTokenService: patService });
async function uploadFileToIPFS(filename, content2) {
  const result = await fleekSdk.ipfs().add({
    path: filename,
    content: content2
  });
  return result;
}

// main.js
var base64Data = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAUDBAQEAwUEBAQFBQUGBwwIBwcHBw8LCwkMEQ8SEhEPERETFhwXExQaFRERGCEYGh0dHx8fExciJCIeJBweHx7/2wBDAQUFBQcGBw4ICA4eFBEUHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh7/wgARCAH0BdwDASIAAhEBAxEB/8QAHAABAAEFAQEAAAAAAAAAAAAAAAECAwQFBgcI/8QAGgEBAAMBAQEAAAAAAAAAAAAAAAECAwQFBv/aAAwDAQACEAMQAAAB5OLl0x6b1opBAIzcPYFdVMlKbhbVwUguV0wVpkiuJJiIJi5JR0Gq1+U9vy2DcznpNdZyqq9bXkSu6P0jy7orct7vWWaei7QazH3eIa9VSACSJAAAAAAkAAAACSEgAAAAkAAAAACQAAAAACQAJAAAACYCYkAAAAEwJQSAAAACQAAAAJgJAAAAASRMSAAAAEwTEje01QRMjGt51ktW8m4Ws3WXjOmZKVUlui/imXb1Fw2lzB2AVUiuKiiZrCaimKrhf0+fRDGrzaTHpysw2PYeb0ljS+u7M8g57suTLdVqqUa3bQaScrFAAAABJCQAAAAJIkAAAABJEgAAAAJIkAAAABJEgASAAAAExIiYJAAAASISAAAABJCQRIAATAAkAAAACQAAAAAASAAN1XVBIIrprIprqIxM2Sm4kioIxsm8c5tZxzbV6G8bii3eJSIlWUVU1xNM1SgiZXLuRQZOmuwWKqazH2mBn1nRWdtrMr2tbl0WjGr29S2pwsqrTLRtlrpQASQkAAAAAJAAAAASRIAAAACSJAAAAASRIAAASAAACQAAAAAEhEgAAABIAAAEiASAiQAACYkAAAAEwEiJCJAAADf1UySXC2uQTFyS1cqoFy3cKaqaivGva0xtzh2DeWLl05zbZomVRRNVBPa8P1vm73+S7jQZ3wr2LY9blTRJdm1UU4OaLNZDc8z0t/DfkNHk5m2W86/yTd8XbTo7+L18l7Hu16Z6Wna6wgAAAAkhIAAAAJESAAAAAkAAAAAASAAAAAkJEJgkAAAABMBIAAAAJAAAABMAkiQAAAAJCJAAAACYkAiQAAAEkJHQU1wKl0mzdtF1ZkvxayiipWUJgrt2LVZzK9npMr493JyN85ioSoyC1ep5k6e9quwytqbNinStSumQqETIsZdBp8y/hG/wMrWROZxvY6Su1vS7PW2xpmmZiu5aqL1mq6aSNprCACSEgAAAASRIAAAAEiEgAAAASQkAAAACSJABIIkCSFQpVSUKhESAAABJAJJISITJSkQSQkEoQmJAACSEwJQSAACYACQAAAJiSEiJiQADo6rdJftYtws5uFkmXXavlqaqSqQt1zJV0vK5PNp6RpMHA8vowruLHr8t+1N6WPvufyLxyPf1+U2ju9LZyjrsLbaoium6Y9WflmnqxaDOjU55fxNhiFqcTMKew47pc/Q1nAeq+WWm0hbzqqqJK7lqov4124aSM/BAAAABJEgAAKiM3F+gYjwOx6d5oi3M1TLrtd9AI+ZbXWcwiwqhaFUlKsihWlQriJpTCRJCakUq5lbVxClXKba4lbXYKFUQiVQrr6G86fE+lPnVOL1/NenTOg4T2vxyGJF+isW1URWFVSba7BQqhFMqhdbxpgvocr88voZD54wPpb51idfF+lW3XcvVnfbrL6qY8Ipy7MLE3FotrkFCuJUqhSrgpTAEhJCYJAAAAJIkAAAANzazxgLtBTXN8vVTQRaq1xk0WJNtl6IbeNLQdPkcvnw2JEq1QtYufBseo8+pOzuclciU3qSKrPOzHcarC0ZgRIgHXbfznam5zKbpiX9fdiaOZ6rFlza9YRUiSZpkuXLNZf1ufUaRdtAAkAAAAAmqmtF333wX3uKcZ5r6b5qrj3KbszkbO17pOPgeP6f1cvn2jY2LTj3cj12Xjr03WXz4ar3vZ57/ADbb+gvNJcHRn4lb2qpvRem7k99pTz2r3/NrPzhT7z5xZxtez9OvbyB6dt6z45a+jtVSfAbXU89M416MmJr6Xd+gXtk+A+/YlK+F+j5lnXoyfJfXsKryq19E4lM/nynteenfW3d56XWPHI+h7dcfnez675tW2mnItsb3QaXpsuj2Lx/2DylXRxlUcvRi4u0muend33u2Hhd33jmYjUdHqt0jxixv97y24Kr3nJ7s/nqPXdTlPm1HtXlRqZ6z0jSPDLf0hg6x882/Q+BlZTF4iSQAAAEgAAAAAmJHQ2ItkTAyYxoLtpBNIUpEQkiJgRMDaaod9Tx+YbyvQY50dvXQbRRmQs3rGZHRw2H6PxU6a0ieMCEwIkXvRPNOlM/B2mjNnizQYGp3uiExImJKppkuXbFZVqd1iGukAAAABJEguW7iuX7x4P7wz5HzX0rzac8a9avTbce9+C+9Wp5L6v5D32mHBc36j5xetfunm/cZ9HF+ich0ieH57sXRz4PoHG9Vz9fjvN+p+ZTOJmWM5p2Pp+gw6zpNLq6OqvonZ+I+wc+nmnfabdaXyvPuh89W3PovkPWzp0/jfvXheNddfsodD1PC9T0dvq/k/rHiWeef1/A99p1dHwHVeXY4bPu/MN7PT6V5J7P5xhzdhj7/AJmnNyWR0E5eju+X32ZbzPCsPcazK1/qeZ6vmv6pot7oOrmt0xHLpHPdFTyW6fmt75f1ZZu05PI8vb06jWbT2MOK9E5boMLaDlcPE5LdR2Plfc9Ndx516PzV47Hj+z5DqrxWz39vlt2fkXpuk9HPxyi7amIFwAkgkiQAAAAmAkAG2iYESIiYITBESIBSmCCSlMEECJgAgEdHzlR3WTj47fqeMwNI7LcSeZAAIBHQc/vii5pt2ZFi1mmJz+21IlBIKppkqrt1F67j3DX4+51BSAASRIAALlFSuV714D77NOR859P4W+Wlu7Sq0Ue+eEe7xbxncc9hdHJ7h4t7f5bl1dpp+48Vi3d9D5h67FuGnTc90U7qOd9Jz0845HcaGJZutyq6e1a7R+kVnwq30ei6Na/YuO9DyrxW5897+2um869B82hkdfxHZW19L8K918FyzwrdVqmWx6zjei17fbPEPb/KqU0vf8P27pzPKvVPJs+a5v8Amugy19h889D8npj6xy241rHFnla/P7Onxtvod+biNXl6+1M7quR6fmet+d+iefaV1VN+PJ2dPzdyY7/yv1/ifWw4rIp3Hn6dJuFHqZaXpPN/UMbeN4vofHYWwe+0na71nmej80tHrXGdt590VyKOIyue3U6X0DzHrrzNqujWsJWImCQRIAAAJgSAAADbkCJghMERIpSIiYITBFNQiJERIpTAiYIiqBEwbzrPN/QTX8Z6j5cQmBEiDMMJ3No4rc6famv6/m+sNBeydeW9NstYAJiRMSTNNRXXarMjEyLho16yJAAAABVTKLvv/wA+1TX6cfMkp+mnzMPR/Uvmdau+1eItX2bovnmqt/dfEsaiWZ23ntUvoy98451Le++c+eWpm9jRQVXceqrYek+VXNL/AEfd+ccuke6+ZcTTa+w9d8Sqtf0zzW3biMjseGuLfQ/z/at1imhTXG/ma6619a7b51uVeyYHlc1t6/5FatK5O95i7R9G+KaFV03pPh9dY+hXgtN6eteXauxnN3Hop2rndFymRhP0W+ep0j6EfPQ+hfE9LGE+h9/8+XdH0Hzfk2LePTOh8RnOdr0PHekYz1WX4zpumvqOH577NCnx30Dy+XYen/P60fRbwHF0j03y63SILAkAAAJIBIAAABJANuCEwREilIpTBAIiYETBCYITBAIiYETArovk2ok6jlaBDK3JoLXRaw1/p/mGQekYmo3xqci7lGz5uvQm10lXPly2AAEokmaZKqqZLl/HuEareasxwAAASABMCUETNIqUySgVKRVEEygVTRJVEAACZpFagmtQK1IqiBM0iuIAITArm2ibq2K4pFU0EXFtE3JtEXloV0xEpEpqoQurUwuLQuxbkrW5Li2Lk2hf9U8lmH0jznmO+s9IxfMeUMrChCVMymACQAACQhMCYkiQAAAASAG4pqgiKoKUiImCIkKZgRIpTBAIIETBAIBEoLubgUFN+zvzeaa/yhn6+YEA3mjHo1zD1JveX6PSGs1W70gAAAmJEwKppkrrt1GRTF40bJxgBIAAAAEwJAAAAAkRIAAACSEwSAAACQAACQQJAAAmBIQkRIRICSACSCSJAAAASIkAACSACSASiQAAAAmBIAAAbiJgRMERVBESIiRETBAIiYESKUwRFUEECJgTArtXbZHfch1hy+qycciqIIA6HnulNhhb3gC32W25kxtDnYIiYAABIAqpkqqpku3ce6Tqd5qiwAAAAkRIAAAAEiJAAAAAkRIAAAAEgASIkRIAAAASCJAAAASIkRIAAAAEgAAAASQmBMSAAAAEwJiQAAAASbiJgRMERMCJFKYIBESIiYIiRETApqggEJgiWQYsZ2IdE12sL2PVvznUwQmB1nJ9YdtwO625453nR8WaWykpSITAAmAmBMxJMxJVct1GTYrvGjXLYASImJAAAACREgAAAAkISAAAACREgAJISAABJAJBEgAATABJAmJESAACYEgAAAAAkImJAAAACRBIAAAAJESANwCIkREwQmCCCEwRFUERMCJggERIiJgRMCGYYubtrBoWy1wm3AiRESIroyT0LXaLcmNz+90prEwTCSmQgACYkAmYkqqoqLt/HumLh7TQmTGIMxhjMYYzGGMxhjMYYzGGMxhjMYYzGGMxhjMYYzGGM1hDNYQz4wc4AJCnEpM1hDNYQzWEM1hDNYQzWEM1hDNnBGcwRnMEZzBGcwRnMEZzBGdXrpNiorACMAzYwRnxgjOnAGewBnsAZ7AGewBnsAZ7AGewBnsAZ7AGewBsIwBnzrxsbmqyDNAAAmJISAAAN3RXSUpggERMEAiJgRMEJpEJIiYITAiRTFUDprWz6deesW8fnyoEIiRAITBHQaXcGhuWh32qw9aYYImJITBExJCYAJJJiJKpiSu7ZuGPqNpqwAAAAAAAAAAAAAABkY98vpC3ctGKAAAAAAAAAAAAAAADJycXKCYLGJlYoAAAAAAAAAAAAAAABtJprIJISAAAAExJuKoFJAgIIITBETAgIiqkICJgRMAkpybeQdfncDl93Tj62unk5oiYohMCJgROSbnm99oiGTkmVg7XQliUACEkARIEiAlEkzElVy3WYus2WtAF/KXwwaN5pG0CkjKMVeyTAN0aVtNWG5oNSy96cu3Fg1zdasss8YBtTVN1pRfsXjJAs3rJjA2GTkc85dtGqaa7TWTtI6tSKZF7ojl09Ac86jmSlt5NOb00Te6ILucawzDDdHzgbXZnLqqTIysTLJiYMfFysUnZa3oo5+cbTV21Zc7LTo0tu5byzGzRrHRc6E9McwvQWmwpMFesht9QG4tGsZlsx2w14dLpTEBs66KwAAABIRIAbiKoKqKoKAQCmJEEE0yKSBFUEEAgmKhTTMDKsZOsYQymEwQzNoc9G7xjA6Lo+aOb22q60w8zm5Nnz+RYIBCYAETAJEABJBNVNRNdFRi67Ya8bDX7CcsrBw9voprxMJ137Gy1uGbq+U6u1cnb6XdHn/ecH3ZleX+oeXnrvEVdeeXemeW+jHDZGq2p03OdHzh6ny8dWeJen+Y+nGh472TyAtXrN4yQLN6yYwOo1ufr9/NCfVuW8qxzdWnE8XoFrm+tOD3FzVnaefdlxp6XTVQec+meZ+ml/wAr9S8oOz3F7NPIfTPPPQzn+b7/AJ06XU7XSnIxMF/LxMskGLjZOMVbvR7a/N0vO7HlunLtdNk4mf0OotXrPN5r0fzj0eY5jd6LejRb7nzrOM7PjD1bF0dJy9VPWG78d9T4o2Wt2WtNvudNdMnjfRvMT0/gNtujzYGyuW7gAAJImJAAANzEwRVTJTFdsRMEJgiKqREikkpTBSkQCaciwUxIu37F/emFEsLsi3sTX7jOvGFiZ2xNriYGaYtrHvHO6zcaciJEJgARMCuiTKw9tqQABMSSCaqajF1+fgAGZe1q8hSAGVii9la8N7ohtdUG9sakNhrw2OuG61dkZWXqg2+oHR87AXbV0ypCLGRjmODfY2qa57S5p1OrfWtM56htnk9Bywmu2MzDDcVaUNhrxn4VI2GNYGTdwR0mkxhtdny4qpC9m4WaEwYuNkY5O3061MrFIte33Nstb1mYvm2esS6PnYE9Rywv02hl04wvZWvE52ANxa1gzMagbXVwOp0GKANlct3AkRIAAAACTbpghMFVuai3AQmCEwQmkRVBESIiRESFVNwsxIqycbL3zwYVYaU9Npt0UY+1xyd9pNaYm55nclnC33OHR8pvajnokQmBEwJQJpFVFUEAAlEiYkmYkxMHPwAAAAAAAAAAAAAAABdtXTLAx8iwYwAAAAAAAAAAAAAAAL2bh5hMSMPHycYAAAAAAAAAAAAAAAA2V21dAAAAExJCQiRuIkUxVBFVIpV0BApmYKZmBEwRFUFKZIpmBFdBMBXsMLd7Zc9u8zOx1sXkkZmJsjEsqjlMHt9WaqbmsIzq9YbKxe6Q4R02pNfKCAQmBMSUkkJAEokmYkavbVmhb+k0TMGGzBhswYbMGGzRhM0YTNGEzRhM0YTNGEzZMFnDBZwwWcMLMqkAU1wYVGfSYTNGEzRhM0YTOGCzhgs4YLOGCzhgs4YLOGCz4MFnDBZ4wGeMCrNqKbsSAW8LY0mtZ4wGeMBsBr2fJr2wGvbAa9sBr2wGvbAa9sBr2wGvbEa5sJNc2EmubEa7IyqyZAASRMSAAAAbiJFKYIiqCq3MlMSITSAQqpIVCiKhSqgpioNhrrhs+hzsLXGxVaZbVUxkGZjUWS5K4i2vWbZ1a3ZU115vW93aOIntdUYu94fZFvVd7w5aBAIlBVE0hMCQSEzElVdFZfqoumkTAAJISAAAABIiQAAAASIkAAAACQAJISAAAACYBJCQAAAAJIJIkAAACRCRCQAAAAJISISAABJEgAAAAlBuEwQmCIkRVSIiukiKhSqEU1CmUCKhTEiKaoIvW+yMvW1U7c69aox6MiMvSlDNF7P12Tpy7zTZ2r38+YOT2qqYgmpUaXm+75U3HI392cw2uqBAAmLZcWBfWBkMcZM4smXXhSbG/qayxFMFagVqBWprIAATQVrYuLYuLYuLYuLYuLYurQurUlxbFxbFxbFybQurQurQuzZF5auEgAFBWsi+sSXlkXlkXlkXlkXlkXlkXpsC+sC+sC+sC+sC/OOMhjjIWIMhjyX1gX1gX1gZEWBkMcZDHGQxxkMcZDHGSxhksYZLGGSxhkse8VEkSAG4iYETBAISETJREhEwTCopSKVQpV0CiuSO15Poy1YvYWmFWRg9HnvjaLPrmuNuMavTniLlOe6tEWqRKVYRVRWRgZ1ByNWw1Zu+R7rhiIkQDGwrtoAAAAAAAAAZONWZiQIMS2AAAAAAAAAAAAAAACugbNbuAFjDu2gAAAAAAAAAAAAAAAAAAAAAAAAAAAAABVSNvVjZIABuAQQRKCEgiRFVITAATJETJTFYoqu9KU5ObJb1Xnds9d1vE+lo1FrIp0wx71FzPotZGPfJuRIRIlbKrlqSuxfwzQ2aKSdbsNeQSRTVSa+1ctguotN1bvhqWz1kbhWQAAAAFVNRnIkU1UmCBMdBGWhjp7G2HPxvtdHZhDMAAAAAAAAAAABnXbV0mJgwbVy2ADImMcRIAAAAAAAAAAAAAAAAAAAAAAAAAAAGflYuUAEwbiJEECJgiUCYEykphJNNYplUREhkWd0bbGx6BFvJMfp/GtwZfW+cepmsrkUTFYuRbKpogurck3KaiU0lGHsLJpNPnYJe1e21RESIiqk1tu5bHQabc25NVlWsO+t3KyKHoacZcra6r0o0XJbjUHUWOksnn+8wvSDy7I7HWnJVU1GbMSKaqDCBk7fUbSeTRCOtvdF0N+rn4mKcra6r0o0XJbjUG42PRak4ne2e7PLd52uUeSdrxXrRwGp9O88F3fbA4XrOL9JOb0lremy57ueBMAGdesXxEwYFu5bFVNxHR6uvZdfLg6XNwuftClW40/pZz/KbnTm7zOk1xwm8xPRDy/L6/DNbtOP9DOE2vP8ApxoeN63kje4fr/MnnPUaDJN/xnbcOC8brn/bfIR0tvXGpj0Dkjdcx0m6PNez4/1E4LT+oeYnZan0XzU1PZa7pDgLlfYmDxvccQdHrOu4I2eu7yDktX6BpjI0m1uHJAz8rEyxIAbdMERIpIEoJJERUTEwSiomAmJky9pn3zAyaMEnIxLZOl3mWV5OFnzTCp2+ri9i/TeKcbKsFyuaCarN0KKhITarwjU6nd6gzNJvdEIkRTXSauiugr6nk97vy27O55y3ZuZ6Hh+T0cMW8x6b5lkHT8ltNSen08PYKO18/wAo9H5vmJLFVMmdMVEUXLZhAydlqt1tyc+2qnoarqcDZcmvK0zG/K9N8yyZdNyW01J6hicLklPY+eZRv9v5/lGL6r5VlFdvGHpc8VhmJ6L51lmJ0fOXT0Lh8zXGKDNv2L4iYNfRXQbmdLlacuPTs63bg9TotfhstluZ6d5jky6fkNnqz1LH4G+Wez8/yj0PS8lUY/ofnmUYvp3mOxNxy250x6D2Pi8lVeCOx4zIxx2vFZZ3NrgMs6W5yWzOq5bS1noF7j9ST6b5dkHeee5OGev+c1YZc3/Hbw6DQaO4ej8XOlPSuCvYp2+HyuKelctq8I77fed4hhAzszDzAADbxVBETAiaCUSSiCqaZKpprKZ2F41l7MGXOig30Wb5MIReou274UTXFOiq7arnKdlg45tNdk5Ma6bKvWSqKKxbu2y7EQSoqGDn681WsujN0O+0RESKYqpNXRVSAXsrXpvVSRQAAAAABMSZ1VNQt3LRhgXrIz4wU3z8ApULQAAAAAAAAAAABm38fIEVQa6iqkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAzszCzQAkbemqCkggETFQX75gZG2grr0IzMSkVIqJTB12Nrd4a29kY1+ahRfp0rlqTIv4El7aaPpo5LOj67jpxz72rqejVTtrZromsomJJpqpGquagx6pkvaXZ60pVUkUVDVW8/CKQAAAAAAAAKoyS9ILdyDXr9kgAAAAAAAAAAAAAAAvGReioRMGuozsMpAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALxk5dNZCQBtomCIr2pp8nbYxetaeDPs4tRMxJMwKppkVRIrjZmy3Nu2rj2Ixppl0Y1yNZpqkVRBF6zUqrprVpqplpGTZGww4yzAivIMWjq+eOd1W6wzHv3qTUY1VJFNUFKYKaLkFpegtrslmbklqbtRaruXS3jbTWGIuChWKFYpmZISISIprFtcFCsW5rFCsUK5La4La4La4La4KIuChXJbXBbXBbXBRFyS3VUAAFNUlpcFtdFpdFqbgtrgtrgtrgtrsFtdFpdFpdFpdFqbgtrotLotLotLotLotLslmbotLotLotLotLotLotLwsrwsrwtLotLotV1SRIAAdPXrbZt9ZagQE0pJmmoiZgmqkTMoVQ2cr2ZhZDLp7N/X38jTTCntympMIqKpSTQFybdZTMwTSqIom2bLpuTxjgcTv8AeHOMXOLXPbXRgFKaAmCAAJiRITVTUVXaLxc0+104AASIkAAAABJEgAAAASIkAAAACQAAJIJIkAAABJBIAAAAkImJAAAABJCQAAAAJISAAAACRCYJAAAATBtaQiAmAgEyESFUkJqJXtyGPbEXaycKLpHRckAFwLdwJuBRARIU0hGKI4jKE77JDR4gICaAiASACQSE1BXkBa1YAJAAAAAACQAAAJBASAAABIAAAASAAAACYCQAAAASCJAAACQAAAAAAASAAABIICYCQAJCAAJD/8QANBAAAQQBAgMFBwMFAQEAAAAAAgABAwQFERIGEBMUICExMhUiMDVAQVAzNHAWIyQlNmBC/9oACAEBAAEFAuT9+H0Ny0T8vN1qzJtOWnLxTLzUTCCf3iJhF4wIjrZYxYsvX2R7DOehY6jxjunllOJyNmrVIrDSeyDMqcghWsRRw66oxYkcTt/CTMn8U4+Hd01QNtHnqnXkmT+Wibmzvy+zMmZ07akJMKl8WB3Za/3AdmUto3NgfSK3JEsTDGeNuRWMPbr4+G3GxBdkkAopOUsWqdtP4RfnJ6lt8FDIwO2hD3PsBEmbVtExAm0dMz89E/Nm1JCzbh27WD3mEhH1IdwNNquG7EjnarwXK97A3qEty/24T1u4TmYM7GDj/B+vc01bprpumiZOLs8LizgbHB3LB7G3kumZqKHR9Fpy07rcz1dDHo0cekWzw0Lb0BGnYtNIdHKWah0crTtKeKvIs/b6zywyREm5O2qlj0/g5vLn90Xgm11cWduk6hjOPl487PoZnd60bivddeXe0Tc/szaNqy18IgZ7ATdlmk1Zhfc0wIQFiyQTzg0EkSKaWAihhlRMQkm5TRfwa2js7ePPyWnJlr3tE3TjKRpnTBKzBY0UZCTMtNOX3X30daJk6ZncXrVuyzWZbC01fx1Z9XctF7yqNFJXljaRBI0wTQFEisEYY2g9pWsZYgHlLFqn/gv7MtObOhbVF4OPjybl4c5pE7+9FIBptFNEJs4SRFVm390PEhqQ62KgEBKnB2iSKxLVZ1p46+LomT6OLqi8cNyCCtOeYrkEtWXeEru8mBtj0tWdZmt0LGvKWPcnbR/4KfybwT+KFk3gnfw0Wi+7PyZlombV7Ie+8DmmHpSRsO1aLRm7mnKhdE4Xmh0sicVu1JHJMy8+4TO6jidmPQXjPbPeeZ5A0twSidO0QhOxg4PXy0wBbsHYkTcpY9ydtH/gh/FbdE3gm8EPimHRmW7xN3YA8n5MnTeRaKOSN3kIBE7Au0Ekkknd6Uu2MXkK3oTSVq41J55ZkzLzdPy015TOe02d0JaiUdk6NY3htXY4bckJvDLaICH792WPczto/wDA7eSfVbUZCKGUHfqjqxs6Mtyj2bfBMteUkhioIDldsbN03p7SGGNkzLTl960RTz5PLjQP25lt1TiKXc51TxS18e7otGRI21A9WagNeUS8DCTbHfoE0kPiBi4F3NeUse5n8P4HdaLXRikckzOThC23QU7eGiHRMmTs7O3mfuthRE4lkYh2gLmuhMnYm58P+OROazRv4uTC5Vs7w9LWfh26VS/eh6FrTlp4IdVom5spNSWO6HapXj6kH67CLNlagnHIREXdblNHr9MFS0YywyxdwRd3HhzJPDIBAf4DRV6s9gtFosDiI8jHmsHFQpafGEHJ+xW12K2uxW12K2uxW07dzRYHGBkZMrgIadD8RvZObIick76CL6Ox7mZk3LReGqdMnbximOvIOWHS1bOwm9W43IOuutMylIiWMlGC1xBivaDExxnWzGRgakD5PJ5aQZbvKMnFRxtMhrgCs5WNmbLx6Plnd61qvOpIyFO25dfo27D13mDwOpL1GuSRRQzkxy95uU8f0jLh/wCTcc/qvyZYUo4souJCjly7t3NFotFotFp39FotFotFotFotFotO4yZlgYgkyoCIDtW1cGNpBxZ8pdk7LTuaLRaLTuMyxDf7PuzD/cdlomFMK4NbSbiL5MQrRaLRaLRaLTlotPrnF27oNq8bvtchZdYU87J5iTSyMoZd/J5F1I2WjII9yd9H8HTMtE4MpItWx2QcFLHTvi2AxGtiapRgZ+Ys7vUIXfM25Ye7irm+OSIo1ZZne3eaybH/cdy3F05lIzi/fblOG36JkywPyfjb9R+QoWQ2LLROKIU7LRMy2rYti2LpPpsTinbuMyYFsTxOti2LYti2LprpPo4JxTtyFkIrAD/ALZbVtXCLaQ8UNri3BdN3TgnBbUwJgTRO6eNOCcVomQMsSP+xWSeTt+6Rb5FvlTiumukui7IY1wqOkue8cSQLprpp4nZdNdNbFsW1bV0302p2+s8Vt1YxYUzau4uKbUmdvDYCkjHZzjLajkcn3Poo5pI1WuuFi1KFhRlubl9tEQoWMC6k5MDaIh8FJIwDYtnIVa+bQXbUlk+7WuyxFDKEgZWexJBFroJeJCLtJCJBOHTk77J21aQdpfQMhWC+UcafqFyBU21n7LWWN6LZy1QrS1pAdn2oRXD1GEcbxQ0ILE4Y7aq0KlZlbx9OyOZw500Qp25CyAFicE8o16lauyt42lZbKYmSk/TXD9eAsbxJWHfjcPXri3g13HVLY5ShJSnIVogZcKRRmYwQCS7NWXEEEIUOF20i4j8cdisPGIiIi1mpWsjmMU9I+mqdKSzNRw1SuwiItLFFK2SwUZDLE4kYpmUbLFD/nLIj/muC2LYumsXiu0KCtBAxCxNfxMRjw+GybMNrjXjWLxPaVXrQQMQsTZHDQyjw9XHtOZrQNjXjWNxct06mMpVmVmnVstmsE9cXb6t3ZkZu/IfPqLreDyE68Vq/wAPH2OlMO2UZIdG2GgickYEJaeOi0TETNt96yRFN8GGU4jrTT2MW4dOQnFi8Hab3lcFul8BlIG4XbR/jsgWD+U8ZfqHyBU/3CsyPDlwJjDiGv0cntVWF5pwFgDZ7TzXuxhkcrNMe+TXHZWWIyYJI8vT7JcNkzKNlw3SaezIYxx3sxYlIblpnxWXIjlAZY7lZ61nAfLbxRQq1k7c5Q3rURYu61yHiGu0+OkblGqliaBYm5Zkvrt9xS2rEw8M/pWxjeO9lrExhbsiWHyD2ldhaxV6axVRqtXKXuzqSWaR69mxA9GyNmHiWmzjKK0UTLFt/mKXGQSSex669jV1JiK4x1K/WnFmEcjkXAntTu9TJTRvAIPLk/2Nav1pxZhHJZJ4yK1Yd6mTsRFXGM5st8ugrvNPBEEMWVyh7zOQno5SzWOCUJ4eJaLVLj/Vat9J2mXZ7RmaOPJWQXbrW58rK69pm7w26sylDY7DveIZJALGV9t6sVeX4OOLJjQ92WHwZea8dLLeHwGTKcNfoGQLB/KeMv1D5Aqf7hZL5hw9P1aHFMG6vouGYN93KTdCjwwH9u9CVit7CdewnXsJ1TiKCtxdGjTKJcOBsxfE8rjXJ1qhdYyV5qHEgM02B+XcUm7RuSYlw2b9vu+NKVEhdRusH8yTplwz+lxATjjSdM6xBO2QVeNiyKmxZSzeyF7IVGk9aS8HUpzsnUSxf7tTZJo5fazL2syLJsQYYf7ts+nWkdbkBLBSahkv2WGb+/cPp1ZHW5C64dkd2yv7DAiz25Wco/Ybr2E6fAOsXUKlBxdGxYwvyuMsb0BPFJDYBrCzhNr8HFRZCSHFzOMl3Rph3NDX/UsSf4/wWflMG1/jMhWC+UcZ/qEtEKqfuFk3/wBjw3Y6d+7D2ip5Pw7D0sfxRP7/AAsbPFkbB1avt417eNe3jXt81l8kV4D5Rrh02PFcVRu8BcgWJjeLHcTG3UwHy7i3yJ0Lrhp/9lc/ZyokyjdYF/8AZp0y4Y/S4k+Wk6F1if36rFtySlykkcntY17WJe1iU2XNwnT+cSxf7tXn/wApyW5CSwhf3bwPJUk5Rrh8X25P9jhD/wAi5H1asnIVw3G+3LfL+Hj/AMuwZRwe3TXt81/UMifiORZTNHdqv+VF3Et7WKmgk9mxarmZEZfBw0N2eUXKKaWPqBXfR5dulhn6XwWTIx3C7aP8VkKwPyfi2vYnk9nX17OvpsdfUcUsFtZQv9lFK8ckEgzQ5eq45mMRjiyFntFzC3Wq3jEZI8ljJ6p7lQo2LZ+zqnZsm0Eds3WqB1wvdaKexEE8OQxVmsYgZFh8PIUhEIBkbfarfD3yzjBE6F1ww/8As7v7OR0XIHWJlaK+r+PsQTvFIDcMfpcS/LSdC6xD/wCepi0nx9lrNbK0XlctwFGxyFjqPRHPwVa4TEtVE6xT/wCartewVp6tpdltJq1pUbHQtN4tlcYe8gJipY+xOVXpxSZfwx1Sz0LAEJhlcU8xnRuCVLEWZSrSRDYzPyypZevZiMZY8vi5YjJ9FVq2LZ08XWhp8QQVK11/y2HsvHYmr6Pnof7PwsRBasWpgOOXCxFJRnHZKz7o7zt2f4bKwHx2WA+TdziV/wDfLLl/tNy4Ss9ahNVCW7xDZ7Ni9y3LC516w1rMFkOnHrPNFAGaz3VEiTvyF0JrEZ8dsUkcoq3br1RzOZK4t64ZfXE8aPondM64Vf8A2t79kTouQugJYbNxPFHLHI3Ez6Y3hR9YeKfDFkSZ1hy/2SsSf36N+SpLSydW0xCJJmEWyGYrVmt2pJ5TJaoHWJP/AGHdkk9/EZdoWjkCUVk8tBVHhmUpbGcfTFb1isqVRV7tWwxyRg2SzcQDws5HYz5bcS5rEZY6RVLta2JRxk5lHEGX4gjASJyf8vj5obY5MRKj3qtaaydLCssliY2H74qCxYuHUt9ox9eaCDIhq8Y+5kS3TfDblKO0vjarVarVarVarVarVblqtVqtUJuL9uuaHIRvqnfuM6YlHKYO9627Obu+5bluWq1Wq1W5O/cZ0xLet63pyTutUxLet63reguTg0lqaROack78mdMS3rqLqLet63reo5zjc7lg23ret6B3IqGAEVlqclGzuUbHJJhaXYqfGFthh3Lctya7bZpJZJH1/LiOqkeJhjMoyjy+sD7Xfk0cjtyxLVwpzG7G+us9OCZY7F7chY/sI7W5M3aAcdHkfcfw2TKYdw/h9Vr3Nfh6rVarVa89VqtVqtVqtVr3dVqtVqtVqtVqtVqtVqtVquHs0Ekc0UcwFgca5U6NWosrkq+PiuWZLVj85FJsRbdxg4tyggOUj7PUR3/7dmz1uUEpQljcjvUsbhyqjIc2T6omHjLflIQ+KyblOO0v/MUszfqC3FFrSzxFkZWkMpD/ADreZbmOtuOBQh1Ja7MDZi0EpjY2Vu5WyEgRjJFYigEzluxm8pk8Utn3h+MyZSjuH+Gfu7e8zuzqnUdlkC2Qd+sEWHx78TZHfWy9XJFkIJK9iwP+L8Zk3KcdC/hjXwZ9ObPtbIMTW+RM4vz4ehabJ8YkPtWthI8hDfpWKM2LmfJY7JShs+OyZTDuD+GSbTlRj6k85aRzyFLIn7vDZ7MjxhWeapjb09Ke1kMNl6+EgnpcQXx23foGX2mHaf8AC/25UBII7Vt4nmmOV+9jGEaNO0EsWYwc1cnZ2fh2qVdpTeSX47JkKsDqP8LzuGsM/Tbzd7ZMzu7uzauADWh7tCXrVq0JFalty0bDZSORZq9YtWPoWTLzY22l/C4i5FYCOMWZ3chcXB9rnIZN3RIhfGnFZxZjqpdkY320tfHbmyZWRWnhqC1BagtQWoLUFqC1BagtQW4FuBbgW4FuBbgW4FuBbgW4FuBbgW4FuBbgW4FuBbgW4FuBNo/e+24FuBbgW4FuBbgW4FuBbgW4FuBbgW8FuBbgW4FuBbwW8FvBbwW8FvBbwW8FvBbwW8FvBbwTaP3n8FvBbwW8FvBbwW8FvBbwW8FvBbwW8FvBbwW8FvBbwW8FvBbwW8FvBbwXUBbwXUBdQF1AXUBdQExh+NrRdQheJjte+3uRMb6l36rRdpyY1a96nYGxHkYzMsgGkv0TIVO7NGROT/Xi+4efkxO5P9c3ghLcPN32s7u7/XxHo/0D/VaaquGleFhB7AaD8Gi+O9nqIyA5pBGOWQSo/Rsrvo/AQ+fOX9P8BB3JvT+Rb6qpU1UlHwsb9+r6fAhcRmzc1OezymNiqznr9Iyuej8BD6ucvo/AQefOby/At9C/l9PFCRqsQ9MjARvvul+Djr1evR52PBXY2jP4nl3m5XPR3I4ZZEQkD/VQ+rnL6OValasi+LvMvZ1xez7afH29HbR/qIfPnN5Jm1exRtQBzgrzTKQXA/qW8voGT/Ss2qDQSln1VezJA8t8iRO7v8CDqieZvtkLC6EyCvKEgkETSm8knw/L4Nv086MQSSTXJ5HrTPaTs7Pzq15rU80ZwylTsjSVHFX7oX8fcouqGLv3hv427RVSvNan/p/Lq9jL1KOjStXju4q/ThhjOaW7Ts0pY6dmSmqGOu3lexd+iPKH1c5fTyy+5o+Y6sWU/ccoIpJ5TwGXCN2dngwuTnh/p/LomcSoY27eV/GXqIqpiMjbgtYjJVolEByy3qFui6qVbFuWzhMpWiVDH3Ly/p/LoxcSUPnzm8kzavFXyVJ8jEASKnF1p5QtW1IBRnyo0Ld55cHlYxTeLx4DLHHNFJDLFGcst6lapSUqlm7LPEcMyt429UgVHGXrsd+hboqnVnuTWIZa80lOzHUUGCys0VqtPVl5D5fQv4t32+Iza8vtytCwzfAYSd616ahTWPh3Ed1gmglhsnkjjkk+ltenlVrdVmegyswPC8MAxgwUpiniOGXlwl/0OWxOSlymRglr8GU4uvb4svT17fDk0uVoKxFcucPXrGYgqwyyQycPW7UuGnt2pxxMkkeR41kk9r4T5xn4Qyo4z/jVxLPLi6tPIZaOryi9XOX08pbBUa3b5V26VdulUeQlA8nGIWOXBBg16WHiSjPYmksT4u7ca5xdcuQ5hmcz4psy44eFLct4pg6ctd7LcF8JllCtzberwhAJ5O9M+Y4ZXULFcJYvJZaCWy5PPwg0j4x4eJWZ3d3UPnzm5Czu8dHIwkUB3Kj4y2x16j1IJamRnKWM4pOXBbu0dTM5GCfjSsEOS4KrhJkbWXyE9rPf53DuH+b8QxBk4+G4xxsee+c4Gr2zLS2fbMK4QkkbOZ6SQ8twX884khDI0cp/xmLKIMjxFUzUt7K271k+Q+X0LOn+j+7+D8m87n7juVImmlLHtrYpDENYxewMRC+aksW7qos/Y7DEBVZ3geeR5T+lteXKecSqqHxxt2br2FcnGeLlwl/0OWyuRjymRmlscF05ehb4tpTT2+G4pcXQTUcxRi6lubhRcM/IliY5JMjxrHJ7XwnzjLXTx/GGTghi4eXE8EuSrcJS5Uim/WUXq5y+XKXoPT0x60x60x6rtiupmOr2/ljcfavPgps62S4maJs7jfmPGnzwC2nxVWlyA8JVJaZzH1Jq9qenwXDas5nhtYl62M4awV3ETy2oSr2OmeV4S4XLLx2eKPn3CLyNjHn4idnZ2dQ+rnNybxf2fMKnmCpScicsfP2iP2ccqmjOKXlwWzvHUxGQsT8a2AlyXBVgI8jZxV+C1nf8HhzD/N8tdLH8YULxZDjDPfOeFOnSo4fJ4WPIZ+r2PLcIRyPnM9HIGW4L+eYi+NPN8U1ux8PVYJLNjpZ3GTcY6lT5D5fRebfF0T9zVu5E+2S742OTNq9cOoZCUUuP6vaLe8Fio+vaaSzFEzbHkCN1HXlhgyP6/wAJk8ekPw7XlzrwtKrMsfS7tWxNVnmkOaUrlkqSoZbIUgv5G5edUcvkKQX8jdvcq12zXhVG7aondyt+5DDIcMtqxNanbI3GorH5K7QUmbyhzu+rqL1c5fLlLG90fZ9pdgtJsbbdDibay80ctnlWnmrSy8QZaSN/F4zKOS5anuTLH5O9Ra/lL94V22z2Klcs0pSdyKzds2Ia80lea1PLZnp27NOWxnMnOrM8tmehkLlFf1Bl0ZORKL1c5uTeLhT6atTdaZQSFDKVMbrzRnDLyo37dF5M5lpATO7PHxBlgjnmlnlikOKW3YmtT1Z5a088pzzdts9iZ3Z71yzdlo5O9Sjv37d5U7U9OYyIztZC5Zrs+jxcQZaOOzYmsy8g9P0TeCJvH6EHZm5xtuO62k/Ji2qpXJ21EWKTqRYyw9iSSnNTOO8c0vbRnjszhG+OttIGUEut8N7AC3w7Xl+Ai9XOXy/ARernN8B/H6oPT9H9k/0DeDnru5D53f3HMTF62+MFFbHrYeEZb9y7uCOXo2Ai2zXdXPxYDAbVYmcS+CxOKf4lny/AR+rnL+Bi9XOb8EHp+kL6IvebkHnc/cIRd1HDq8ELEBxAaOpCaLHXMaclaeUycmeGwQibRzMfuPRsOJZSv4/TWfL8BF6ucvl+Ai8+c34IPT9I3j8FuXj8B/F3bRw0YrQbrPiyoxEIgC+7KvWlsDJNNIzLIRStLFK7IDDWeN5hAtijkDYdGR3uU5q30pNuYwcX+uZtULaNzdk46fXszugbRuZNqxC7fgIw+nJP3G+C/Jn07kYO6nEevWF9vJ/KEHkOVrFE9ORCxNLQiNSUTjQySRHM7TuLjuGxJGMU0c0T47U7tfoS99vitFG6miBg0ZaMtGWjLRloy0ZaMtGWjLRloy0ZaMtGWjLRloy0ZaMtGWjLRloy0ZaMtGWjfA0ZbWW1loy0ZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWWne0W1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbGW1ltZbGWxlsZbGW1vqG+Np3GfRVoo5I6lYylOPQeX38Xdq0rVpJTlLRaLRaLRlZhAnnqGBH4pyFkEraxTuJuMUo3KhQ/RshUn6f8A7/Tw+hjFzkYBjrSm3TZ3dbXTt4Vq8l1zmMHb3eQtq5DogJiTunbVltHd041dqxuDuzKCfRpBGxWlB45PohRen/37fBZfbk3dgikkk98If/otepqiVitZxotCQqtN1H1VLxQto18GGbu6KzVj26PFJQlhGtJ+p33+Gy+xer/37/Q4yF69Mi1JE+i3+7XrSzVbZPYlGQTLpgKFlBP0T62jSOcsrctVpzJtRuQnuiLR4HiKO/AERd4jBl1QXVBdUF1QXVBdYF1gXWBdYF1wXaBXahTyA77wW8FvBbwW8ExA/f3gt4LeC6gLqAuoC6gLqAuoC6gLqAuoC6gLqAuoC6gLqAuoC6gLqAuoC6gLqAuoC6gLqAuoC6gLqAuoC6gLqB33IGXUBdQF1AXVBdUF1QXVBdUF1QXVBdUF1QXVBdUF1QXVBdUF1QXVBdUF1QXVBdUF1QXVBdUF1QXVBdUF1QXVBdUF1QXVBdUF1QXVBdUF1QXVBdUF1QXVBdUF1QXVBdUF1QXWBdUF1gXWBdYF1gXWBdYF1gXWBdYF1gXWBM7O3xm7n25Ny8ef25i245y8W8ZY5NFv6r4iJrE9wpaj9MgMXkGMhYEXi2jaM3Lw5M3L7r73Y2MTFVZniPKA51O7MWn0sRdxlIW5/wAABOL9yYtG/PCTi7Pq3xvs3wPLu6KpCU88zMMjfq+HZ4mchlpy0gnPfLscxj91D4p+Xky+7825P5yNuazo4+Al14xxHdl/U+kD1/fk/p/BR/p85f1Pz8H6fxmT+D95l5cvs/JmWBi8XiklsWIqNNhu8PkYYyCeJ3J10tXlPV4hcQcXcmkYCJvdZ9yZuTcvJB6VqylLZHM7iReKt+juy/qfSD6vvyf09zR9WZ3+tj/T5y/qfn4PR8VuXm3Nu791oo4zketi3Y7FiKNW7PsnEyGchrGXp6Fi60Ti/vogEnfa8nSHUBJabuXgm5s2rOzsmdnfwV39CV03iE/jH3HUnr5RAcpvVrwL/XOpKvufGH1ffk/p504YYEMlAb0BUoZ4HpRKzA0TfVR+jnJ6+5LDLE35qD0fA+3x35Qx9UhkihE7BSJvVxcQvew9LC3JLfDlKxFfw9yvLi3c+GnZ3QNoIBoTlo7N4rzQrXxFP7y8uWmqdnVh3dWyj2Dt3Su3R7snr5SF2GrBXmnXYJ0BS1prgA488dj7WQkucPZKtCqWByFyrfwuRpRqpirlqlDGU016rLStIfVzL08q5hHJlyY4+fUAMc/nyx2PtZCS5w9kq0KxuMuZB7+AyVOJY/E3L1dWMXcgx6/pjKrJYu7j1EBSy5CpNRshQsHjasJ2bH9MZVZDCXqNapXktWf6YyqyVGxj5+UXo5yevkOm6brQqCe453gFoe5jcbbyBXuH8lUhWMxV3IrIYLI0oVSxVy5TiApZchUmo2cbh7mQh/pjKq9Vlp2sbhruQgPhrJgCmxVyLH4+nNesSA8clXh/I2a/9MZVE2j8o8PekxyoVJrtl+GcqzWYJq01aE7Fj+mMqrtSxTlFtX/pjKrJYy5j03n/AExlVk8Tcx0cYHJIPDGUcLVearNSqWLk8vDOUCMhISoYO/drZKjPj58Zj7ORkmjOGW7RsVIlV4cydiLI0LVCXlB6Pia8n+C/mm8ShBgF0wiyJ9FxFE9rFocnfCGSWeYmh7HiuR+6Ito33fxLV3WjstpJx8W8G7jjqJkztH6zHXvSetVxYrFgO05e1ZKZ3ExUJvcCD3sXzsEWP4Px2St0Dd9XukQcE8H25iyORiaC/wAOW+w8M5HHtT4h4v8An6H1cy9PKvL0ZMqfUDmM3Rxr+L8rBFj+D8dkrdA3fV86Z4/h/hC3NHlszANbKcL2XqcP2MNHYz3EFtrvDa4vq5CfIThPX4NxvzHjP57T/wCGZ3Z+CpDKUpZCbhn57msTmJ8pfhsVrPKL0c5PXyADNRVrcanN7ASVbAd3IGdDhTHZK3QdcSGdHEcG2pWyeThavkeGrfYeGcrRGtnOM/noySA3Eskg4YncnwsE9nhCziM1BAq9iEMZgKZ0OKr/AO+xksvb+MJZBznKCMppmuRwZ7IV3qXuDvn2UsWI8xxD/mcPYH5zxVNKHEFkiyHB0P63FtTIz5O6M1fg4PXxTjslcvZOnfpvwzPDXzWVwmWO/kZLctrg2aJkWJzuOmMiM+BPm0j6nwQ7jY4iiC9R4q+XcLVxsZvO2LVzNZAs0+M5Qen43jzfusn5VR1NQwSSqjFFLPYYBPH2ui9zh/qoMFlCPH4yDGFJ15V4vy9cnm2i9Rt7q8NB8uerc2V1mGzo2pCzR9x0frQPtKUfeB2q1RvWWeKJmyVnSHHc4oyy/CtDAXJiJtClq2LfBvDmNnx9i5N2i3V/4fhecL9bi/5+h8+ZenlXlkhkyhlIHMJ5oMU/i/KKMsvwrQwFyYibQrsJ5vAcNYqzXvZSx2rIYj/kYcxNHgz/AOHXGV+5VyNq1ZtPVPpWuKsbatX7MJ47g5cD/qrhn57nKmZkyt6C1BNyi9PM/WsaMbtZlyAp3d3UMkwvWa3IpNvU5FEeY4Yo4C3Kz+eUgkzWG4ZxlinavTdpu0f+H4YnC9V4z+erif5KsOFiTg+WhnOmuIPkPD08eTG/++xvzHjP57y4OrtJlD4iqPZ4yiEpuDvn2Rw2TnyvEpBUxWB+c8R4vIWc3k29l8Mw/rcW5C5TzHFYNbrB6+LK2Tmv5CtkYRxlM79yvjs9Vs8blG+UxeLnyIcOVs3Dks2UR5fgavO165XnrTcF/rcL3ACbjWLoQcO2hp5fL4rIxZe+NweEeVf0/Qsn8mTcmX20Q0ibHVHp9mq2Za/LT3XbwbcK607ptq7VK1fs0fYS9It7rJ38A8XTrV9V5rx5srhEA5Vm0Z9VIGkHdP1csbcGJZCpvrRQTSHtrUIrlgrM3OvPNXktZK/aBQ5G9DFZt2rPJrE7V4ZZIZJ5pZ5U3nzP08oZZITmGW9D7PuL2dcTYq+6nsT4+m76vyrzzV5LWSv2gVazPWO3kbtsUFicIF2ifs6s2J7J8quSv1Y7Nmeyar2Z67qGSSGT2tk1ZsT2T5Renmfq5RWJ412wiTyVI12+1oZnI/OtYmrSW8jdtgqtqxVO3fu22Q2JxrwySQyWJpbEimsTzRqteuVoyyuSJlLYnlirWbFYidyICcCsTS2JOUNmeGNSWbEkEE0sEj5XJOzu7vGZxye1smpDOQ28Hs2J7MjWbDVl7Wyas3bdkWfR2zGUaMncihllhkmyuRmjUGQuwR2bE9mSvYnr8rNqza5V8nkK8ZW7RR8q/p+ifmLORFFIEmUpR1GtXYpcfWnMqfJ9GQeDF4tpzH3k/qlst7PKtI1U38CLV/ty0bRmbn9+WR16Fl+oLbhOTxg7jo/VzilkiT3behO5P8ZvPmfp5wH05o52G9UnaGxTnaD6yL08z9X5+v5fGZaJl5JvKhTmuFRjrtenOKvkL9uS7Pq+ioiXSbk6NB5L7p/NveY2J3eQ3hnKt2U4zAHW514p191qted79AyfSMmZT+EPcdF6vpG825n6fwUPp5l6vz9fy+LpzKMxZsfrisfZrwU69meu7u+7lo3LGsDQThsk0TNsXkvuyEE0aIINvuCoIR6csEm1n1Utg5o7MEETGJC7EtNUTeGuvc8lfcThfxCFmdWvdr9x0fgX0g+fM/L8FE3u8z9X5+Bvd+E/OvEc0tqtJWs5cKIlayMtmoxeHmm5/flR6rSuSKNtJfVoyaFS+6vPl931UJsidhH1kzOtdqnne3Jcg7PInX/1ztyaRieresA947hO492UNU7O30eiAdO6Y/gQDVN3JB1Ts7fngB3TNp8J0MExxYuiFwcbYhqXJZ/8uaaSeXXvefJk2rqlUIR2sIbnZSSsS65OLu7oU2q15iT7TbqJvBaM6fydyZQHtnLW5bkB45H56q6YqIPe1QxuT2D3zd52W1ltZbWW1ltZbWW1ltZbBWwU0QqcRZ9FotFotFotO/otFotFotFotFotFotFotFotFotFotFotFotFotGWjLRloy2stGWjd/RbWW1loy2strLay0ZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltZbWW1ltb4Ti4vex8tWGR8d7KgyM8NPVfdN5ctFr4oV5L7syhjlB4JWkRoj1ZD5fZlrz0dNyZfd/HnGZRlSeB5I4pJFSpnYOeDG0ont4OV8nRmgKENBEW3TGCJ9XdP8dkyn/U/9xBDGN640Fe/lbz3ZDkMx5OvLl9vBffuE681DGMY1waSSONzCyLxA/gvuzJ+XlzdPzfz5E7sKZ/GtNKyu2YsXjbdia1OuGbHURC++QmB5T38n803xmX2PxL/ANwRORdx+Wvc1WvLRP5N4qGPppycnrFo9acDjyNgCEy8X5trt5unX27run8sZo1vi4jms4nAw2SucOVNuIgaDO2HGSzbIej9CyFG+gf+6fl59zzX/wA//HIfEky+0Yt1Bbe5ea8DTMzNK3ih5fbmzpuTN4p30fXxHkXpgfQuMG/uDJII2rlmyuGPC02jtabSbl928eX2+IKsej/3P//EADgRAAEDAgMEBwcCBwEAAAAAAAEAAhEDEgQhMRMiMkAQIDBBUFFgI0JhcYGR4TNSBRRDcIDB8KH/2gAIAQMBAT8B7YGEXT/boCdFp1QtNEYK2Ly270rRICrEFvWbDhBUGbSqNcNFr1WcHPJHo4CU6mQJ6s5dcFPF2YRJ09H0yA7NPe2EAFA7PBPaMiscG5efIT0DNXdEqVKns4QEojJASFaoUK1R0BquUoZqEAu9EeAgSnNLewJntimnNE7ycU0F+iptLhIKFVBxeYCLnX2BCm7vKIc1NdPRMq3qwmhOIbkmODdU4XUrlTtbTuctq3yQohwkJ4bT1W1b5K1rxIVsJgyWGEkohFqcQE1wTuNOEKVlCAlHLnqbTVNoVXCFjbhypTOJE76eclhu9YR/tHNVXceQsPusLysOCGX95TqNZxkqgHjJyAg9AyCglQo3ZTG5SnU92VTEtQyKDQWErAsDrpWKaBQMLBU223uVemyow+a/h7t10qi6m6pdVKOJwxEIlram5oqgzTNFTv8AdXtkC5rSXKm2cysioh6q5uhQAnjKUzhTY70S3ncPV2TpVfFscyG8qUziTwb0ZWHESgy19yxFO6CqjYp2qlwQt9C5Qo6A0J5GgT2xTCZwr3CqHCUdVTduELAvDZBWKdNEqg+KaFTIrBniCo2B0VFs6PkppXQAnuTTkqJgq9ONwTHRkphTLpVTWVdKc7KE3hTY71AWXieilShkrOgiUB1dVamwE43CFMCFdIhDcCJTKkItaV7lqBtEIPTDYnEOVqGSJQKhQhkjmoXfKJULQIH0HKlSpUqemVKnonon/KPZGPT21Ecq6o4vtYhMZ8ix1WoLmkD6flNFT3iPt+VYDTLh3chWqWRBH1VN4qNuCpUy/ulOyPi1W/INVOlacihUDcolPADt3kKDKTuJsnzVGlHDkqhdsocZ5DEPjK4D55/7WCpuYD5JzGGk20Ej5/hHXwL3uVnkqVPZiO5XUv2n7/hFwiGjkHBx0KAhNfAtOngZ4x6eP6np7+r9OpKbWY/IH0yP1vp1Kx2jS1qwzHbT0yAdqT0OcGiSt6t8AmsDRA9Nme5NpSbn9qTCGIB4QShn2dWoKYlfzJ/afsU2SJ5KQMvHcQ4XQ7QZpm0Obskynu/Az9x2dQe3Z/3d0YUgXH4f7HInRUKQGWR+Kc0t1HhweJt7bEUi4hwTGPByWJii23vP/nZ1Ge2a+E2jUfwtKptfSkukci6hL79fmmMB1MIVQzIEn/vr4WTAlURcdoeipTu+ap1Lsjr2zar25NPatqObEdynKPHqkvdZ1MU4gZLCk3emCfJUmWjPXqOaHCCmUms09L1ZsMJmshDT061o2mnpT//EADIRAAICAQIDBgUDBAMAAAAAAAECABEDEiEEMUAQEyIwQWAFIFBRYSMyM0NScYCh4fD/2gAIAQIBAT8B87JiXIKYTHw6Yr0zQw5GaTyqLy9wWOXtcmvmMALbNBqH5nfJq037V+IK5A0z4f3lkHl8zWpufmZuHLHUkxAhQD7OZgoszHxGPIaB+Upb2fnIi7bSvZ/FYjlxlROH4TKMgJFRi97TU8BNeUwi9NUr5alSpUrtqAXCKEAsSvJO0uFoDYuBpqly5cvrQb6vlNMIoQAVZmoQU0K1AJpA5zWItNGXSLnhC3NYhWKIzBdojhY3ix3FoJZmsSoaEuEy4XmZ9InfQ8RMYdxcy4sgFjeYXvh9X+ZizHIaWd033h1hwpmR+7NGY9T7zQZfWcpfT1AI4mVPCDMY1LMu7aRMv7tPpFyYl2EzaDus5rcQQ+N6gCjaZkA8QmU6sIMwqNNmZVVluY91g2M2KmcPW9zNWiYgKszIVIgaoSYdc3K7xXsTK/iEzviUfqTvuD/9cyNhy50TFOP4hsdY0mvLj8QMDh+EZx9jPhahcByGNmyZjZM4TM2sI84tdfEqs4kZaC4xExZ1NzcrvF6zbpjBygmWc1qYGraYzb6pl/fcCYzH7pfSMRW0QwnS9ywZme9hMm2ICIfAIT4TMfIwwNtMbaYz2KmqoXmZtNTIWK2kPE5fvP1wmomYxtM37hPiallWp3LfaYFOHMrmcdgLkOs0M+wEGPRwpT8GfDqOE4zDgfHtOHwEOHacRtxCtOI7zmhi5Mp9ZT1uYPqdSoZq7Aamq5UAAhaAy7mmLQjNqEuhLg27L7LnOER/HF1JO8/EIZ+cCVMmPed8ftO+P2mZe+qxMbMgqNkYjaLapoqYsLA2s71hzEUM76jMqamiWu0uc/YF+ZUqaZXZU0zTKlSpplV21/ssvDEi4RRr26vELW8dtTX0gUVbRlA3HQr+ZeP7f8/9QhSLHQkVESxf0NR+mT0gr1gIfaMwGwimx0FMvIy3/ujZSX0noEW/SZ2x7AjeZ8iaBXKDcfQl/iPS6qFDoi6nciNp9IMZ16mPQKQOYhNmzHDH9pqC63+hL/Efbw/iPt7+n8pQj2z/AEvkUFdzHPh9sk/p12AXNk/zCxPP24XrZfOCRlK8/MXHfrDjoX0VH66qk8p4B+YaC/jywPXsRtN9FR/ImTny+nUefnYCLozJrxmhHOptuXlpupAndP8AaZX5Ku56FXAFTSD6zICwoH6Y223YDUI87UarzAahYmVvf15dt/bxP+h//8QAShAAAQMBBAYFCAcGBAYDAQAAAQACAxEEEiExEBMgMkFRIkJhcZEFFDBAUnKBkiMzNFBzobFicILB0fAkYKKyFUNTk+HxY4PC0v/aAAgBAQAGPwL0eSKpsY7ZzKx8EMeKvjNXhhyKpMLw58U4tDy4ZCiq7B5yGd4psZs7XXuLH/1VMWkZhwoo/o8GdduNUXuGsa84163/AJT5Hy3YmMvPNMQuhbJo+RdFgjLC5s8ftR4qSOSAPJ3Xg0LVj+5bDb7dnDYww2sVUrkhVZrAU7le4ZIBpyX1mPNBzrtQKd/9Vfb0XHlhRPbea4Up0gqOxEwIejZ5WiazE1AcMHD+qdbPIdpkhlZvROWonYLLba0yo15/kUY3tuuaaEaaj9zOLaqrdnBULdGNAFvt8VULht46BgiFJTiq1qAEKcck5tK0V44I2el5lK9yME7bzStf5PkfI0ZXd4LV+UWls7MGyNH+4IWx/wBbA/VF3tjh+5jHYoUS74L9obN0DNYlZjxWJWfoqLAokuKIQHJOOYTJxI19M4zmEySKMQe6nVJmZXEHNUbLdd7LsFWaKJ9OLmgptkszWsswPVFASqSNps1H7kq6exY6OnunZwbgsFV4WGmvosFimsnEkTD2ZKSOGRr2HDLNGgpyQvKsZx4ppriMRTmorTaXEwuFKx/zV0uD28P6rUzi+ztVbM/+ByuuBae3Ywz/AHG0yVNqmimmmw4g6KgKjmrB9dvJZbAlbNWXiwputN67lox8VdI+KosKYJ7DORKDVreDlqyCJG/V8+5Gzy0BrnTFBzXV7kGyNa6nHii4m63h2lXqXh2aaj9xtFXYy0YbdytF2BcNHbzWRHaqO3tkN7VVzQ6goK8EdWLrtFzWNZh1lLZwGOBNDXZpwRDQeiUaOxX08esYnMeZGSF3QcSjLShBo+nAr9oI3hQrzVxumtWlXX0r+qvNFGOy2Mf3G4aCUD2bGWxVXgFeBovpG4LoZbfYsF9N0O/it8Jsk0FI+APEK/FHq2ezsmug1KwHYtYOi4ZJss0FwvHDii0Rhz2m6cRi1FvI+K1jc+K5OVyVokCvuwHAcv3HYbGOZ4LHwVCslWmjDZqXUCutNV0lQNIXJuzkvq3091asZoQt3GfmU2SOe880vMQD3l13Ku1U6MOCrTDgr2dBRNkMweyM5Vxao5t6jhVSvumlTccv1QfWoP7kqqiz+CxWFSsWuV4nLgq10ZZacG1CvvrdXRjLfiKoh5ct0LLYbE3NxTrJ5OY28zB8zhU17FXz1/gEBboWTNyvNFHIvsrGzMPX6zO9ZeizyxWJoRjRS3pgx+YrkVgtXS8Y6FtBlzqr9n+kY7lwTrO9tCi0/uPw09Hx0VKph8NGSyWWjDRdHeqnFzX1/LQ6anVojd/VfVlYtI+C4aP4Sprjix98h3ao7PaLK0Ws5lsd2vgnT2VoNnA4vxTWnGGU3JGp8fAZLLRVd23RoCa21V1d3hwKrGS/HBXXZOwdQoUAwRlZg5q6ZqfQVHqwcyzTOaciGFDWxPjrlebTYoBUrWXGA+xexRY9pa4YEH7iuwQvkP7I0yufK5lwgYBa9kz3m8BQj04a0Ek5AL7LN8hX2Wb5Cvss3yFfZZvkK+yzfIdqVr5HMuCuCktDZ3uLKYEdv3ZdGihdSq7F2bI0h8OPMLGNypk3khyVScvzV4TPH8S6TxJ3tC3Wt7QKIVdi7ivPbIPpwPpI/aRa4Frm/krotLnt9mTpBQiGysiderIWZUTy3JvR08xyTi3oq844otiZj7QXSs2PejWFtCqfVO4DmsQhRNvsa9rc281fszHNY44AofnigymPBP1xoKZJzwLoJy9DeHqtl9xWXud/LYs8ku4H49miZ0VCMASOJp9wwMkYHNJxBHYrrGhoHAabR7wX/wBg9PZfxW/rtO79m0e6FaPh+o+7+ks1TguiNGapx0UAJVCRVVC6JCoRRwWWjAoVJJ0BszqEdZA2iCOb9sZqupl+dOs1gYyNxzu7FAjdDsDQ14rVjJzdnzSb+ArFBzd9qa51n1Ruj49qyCxPgnGVzz3q6fRVHqlm9xWbud/LZ1QtEoj9m+aeirT0WR28tuDv/lsT+8F/GNGA2sBt2f8AEb+ui0Ue76w8e1fWP8V9Y/xX1j/HYxGif3Qp/h+uxlt5ev4LOujpBUAuhUWSrlsdqzKpXDR0XLWPGYoaJpheLw6pwRwoeXLaqxxHcqOleR3q8FfG6fy0ULmt70LvRA5Jz9W3oU+Kq/IZbXSJe3iCi6NQmeMatp6L6YlB4ouZ4onJ3NdPPmrvrtm9xWbud/LYjr7QX2aH5ArTA+KMte512rcqKSMQRNLm0BDckQRiNLXywsc6Q3uk2qigiijad51GrWynVw/m5fRQNB5nE6KSwNr7QwK1kZ1kPPiO/aE1rq1hyYMyqQwMZ8MdHThaHe03Aq9vxHJ39dDS+GNxqcS1WVkELQ517Brc8kHTNEsvbkFQKkkQve0MCtW/EHddz2J9ZG1+AzFVebDG08w3R9ni+QKrImNN4ZNU3eF/GEJbW28/gw5BXWtDRyCpNC13bTFXmkuidkeWgRRNx/RVkbrn83ZeCo0ADsVJI2vHaEX2Tou9g5FFrhQjhsQfiDRP752dbL0YvzKpFE1vwVHAEdqL7O24/wBngVMCKGilHd+ujWy9GL8yqQxNb8FRwBHai+ztEcnLgVM2aJpoMnDJTFsEYNMw3t0YdCMZuXQha53tOxOik0DH9tMUZ7LV8Yzbxb65iqcNPFYBZ6M/R9MXgcFW6WN7VVmIW6Ueao4bFKro4pxxpXD0V5qHR+grxGSvDLisPinPGFU3HLNdx9HT1Kze4rP3O2I/eGiSVubZifzQe3JwqFJyf0xoZE3Nxomsbk0UCd/0wf8ASFwa1o8EWwOMcfZmVXWOr3oMtDjJHzOYRaaOa4eKfF1c292xrZBVkX5lOkeaNaKlEQnVR9maqLTL85QhtWNcnoxvFWuzCfEeGXcm95TbXL/ygaDtK+tMbfZYaK82d/xNVWlJG7wTzTpR9IbB1MjmVzoomPne5pOIJ0faZPFXJJnObyJU3eEHS7kZvn4IiJxij4UzVW2iX5lqpaa0fmnxHiMO/QBTpuxctXFjIfyVXyvd8VVkh7jkrwwcN4IWtgxyfsQe+NDnl76uNVvyLfk/JOcHyYBNj55oNaKAIxQZjNyrr5PmVJDrG9uaNpjykapP74psfPNBrRQBGKz0qM3Kpnk+ZdN2tZ2rzuLKRuKl7kyJvWKbEwUa1GGzOoBm9VMjye9C88yx8WuTZYzVrhgr0YpFLiOw8fW8vVLusdRBrMOZzWYd3hV1pQvRxldKJhVHfRO/JcxwVMfgpWt6HTugjOioC8HneRafRSvs9TZmn6QKvtBXeAVeqFdGNU8dUejqPUrN7is/c7Yj94aLR+If1QYT0ozdUc4zYaHuOgynKMfmpH8aUCmk7QE6Fr7l7jRfaR8i+0/6F9p/0JkTn37uFaKCTvGw0+2SVHEOucfhsRSOzIxUUnMEJveVAzgSTppzYVOP/jd+mzD3/wAtibvCdTi4DTCR7VNDW8NZodIZ9413V9f/AKV9f/pRdrbwIyopmHiw7EPvjQ5mqrdNN5fUf6l9R/qRbqcx7Se7kFI8ZgbEkfLEKT++Ke7k1SPGYbhsSRcMwpe5Od7LU5rXXSRnyX2n/QvtI+Rfah8n/lGIy6wVqMKUQfxY8fe3m0h9zQ9pwDsRo6W8cAOz0Vp8ycbt36QVzWpOTl2o9HHghe4pzaY5ek7PUbN7is3c7+WxH7w0Wj8R36rVHKUU+Kkh9pqoUHnOQ3lFZxw6RUzORBRmYy/Q4r7O35l9nb8y+zt+ZfZ2/MmNMYZd7diMeySFFKMmkg/HYhYc6V8cVCzkCU3vKs38X8tI90qb8M/pswd/8tibvC/jGmD3xoaf/k0OYYRUGma+pb4r6keK+pb4pzdS3EUz2IffGiX3zsPb2KRozu7EknDJSf3xT282qSMZluGxLKcjgFL3J7ebE97G3i0Vovs7fmX2dvzL7O35l9mZ8yMBhawE1rX72BGYTZhvcV0vy4Ix6x3xV5xqfRSixSXHBmONKqvWaVr61vI1ccOCqN5Or6WnqFm9xWfUwySUBrdbVfY5/wDtlfY5/wDtlfY5/kKiZNG6N14GjhTjotP4rv1TZG5tNQmStyeKhGFn/OcC34prBg1oopZuBOHcmueeg7ouRa6jmuCLmNMkPBw4d+gXWlrOLzkmwOiDmt48U9lmc50Y4nYNmeaNk3e9OikFWuRowyx+00K61rieQCE1qbcYMQ05lFzjRozT5eGTe5N94qzfxfy0j3Spvw3fpswPOQeK6HBsT3R16JAqquje0doU3eF/GNMHvjQ/3imvr0snd610O/xHNXXgtPIq7G0uPYi6YAvdw5JpZVsjurw2IPfGiUtgkIvHqr7PL8q+zy/Kvs8vyprzlkVUIy2Zt5pzbyVC0g8qIdAsZ7Tl5pF/y21Kl+H6pkvI4oPaag5IzWel45t5qhssvwbVVmGqZ25o2OHdiZj3qbu/mmTDqnFNkYatcKhGWzNL4z1Rm1UKuwRk9vALUSsbLXFxI4rVWVzjTeBOXZ97iNzug7BVZjzUb6buBPo7tjkuSAVreonMlBDwelVPwyOCcKUrzVclG3rHH0tfULL7mzZ/db/uOi1fiu/XQ6EnGJ35H+yoLSc4qqQ16T+g346RBaauiGTuLVegla8dhVdW2vcr80jY29pRgsdQ05yc+7aENuNDwk/qr0b2vbzaa6L08rWdnFaqIFkP5u0M94qy/wAf8tI9wqf8N36bTYbW664YB/AqscjX9xqv4wp/eC/jGmz/AIg0Se8VfjPeOawkDH+y5dIA96wAARaxwlk5DJGSR1XHYs/4g/Xad3oQWkm51Xclfje17eYOgsjcJJuQyHerQ5xq4gElTHu/XRq5AXxfmFWKdh7K4qr5GtHaUY7Ib7/b4BWiQ44CpU57v10XHAvhPDl3KsErXdnFVcxp7wrz3NY0cTgEYrCbz/8AqcAiSak/fEbnfXRjmpL4qKbd2JtearaXV/Zai6yZtzZoayyyauTO9eonxGJ7pGnpI3qg8RyQKwJCGHVH3ZVpIKp53P8A9wqr3Fx7T6CrHuaewqhtU/8A3Cqk+tUZPI0djl9JK9/e701WPc09hVHzyuHa47AaMzgr1sffPsNyRYQdWdx3MaAyNpc45AIMdTWOxeo7ID0nG87u2KC1Tj/7CqyPc89pr98E8ArrASfaQex1HBObNHeciaU7BpqGOppvwDPe5q81xFVWuKq6rXcbqY6Fxc0Y3i6ifusccz2qu8UexC9IAB2ou/zO2y2t92QYNcesrkrGvbyKrq3jsD1/h4WsPPiqyG9Id1gzKfPKaucfv1woHAihqjdy7UDzFdOGXNYNvPX0cRB7clhGxg7OOi83lzWotNDXrlV6p0NbEaOTmS7/ABV4ZV4Ixh2BP+arrJrzB1X4rGzw/mqNcyEfsBF73FzjmSfv+vFSMYBUCuhrOZTY69EFGKENujeI4p0Fxrq8Tw2dVJVwG6eS1sJ95vJARb9cE4Sk3xmnRgK9+6ymaqDTRrCTgvewHoBbLay/NJ9XFX9VVrYGt9kMWrtbRZpzlIN0oiZvS/Uc0ZMsfUq/uZOCw0tbwGYUge69y047DbwqGC8rOJmuMQjyBRm8nWkmmbZW0p8VqrQy67hinWWQ1tFm6UZ4ubyTbOzq5/uswNdArutxKfNdqByRc7Cu33toVDbWCpi6D+5NdHLI1lekGnNOZIGw2gto10opQ96s8cmF/CoxDgpm8pD+67MY4q6w4rpbbnUo+9mi2Roc0ij2ozWRpms55YlqoU7ypawWRQtOrr1inSHrGvqdf3MXY6XRx5o1ja80oCeCqUWsGCqVRF5pepgdoQ0pq/zTGsfqyTmnRmuHEcUXeZwl3tOYi2V/Qbk0ZD1Wn7mKDFCg6RVAqHNVzVHONNqrTROke5nnANKZLFNB67k/1WqqcAt78lvHwW8fBbx8FvHwW8fBbx8FvHwW8fBbx8FvHwW8fBbx8FvHwW8fBbx8FvHwW8fBbx8FvHwW8fBbx8FvHwW8fBbx8FvHwW8fBbx8FvHwW8fBdE12qk0C3vyW8fBbx8FvHwW8fBbx8FvHwW8fBbx8FvHwW8fBbx8FvHwW8fBbx8FvHwW8fBbx8FvHwW8fBbx8FvHwW8fBbx8FvHwW8fBbx8FvHwW8fBbx8F0TXaqTRb35LePgsz4LePgt4+CzPgt4+CzPgt4+CzPgsz4LM+CzPgsz4LePgsz4LM+CzPgsz4LM+CzPgsz4LM+CzPgsz4LM+CzPgsz4LM+CzPgt77tx3UIW07Sm0ukVVX4vdy4In0EYnP0d7pUVbBLfjpzROTgcQobgV+tQ71WpVT9wV48dip4Kp+4K8eOxVVP3BdOXqNfW6caZ0R1xoDxGavg9CvR9FaBah/iP+WdFWuIRdwpgiHDJvqo+4T3bHx+4T3bA/wAmNGRIvE8lWGZ4d2lUeTgqVw9Cxzm3mg4jmg6xR6tl3HCmmFlSKNxQphhj2+qjv+4T3bA7/uE92wPvOvrHIJr+yhV4uFETlU19FaIJrPrHSbp5bEcYyAQocx6qNmscT3dwVHNLT2+t/DYHfpLoYi4DjkF9SPnavqv9YX1X+oL6r/UFQ+snu2Boor74+h7TTUbH0bKjnwRYaVHrQ+6KuxpwXRFFVp+CqIY2nnRVdiT6ETtjc4MNa0wTZRDqqNpnWuimrcmue2gGOKdM9l1w+rCLzx9VGw58n1cbbzu3sWDyxvBrcAF5taDevbjzm0og5jYbBAy/I7IJ0UguvYaOCbbTF9A40D68dF+zWdzme0TQfmgLVA6OuR4eOi9ZrO5zfayCHnVncwHjmEILOy/I7IVX2M/O3+qElqg1bSaA3gU5lli1jmipxAWttNnMbK0reCbFGLz3mjQhHaojG4ioUlrZFWGM0c6uWg+awOeBmcgr9ps7ms9qtRp+Gx8dNlaz6jVAtplXj8dgXa14UTa79wX+/SIoWOe92QCvmxmnY4EqhFCE2aKylzHioN4L7Gfnb/VFpzCJssDngccgr1ps7mN9rMaBPZ7MXxnI3gjLNZHtYMzgaeGhscbbz3GgCaLVCY7+7jno1VmidI7sRllspuDMhwNPDQ/zWHWXN7EBfYz87f6otdmDQ6D3bA0UHFaxsRu9YA3gU2SIUilF5o5dmhrDg3Nx7F9FEWwDcGQRY7MaXCyxay5niArzrE+n7ND+migV8WQ07XAFGKZjmPGYcEyKMVe83WjtQZaojG5wqFqrNEZHgVonRStuvYaOGhs1os5jjcaA1GgyWWDWNBoekAmedQ6u/u4grU2eO++laVToZmFkjcwVHa3xUhkNGurnoEjLIbpyvOA/Vaq0ROjfyP3ThskAUFB+noboaSeSmsUtm+s9vCmjWuyBRbcqBxWVXNFU1pNKA+rDS6R79XC3N5RY2S1NrmcKFA3g9jt1w4ps88ro64sDd4qjZZY3njJkjHIKOGmzfxf7SrVJHY5HMdK4g88VBDOwseJsQe9yhg/6jw3xKZYLLI6CGKMYMNFbPJ1rcZQGVjc7EjRYP+EP6LGUlax90k0/9o2G2mYRuNfpBn8UJIpHRvGTmmhXlV8lpme5kRulzyS3onJXZ7TNK0Y0e8lQauRzb0jQaHPFOi1jtXcabtcFY/xm/qrVZo2/4qxkOZ+0C0FeUPxP/wCdFk8mWR5ibq6vc3AlSwuhltUUraDWNLqeijssYDqtD3F+OfJbkP8A2wtyH5FuQ/Ig7VxfKg5pN2VokFe3TOy8GzPipGSjaCbQ+hqSHXwfgnzSuvPeakqzRC1ziPWNF3WGlKpzIbVPG24MGyEBAcXFWbyZY3mGNsVTcwJ/uin8m2x7ponxk9M1IT4zm1xCjNkMok1v/KrXPsU3nxtJs+rx19aV+PxT7m7XDuRtMn1dmYZCU+1O+us0xJ90/wDv8tEMln6E9qf0n8eK10fnFoZxa6rgU8vj1bialtKUXlUQ3tbq+hdzrR1ESXW+g/8AlP8AVVJqToOwNAAzKvMbcPZIFctEYilGIcKKl1p7bycbgmldhTgrz2Xv4wjHIKOGenyiQaERD+abJ53NIAcWveSCmzRignZePenzyCogZeHejP51KzHANdQBWPyo8DXVuPPPP+isf47P9ytVmYP8TY6PZ+00j+/yVlY8f4m3mvusAqrX+K5QQkdG9ed3BeVrEMTGb0Pw/wDX56LPEJHBhvVbXA9Eq1NfI5wbM4NBOWKb7jl/xOAfSQOMc4HYV5P/ABP/AOlZ3z/ViRpd4o2ixySvs9Bc1UlKYJkduLr8Qu0c2h+6qbB7h+mzdJoF0JMO1XtcCO5MDGZFC0MYSxhrUhX3RjLC4OGgYIxubTFEhoNQrx9WGmGBlQGVLu06JQ/da9pCLxUNyaOQ0Wfe1jGXXk8eWmzfxf7SrVHHbJWtbK4AA5YqzyzPL3mbEnvcoZ/+nIHeBTLfZmOmhlYMWCtFbPKNqaYhcowOwJ0R2iETNbKK1hdXxorU7yqDUH6IvFHaPLH4R/2u0QatjnXZGk0GWKdLq3au40XqYKx/jN/VS2huQuhw5i6F5Qls7gYrQRM2nbTRZPKdkYZWGOjg3EhXLUHMsrI7jA5l3FP94+hg88vCS70bmd3tW9afALetPgFvWnwCbrH2inaBRO1gaPYu5XeGmTzVoJiF49KhUMLvOjHepIJQaAfFWkQ0u3sac6Y/mrN+K39U73GoOGYNVZvKdjY6aN0VDdxI/uqn8pWtjoYWREdIUqnyHrOJUc1nkuP1lK07VPHrnedw4uu4awf3+mh1otcTni1vu3QaEj+6qSwWaxyQecMIdV1a4KSB+8xxaVCyzC/NZX9JnHio7MGPjsofWS/HT81aveH6BeVTDe1mr6F3OtHKh8/of2CqHA7Q0UX07o4W83OCYyy4Ok63GnNXiTXmn2a0DWYVbzVbJJHO33qFOjkFHNz0+UQMTqh/NNjFkmZU4uewgBMhjNRCy6e9SQSGmvZdHejB5rK41wLW1BVi8mPI19b7hyz/AKqx/js/3J9oFaC6HjmLoUM/Uq4Rjk26Va/xXK2eVph0W9Bv9+CjFmsMsEkhuXy+ufxU8Q3b15vcVZ5RG4sF6rqYDolWpz43NDpnXSRnim+45WiKb7NPI5kgOWeas1mBqGT4d3STIIhV7zQLURedChwuVLSvJ77Q0NtZZ0/y+6Rz47AdyKJ7B+mkAcVqybqLWnEclWa/dIor928F0Ize4AJ9jugVzqqPbgjUDvV8HAtCxzp6S8cHD8/SDYJdNHGB7RTbPBXVtNST1jtNngfckbkU6WQ3nvNXFNsRl+gaahlNFyz2ghnskVCHnU7ngZDIaNXBaCGeyRUIedTueBkMholhhlusmFHimehz7LLq3OFDgCtVabRrGVrS6E2WM3XsNWlOnnffkdmV5lrz5v7FBoPm05aDm3MJs5tRvt3eiKBVPoY5IXNvBga5hNFuN+cLcb84W435wunqo28XOkFAmthN6OKNsYdzppEsEjo3jiFcNqp2taAVUpsjDRzTUFa60SX30pWmgizTljTm2lQrtptBc32cho8y1v0Fa3KIyWWUxuIoUXHM4qKGaW9HEKMFBgmzQuuvaagp087r0jszRayzTOjd2cU2/ad1wcKNAxCdPM69I7Mp/ms2rv72AK+2H5G/0Rc7Mmp2hoor9scImcq9Iq/SgyaOQ0NlZm01WtsBbeO9CTQjuTo5G3XtzGlxssurvZ4Aq662vp2AD9NFQaEK4LVXtc0EoyzPc95zJTJYzR7Deae1Ge0PvyOzNE2eB9yRuRTpZXXnvNXFeZa36CtblFUYEISWqTWPApWgGCMdln1bSakXQUzzqbWXN3ABa6zyXH0pWiL3GrnGpTLPPOXxs3QQFUK4LVUftNBKMtokdI88T90kXQdgDmqdg/TS0t3hxWuPwHNVusBUjWk1AXm8lMsHJtvibcunPgU6d56fFXQ1CoqjE52WSvUwpn6R7Wx1rxca+kH+Sh6DH7up6njsHuH6bDTQ05LpYHgCqyNp2KtmLjTG52I2W/QNwLe1OrjVBzR0TmjyTHAd6Brj2Ig+iNDmsMvSD9wNR6leLseWw6vIfpowQqFUlUcKrEJtpsslwvFAnSSvq4mpVHBNDmXxzRuOxRbVNho2h4rXg949XH7gaeqUOiTpAUph8EaVHBFxzOSqcSqaHuju0ZnVBr31DchoLgMFiSFUOoVfZS9xpxRDgiJpHuafyTTF02uX0lKHiPVaf5rqfV6+oGnHZdRlXlG+xoOw1nEmiMespeGN3TiKro9Eq9EalUpdIR+jFRyXFDVk05JmsuvPIonWdHsCDQagjD1XdVQ37sy2stGWxkslkslkstGSy9FkslkslkslkslloyWSyWSyWSyWSyWSyWSyWSyWSyWSyWXrFD6m7g5E3qhnFX+Z05LJC1ggN/NVe4uKz0ZrPQ0mMOxoU50e7wXYOSJZjRb1F0H3hXIrG64FF9Rdrh6qf3JBlaVNFdbiA1AcnGqwoqkqgJV2Fwac8VJZXvNGHLgv00UCyc4/shYaKaL13Fbgx7FeZHiOSq00WsAxbmhdIN8eCLDmP3TXYxVyaDvpxr1ig4ZUx0sbrqOfW6WIyOdfcRUko1OXDQ4qgUbxmcDoy014LFbvGtVRGpANU7v9VP7gK+om09d2VeSFcar4rHijTGidP0QGplZS7VlXArwa2qNPFGmLXYHBdGjx3q/JQU3WjboqH4FFr8lq9WHd/FNLMncOW3n4LrLrLrLrLrLrLrLJyycsisit0rrLrLrLrLrLrLOnftV4LiV1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1lUGu1n4LrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLrLJy6y6yycusuKwNfXw3mVq+qzAJo7V0le7cFciNAeJT4Gy0xx5KSQHE5LoNw4odKooDliVTIcANrHZxr8E6gBCpSvemyNj621dHx9VuH4bPZ9w1GzdHx+/6hV9ebGM1dFU08BiqupXsTSd4qOVj29LkqXiXlUu3qo9K+7nwR5+hroqsM0bvgu1PccDk0V2j6qO/Yd3fcY2D/luml0xzyCMbBV9eC/x9rDX+wzEqlLVH+0QnS2S1Nlj5BBpJIAyqr5w5LVDBtMuapkUDXFCJ9a81htVOwXLvQKaNo+qjYd3bNKYrAeujYP8AkD4+odvpLrW3imuncKclqmAZUwWtH2mbd7EXyOLnHMnQJYXGnWbwco7ZD9VM28q5oVCDR8aKuNe9dMigyXZprpFcUbqx8FknBBrhgMiuCFMabR0hkbS5x4Bf4q0dP2IsafFU/wAS3twRkgkEzBnTMfD042D3bEFrtU1zpXmMDak0K86E8pN4upcWtE0hz6if9NIb7C3cTHsffjfun1sbB2WmRhaHZf5WAyHEoNs4HbVVv/BBWVkl7VCKvRRZW11aKkvutCaLEWxY4vqXVUl2GV8TevdTK9SU0Qo6lFQmqc6uaosRhooF26CuzYzK3cKVquiFgqbR0tjZhaJRee7i1vJfRsJHPguiY3nkHhVxY9qZaYhRkmY9k7BZZo71MzwCMpjbI0Z3DWmhlohbHcflVy1s0FY+LmmtNElrhYHRsrXHHBMiZvPcGhOs89L7c6HQNg92m9JEJR7JKsjmsDBqt0cMdiG/C2TpOzOwWWaO9TM8AjKY2yNGdw1poPm0VWjNxwARlfG17BmWGtND5rMxrmsNDjjoZbpWARPpTHHHRuxfOgbTFRrsnA1CZG3eeaBGzz0vgVwKk8oAN1Mbrpxx4f1TII6X3mgqt2L50bRO1lwGmDkyzxUvvNBVbsXzoQ2gNDi29ga4aRsHSLxoOK/wUDNVwkYLxKIjL5K5gi8mufGyKeu6zlskWaKoGbjgAjM+Nr2N3rjq00E2ePojNzjQIzSRtfGMyw1poktUDA5jCQccUyNu880CNnnpfArgU6WzBha1101dRbsXzp9mmprGZ0KM1nDCwOu4uonPLYqNFT09DLe5g1LqGoPNaiCl+lcSnRuzaaFMnjbHceKir1uxfOiDw0+ftYNTdLs8aDQLPBS+eZX1cZ/jRinjdG8ZgpkEe+80C3IvnWqtMTo3dvFADit2L50POYrrXZOBqNG7F86bJaQwBxoKOqmxxtLnONABxV67ED7JfijDPGWPHAoQ2aMver4ZG/8AZa/FFrgWuGYKFogay4ebkIbQGh5bewNU6OzBpLRU1NE6KQXXsNCFBJMG3Z23mUPD+zoEmrbEDlrDQq5aY7tcjwPrNdigVAqrDRZrczHVC5J2aGwstUjGNFAG4L6SWSQ9rqqzWQ4Sb7+/RTiqlV4nR3KjVmsUHDBc9ktT29ZvDRi3aOiNpyLgFNfNGNJvHkArrehEN1gVSCF5vLjIB9G7j3K1A9RzXD9NiziA3H2l9XuH99yc6zybwoQcQiTxVgLXFv03D+NeZyPMkMrDVrsVaIG5Mkc0eKltNKhtpx7uirJLD9mnma+MjvGCn7m/7RoGwdN/Vxydj21Csr7rW1jyaKDPYgOqikq52+2qrps4s5LHWl9XuGf95JzrPJvChBxCJPFeT7JZyWCZt6QjjgP6qOz3yYpahzeGStMLN1rzTuVstIFdXLWngorRHTzGZuvc7h2hOnYKM84ozuGiN1kimczVUNznUqWPyhe1hk+jDzjmP/Ks34rf1Unut/RW38YfqxVBoVbLz3O+i4lUdI4jtKsvvfyU8tnY7VOd0fpQP5ow2qutbnV1ds6egxzu4K/XUD2nOuoMs9qbeG+N2+ea6UL/AA2bFHZ3XPOOlI4Znin6iTB4oQ7EaLBYLO4sY5lX04/3VCyFxdDK01YcslaIG7rJCB3K0WqlQy0ivd0AVZLTZ8bNaJGvYRlmpPdb+io17m9xXkch7gTDjj+y1VcST2q1Q2YVldN0caeynzTNcI2irvpR/XR5MslpAMNrh1Z76CiNmfwY66eYVo/Ed+qszdY+mtbhXtTw2RwF1uR7NLImYue4NCs/kgYwNs+qI/a/v9VNZz/y3EKH3XforWY55G0nfSjv2lYPKMlNduOPPP8AorJ+K1Wi5K9tLuTv2QvObQb81nfg85nGn80z3gmvssUzmaoDoc6lam31EzpPow445/8AtDvUcliaSwR0P0lMalMbbQRexb06qGScgMxFTwwUtss8muvOvMc2SjgE7z4vMwwN/grZZTKIZp2Uif4/1RtMFXEdaN1a/BFzyS4nElS/gH/c1GqtbhmIaqHy3Z27wuzgcD/f8l5I/A/k1QNeKtb06dymivPfdlMcbB2FNgtkMuoiNb72Y+PqGHosFjorwGhwibepiVdmddCcGG80HAp0crdZE8Ue1a7yZK2SM9QnEK75sR2k4LX2p7ZrQN1jcmo2h7SQeOnsGmiwy9Cac0csQgq9m0dAcMwaq1Ssymivt/mmSgAzSZE9ULpPvt4tdkVZnwijJekBy5p/O0S1HujYjggobRZXYs5jFONqabJC1pJfIEQDWnHmrDHZ4nSOEtaDl0k7yj5QHm8UTDvHEqafLWPLvFWv8cf/AJTfJ1oPTs7xLAe4qfub/tGgbB0346Xu6qsz37xj2LOYQMXur0aok6Y4LPQ2iyuxZzzTjammyQtaSXyBEA1px5qxy2XpzWYXHx8f7wQt1sjNnhgBdV+HBT2gZPeSO5eUve/on+TccT0Xcm8Qmfj/ANdETLPaJI2mKtGntKBtE8ktMrxyUUpyY8OTbZZIjPFKwYsxTrPaRdltEtQ3liP6aLZ+FosvvfyVofZ2WkxF3RuuwVLY17ZCK9POm2dEnRjfN/y2yZKkmsjH7IoFUmuikT3g/slDz+GPzfrPmF0ju4p1zdrhps7LNR1ospo5leCkktX+EiY2t6QaLHa7GNZJC27IwZo+Uba3zeKFp3+KmtGWseXK3fjj/wDC/wCF2h3TieJYD3HJSe639NHkb8H/APLdFqZZQ8zGbo3c+qnayK1XKY1do8ke5/IKC2PP+KswMcn7QPH++1Wj8R36qzfit/VSe639NPnD/q7O2+Stf/waAyXqh5dj+is/lGLctMY8f/Sh9136K0ujsjy18ziHcKVVj8kB4dJH05KcP7qrJ+K1TywWV72Ou0d/CE3ybK4G0zOvOaDuitf5JnvBRiC0PY0RtddrgcSrN5XhJMcjbrhXdKHeo3WJs5Zqsbh41Ka+3MmAyaXlNszHsYXcXFCOBk8ZvZtd0FGG01jYhrKKYwOjvRjdJxcoxIJ2Wcb989GitT4aXDIaUT7SYnal0JaH8K3grk8To3HGhVt/AT/J9pxs1q6Pc5eToa11cZbXuuqGaQ0ZuuPen2uyRvka+TWMfHjSuKtAt8l+e+0kE7uIw9Xz2m2hm7TFSiYVk4J2rOearxVNF5ri09ixmkP8SzovNshx5rX63pckVTSXaMFUjRgsdirOaY5UJqukOHDaOkRT4x8DyUb7OdYGYYclcZG4nuTHzvq5kd1rRmeavuwGTWjgNjWQSvjfzaaLVz2qR7OVcNAiitczGDJoch5xaJZaZXnV0GzCV4hJqWVwQlie5jxk4FGWaR0jzm5x0DYOm/G66VE+M6x7RR4rivqfzC+p/MLCzn5goLNFNdmF4yXTWnIKpz06yCV8bubTRXJ7VI9nKuGi/Z5nxO/ZKuWi0ySN5Vw0OgZK9sT95oOB0eba1+prW5XDQH2iV8rgKVca6dXBapGM9muCv2iZ8rv2jocYJnx3hQ3TnoEkTyx7ciF9utHzq/aJXyuApVxrtnT0JXj4r6eKOXvbQq9DFfcf+pk1UZJqxyYKKr3uce07GsglfG7m0q5aLTJI3kThov2eZ8ROd0q7aLTJIOROGh1mbK8QuNXMrgUJInljxkQtZPI6R/Nx0Rxyyve2MUYCd3Rq4LTLG2taNdREG3TkH9vQyKSV7mR7gJyRdZ5nxE53TRFzjUnMoOaaOBqCtZPI6R/Nx0vjimexsmDwDnobA+Z7ombrScAhJDI6N44tKp59aPnKqTUlCSNxa5pqCOC+3Wj50XyPc9xzJNSqrWTyvkdSlXGqNmEz9Sc2Vw0fbrR86DbRaJJQMg51VUK559NT3sfFFziSTmShJDI6N44tNFq5LZKWnMV0COG1SxsHBrlrJ5XyOpSrjVO1Er47wobpz0N84nklu5XjWmjVw2uVrOVU+N1okc2Q3ngu3j6t36OxUAqVckbcd2qIsn1heMlFZ2QBj2cVqbxoDsY/FV2LvLIruXm+qx5oTm7QrNYVVNiu0XDgqk4UW7ULiMNo7H0b3N7iqa96q4knt9TOwyTO64FecXcLxdRa0trgVNVtdZEWeP3Af8qOEQyCuW03WDNX7IbzGu6BOK1klG0FKBCp0SYZ7F3lvd6urFAcdP7XAoAigQjqaBRhjPpeKa97C0Oy0ZbWWlxrisVRx+CP7lqprnMcGuyJGa881za+ypo5YL8jt0lF8MhZzWOZ4nZ6JqTmjRUV7w79DdHS6J7kLz23edVeBJIKrWvJB7ulIeaqHNJ5XVlSmYTYn7rclGYpbzjnUqtKVWRWIWGay2TQoHIhC8gKZ/uUbFGKudkhDaOj2jHBR+ZOvAirsVHZ3NaAzkqVw5aa7NI6061EWEtPfwXRwKpwGSyVQ2lVTCo4hV0DRHyc3BEuNAnvGTnLNVomAgM4K5W9hXT37F0ZuRBVRUURFD2JrfuDD/OJlbG4sGbqKQunEdwYLWSx61uQT54Poquq27wWslfeceOmqw2sFWSgJRaBhRAup/4RutCF1rWDsCxx0VGnJXKVbyVHvkcORdhposE10rb7eKOoju15osdm0ru2LqqqfmgTSoVfQZLJZLJZLJZLJZLILdCwH33kslloyWSyWSyWSyWSyWSyWWjJZLJZLJZLJZLJZLJZLJZLJZLJZLJZLJZLJZLJZLJZLJZLJZLJZLJZLJZeiuuFD2qOV7mUfwTRGD50Cn2Vt247sWHoMFQ6cMUJGlocOC3XBw7Eekc1Q4rJUXZpx0BY7d5hIKe61Vf/AFTnMa5zRxRu9Fozcr1rk+Y5q4y0SRVyq00Qkq2WJ+69uSrj3KooQqGooif3GCK1nVtB6S/w51kbTXFNfcDLoomte9zg3KvDaz0Z7PNBVdvH8ljg0YlVJLWnJowVbxLMiDsVWWnnoGzWirSugowROprMCjJywaOZTppnlzjof5MlNY5R0OxyxORyVea5D1Q/55LnGpOfpq6bz29gVSi0ml4UQBcA4ZhaiM3nHOnBVPHQNjnpBVVhs9qCB+KstkbTdv4mmaOttrHXd5sWNPinSxyXGhnRFcK8yVZWMtEcrr2NytAnFp659VP7gxppsN708nkqaBfaHLAU7k3v2Dpr6A6KprhxVkk4mJFrXuDTmKr6eZzuzgp5utHC4tTa9id+47//xAAsEAEAAgEDAwMDBAMBAQAAAAABABEhMUFREGFxIIGhkbHwMEDB0VDh8WBw/9oACAEBAAE/Ia1musIVSPrzZjDEmkUdR7Sy0+ZqwlbzghgwrBla5cWJDEO6VWkoVcVuodnaYBNHWM5bMYgoPwmcK2rYbyBsNmVbG0HVKmg2FxZFkUNh0hiRcKx4iwtYmBVrkslD+Idos0i5eyK8/dMunhgcJzC7OOpP6QFv38PJqe8zkTuH54jZeS63BKSZkyf/ABLnlB2ldspTwx09AkBlZhXygYjpPJUORfmHG17zIphoe8A21gAxhbLb4jjxF+soTXFQap9Eyv5YhP4VHJ5TZ9v0JXmGsUzKttwrEgQthGkZg7VbzzfmFQ8ehV92CO5zzdk81idrFgDYNzSZwc1cw4jOFDVHYf8AsThtHsJPk0Y0qwGzLjSaQNgxlSf/ABAqvPRcMwaqjpEZWdG7kHuRZAm/JAlVO0qVk5O1xl1paVjvFGrkLAlvjijYZlDPyhWxHWFszSeYZS4a3LJpV1FxWL7bRWBUpABTfmPdrOkrJXDWkEWUNyYpa2DRYct3mEBWLuruH7+uHkdoszksouE3lNoVK+IPQZdk5eSXBm0VTvp/8PeE3qVUzEURa8TNqSrlZpAjfthgOsJYyUs2hzN4BMohyuKJY1pmWNRl7xs7QlXluA1hndDiJm5fGWZ7QIUbysy8g21lWsG8ChHBi4HKlZ0happ1mKlmrUpE/fL5JdzSkaZ5OIH62tp4YsC386/5md7opH1i0Xv8BJ4vLs+GEUGCM5IvF/8Ah190rnSYnxA/ghrxGVzmLWxFGETt1IKgOwy84mqeMxq7lsQ5O8qAVl+AOGG4IBoblWXvKS1MbdDWciKfEvOJnRKW95wHzKjb0TVDYtHupiHK2vTiFKGB9HFEzPIeUrYeGMFqQ008OY8uOgc1sO0S2JtM7Jvnc7h7x0M6gzBigDASzUIjT/8ADKCgjeUWQpdf9zej2iXl1hXlNVusQS0AQV4QtgFTF8tZXboBivDbVTJ3jtMy5Najwz/brKb7TIu0Ehq6OMXWWUqSLNaTviuWYutLlgWjIbVVxVUTerf2iC2fEHhNPhUHVzeHmWwzrss+8F+9R7HmapoUNDd/pNRgh6kHWq3eogrcUIr6oWlQjhQFPWB23mGcEYEaf/hdQ7yyRwNQx1x7TkOIVtxNFPLFjXPYuLJgMW6z/iXLGd4tuko1/mDdDzeINXc0gAiHhg1WPiJbO2LpYNBKdWHzLzgmu0qtBIaW6MJYBdIM1QDIh8GrFaPtChaI1cJLnIdD2iKHAL7WRJRzAVbgLhtKJTkg8imkqVNl1pCbhOBjlsDBeTud409DZPYfiHg0Kh4HHM0SjvaxpGzIFS1N3TZUwF9IvLoggpgCzWNUP/hSMRuqNHPJBS/pmK9OYik5uZE5gDeNI12NJRgbRF2eZWM3cu1JylpLGlOsErW2lTngdgWziVv0bACE10hpmYauq4iIjJCWSDCNXaZTFCZ2Z5UkluDJ0YN7eYWlDG0KuAqBg3YFKWLlCGL5dI2YL2lMACim+Lu0NUC7CaVBYx/mSo9cuLsivK/lLBSUrRXOGK+0bgQYoQDe8ap/+EtbWs8R0XK5mzWZcK4oxBy9xRMxs1pKJxZuLs0CEsim8xs6xcJqamYvL3gXRhq0ZqtTwosR60xtMOM7NS0V2YtQu7hPapm918Sy2RvaDBzaqO7dr5GP7zk5OYwdDW0huU+seTBxHYJy4h20jZtEEStZe2SMkVilvAzl4CVmKEIOWG5hCcXMQLyPPw/DF16XQgvWF3I1o06XBgwYFhrGof8A4Qtk3Hd3lmPiWsCWFzKt2KBc7s272pVUq7Q9KFR2wI0aZLjwGabKRVdKl3pX1jNdwIvwzXddgmRtzaArBDkcJCcJ5zADAO0pL2zFbVWI35gaaHMZkwNSHMvsfSoai6xTPMQMeoLuIe69poZzfxKgA3M2QKhhjeuIQrd15hqCG4CLaKQJRvzKwRlAqsNSxtMkcLcmukxEBbnlxnWbZnFwiUTnpcIMIGFYawKp/wA9UqVKlSpX61SpUqVKlempX+IzDRFMLtAXMsNAGYqJlhVldoEGwwJ/SAbssAK3bxEW9mJFC99ZRGdC25Xc4WMfwB0uOlXvKpU0txrYJQfbyT54FFvX6GYDEeo6AeWVmgBBMtxhkHcBdWo/yl3izlPOofzFfpk6I4vzKUWy/F0lHLGTXJzL8xKas1UTu/aDovLMpvPJMbMS3kRczRClV8wfQnBmiZ0nWqIaUhRDKrXj7y2qOLehpL6XFCVdwlU1+1yFARDHwluFvr1ICUjQGrMvIXb/AJ/MXQNBSMr9+EI5oJa156SWT4FTdzSFFAZjD+mQI1FqBas/Jv4n5N/E/Jv4n5N/Efyb7RRpKidAhFONBUbuCP6gKbB/MSV/hxTWV8ZiGYes8sW4jsY9kIKuKrTCGl6yrdniByMDlswQXhziFunCMUbmuZ28CYuKGV4lUuYENE+6WSTuzGXJ3lX0ijD6UyGU59QHPhODeIqi+kG53isOpHCpYU9ch9YDwElxN3W0Qm6Lc1CV7wQCuUXLTCHSYEPdpE/PiEda7ti222DiOqctJpG0js8x7K94c3nYpMpRtl/qUtAq3oRgE6e6KmQDug+0kG3S+hCDEw0/aAQT4WC/wswJUEpxBKdOD7OYZLI//BAAHoJ0r1gV6ah+mA6pXQdNTHcsOUEaAgoIwR+BdGG6fjnrrFSpUPQ1dDpZ78qer63+/pZfinVhsu3TD07y/oFdSpX7xiqvxH0G13QXcrbfWZxPi4ZtVMy9S0cymBHN/mDVkYbuAZLyafWXSw8N/MELCLZQm0sd8CBQxSuXMtuB95cVCmKGnGeKbli2gL95s9swfUSt9heeQued1mHNrD6QTFQ3kuE+uEUeESrd3Wl2Oer0O62z/aVIMbJFKFLqtSEXdGs/FCyDF1hghYQbsLRMnz9ZS7Rw1qdToQYRZlWS1Vh/Zj043+dmDKg6eL6VXA8epcnondNc1HqROgS3oEhLSPEekQddbYVc10aOhUv6dC933dGSfwZozAfnnpbwfBF9BOzNQHwRDbrzAlkzP5U6CqZhpQ/7zP8AqY/7DL+gS6TcB7Tsz8sasFDt9mdmPZL8TVEe08IqMvV22GniPQJ+7ulWG/vE1Cq3jAHej1Gsfy0cQB5J3ihKUQfNGFRziTz0JXWGjeJitHFx1R2dNQg4ZRUn9yhbxM5CSoKHWDjXMLDmVcIchBffSchHlUfKQOOxKphgNG0fxifaJEmpD1wotfMU+yBAJtSvB6GGM3Bqqw/UlNaupueZ2OgN4l1i37gQV2IZjSAaDSVAGVU1l5qNnqdDoRQmGLVtt+yHphv8LMHoIIwI3D5n5l/ENT0oNk4OMXGTECitmUtEpOpd1ywINtfF+8DX+YhrQ/n6QARsJ8H9wMFNr5XoqsWzT7kt2K/hfeV9IJb0HcymIHfiBKFufc1jkpii9bP2tfeVW3sBp2gjTPva6xaDRSLaNJqtaovwH8wAAAaBEI+w6fff3jrcxGD/AHKmGUzTDhU101hod0CJ1k3D9EO8/J2jDh/DMFq2fkPLCYjoFEYXvdg8OsKqbPquHpuwLVdBywaHdH4R2AUKnZfhsw5+bPocR8KqUZGUTJM0zf430tb876Fuk7YtUbMV+NQvX9zJ99YnatQWQswZp+BGQAAjtmeIvsTtxKK2Yr8ag+j7mX11lnq2FkLEs1/Ml9iZTbX3geuKCJhOxGFrOc+DlhmkbP8Aw9oAFBREFq3fc1i35p9DnudJ/dI3aYVjoQBckdoe6KKCE3oS+UV3fXpU8x6sZ3jA0wmWpCfeF4LKxni3hVePmolQctGE6tlkcSkoTKUwOa2YXA6u2tRnGRlsevv02hJ87mzEa6K3qPPEyFTwYbNC2niWsY94hWVcEBoLrE3E9PeEIMcKqMi1P2MdM/Lduh16D+Nv0+Y5MPZZE7Mwgr5zX5uapoiM+8PiiB2IFarmfQ+f5n9VgCCG+jh372nyavcbYWtTu3vBRoybBlU26l3Wn9dHJ0X2Kmn2YeO4O0Zvtbvl/qZHMGdLarrPD/cGWSkmYoeXOyCh/K5rKp7zRp9IxeEwHvvCq/as+zHyGJseSchT/f46brFmIJXe1cTEDQHD0YDMVrg/PcRIwyTym0BDFeWV6HzYI0hsTAf7h7D9JsmqqnNtPfj2i4wK1dD/AHLPjvAWnN617ShWg4WV8Rpb8P8AH0lc1TNPyvfob6hUm/tH/bn9T/r/ANJYgKlp/U2+Fl23h4BUBsRkTQ4ngl12+UCp3dj3j8ia65Pz4hs+x9k2uFlwbw8AqA2I5Wicungmfn5wwNuGv6x4o1/Ifz6Q2PZ9yYkGi+O8qZCibVULVe3E7t5WsHN6i2uztMkDlK7QJmmw/OYY/uVjl5i23+klk7R9atuBVXMJmFLk/WNZNxCnXrvtAhS+Y3x3Ed2Ddy94lpkyuZQVpcCQF2wGr5i/MWV+uJQJjc0Tn0PqoN64U79/NTagLMQbXhNN5dBOVCjEa97XOU8nPPU09BCPoqVZ/Z2flu3QmYcz8tz0UNkwtPG39e0r1+GPf79Ndtn5YPi5X7T924hch+hz/M0XMOTE/Kf3O1/Hmdr+PMvSjTFjaFjMt/wn8w5gzBBDMq/Wv4j/AFDvcU/vonTJpdVco1/E3hOez/ufhuZcTIvav76WaEZcEfhhENH7iCapm6avzvu6KKfmuIQKrj7/AMdHPN1QfVjozTkOw9CH2nZ+Zfj+fMtw/PmafZOH+YAi8DzWOiMw5Ifzd+lg9i274jyPz4nefnxL1Cwv/iE9o/V/1HxpNeZljnLozjhnuaz4B9kN7A+rFxZHu6Ll01M4V9p/ifDfcjp7PlZb4QK/VFNn48xb8n3ioX5z2y5QrJX2RP66H9y+t9KT26+I/pKDyTzxHmMmGO3aHd5eLIXIV03S2rHT156Bwji5jgOYoy6fZmKHVcpmp9UShsIEMpbYO+vXeb9B6EHoalTMmr9hfQPwXPUHM/Pc9RlwlfSmT+frAS3g87fMRQKTCSlGcvGh/fvMsYHv6H8/WWnz9VP9QhtKi1h3n/dT/up/3UR/tQAc1xa7jzBzHCA2t/W/5gSfZp/XQaxQrayjy/tORvqlf1MvzsxVDyzLLI35XlFNceelZ5H3eh/FcTU/DWZpki/A36C7ph9Wulhel1xWxNJCy0roa4vzd+lP5mekdIbzr/R/3AOtKvbMcdYpa2pD/P8AEdL2PsheSHsxNSL3bS9pHWOUayHta/xFT9n3IInteyS44o5VH/eoj/aiH96B/uQ74KL6dL+639O/qZW8Or+ixA6SxgGTAxN94Yr4cF9oJBNkVZHC33fTfXfpeCV1w4h5iZ48kepWL8SjsBi+IxSXs2gE5BfpJnoS+hwmGMy2/XLoSgbmqmnEeplg5CEtBV0VfkZR/aP5iaJN96BRX1Fz83MKJjsBM+fZ2D4lSA/CO/tAyoybIzW0wFo4/t0Hl5wMD+ZaFihfO401aFvO/t0SK4NvUnb/AH/qU/lTGzYlzHc2nnBYYmv+UTwQghbToEqW7tDsNI7f8bionyTJLjn+c5dJw1maKHVg4HHTMIRYVO9MFJ+e4jp/hrM0yT8O36Wgcn3IWRTDxFOrp/e8y4CdQphpP2FwhbKtkHEsjTAdG72lscpkmE/O+iRIwipzP9qz/v4L+/NGpfZ3iAQRyJN2wDqu3JO4vWUfOSCvobxM0B5bXfvFZ7fYiaoYnJvDFDtG5FHGZ8C5GWCXuj6kMci3PBCTATTk6fnMdL2fZL3HQcm5Dp3hHOlaN+xxETYJsw4HumteZglvyd2cRVUF3A+D/gTN+vnonRPVt6a6M4H2XRlVZbRcUM11Dbq6+tjwzvAxrhgariVSl1ZTeZcndslsaenmAoUt/H6BCEGPEsK6/rEXqmoOmUfhZQjOpWPrHzGmD1ObMfTMpun1bV8XGSSHwxZ/sJgl17h5NSL3ryrcphm9UFfimwjjh1K+ixVMxYGKdfxvBLxoAdOz2Jy8GswWbkfk7doRcPxuUOtW84/nuUvi6UdGlP7Oj34ZRBcnGR/DM/MGjFY/nmZJnmB/C+lRX/2lFiOH0EOm8Hp9uYBQvZc9hCxNik1we7PtLr2l81SuYH1bdt0egPd8XtCqhpaOmgAgl/i2iF2A3bZ4i+z05RF0H6P9Q6gd1B7M7vkMJf48fw+Y2LrDdVgKOw+HQtya2+e7+kKJKtvR8kuT+QYp3DAEvOWGn0OX48xiyLVcrH/Ev6GfTo2RsKrOhf7l0oWK59bq/NS0EHdtyY+sQbFbtr4iUjiHlpQsMZWj1znzA55YbGAbAtl6AdYVGlVes6kI5QmZbm236w/pD86TL0yTpVojTAqKOP8AZO7bLGPSL0Hqnd+VTLARw/2RghXVeg6DLBB1peg9dPSFPT2d87XGchFeWmd3rgyvpnfPL0Pz6e7OmGdr1OJ59BFDloLaJXd6Ne51fiJ+Je3/AGdLLHoFrMkzXHPHtPoclDT6v2j0BjY0krSOAP5nfRjww/u30PV/Reej0eOufR2IWyi04W6+0fszCSldSitGLUw2bHTViljlUeN+hW9WwZtxKK7Kr0iVi7omZpkCcpDgHwSl6p6GXul+rY1ZvETQJzxD5T2bXad2nHo9vWRRzObn7K5cuXLly5cuXLly5cuXL9Fy+pcuX0XLly5cv0DD0iuX+g3YvqPrft6lkkls4TjYXn7xK86jZK1LyKgbaCnWvdzHBQZ3/A7zJTZ4OA7RZcuXL/fvoeu3Xb0VNP0Ho2kiBGksXxui6pKiPUkCt3CDMpVvp/UFLupVxpNVNcru9Huo01H2mAFrCUn9xyheg9LUC4bqorAypO8GrFFbI4rVVx6tvUdFHDJMrs/+LuX+ncuFNtAqeNya93tT+Yj99H6tzLD62X3/AMW+l6NR6s26VNvRSl6RWtWzphlrPzFdujCZhaLBeVVi1ExCFZ/E6PW4+5ef9Y901FGqZr9g1Ut5bJmIy4zClQK/UOgxRy5N5p/8KfQ9Nf0TRKEX2SzJcj0SAMHHOtfaA1qNh55m/pIZ8xdHD2OYpBLtP7gTBtubvxNQ9xxwJfkBIHr267Q6HTRFNSY9o/8Awt/VYAKj34mUmnl79NWM6BQhzH0gbd7OnWkaqv0Z5Er40+ZTpu6S2ukOxY2pcUww8JC6BElTqfXCTZ5Vvvx69vVvCEcUtOf/AH7+yZUfXxzWU6bMf8CKzwMHHbYE0itv0oHDZIrLQO2x+v3lAdXTHhxPAYowYwPyxs2g6JrOxR+f1yEcM0lxw/8AwHaPV9D1Y9NPTvGb9Crc9aQ2Yi9JUDBJY1wSl9O0IRpJvcy4Ar7zOi4fak/mUAR4Y6zA4qm01RXfux/S39B1FO8j/wCAe3perHtE6+3pfRvKyQ1ekaM90DcMDFlLhc1DJm1TMRJa6xCBlalbS6wvMW2/QTDhHnIZizlGrGbdeyDmFsMsy5Wsb2unaP6x0OJaS9/+CKz17V6NulR9DpKj08dCB2YJojd3ghkLWNzobTRR2SxBsL06bzTqaazcZxl6E94ubt75lQ84HvCEPF+a6uf1eUuHQ8TMSagcjO//AHzGMYxjGMIQhCEIQhCEIQhCEIRsXs39VVQcjO7/AHzGMYxjGMYwjGMYQhCEIQhCEIRsX7vVQUh3ndfviOYRzHMc5znMc5znOc4zjGMYxGCnkqP7J8+nePrfWzuenLaWMQxTWx/MSEixINd3otE181m3peiUlwNViEx0ES1O5AoPsxDazKeIlBEu66MP0DqQ1j0Ioo1j+QD9+KNmsyzR+H0WJpRaC39+lWNJPpV6AK9tDll6Lf8AAZgz+Jv+wyis59O/R9D6Xpt6LjLhZWC5U6LCkIIYhAgutXPId45b3/RvkNmLt9Neg7OM06ywYPLP7Rht6D9N46EIRx4+/wDgdP6Gh/gSyYOun7v+CG6ex+we3MY+h9O8TtHo9atjrNptrNvRXR8OWwd4pUYxkGPNiqR2ZXnW22m/V1xN/RWmNfZekS+FDiXsdTAO3C7ZcFlhl+s08zb0H+D18x/iQb57/gtB4P2Gky+T0sdfRXVlzePorr7TO2bS7xA9Pb1KXnO5hHKJvW3Tfq8dXpXnOENnPXVqCwRCa/Vi3bmp29JK9O/T5esT5PpCoPLs7Z0FP7vU9YNZGTT6jNQ/C7xLb+Pedt+feBTnXCfzEQETCP73Pv8AowjVal67xn1jT0WqoarA92ZURTTZ+6+J+xec6QU1HXX0Z269/RtN4s0I3xGaw1hLFE0EH1I+u795uRarRmXW2ZRcyi15j0z6HoRUdi4rlmv1E/qdM5lPaW5wZNYEPUO810fSZtXq+XqOvyvRcCuI4ae6Y6vX0PaMG2sjzOITVJT6MxZ5wui3XsS8+Ny6TWKSMXM5bXez02sVQbw6oBEwwK9mOiArasn1nWWRGouK+TEyuBhF0W69GC/beWGr2e0chQBQPdgZxGZz7MrPjcq10lQQko2eSOkxjZY2u9zohoUwh7uIdSmqD6xp11PQ0epJyV3U3Pd6GwxfuXDW5v7ef46rJah2scMgtPpwbjNyKRMkxyiLs93owEGkpIGi1NwHi3EGKDQE+odGEKlPo06syohFHys9FGBm3XQjWkLYOGuj03kXR0OV2lZG3RLwugqc0wqXpq9nowD6nBw9UOjPvejHrKiX/dpB3EGfyFhn2PS3H0ANZV6I2lHOdYR4PTTfVhbA1qXpqxO6NbL9EscYYEAVcAbwueiw+llubelUSVMZsapoJQtQKNnkjm0CEKOcyzYly6ToaaSEyl7ONOiKbKKD7sXDO2VytdHuQKp1hGDzHfDW2jtMY2WdrvZ6HkhdjfZXGw9mnU5OTroeP2DGajc1mI69Hs9GbTKb6T4jrHLHWOmJtMTxKxUbiJ7J3jTWs3rfSsOZk5BXs9FejeoBUWgGWLtxurqxx0wApgxqw62aD1l9vZF0jENc+3r0Y89d5p59Z0J8zrVtpZeeA3YIFGvlBxD0DvTf7QKTgfuHEsfHFanuks33J6LxCTYwFUzm8/RaTJlfDhKttuda5NqqallMnNZ7NJ0PlMAgjfzo7zGR8sabC1JqQoMPcjFnHQ1UuIXfFAo85YY5NuUrhmjCyPKtan5vhCWVoavB9/oc9PhbRDha02brXzb7yshcOtue0cYemt46s0PPV1OTKjsGkXmf87P+Vl8GnSpHbbI2h1JxQ5S8n2faIisB13Dp5J5oyJmHfPPExV1Utbt+Mhl3LqW7rCJ0dalMp5Pe4dV5uAML5+ImuE+zUt4VSsN75QQuXUZD7Y8t/rYlCowtBqj+X2mSAI3s08UOkUegBgZY9gPdhd1Wf9lQPzYa75oNpkhAWVszvcPrC1iZuRarl6fC6s0+7oDVpRLTx3/sy2UbBC84frKxJwFf3DeD1ApxnaO0LYwnguXOPQsft1ZMgEckp8yRV4zD91CG1y/aWXBDu0fpcsEm7odgCY0jSFVsff5M/L8ISm8G4Kn3+kH7ssdUR/H17T8dzMsn3mfrp7wqFi/fTj36K4rZuzeI/L0aHYcT8lxKI96qqL/nw9uh6TM8aBDXEh2VtfNtlzDSpUu6c9dHx+yydoas6bXNul9HTo4jpLJrmNxnmPaGOlJTRhE1VvDTob0Tif8AN03njpaGRbWscSje/wCstUnXdLL2hZf1gGUaKN8xs6lbuTzERpwwhBXWoLDI94hxoyym4eNuu/pOOunmP6BCfO6g5mAarr9Oi1x7s4a9oAeiI2Nug1VsRij/AA9F+JBU0CxMsf7taCY+vB+BlcV9lgdtqqLf4Os7Ye9HQG1brw/DeNHUZscV87+fRK1xdu0rlmrCyPKtLn5vhLR1Ob7z83m3mOBq/JfvBRE1JRwRtm7082e0BVjKSKoMW0DPwHPT7XVmj56254bXe3LHoZZJXU75+YrMqGoAHA0e3VI0mjsV3mPl0Lc50YmlKODF/NPz/GfkuImlkISkxnUrkPI9oBaRmZC0Pj6sclSz7txoRvCcL5gpFaeRwhyWVyOlpJzGNA8YXvAfNgxVYyuywLPhhjoqAagNHsn0Zj3cgZ2sXbgrpyweJaOGrvcb3QpP9MRAg0jt01PEOunoCA1WiCL3Al9Kg8NhuZD+W0sBczmWqG/ibHfiXr50AH5GWpdQsa+nUGFAA3k8gFAvNsPrdI73J9oFQWruM19LjzHoyHkYc7FO3W0/NPZn5fhL51Ub9h/PkjpsCTYp/v3n47mXJolWF0sPKxnAigZb+VSp1P5IfTT2i4rJuzeY+D1MDw5n5LiKeOiAtB8s9mHfDD7rHwwDlHrRcVWGivu5tLHrVCnS1+/89dPx+xeOn1SVN6jL2gQlEvE39ujE2m3QpjVjPeKGDll6MN6DH3d/h1TIlUEGu2zdRqqmHdEaRVZNWO+ivRLmTR4GcAkjJFN9jSHMdiCMwUigAdyXBuZeph6KOXjiBqk36j9AnyvQIp2dT2N5nAoFTz+rMWeMasp17MvPjUq11iknFzDner3enZV+LxentGzhRH2MdOOuiLxentHbKXSB7GOifsZzWk3OF6OQsAsHuSzSlcOTwSs+NS6TSYizxhdFGnYjQ2sWTe9avXpTM3ICvNMFlFKZDXFVGdrVt6fY6s0PPVSkzKE3L2n4D/M/IP5mlfk94hvsIT6zxSTa166NcnqLHhKU73DHtEoirlXeUAA4yaRKpxhGDx0RPFoEfDDBO3QPoGvRUpVpo1u9auXJCQDZ4ZW/aqionTBMDQbHaJZrnszDhuMXitpzrLZ5Gj7yvvRIiyxaM55lwu3WF4raChzTC5Wmp3ejBPrcnL01vEPTBAaukVgBnE9kCM2DDgmh0UyqiOn8oq98tSLGRTbPVj7IVuVpqRwQtbn6i4qqrawm5FiOSH2gKPqYmfeayl3aypjNDQNjMLgYRdFGky8DjGrK38yyYlSrWKmyuia3etXCbqLE2mBKfuisHeIpopYfci6Z2yqXrodiBVGsJw+Ze6BOVlPp3CKKM1biICImRNoeeRQjPdJrdSf47HXQ8fsWMVrlGGm0z0+8+011i5jN4kI6R1zHTWb5cSt5naUy8AXfX2j4m0IdjQglyHT7briukbXxBoX3IADX5rNRbxNPpCg3sgZ95qQVWnyEL/YqmieIUaU1bmWN50mDdajvMi0x1bzX1EusH1i5iKMBiv0SH+DH2PRoef8AA/ah0Zr6ltt9KVaV5f3Wl+xc69TPIadW0bJ7zXSpW9YizTGsfHR1JW81I+88dEgm0ISaXLPB005+f4QFwTHQO4VUZxNF3IO0FOrCS+0DgPksqoZyC6MIFxjviNWwaGYexo2pyN5xGFdkMpEaR6EfSGZexM0ilPeOyk/5BJmg/wAD9r0az/BaX7B9ApSQZ5J7dHSOZoUk036Lm5b0rXeptU+IQ963lU9pe00UzrwnaeJyTeMn209pY0ui44lzu6SyjjGIWDBou0IpPrLqOZBxBB20arE+Z3nY/JyEpj7N4W31pXEy4iBEIuD0qHeOkxNsxb6kYzf0b+ggVv8AAjV6Bg/4E64dRo/4IUP2emnTB9Z0sjrCbRm8UuUNGYxc7GFaEe9T+JoZl7bRL0O+Omoati1nkjA0NcwnUBqZcNJnFjVBRo9WxAwtejNNQJp1hVotT7T6NPUsGYb5ekrbzkJ5KkJcdZiNW7VWbRuDQF/VEDF4XCeZS0WgmOq3HTMvPXHTb9IgqpXkx+/TQenrioy/fqYPS2MYjp/gGXYh+x+09pnSug5veC/KYTee02nsm8r2JV+IgY6bSwxNtGeUx4jUYUpiV07XG84OWBHDfgItrzYUaSsaTtU1M1UCO2DpBDbbyEFriGkoRCW9FOJpwDJpctJK0uo04YvdCq6VtUSN/wB1SiFKzLTUGuWbqNkFoppH0PVv+gQhAEpLiGTFtJO87U7U7U7U7U7U7U7U7U7U7U7U7U7U7U7U7U7U7U7U7U7U7U7U7U7U7c7cAND1JO1OxOxO1O1OxOxOx0HYnYnYnYnY6DsdB2J2J2PWAAB2eonYgDQ9TbWdr9KTbbbdv9ptttttstkkgID9l7V0rqinc+JrvHSfE+Zte0x09pWdIZdfrOZhl4xGGa4eghKG+Zaj3XQlQWYjR7TkNsL1JtL0CXetpiOR50hQI4p5TAG6tbllz7J5NS231S266BJp0mamLwF1PiJzQxWn+IS52L2mcy6+YYo1CaQtxSG2WPlN/W8/pHUN+D/3XtM810epSxpMyuZ4hpM9NTaJ3neZv7ztXSsXc18SqveVcNdIQjykIPgsbxgc4IO8xYHmf1HEWwDvcoLuLpmtQ0NQ3DU3VL2iVFrtM0AtSypb2RHIlJODMyzAwwRvMYVfaBcuqKNKYBuO9K1gZmmDoxEI+oiCCtNes0r9M6MkR1/9y6yuOnM9unF0ZSKTee8zrt0rfSMDMyjDoMrjSYbRMad5mtcS+NpWlwOvVK+8MHXMmtQEvs/cZkSgqVcRetMyKcPMQdbksVqfM0K4PeMQyyQEKdZl0kKIZ6ExQLg3hpRVReLdH+ZlbHYcxsJDlWDgGSZRnaXpDfdntGqOqvWa/pCGnTrGAd//AHDNokZiptcZczOWnQxfTbiaYSNzszbFyqzWY4rVhrNomnMxWnSuZSIr8EZlsjNwqtMqcQUfQ3llqPWXOeQl5aljVRS3UfZNrNIooudQckUavabSbJlLXDZ0B94JoBkXXmUM3rKjgcsMrbuLk6X3OUquFpNoQbI+sq19XWqLkze6r1bzCqUjtR2o7UdqO1HYjsegESH0YSNZeJ+ap2/oJ+ap+ap+epoD8ERHPp2shyYjv4idv4T81Ts/Cfiqdn4Ts/CfiCdn4Ts/Cdn4Ts/Cdn4Ts/Cdn4Ts/Cdn4Ts/Cdn4Ts/Cdn4Ts/Cdn4Ts/Cdn4Tt/Cdv4Tt/Cdv4Tt/Cdv6CHbe0KSgOfTlwR2m7wJ247fwnbjsx2fhOz8J2fhOz8J2Y7PwnZ+E7PwnZ+E7PwnZ+E7HwnYjsfCdn4Ts/CdmOz8J2Y7PwnY+E7HwnZjtR2o7Xwna+E7UdqO1HajtR2o7UdqO1HajtR2vhO1HajtR2o7UdiO1HYjsR2I7EdjoDsR2OgOxBwH2l6qevwzeOuZ7ejtMddGJTmEeg94GJgUszfE/0lYjwMN0QsjjmeKl7VgIupgqIUrSmbreHZRhx4hiqo9jmM7Sf6Y0xhw1Su7hS+k0rkTfvBX3Gk4IHgEsGJUV0oMtexMg+yMWvIm0JJ7OYzDUHDBIHZGT5S3VMPqrbj+1M/gPQLai8Y0P8AA/UYczGE0cnVi7w/59cSEJ0f0Ej6O99NS1knwmsaoqNa7TKTbSeZ7wyLmFxZ5jxHXSfWaMYid0nXgmQQNVixMNZSKTrK8phPRuGUXsvVYgkteWfM1AXDHvNod7a8cxciHN6wYu464xcUkOP4lXkzJCF3N8yyv0T2gajaVN6thhazTXhNXvpqNi1dYbSb9K6M+f8AtcPCjq89fkP8H9z1Z8//AMBoeX9DU9DrNJUwgUJ3xPaFcYmmbnErmDPAx4S+MyrFGGJxYuJesxtzbUQYCzgHcDTgSXmw9wX7QzvLAydoTV8FaiURO9WpwTdz0dX3ZqhRRmE6g1rciepaLRhDVpzEFGDeBWkcqBnmeeWXqG0UFkV35ziY5iUt9rYva4WE5Z4i2BxzMe+bej1Z8n9r88jq8+uAVALXQg1a7KzEKRe0BdBaz+8+9h0Z8n/wOPVbNOved9emB3hnDHQdEKJ2I3VZxrMsSvMz2llUxwAwpBUqt98RC3cCosrSOhHKd+0FGtDQEAhHGn5e0d79qtegsVtTBwwGTC40dyZLXuLlAGNKmZo7lE3c7mAtuR7vLBqnVmVTehFyFltWO0dQxCpZO9VSzArWpmT6JQ8ILsXdYjtyhkZnmReJiA2ZfU+f10SoBMVaNSv5aLmw8y8fi3Fef9d86Or10arYVo6jwYj5gu8c3/ceJkFPImG+MK94QEi01pqJ+7++6s+f6RKxad/8396Hq2qL0Ere5tmb4mvmZqZHSPaeKJqaze6g7Er3YLeJXvcoW1tCzI1UZG/oEd6DNGr5j7gNKOCIsdnMeYAVLcuavxATkD/AZVZr3Ds1qAzjh0E5moFF4x5tvGzEyAb1AYVu8w9R7ay23gTTLgjjy6MxCnu7xpoLlBojnNTClVatdZoowQ4iDmGMXRE1CAlw7lR7E9oaotWl9G8Z8/r7m/Q0PHLLZEavA92We/MZR29CfeaSGHs6noavv7XlYfabzw5r+ujBF2lcKfxFNA0I+VadEbWO2W0eGVDZxd1ohzGvUGS/56fIm76ixo+rQfEW08EsyegW2NFhX0itIUcdWr7+15WH2m88Oa/rpn4NPtef6gFVvFvc16JsEDVNXQRxhn2UHMx0/wCVh95qCR4xpKy6N3K1BBJFkMzOiR3rGnsg3rL1Fz/lYMKRZXMJFZion/Kw1xziWU/h9SZ8/qWaWljYmcjG0bldoykyrD5GICmbYaapt6dztZ9VCcZaxHNa9KC16pF47z+VEPpr0GN4aiAtG+GVl0buVqCCSLIZnNlISh/mf8rARFGoMg/ZiV4LMsB/mXc07A6PwmFlDQpC5tLRFEqsv1cjFvdHjU/5WJrpU9XNGyO8Ne3QnmamAwXHiL4DNAYbhCiO9otiBqe2bvZNg5HRia6VE/5WLO8UQjxZBYDef8rOUyelStAxrVL+pr/APma17/wzGSrNGgcrsRejC/7CM3GgUjxHeXQwuGoFYAxKVP4nCYPa459F2yQWjUxoHP0dNaGBae2p7wc/a2/C9fvQ9bpfTabx1nCWX9pqz01xjECcQz9ZYaEMpG+kwHxNoKiW8TGi94eWmtR+xlm0AeWElb+DfneCmjL65FxPaClDguUSn6Hwtvn4iW22MFzrEdmanEfA3Fl3q1m9SlU0Y453m8Vu9wSr4ONWZp7saw1DlDXOJtZN4XV4c1CuqviIjFhB8k7Qi23T7elnyOmokz6yj2C8T/iV60egD+5QcXUqMUvF+G7mHYHmi+gtqwWlG3XwCVNLcmd65I1atW0VHhVi1UPB+vpgvf3+s+HjgQS2a8Huo/DAnHRQLZ+WOz16fIm/X4PXjmr7am/jcQy0PR7G7fTSKygW6HW+yRKQ2/YEqaW5M71yRq1atoqKNSjS7E934wU2tW9RGucQGqqvCyHzMTGLkVc+kBFbYEM9i1Pq8QeC1g3kP76CswS1QU0jZwmA+F4n5/j1EVElBojMHZjY7zteZUn4fdFWLSMCjaDvAlMESzPv10erPkdVKQ4ujhZ+QbymQK/6ZMnU5LH1I4afQnZrSbDC/oe0WMxC92tLi2rzHUOd0sr+UwuJrbsJuvaveffwXY+JsJl5X2CynjR6lCn8nnt0EqDuEJmBxCLgtatVWxo2FG0tz4GIxml1HjoV6S3b+wr3Jfq3KfGz81ygDFVy1omls0oQ5y9BvpD3WomRabRQJfsBF0eFXc2fpU/Ec45DvHKyl7GtRKq/2+bPx3MKQsIhUy7aHQFMvYfSfgOYArobV+AmJ5MsSr9vlPgocCtQ1jRTkmdVwRp10XmdtYmagYRYrmQYM1ppjiLGGYU02qUAlRs0Md8Gu0FC/W98ll+ka+5ZaveNqtrTgiUuXWarrH1gsCravF/x0fZMxS3pZ81C6hq6YCjlqCL5pZaFrzXX78PTrCX0qOkvabrSVffvMvG0Ll1neYuNHMbu2I0TaYpyYltYeK+qGCjOYN/R+Zhe0uQpwSu+tytNx2bhuMoitnuRU5GY0/ZWojuZdk5e8LO9nbNhx4jdAGdpZ3O3zxC7LQlKvEwFKdWC1/6IWyzE+xhVYKnmPEdAb7Qb5h2Iywqyl4GoLixVSfMzo+Gjc39L5nRdPIQnfbdrKS7OaS6nU7s1z2gsI95B8Qg21Y9/D9X0I3q8zoK9n4lTzRlY4uEelIDTujEmPVLG/kg/K5RYlaH5dRlTQ/Frn5Lmcv27rVifx4e3Xp8r0fE61BVKzKgDUUVu+huxzR3nMbqhbeqPavKRor2fiVPNGVji4R6UgNO6BWVyTYC/B94lYtlLY0+YF+zz9HxPxe0jbKu3Vz9T7s/L79AJ0qgLrRSxuL7IepBezcqgZ6Cj7VUoWYlzkfb59Px+/T8PumWlApSjTMqvvmtaB+Oun1Z8zom0IWKfPlmhF2pvpL0lyvQLsoJDUy2AJ3YtCQa3XdU267DqKaCfan6w/Vtbw7cd4AQNnPMt4A1qouvp9GJbf7FJWnvMZYMcCz8NzI6gr9dR+72Xj0iC4XgTrVeva4mw2JdK756NHGkcAcnNQMfC4/Ncp+f4+gRfSLVoOh/L7RhQqUzNG98NzML2BXyPpPxHOIELSCTptlJv7eFTj6r4n47mY3FqqaD7kLPstYH8B9Z+A5iyqhzt430hnrZY/AR8T4KBLYLYe48RzJciz2lgotEf7e0HrMPrC6VHyYC5W18SvsSVfB/cu7bV9B0H+I6KYWh5frcNEoVlofhjHGaNNXrPkfvHnoXHcwPvp9OJUfumoIfi9VsCr9sR9ateF9GsbPSAUNar6+/X7kPT2ZtN8Rrid5vM6xvMNamefELPE1NZmJ95TjFcUqt9ppmsy+aZkimbaikFgl1e8tV1cf5mIRpCaxzd23Ms0uuqRsGvfeNgk5UkrUFwuoVlv7yzwtaMWaC+MSaKGH/SYaSj3S+imnkntA0uriIBMMl3iLShfLE3ccTFFVEsrEdaHtB+tSzzFOseeIlTBNbjCWBhu6V79X0JgGR3M9fZj0E0Du72VzUFpL7PMzdIpkdREhBGwFoHoBkWMxOcuOi8hr01tTmBBwJoOD26VuxbK4zXsTa9uSSpEeQWsdPnQ6/A62B01ZBXK1AG9Z3v5d4K4f5d5rY/DmGtYMsjk7xna029TwHyU5j46LyGvTm8DTfnmblZv9g6PtC/qidFiqlO55rpXhAtA46iBzQWHgdJV5MC7Xjjo2J0Ep0U5FvpJ/2kF1SbwOPl66fV9CwpvBh9JoQ90PqErU5lZdit4hScJ+2d+5Mvo2IngYgQJ/5HRIOqVN+eYZEc/wARp0pIimVjKex9JlPauki1sKbj0ywTGBjB9DosW7GC+YBaKRWToItqtA9oaO6T2IsBVpqsS+UDUSLWwpuPUNTYEHh+r0yCgtPCTS7BUSLFW8FGbkWq5ZeoY1Kj/ssypCtj3iQDSaQAJ0XFcQ8Nr1d10g02T/tIyG7SAxAREyJtKBw6/BcXC1otWaaSGIj83Vg2d66aXeGgQAJ0XFcRRKaGU4hjJLxmGfk16GyIozh4vSXPqgTBl50Pp11PMPTvHTM+kZms1OY6azD7zaLgne6hhYG5vORBQ1/ENcNwRurRyy86+kxmR8b/ACsjZZzqx2e8yQ52dtv5hrW0002czgeMQlAaC32494LGHNcQVl6P0hppjWb3WCWaqEV/G9pZQlOFRtA8kdvhEDSD4jVYKzjaABpUqzErNbTJL8xjhneVhqpm82SjVF2zM3RAUcolLoy6jDqChN4w2k1CadumOJ4PWC1+ykVgvDUWtWqrf19PzDr8T0AsUqeaZeqdUc3EaDTQ8lTKCp06NM/v9/8AAjV8w9O/iXnnpv26Z1bg05Ib/wAQMcTDvDDjE0YmcqlbHMyXblWjxLFbwe5EFYnUv9XDJBW0SPAGIOFcsU10Aj3P+wbfWOm8Fg7M01OWWv8ApFQ1TOT2VLIA9glaafxKAOBht+z/ABNx0U62S48u+8ujN6tJqyCpVxUZs+8MvGatNYsaSx11ZPtKd1ljVd6llYuYxMsQHFxuQY1c5NUeGuteJc8yu/VrftdDz6Gt/hhmt/4DWh633m2kxPfaXxrN5luWSt36w/4h8EvEQGLfgHmHHvoLOxLyYUOYha0tSNaWxwhW8yawKHSadxfYysXq78TgiO+2Dzz9oYJ7y9rHMpetwjf3NUEsHcIqcsBv7xvyV1VpKGXcGgOYtcuQH9w95WOB4jSG0CPyJeZUyW1aSJoNLDQJswRYGn3l1j6QTeO1EHXtzOU75gKTd51lEA8VK6kUrMqVjqNv7UWYdRbP8HR1sNP/AMBVbmHrfeZlbyhpmVbpC1xG6KqKEMhU9yJ7U5ZDjXIxJumTrRiJe7lGjMRpoyi8PMMYu4Oo2l1moVVVTvHdUtH+0Zr531+4nc7Wcn1hsooqLxzDSjQRsLgmjqQ2WQUWbeYlvePtcx5UXzcXazB8oMQMqw1kNSsYmgW4xBoenfWaKmDKFG2TvMjj3mRrCFZ4ZmvMct7xrlIDnzxMYB1UQAKlZDmWicgtwuNPTXtGak1imT9mJ0JrHX0My3FPH7+niIrdIOrNWaxDJ/naY7kolSj1PRq+nD7RzP0FgYwps7vbiNMNavvT+ZlJKUCC5da0QsnMELd5TVtoWeyG81z2lGpqLlxdythDpcu1T74iIlnAEbJPbYS8kEz3hgQO5Mo3DdlHtvBSzHEuZY5dfZhX2Q1nJWzz2lg2PmbX0qCMcQZVrGsoLDDaQe64Sg4nVVKD8DtMjBTA3kzektqUcRtqr0E2lACYilQUDni94kIHUx7y401ibM2nvHTSMSA65jwp2kLdE7SdpO0nbTt4cCH+qjf6IKBJTiU4lOJTiU4lOP0FOJXiV4leJXiV4leJXiV4leJXiV4leJXiV4leCV4leCV4leJXiV4JXiV4leJ2p2p2p2p2J2iHEQPUh1J2CdgnaJ2CdgnYJ2k7CdhOwTsJ2E7CdhOwnYTsJ2E7CdhOwnYTsE7CdhOwnYTsJ2E7CdhOwnYTsJ2E7CdhOwnYTtJ2E7CdhOwnaTtJ2k7SdpO0nbTtJ207adtO2nbTtp207aHCgQ9TUNO8up4BTGxhKGpGVABXD37JNRUFuResGZsc1iMGlP0iSEYjdRWJQ0MvGyyLFg3vK9kpbVtGsAtx7zOTgTl7TJ1TI6JsirRK1OISJZvJpDTuIqDl1mkIrnGO8OAe8Wz7JWuzpErXiDhXaGv9RGdL1zByNCYNSt5QuVhh7SqF6J3i14sXbcH5k22kDDZhXQb7vgGss5MF/ATXRbUO0LaHDDDkDcIYha3hgGFW3UBdGvQTf1pnpUqBAhhjtHH/AJOv3lfpY15/1xMcihax7RHAwjnduYeJlXGmrP5nd9ItsaRTbVnsHMLb5latUB3uXjMNnMdQAzAAcUhgMyhF7VxmOj7RCWfjcDvKH1Ybq94LVe8TJzC1N4a5HeBbZs3IJhpfEKxdk83GN4s+0GRVfzLoocRxiX0k967QUwoeYIDu0kzdUyn4WBgW6FyrA1i1RPvt2Oitpps6RePp8Q9NktvzEFKpps+8RaAOIay+Wsc7QWdptPHqehCENYZpCtd//c2fFad+nbToa8sW0rDOFE3PtNqh2oY0bNoKql5yLClJ9or10TaeamcRTD35nAA4g54d+7DwPTtIyuXU1gyu5qxM7S43uxHOHGJgX8yzGl7xHDw5i/WrljMVGCoCbhxKdVZ5ne42pvyShcLW0bAOCU4q6YltDSWhkyPMa8F8EKqzfj5jQz/dEabdJXuL+JbJ292BvKFypPVtnmMBbnHe5tHvG43WI6RxNrm3p2PUEuHb/wB08dd2zK3ib+01MkMszSpiXTTc8Tf2hAXaLlOICpQt+0J48sC2KqhzdpW83liKrRTMGhniA9hLqqg0lvMMBOCcHeagtbiUzVc1X2gWxNEjYXaGDTMS0YLRncmpvqM4zqhPG77P+4yFLBU+0TEMwWoeDSAILvrZqGlGvylUF16bkdUAMyvvCFxO/Xfpx0OhDodP/wB1/9oADAMBAAIAAwAAABBwCSiyTCgRzwgiylmJydCAxTziAATzzzAATzzjAARTzAAARzzgAAzzzzTyAAxzxxAABzzSQABzzwAgyzyyABhzzigAxzzRBRihBBgjShCRRxChZKzoukwyAAQzzjAAQzziAAQzziAACzziAARzziADAABTyhQARTzDABRzzjAgRSTyABTzzAAAxzzzAShxRhyDSxjwRzSjb+zxjAaEeVfzzjAARzzyAAAzziAABzziAARzziAATwgzzwAAQBzzBAxzzyAAwjDwAgxzxAACzzTCCDzTwCjygyzzxBCjChShAxRRNP8AB7w8AE884wAAccwgAAc84AAEc88gAEc84w0AAEE80wAMs8wAA8M04gAAIcwQEs88oEgc88408wgc0cEygQUI0SlcEwcsVsl8go884wAEc84gAEc804AA884wAM884gAgQcyy6QAIc48ANJc40HEAc40kAMUc8EEEUowoAEUIMokEIAIrFSEY0M8IAMR/wUIgMYAAU84gAEY6vswA92DNCE4/JPC8wAGFe8wyv63Jx5cOO9yhjhHEMEO840Acc84gAc48Q8YwIg80n4oIoZJQcwYosPsIQ8IEU84AAAc8Efv38058cNwlUaTv0aenHVtjbvrKD3Bb8i0OwGdi1PDiUKgEM88AAUM88Q84MEs48cAMQsYPOV0s0QwEkggwQwEgAAc84g9eff1RNDlSeXsmfnO5O6Ta9B7UJ+r2PKvVxnKkchwlgxsPc844gUIc8cAE8IUk4IoggsUoo4dT48gAosUck0AYkAM84gAEjKiG2Bkm6hq3KqW1+HZmXl513euqy9HF9ZEJDb+iqD7rYdwUEsM88sAAEIMMk84MEYAYsE0U8cUQM8oI0s8og4YE0gAMc8tDy2RfrWxvqUDQfvrkdCt8q7wVoLOfUFy8jc4s3GptH7tiAg8s48AAME488E440s8MAgI80A84og8kIgM804MMwgEEc88AAkNvLTXWc6SgAX+uSyyykw+TyV2Pl1gw59Z7FFLxAzKSsA8Mg0ogEo88gAU0w84cQ0oME8ok0g4kcQEQUs48oEc0w88gAEs80gAEM8wgAEM40AAEcAcs4EgsU0kwggQs44kIc84QAI4c48IAEM80gAUs8c8Y4MoUIIUsUAwIYIIAoogU84YUsUMoAEM8wgAAM8wgAE88wgAE88w8YQgIE88AkIc84QkoU88wAEE840oAEs80oAAM84cAcQkoIU40csk0wQ0AkcUwc40cssgQkY08woAAM8wgAAc8gwAEc8wgA4wME48AgEU08EocE80gAkA88goAA88w4AA8c4QAowMgEkwUEgIs8cgccQYc000Ig40oUwU0QQAAAAAAwwwwwwAA48woAAAwwwwgAAAAAAwcE4QQgAAAAAwQwwwQgAE8cowAAMYgoEoMUEIMoAQpZowME4YAsoso08ccQIoAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAAAIwIAAAAAAAAAAAAAAAAY4wAAc8ogssskUc0Mc0IYsRM0UUwggkYcIQE0cwggAWFAAEEAMEIIEAAEUUAwQLAIMIEAIAEAEIcUAvABLAMAIMIAEMAIAgAEc8ggAQAog4cAsA8Mg8v4wIQM404ogMMMgsEogoWWRLAYAAMQUUQwcQ8oA+gEAcA40440UUAoUogeG/gAsoc8Eoo4U0A8c84oAUsY4E0o0wo84Eg8V4swUo8I8wMEMwgUoU4AAgAAAAAggQAgAQQUg0AAgwAwAggQwwgAQgo0IegmBAgwAQwwQwAgA0wgAA8840gYcwwkkIIgAMwIUgMkwAUAEsYwU4Io0oAAAAAAAAAAAAAAAEEAAAAAAAAAAAAAAAAAEQgAAAAAAAAAAAAAAAEIEM88owUYQIsM0kEsgck4MAo8cgQ8EwIogAoQAM8wAMMMMAAEEMMIAAAs8kAAAEAAAIEMMEMAAEIEkMMAIAAAMMMMAIIA0Uc4oAAU8kk4EMEUEQYUgI7EkMqyU0Ao0s8sE0g0A8g084wEM884QAAc8wgAEMcwc4wAMIc04wAEM844gMMMwwwAMMc4wwc84gAMc8kwgYEcwwQkwssU9sE8e40cEAkkMsIww04QwgAAI88wIMM888MIAwwgAAsEUM48IAAAQwwsMM88sMEIwwwQAEU88MMM804gEMc8wQ8M4MwkUk7oIHX1oYE4UAcoIAAAAAAAAAQQAgAAAAAAAAAAAAAAAQUooAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQIU84so8IEUc8YQIgomNckgcsocYI4cIBLBAAAAAAUIYADRAAAAAAAAAAAAAA0AIAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAo80oo0ssUcU4YQggIQ40MokUEE8IwkgaxmAEEUQcAssAUAWJEEgUsQAA8A8AIcgSJHAAAEcAQ0oA8sEgsQQYggco0wIs4AckAwgU0gUkwQU8w0kNUIUc0YMYQEcggE93AU4AQQE4wAvCNKQwUEQEQgQEQAg4gnJnDUoAwAEUoEkAAw4MY0kEUkYs0A0AgEcwAkso8MI4gcWi4qm8Qo8IMY80YsIAzBAAAAAAUoEASTCAAAAAAAAAAAAAcwIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIcwQo8kEogMs8kJEMo4bk0oQEoIIQYIMMMMMMMMMIU8gMMMMMMMMMMMMMMMMYEgMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMwwAQUA84UA8gQ4PIQo46owM8UQ0wQwU0Is4YswAMYwwAwMsMIww88cIAA8YwccI8wwkEMc0ww08sAAEw84gAAE8cwwwIM4gA8gw4sAw4+sNNwUsQUA8I8cAkEo04AU80swsc8wgAM884gEM88wgAE88w8c44gAcc44AA88goAA884wEAUc4wAEc8w0EEc80gcgAA8+gchBggg8AAgcgdggAc8AgcgAcgc8gAAcc88Agc8gcAA88gAA88AcAc8cAAg88AgAA8AAAAcg88AAg8gccA8g888/8QALBEBAAIBAgIJBQEBAQAAAAAAAQARITFBUXEQIDBAYGGBobFQkcHR8OHxgP/aAAgBAwEBPxDtnVjG1xplu8fD9Smr8LoqFsRVPV4opnhN1h9oEAwy9vClgMOF29Un9hmVJKg/a0f7+5TQh8HIqOs4ApvHrVRyZnf9zUNvotSuvUqV1K75eoA6bjDMG4/aUXXYktWpZmD/AI/tO3G2YNRajgF1BiJWVgOm5cvrHQClotkVLQTLRRCXFynCV4QQxZEqkolSpXeb6tyohT174RMnt1jmQSgijaqjDQWQklxJYZWUoZFydAWpZUQW7KSECCRxuWssES8pcBSVmcxGWOcIazjMPr4S7/fQC2S1wOQhksjdasW04gqnKDkyvCFrEoWSmEsld7FGyAi8+XLnL2XWp+u66Y8pm9AVvpjid7T0hdk1+8P8CiOaXY/olGfc/cDTxLMI5IIDLZcMxqIFsgK3EuPLoi+M0/ExRdV+ZVitPki6l5ovaYeAFjANkZ+b+Iyxtd8vpsS4Urk/qXd3/MQyFnymZlN34mtBtCtBMSRQDxIkBAtBBwRU2Z7hU0cR73nZZo8o8NV4mnv3YKUsEJYVUXJGrbMxGURgcOEllpYXqwd2wiqcxmSYkKswY/28fY6E6iziB+I8ylr2v9wwDw+Zi/NmC8mFTblfMCy/7Ei/k/uL/cZcylQ2iOMsQhBUpkxo8kxqgMpZRMkTYhHaXsj9RYFrl+Evwlktayi3DBSSzbKdOoMsFMrxgW94dxhWgucUYgN3LmNLtjUEFeYUzBUzKdYzbrOaIOJbMMrxleMcgVwBrHMBSmV4xSglRGmV9UqVKlSpXXuWlpaWgorouWl+hfQvoX03Lly5cuX03/6WHtERp8O3eaLbfdEhmNV0L0Mau+1EOYdxo5G6FL6tM8cY0h3K5I/KF8hQeTd6eeNO4OqJdsL5N4+zBO57cTmOGKYXkNX2fiCwqvL6Eua7okYauXgUt89jzYuZb1vPr/YieEed59bx6RoKzb+8tO4AqtjdLFvUeHxpA1Tmaj2OqVTda39/f07hguxsLPIBf2Ze2tUKrnQrXK2IzC8AGzWyy8xxwLyaRVfQlwOfdRghv3LAWxpx5X/kKc2ck31AeLf4O4OBQb4z6N4+zAAEtRvVyeJGrx9CWLyfx4e0eT8nh5qnN8nUQFsYyvDKVfzXqCmtJSYrwzeGlHy9FuaI7V+68uEqzRK8NYOKKa27Gx++b2oBVoIvgOINe9X6XFSzs7SyugWq8MQew0hOJmzTlnzgUDB3JYJy6fXaLTledVR55briEeneTVObevI+8JY5BDwC0+3yPZtZWM5vzbfnoQZquC/QY69wYJWo9S19TzW7fX0jQIc/pyXbJ22qiYTiWPsh6XDiW3SB2GZo4gHlvRwTh2a4ii876OHGnrrDrRyFhJLSrqnU0uo9wtVVthdcnY3013htiDn7YzA6ZwcH2u3tFt+lGyjJuacv9+K6KtjQ0Y1hoan5PLtg7IeSkVW3tMoarOeP1FoWh9eozpq8uHrArpFmFwNLa8MYUyeES/Uy/wB5dSmNk0vXhdlNdTMLnjvL0vXw4waodlv4K//EACwRAQACAQEECgMBAQEAAAAAAAEAESExQVFhcRAgQGCBkaGxwfAwUNHhgPH/2gAIAQIBAT8Q/NnwhNOWB/p638S4wJ4n99yYUW+7aXrKgSpcqbOe64C1giWdXIqYEGvDxIcI046/7Eksu6r7oLjyj+uqwU+SWaIp22pNXnucgSgmqF1WLQNOe/8AkCutZFW0KN/pKlSvy32xqcysAHMJkK5PwyjYPjXxEWSvxOok0Wdgvq1LS0rpqWlpaWlpUC4Y3M2PZEsipUqV1aiisEgRGykrKSnQvstSuiulaIAs7OayswIlaxBU9EbmbFiOyIsWjGi1lG4dgS1Rhh3CKB7YLqQ6slrLCsuLLiEJHxxFNkSlk2iMUdCpCVTE74BtmwUiFeTbLfg9Fw5mYV5z5RbUtGKbRDTBKNsENMG+1aytUOzKqGFzNKqmAwAYKPpcZW1CiBWej/I6lzHFGWHg9IDQlbhnFF/sCMzFAMkzDdFDMJmmFYL0+YgwhdRNBZlOprCNaENAp6ApDiQsvGzX4jvzy/iIhhc6nHbwuWgpcrw4QZbvnDQq0edN+uZqJN+R9Y0YG40IhqzZexP8ibDQ92aCW1weErg9T+xoIpis7Xe+OGOyk0StIAiGope3S2qXalCwsYXYSzWUDTAlL0HMkYJJD7u+Uh91lvKjqSzM8mdx6MFVRri2EMtLlGXKJ5R4v2jQHxj3h0Lz8Qp1+TAJQH/H3gxXRTym05hlN1ZzzfrN0i/J+sVsWb4RFbuLOWz5ZSGNt/ser2EC1UNH7LUlN8pvlEC9IViW2Mq0RApldjMgy6URJplN8C3tmIWGBMyoq1FuCIsVdxtR7uXoVpHgNJfXVGdzdCEtDWk+t/yfW/5G0CoUZYSoGpY7S/WaLWabJCGiQbt0pbRL7pSrYFftLly5cvotl9N9C5cuXL6alSpUpKykASohlJSVlZWIhdZEHUmmCEVK/wClLKcx7nd0x2pfErshbGulQgex7CtonEeSEIpW9v4OwUriIqZlAvA1f4Edf0QvHHz2TbQAoBBROGZZGJv38YliV2A0ieNR3bzhZLwv/nYGeE8setQKggLR/wAz5Q92ubTnj5iARv8ARerPnspilXq9iTtXwa+GJGKPFv4IsXKugKM7XLb2DP2Pp47/ADI7ajDNRxLPEs9yYm1t/RerPnu8qDifPd4c+Z7PUC4Pad2X3fHUpNKDq7shTav46EVErXz6CM2u7ZV5gCiuO38yuqHNilD8dwq2DxI1JHfSNdiEFDB+9RrU4jpA8V15YfWOldrTg/fPH47R3Oiot58nYQVxBS7o0N/LT2Ylu0++H65q3PzDt1e3dqfPtCW4KKrRxnnmPWKDbz3Hj+M58u7xPukRLX5MuaSOi7KddaPDWGnYLAU5fJ/s1x59fn3mPQ3/AMziBRX6oLajAHxhH5IRk0/MHQtfkRCQCnffnAiGr++wX8It9LrUXHdgq5c0aHVVde6+sMa92tvUVrup/8QAKxABAAICAgEDAwUAAwEBAAAAAQARITFBUWEQcYGRodEgscHw8TBQ4UBg/9oACAEBAAE/EHBaStsARaiPARN9R8/M0YzBcjruId4ZgoswxQiWimN5eyV969nErQnnD7alOYg0dj2ljICrZgmGtBghQNebbmSoBqYUC4it8GLG5TYPeWlWpeYMBR9yFlWhpvcG4WFCUZbbi1kYo08qrBJaGQGL88cQjokthdJWciKDDhPnuZWk2BGPjHxBdSA18HR33NibChPnj5idsXP2Acufio8tqN+0WL4qiNylnIW6cF9BUt1aWrAWy6hETmc1XaUaBwz3cNBedMuyYpTk3vma5iRoY5WEDAKXSP7dKgQ9wzeQDemIjMpVK1e1lNDfiNvsnJ/z8/8Aa8TiPp8w36fM88+jOOYlS5xufSGvL6/7NyiV3P5mI6zD0Jnz6feD7+jW/THeIbmJ8z95q7jOI4aYM+bnwTjy+v8As2TzK7h559HWYehM+fT7z6+jW/T5hu5i58yuefRnEcS0iOQIOnmFRQaalg2lo7IgFl8QeWYl6lOLiB5hVqKA7ldW2cIJTV/aFdjz3BtLcszTUD+iA5C0s/KWi06Q3MYTlad/tDjujE4VjFEQz7qHAZerdp31KjFIOe403SXrqUVAbcqXUVWcCA0QBG1dOXPD7R/CaYDMqcS1NZrDCaFCksr6iZhXTBfRFFWS2yK+NH9ZZ0K1IyU8bPpCl5fKb8nhvfcubeZIXTy0Z+ZkhwUqu8BKHqWgiwGgN2UXxlzCVRBlLrno+9xuZjt+bMkYaRHsm+JQiJaVbOAaPZLrmh+/lOuRxcS9QWkOIX0WwUmLQFfvF7h/4z/4z/pCcTmFXPtOfWp9JyTW/TzPghxU4miHcpsxA6xD23KzXpmb9HfoU+lZqHpzDxMPiYv1r05J3NzzPiF4qcTUO5WSV8Q/eVmoamazNz+5jufeb49KzXpxOYbm5z61XU+k5J7zcLeT5hRUbTRL0BhM+00B5j0OIg0ATEHwmAHZYS/xUR9jWNexL95aH7kswvEHoWmrZVNjyxd2fFRwgpacmNgGuMiwnFqWoxj9paJEppH1j5ZuDuMZYzDu9BaMrJdqpLgwswtMpFg6lgLtLYNwKnWdVUKtmDNeaiNEKS+JUbpNILp5i9UEtcAQjWqeRzNFEUks8i51+8qHggAKNg+IisgadZyD4mLg7iNwMvGP3jaZWiC7NFcTL44ADRrlGz2meG4fC5wj9iU5uoYOON9Rrt2i7y2ryGSk6YQtue9BS93BfJC2RmW2mXeUJK2VdZiCrkq//wACXHzPj9B4jD097hNa3OfTx6VOdSn4l+jjE4u/Tj0rPodRnj04zPiefUviMPTe7hNSs+niBKnOpT7y/rCOMTi7n7TiE5mYdenicz3leJ5h6HiMPTfcJr39EUBXOIiYKfEGMyg3t8RxUia6mWI3QMuBVEJ12q7lCLPbNqCwLdRxrrKr/pAS1kxehGrG4yy2hvEW0B7NdTLwrCsMyI5mkNfeFcWNZH1iVSi84MfSA2BLlhvJrLC2Bbu4aNL3mY6LoqjMMMOgI45AuKuYGWrV4O4GmTGarfmBs2hppeoCmOX+IiThT5esS89WC2A/1lylyWaNYPaAJxNtzPse8cbN1jKbS+A45m8JMDIoAtXvNt53I5VNPjUcRcIr0oXCvpiYWKTB7jEpzFAHNW0UC8fWXItvINfIYfiIz3KSngiNF0vUbVOS44he6df/AICuuvR1PiczNdenvLlVz6HtM8x33DOpSzE36+K9KvU/f12+hfpzPaJO5xPiZuF163UqvXPMr5hmUvMx1+jxOZV6JX1nn02zELnM5ntEnc4nxOZmvT3ZklVPpPiZ5leZUfoAhlaKdQsNltbY1SCexlOBGqV4mVBs+cE0wMoHmPFSjjN+8RYwYaye0u8pMU5+kMcEbBR/rEuVq+i5llrllU5UctzAVpeoXc7Crg3xAb06C2LOX4IuBpwkuMjpOIhKOWuCAAVb9IWKpdZgFbpisVxuN25Hjz7xHHN6qXTVIeyNLLQ+fdhcA0UEC5MAw5gqWPIlHN6gtfjzAbsjgqaQZzj2gDCNiQw06q0xKZgADzujkqBT7PQRurr4mSFzBkRin4YHKngZli3yQiwx7D0fKk4rEfBzm06oO0cmmEIEOtk0vv742S9QFZqTo/K/eKzClAfEYdjPhjeaO7louytXEAImEf8AvsTj0JrUc+mJ3Gu59ZzPmc1x6Y9Pio+j3KlMx1KnvGE+MTEzC5jj05hNajmcer7znmpVOPTnipuc79K8VGGo9ypTXrzbGGp+0xXpn+JicTz6GNRz6fE7zGp+01MdzPBAIwQyp95ZC4LKNxWQlPUJSyWYE3gpkOoqKMuIhVa33qVgq+Ly+YbTl0W39Igqz3xUoA54vqZilxFysswrBCzgF7mLzb1iMUtiU3pihlQsIviZIli0wA8xcxsoUp9Mxb3flsfDMYlyLX0QJu6LFuoZDlTfXZHoFtuGtwNGqfrDJeiKqhckH4uXNLDgYTWTgKpiBxbN3CFUlNamAS5QID+ZRyKyLd1Y9G+Y5FQpVXzVXqKFHpGvhK8APg9yYyttygnl7vUz4WYA5dwADFHRq2h/EXboG5soHJ1/sB3nQOz2O/KzmEZdlrjSP0EMMbOJp06caY4cbgOkDw+M83wd6iKEjVt0FltRATITuoguQGqYIZv2hXAEv3ioUTv/AL00biVKuG9xlfoxOvT5/RxOcSvmErE2xJ9J7zF9z6no7x+lJVmIb36YrM49cfPp+8+f0cTnEr5hiVicxPT3hV9z7fx6O+P0pUqG9+lY9fiY9P7ifM+Ygo/biY1g5fEUE0Lwa4p+kx0jpQLtZY2aAaNsaQuVgUXCe2ctn8IG8avMLABFNaJspaHSAw8xTucuWVwMKsB3C9Q1VnlGh08to694xheAHYO/dgFUUtSRj2HhBQilEZIQsDAsfmKhgLsMD8y1jRhuGGeeXZHJa/ZmeIF3xDEoseLalZlTUDaHa5uHoKpt9OnyZhtmoEpHIl+9xINJ6kK+qr+kqdBaKDYEqz+IA6d6X3hEUNNftFioctlRKAbjuV1qLCWzx5iHribba/eJUxDzh3mpe68FDL2GHHvGamVAMr4e2de87rYjl4Rzfd6h16ymCk35iWG8SH2IczmQqzNfDeORgVQtU6vH4lEBW5loWjwypy59osG5XSjpiyon/wBp/wDeXoqMx6mp/SGoblxMT5mLhvE4lTjcPtObuVcP3nvHUz6Mcs8/tPe5zKx6ZcEd+uZxNwuoblx4nzOYXfmcele0Pmc3cqHjb6cTj0Y53Nf+R83OZx6ZcEf0cTcNcw3L3HU+fR3LBTgOoYXU4RlqGi5Hjz4hMpRhrk9pRYVDJ5f6yrN2LqoaxvYw4V19IdTMCi5zAWwy33xBMtNs6hYETtL1AsnxGupa88Ro3pTSfeBZXg7x7RGhK0GBMMMpCKjFsoDuVez3O4SExu31lxuX3Gxkx1ByruWilm2CYCjPUx6EyMWUt0A14maPCPAxZaUQAGqWnT5wy0Ro5ahlkLQHZhe7+YJ3eh2V4YJbS9u2OkgMmAMpWmqI5OTRr4nTQX2UYjYqChCGrbKIXvfPNxNqAcKVb9SUWMb1glZqsoH7wuW3YYps5z7kArFBmXd1RCbVHupQYErjaPyQk1W5Sezk8nmBLNsrFeSVnZQ5h5xn3gmYqUegRbIthWSMTMSgoaY8Ok/6k/8AiNGcTHuQPEutQ6nEZxDczc48zmeYzn0/icQIeleZmB3Pfc436Z6lT2lf2p8TjomPcgS6h16PobmZx5nM8x9pz6cf++hCeJXtKYHcxzufMqZ6lTnUqfE4KaJj3IHiah1U4jOIOePTiYueZiUgVtZpDWNXuIBVvnd89Q5jaG74hFsQWljkzwyho2MJp7iUCrMnREIUaU3jRUsgGaQXKoGTdHmZV0t5/wDIGSimacsYwdapWFQnB9Zlme/KR0axZZT/AD9JngNosBHGZzZX2IdoAnW9otsEvC/bMUcwWoG2i2Gjtjm/sQaATVBkvsTFATbBXxGImbCU9sYa9kY/IqwrjCmtHDnDR7ShfsW5ULbvRGaxVgdvb8yjA8DwuIC/lrcHBs6dcwollhkypecAk0bXkvHtFDjSA5fP0iFBSBi8LxwzzbMqrn947jCULWKTmvMMxlGq8FtchLUBqDYWxxsGnk1UOkgW9p/eAFK7VKfsy5WXhcGg6h4YiXuGBiXG8SrHi1Ex0n/dGp41Nx3OYWYlVCcysz3u4w3PPpjMDie058entOfMx36Die+GY9as9M/E/ieDE3HfoX1KhDcrM/f1fj18T2nPp7emKJr4hqO87mPXZOZn4lfaeNTcdzmF6qVVwnM5nvdxnMT2jWyxvFZlc5DNsv8AbnULFU0/5C/DLODBn5zibttqDN319vmFsHr3efjEUSb2AtigBFtbR9x0DVUwA/SUO0CFm4xa01QUsBZ9CurqJmRdC1L4AJyf+IcMhWRt6gr02iv0u2J8Rkp7d/NxiKkex5JTTuxZ+WV8g4aJgw5O8y2OTNLF3NFlbjyhGuHJ7At+Ihce7LLYA1k2a5VrfA/CPtFg26SYUFC+MXHS1AhTYNWdXcRjzLygKA9HcFqv3lKGrautwwNlXfvK1dw4tdZx7QGEG1o8/EJmqOEwwNaEoPUaYWEXho9ssMBZgwmF96IBk/CUs58aqsQ0wHAzV6uM8cZy8rdlXnF3qDrgXEW5CCms85jv17MUid3GI5o01wzRc0yTZv8AeZN6mKhz7y0p/eULoljFJ0m//mqVK9CVKlSv/r/apv2nEarqAzaffBcTeexntlonE4z6MtlTknM+3oTEBqaZ7lZ7Gez05biq8SuJv2gSioKbxOID5iZz6ELlTjPo/Mt9OSYvqfb0JicbjdZ7mJm+Z7+m9x1v037T6xqErM8cwvi4mcvoQv0KaCAeTmoXZhhUZ8ObXWYkU5S4CbGDasSepvKiubgd4WGr88xhYiuOxCQgi0kQAXwNI9QTQs7q+HOfkiZTiynDXvWo8QBoU5/aWIsGnbmOhlnLq5SQnE0NH7suVEqsH4kqOjMDCfi0gg3g5SJ9I6lHtJ+5HuJJp0R2z5hMgXnmj/YF54TBaAj/AOytltQKQacD2xqCqPXUTJAV0DpFj5oDtKdF37wTtum832Y+JRAWPWfiDSbmPyhkKRpzkjlAMa4TqAuwK+YVz53AkzsDnuUHNlmZq23ggqLRlxNAJCizNQYyVbCFdQsBCbAMW4yObPaKL7iKrJaXjf2lUt6wBxVXtw0kGswE0QFFhcUDhX3Oo2IvMaIPLOQYYeYPzAbmEK5iEp0wUPF1uKRFJ/8AGECEgWjP2IUwcYqGybqheyInoLYBwQ1o6A5YEriBFXiqo+G0VMdYE0iOmNInrUqUypUr/gplMr1qVKlSn0ynoFy8lsoyXAfcMHzPZ6A0FjAC237R/osMWzj2lUDK8VOJwTqVmqlNSmo+3p9YMy6EwEwSaADKw/Q+HDh1GeVIQ0jslEplkZ4hBJ5aEmb9op0AXsFPlHIqVKxiU6genGqnE4laxKzUr0fT6w9OJ1ic+nPpUJmds4nE+ZmHp7bniFel1xEBQK0wF0rgISKAaOI/rSUcJl7jzDLxVGRXl0QuOK6xceYZWl69pnaLgjG8DqmgP3gmoCcr5/lPpKrGETwZv9yVsxSQur/jUA1MI9FR4mDOwt6r2bhcIpoga3jUzE4YDus89+3xHBJvIPvHIAxWyI9WRX8rl3HvvggCsAvMvhYCIrqOPL0mLaiG2UWDXga+xKwygjQA7dn3lK2M1JFHtjXPvtyHRkzY8jFwKSkRKpLteLqF6RlIE2pq6oyAQyVAOni/e4l0laYrPDqpmZFog/XMYBSXMH04hAJF8EgsFsXFb08CKxRz4SBe9WROyANmq3iF2cI3YHPGb+JdiF7fseo2XNR9Kb+IbVYoU6R9khe+kxtizmrViG6hU4OcdxYGaMXjo819ZTKGbTsqg7mti0xvBCgeYZBeWDj23OUYecSghkz9orpLRHPJ2f8AxBmC5bBQf0tntmZT6L2c495mRerC3FRAIIliaYNQKq0RK3kq+albqVrKeoJhFupbqXl+orqMp61CEg+peL6ioKD6lpbqW6i+oy5QLeZZiM8QMXIFdCxw5CBcqiydAYIo6mXU0Lci/wD6KinieCU8RfXpHE6lq1FEVHCJmGypc9yvoL+o4L/VFvUveoi6Y7xLL3I80SqOI46irwTBPBL9RfUwNS8tWoqY9xwiVDxOJzM1Oe/QGtevP4j5nPpvM+tzd3D04KxKzGrxOMeqSjkYs0EHyg8Rw3uVYhbK7JT0IVtUQDsK0LteoatHUXFoDlYVbMfHY3GN0duWK0dm6FywXG2tEocFhlhxlKxoe6xB4qgaB50l2U4j42UobLycRl4Nruuzsgg0UlgFOClX37wwlSzn+j/2Ue2rmqa4YVyUDYzyB7l1RU5b7A15mFb2gJ1ufaIBQN3ofvMBy1kfOwvBnFxFNk9NsQK03byYYgVPPvBZs/p/5AH3MoGB8BvMZkAB4tVe1Vji5p1Es9uZoTJm5VneCtPb+PpFLNlIww/y1U8iJyQ5Qg0bFBAao9tsuEwrFXG6NaPrDSRI7XxXUswtlDY0W+KY5mFFZwFtPtiG2rg4rn3gG3VGPMxdxeJg0/iNv8T2gSjc3ucqLPj/AOE3BL4aHo/u+m4rjlLGWBiWhjAniyqvExangjjqXuOuo6ag+pfqC6iP1GV9Y1ajHEc4lECXx+EZ4jdQV2goIxxF3qL1E6g+oLqCDY2FREDUe2JRxC7qJSX1iY716f4Zl1KZ3EuP6KhXiKnD5ckAtiMQ4ir1GeIjDVK+5FqWPSRDiKcRhzM0vGJXW03oGQOsIC3mD/tfeP8AWv3n9lfvFStqubil1DANXioUspq6XEIdlVcTzrNe2FuBGs5RZ3VouLjoRuog6l+pfqCRrtEhKuJTxKGJU47nJPp61j0ucz9pombYV1GViEzVwz6fE8TGPRiMqTO6AvT9pVwBby6r2hS3WnEIOC1eLi20GRce87VJOHEwptxfvX5m5DN5tuHDQbS5dhx0wTWxxOOfEFizNlKJzjMYoGB2e8S/bjic3mP6BqE+jK3m1awVVLqyvvGvZWCRkt/aHt0AyvPvTBW8l1UNBXLjgiCabW5TAL+8rHnDCO0+Er+yeIO0k+sb8idmTkb2OkidYGBuuv4PGmIJTXhKoL6f5+kwmOki/L2hTtw1FLlbepYhrIbG6a2zKa+JRxzCrQubLbE7AjhN3BwUIX2L0ncBqsXaXqEolg5ApT0Y+ZhJA+BdeYlECm80JWdYj3W6FyXuE60aBfPbXf0inPL3H+zb7TWVaix+0vzqJgpqNv5lbC4ESow5dv8A4CHUsgofH92WOBsiZliQKrILErhgOoABzA8qATDiOiPrvTkwIWU1HZMO2I0kc9S5MS0zxccEQ4oQS6qH4sbC6W/wlmi4R5s9Hl8DmjM0YqeW5+mI5KYiuGAo7Kl9mzxB6SlzO6AFU6BjsMXmYlbqZZ1pZWIQ3DxDK4vW3xK2Qqur3dr5YBAESkeZSuDiC93gvYwbhzSL4Dh6dPjU8EVhSUY0ylw+wVDomhe3erY0zBYn02GuxfVQcLUCgPaJKw0Se6fZY8SuoTVP4I5OPIi3GJR0hIh6E85g3qxqZtQ+1QhZ6f0D+IloXxdwsLhDOZloS1mP7pmA4r9hwdLNfKDD2DEdFigh7Th8MYUYD2MeL5Hmnqbam7xsbnJwH/hKbGKFD9Cve2EzzRQfBHqsVSfuQ/0imvgTleFr2jq9VoGxOGKnEo0lwxKK2l+30wptvvj9R6IJ4lkGhegwUch12fp2ESxVL5ll8sxQ+FT3GCg7g+MOXVY/eHuDSlCsZ5KhmsUA+g3RyHXZ+nYHXFVr+7y+WNNsip8MNNDRrwVp+THZzLISlVKuBhngLN1AhZKYcgEL4Ho/8Dnix0EyZnsvHwEAADQGCMTeDB7Gh8MIyjndyjxc8nnKVOoEZWe49+nic0N+nENR1K9/R9Mznc8wzPE4l+mOpn0wbmBbGA5g7dfdHM3i/eoKdDqHwju4le0KAnzKZSdGJQtMd3cMRe8OWSVjUbFDqC6wZhiNnnqpmhZpeYLdiww/RFTzcMoLDmPFS/GtENDOc17xWLF4X4OOJTZ7NGyjIaUUXXcRQ0RRGoQgpxmBD8RCFzWa4uFLYb1sslPhHPx1BJtIKu5dZ8PW4AqCF3I1MLgZbVC1rxMjVj1KrO5rwsyHn0ZevmWrxBZh2aOkjiUQJAdC4PJ7RQ04M4f4zf1iOgTkToKg/ToLVTWEIR50DRU3cMIQNNYP3IOKqGcHEuKhM+zupbETW/rGu7r0UVM7GuYDNJT/AM5NyXVMPafuw3/UzI3BByT+38fQ+rPHg1PkxPIvhAsfoyymopK/sYeqFFnzqwX8bniD6gAH0IgISh6RXVq+qBXDxcV9AAibSRXuGw8FebgZIlsOR3dw8Ik792Dsbeul2bVZC/ZGNTi7pyreTK8jKFx6K9MQRlJLCavYUr8GmMwIvgH39oa6KPAe+D2pXbKa/NUv3tzFywEFFgExT0+exbbdQj/dy8Oxc3ZX035uf2jyjeJBuFnupHsrxDOs5gDyM/Ji0Ycs99YSiUo3lrxNPsldLRU6hkDB9sn3CUriCoABDQgCwhdX9WHr0sAuz9PQceGrMkWaYP6fKC3NUsaI+6Nc1XMDNlFUuxyPgQ99woU9ifcVH5hOUm6PC1oHIYzgKinx7JdGV9QguzdVUTBDK+bGPaMe9vMrqkStWmuVwfLGai3no9jQeCOZsW83Sv4p8wQRmZfteHh/EAgopaOH8jt56S04mOsxMStuv2PobabqiravyivTz1js2oqC5jaFqGw5X0IJQZ2AKCFdspB7AcWcr/7NnbYh17U4l5p0KUdnJ97+JbrL9rfvWHzF0cxN32obHK+h9YJQWuAoJf4KAHIDhTlZbvveBD2BoljuA6ydm9+9wGAXClxFO6sYsrmNV0PcabfgC/EF2CXL2vlcvvMy3czzjqO9vFctXJvPHdrLLWBkuz5Xi68Qj4nicicI2J2MJmUagJScAonRTiUMFbmK9T01PifD6hA9D6x+3odX6cfpxGdr3qveXCq71EzgRiCfvKX3iPzETfcbN74uN5zK5q42ZJkLL8QVbGSJrjWpWeHmVRZrmJWSOGh3iI3g4hY4WyZsezXXjmNCmoUT7NymcbGV9KmB7AUZe0CwVVQK/WJLNwBKPzCo3IChOINYWWBBGXOhXYOdRZGN+yLfL+YnoXLadpZfSGDarRStA+ycR/2X5hmA4IWucR37zNdQunUTOIGqALCU0HApNGIijdIShjuYDm5Nq0HN9ExtRHGOl7mr2QOsK7zrXERY0bHbH6upVZ3M7JyYuXbW6lvKYxB6iwJmPnTNMVlMvMSZOz/nJvHqfZf3Z/SdyMvoKBMP7+PpR/Zyh2IVm75ftSwK4VKfAvsAily8VaqsZf3H4IHJIudZPa1+INZZ16Ar9n0hh11NIpVm6r2uf72f9XP+rkyzmw2aVboo+JghUvsP5H1Q7QYGyVzPJqI/YxWdC+BQfFh+Iwx73L45y5m0m/LaCAB67qT0rApA1wpJ++Uu5ZtESVjeMIP2+8MCwn2YFmOlUrE0ykX65ss/vu0cAMl2X/IShcy3aIhSp7WX2X0PQq6aUqfQ9L1agpouD2FHxAYpHA8KXqzYjdsmfqyvAoPBK+oQBcSv01/SuPoyOIlg1daQcgWR2PstWVcLUFE+IG8yb0sD9UjibzF5x0Zi1kG6yP2H19GitLaHij8R+bIukUP1SOK2rH5R13GNKm6W/wBj0IhEuz2gL+l/Wb61sslFLNb3PzTn88Z4e+UFXZsbgWbWWX8scoplOQH1fogpm05ho6nt6c+nM+JxOfRy1O6h7T3/AE8evxD5nkZjirGK5jmt+Zq7a8zs0vJPFzc/Eax3DxqOsfMotviEvnxBt7cx52Mye05be0y6vruLZi8TF3epdYx9I1oj5yXHlmAt95eKrHcLpQi91c59d7uniD6VMPFOSVhqNRYBfruZWBHSO5dAlIKVmrlaAmG0u8R+kMPmJgqNUkfaHgmJ95VyYULHsKBye15qXNoxeIcfMDyWGJp6xOEjZwly22DOmXbaw30Es9mJ0KZ+hPmcf3MPsl9L8S84JQ5xM8LUVNk0F53MBeJReOIrlk+j/wAxFmVVHb+P7sdTAXHKUw6/r4+lIdfvIdxhm0bH6Ug9i0bo3fwB+IwB6gpE2THTfG+L7UQByVl5X9EJcDFPCEMQyu0atPKQ/vH7T+sfxP6x/E/tR9oN9evgByeIVoUmJPbLCW5PoYrxoA1RD7Wz5I1ZeKqiorLNllGHDS9nhg/fFam9+Qzsy4ZlQ/rR6RLrjikMymZQvXG0/r+0VJFXtMeW/wBfD0a0LUvFv8vQZXLDhrqDfkfiD/lfiDL+4/EAuxg1ZV6hZjh4wqv7V9KFev3UybiXLeZaMsyfBCjkhOXAfaMrLTQkrIirW0t/dHgSJbCD74h/C/SZuSR3S/uCIIERpHiXhhIBgI7y2f3fdPE0JZgWfJwPov0hZH1axWmPAw39D7Tnr+nU5r/t1OdP7dRqsZ6yuqSMubTPMPv6VjHp+/p9fXfp9p59Wc/ofXC11KUdE4z3HOY6zWuJ8zHhHXdftNHxAB1c1sTxLvjMFXZTGwDcsjbnqNfE5x95kFYlFdyrPbiO/ncc7xDAlEUC8xzxGjBA6Fj7SgbEcS22i8gcW8XzBw1lr+hUftqAH7nHwNTOi1a2JjiqhdxD/wAjg19IUcGJXKUXClrqAopZq3zFI1VKeK9q4vjsnC7XkTI/RJjQYV1vHxMPyAVLat8zSCapSKCvJmXe3cVItmvuwwz4l2aLhzeGDm9wMrvMGsWxcVnzCkVPcO6bOZsoSGTSv+U3FKI7bx/dg742A1rdGrp+kT/d+0P77+0B/W+0OzEeFQaeLH6elRvQQu6pOkE/aMPftcBP3leViONHwPpkLMtngpD7EW8q8uMD9BM+RK8MKfuB9ri+S3rG/kZeS/sAAyJ4U+NFe4jui/ORXbwfNGYVdhKrbaabXO6+JQ9HRI4JVhwPNSxZm3MbMaEYooHAfDHuDmYwt40nIjwiCeSb8Rfp4Vq+3mZiRVizqguJLMDpeKfUHLquYyqbVCLX6RFg9oi+rL7rP70Zz3/K1ZmBmf2CwRU8iy5cx1biVDMOEITSLPwK+isU04bYNaTTfUzFiq5fVpENX91LF/eozMzsy0r3+y9LQBIRyNo3AYHYGcdOz38RuOkXhUMB6GK5D6lQzSYfDGqBh6/8JeZ7If30V5+hzfImd0do5yoKfjEBOZfNZzBbGy+30Qw++CqRrJG/3/tC7+39Jvv6fiE2aFpu+MPG/iDAcQsR0kDcK7+br9gyXqomNmrRb2Y3HXOivJle2PJBjF03bVbsFvuTxjDB14A2uB9FgIWtYQsY8LbfsNAXkcc2RYCNX9CCfeL5Nzol1w+7XzN12pVgJ5ayvfYnh2ZQACi1fj5BYPQQeR/uop0zBDlKb6prnVo0LUhSMforNeQuD228DHq3QVQq1sBgpH6sB8Usf1sNGW1q6vcdrGV3j9PtiNeJ7wJ7xOvT4lfSPoetT3nfpUqvbmO8+0eqX3nyVHOpmh4lsbYH2RzZWfErOq6iGdu5X3Ii+8yYeJZnSTCarMvtv4j2aiN9RMvpq80+/Eqy9dxDHLK1nc5V6DHLEQF6wG0nWYLd3lu55PduDfNqrUaecJj5iP2lUTAdQK2L7xNZxEziPP7RKzw7hv7QA1Xi7mSCm1jSCZbvUXy1FgubefeKFapsA04rj5iYDBeKB33moxci0vSrNvNVH6EQCkpR9YBK3cMSrqGMOKh1nHmFfzF38Rc/Ev394ymca94DR5mO7G8cf8puKn01aeH7v6fMHolDvUTyzQkx7n2A9glYwB4MW+oeWBXW2U0Ij2L+CeWeWBCylpdJw9bOLKIef7KkPqHhCZ3rd0+qonBGuXwXt8GYRpqx54Nh7ad4Ntt5lruGcoTMRSCZEdRykIZoMAEzfh81ldjbFHyPolLBdh7Ll8EsbVEZRw10NnbKuK8s/svnPcMbncqZmr/AipuoWZLVg0zGlFZlCbxbBgGcHLhq1HZJN0IfkZZ+H9ost3UT+qGIs2lO0vsbH7PToYP3wLUb4fPT08fUW0MKW/ycfHPggoM0CD6xyBstAEJURLbwvHwW+24v9VrwOAcB1ETmZ2l4bllnY/Z+qouH70wwiAsegy9atNUmtdkQb5I4LY4pDZB2jrpnutxn+wWpYzwVNb8xzM8ZiuW+EecM5szZEEtN76pjgXLSL5WElA0HyW3648uo6ubuqoteVpZR6s3lTJ5YqpKdHd3Y91h8bjRXY/IuT9oIA9JD5SGhvIx92gmxHn7+r9ZO0NAwuUZVXaxRVlTfFzjqYmK3qZmvSo+nx+rj0x+j3YYa+sayUHtKKqPtKxYQHuJZqVWohxERjnNFRu7VImNTCN5rUX4hbs3MbiOK+sbq4mdSseJVpXtHHnOo4XXtK4tY1vn2jV20sKOcwuwRMicRf4gWwKWuDvxCurduDSe0ZXZELy5JTS5njnuN1TQeJhzGkC8qw8TXaB78viJxcQI7bm/EZGxVIlUw22RFBukyudEpMUhcfL5buXJEPoDlrs/aYKMBdLGAAtLsr/YruRJq0q7xKd95hmc3cq9zZxUscOJlWZm6dkNXmYe8eRmfcsiiJmJQ5Z/5Q+gKEknl6lu4+UF3Flu55fQF3H7m3CTB7JKQNapTD5h25vljvMV5lkHMY5iHMQ5nlTN+sMfKe0R+IdE1otXyxfcXuX7l/Mz7mXcr5jY3FTe5YxQY5FHcYNyrmHnHHct5irdyp3KOYVNxXcF3HgseaD/QZXjdH/dY7DO2OzJMTMcrMcItFu5etxfcXAu5ZVvz0MVLO2r4WKi/cXuPXiR2LRa4DywDnm4PjD8HyYgLSDwhemk+dJHyh57X4PARXG1+XwF5Bj3t5hKkhDygPyM+eOsLoRYjSMHGehR8EeeUY+qyzmK2tsvP8yq3MVKnE5ndzRU4hCX16nqTPX6f29RbLz7RrPvG7vc63GqbxEx/JFm6uU05u4jXiZHDqLpS2OlqVzGkW5i8cwJ+6XZco47hh6xqaRmzbUdW+8KO44aq41iiaPEYM0JauhQPux09GhmZrhrd8yyhptMdgYqo05G46VY0llxbwR1iF4LvqtwkY2HUCZWdHuc51EYsHgK0r2zGmcI0W7EuK8kuzbA/vKQvlvcAdgIfay+O6jNRFZocrm+2ZhYq/wBPzCryMLVlfARmKqa6fAG29fMe0UdHRwfSeOJm8OpeLSCQDucLmFWVDLdwc+0vNx1zkn/rU0+Ibg5iJX/LcuXLh+kFpaXj1j6BA5eMv6AhB5wXctL9y/cv3PdHzjBB5z3xtzFWfvBqJqJ3B4l+5buLi9wcGQUVL9wV7g+4qK8xbmX+8GtyiDOYPuDvcv3L9y15YsYl+2C7l3mW7Za9xO43cGiY9XKDR1b053reKqPdPPmK0Jv+RK/eBWwCN0s08XUXiREt4Xy7XxbiWLIq0/QAoDxFny9DCpf39H0NfMzzDx6e8PXmZqYh/wAr2k7zTO0RWVmpf/uJYO7mLjo3KS1xLSOwxNUxE4Caxwmpp/eaXG7OjmdhzHddbYaCiN2lxu88SssW7qpTVTbqDpnamLGx4cbhOMsUIPNRrD1ioeHpjstmzPES26WjQ7jJkM2T5eTxiEcaHwkYMxjnCnaLtM/SOrm1VOqV8ihuLT+320NGU5zgWa8MRWjZMlHOKeYpmQxZhlzuz94xLdLsHn6hC6hhVKC6fGpdOyOpkLY8XNNYnTE1QYh7w3RAdwum2Li8MMUTBEvEVg8kVCcvof8A2Z/4s/8ADesvp951KJU+WXRFeZb3G/T5mZct8MtrEuDiLwXLz6Z9p8wlza7lt6ivUuLTMy5cuXqvS4eUMbibRBXo0JweBCDByNZfRX7x8kwtbPdR7lRLw2B/assXuNvicTT3M1gjKxOw9OJmUQ9DLc86j65/TX6Pf9Lc3j95Q4rEarzHXdSjaM/qxWttHic+eYuD3nGIAa37TTuK6bx1Mj+JRtqOgBSbbm2olHt3BquDiJulm08Ry8ky2YlcNc4maecy+xjhxmGoqtn25i/BUNEHk4htWouXz+HPhjRR9oUiiEOYraLeAvO3/wBhQASA3gybAggNd1aSlNLrllA25lq/Ebmu4KawoxxyXyjFP8RptNTJuXw1uF8oFDYZu3qVZHchW/2jxcacHlg92y39h9/3l21zHxzK5gA4wzOLnvc+ZjbWpfU6/twoGrx3FfEG+WzxMdupY9RCmuIdYYWe8RSJk/7Dgn09DxHqbZxDmomfRh/ScZxPtMXDcc8zmF/x65lTE5n2mp0yoenvHXz6kZz6dx3Nxg/5OOozmcx930L/AEVMTn18/oPP/C/pxDnNSjbVwN3smzDglN7jqqxKeo6zDSma8RMZqI1F5uqgVv6zgLIhVFDGqu5oK3A8XmPaiA1THziN0Yse4mSJmXnDuVke+Y0tNMoWJV8xxJCgrCeJjZ6Whp3qaLq2ZS7k1nhb2s+8qbYF65J0Tp51Oc8QLWXsY3VXOjiFQBaaK5jySR6Ggoc1i1GrDbLVDK/cV/dKAYKXDAK3fW2u4vLPUdDCcj/FR0QI7Yubz4ojqGl3U4zKwYl6eo5nwiFYww1Hl9YLvnM3XESZ7l8mJYFEzd8EEQsl2H5f+w416VOJr153Ce56Hcf7mc8+u/b02w+a9O5qexc59CO7nVz2v0xzHPHrxU16e053CHk9CM5hCb5ampt959a9H09j9D/yc/oIxibuPcxrfUrGxr7zy2/Ed054jgo7jlwReMDHh4dsyNZjVvMbv4la/iYGOS9N8xMiO43/AHiJd41HbC71FunFR5v4j9J08vcL51KZ1EC5Ss7gDTyll4FHG8OY3k6YWAGVoDaxqTZIOBxvBFKKRY3A6w68T4xM2m2EDMCBGrPEXGbjrFVKwxNJIRZeFvkQ6BcclhSIODjiKj630t879qqy9zqDatViOvepk6D6o9204fJ1CpwSMFPutbj4nY4Z1WpdajThfMzcdNTmrmy9Tz31BevmFPEGFfF5izXEQW5jp5qFUHkREad/9fxnqfv6Ea6lcemd3PEfQ36PxPifWFMxfoVWf0Z0RJ8TxU4nE5m4Tj0fT4nifaeZxUfQ9HxPiY8wp3Lz6Hn9L7/p5/4PHr4/TvqOG4La+scaSNr76n2liPfEb194cNfab3z1H3jxn7RM3iX8zN0srOMR25mYtH2jkxZLbqdmsTpeTqc83qeCJW06iOjubG5WG+oFC9DoWmvjUtpK3Bt1A3LSUHtlvGcRl0fmBbVdgCig+hLUIGPEV25ftMU/zN86j1iLRjU0PdyCrpPuEHOiJtVt/BY/8RcEA5mzgbV2MYr6k1MnDQ1ujiAzae5tYwsPbmMFoDxTohxc5pmsKzHcDnGZ1meJRvU53MwahnTLbuHOIjDkjzWblWFmQvaYUcp/15dXMa9Cb8Rh6ZzP29cT6R8sqHtmN8zMxHj0+kPeMfacT95U5h/cz/ZndzGvQ95uMPTPo7nzMVHXE95UJnn1fU/WemZjX6T/AIKxiYrcTETBVNx2xnzAmcRbq2Z/9n0HmJmy4uLMdRGl+sHjHBHfRzE3zz6BS+OZmwMdxtbjq7gvP0iNv7TRXHEVwMTLNErZPvPmpSCK8DeA5lN5+5MmyEX0CDHG8Xcso4KGa6viHRMgAr8wwAt8SrKzd7l51kmXcTPFyqw1LjOfgDAParlQ472BMtS+5xCHfKo/ZmuUIe0hSPtLZohtgVdma8r4YXoEp2i19YEd44Y96lZucWBM1EOfiP0jljuIzgELG35lu7hdfxE3mWWnUWa4mQtz7S3By/8AX1i79Pb0/aMO30zxzHfpzv8AR4hKxcCczfiPp4nt6ZIHtDivQnM8r6e3pvmMPM1M8cxxPmc/o8QnmE5m/Xw/pPQ9PNw/Qw9Pb159Qx8xKaZiw1MG7PiUX0cRUPPmK0aiHW5QKdDOJtzjmeyfkmDExXmLY1u/pMPKGvMXONS7aZQmsxC32Rw45lXkwzVwLo3UyyUaWokSAN6GUuS117Swa5sQ9F065mVBYBrnNHEZtsWxjl3WnmYjABfcQJFG2YgAjiIqbVV9461cSJh7gsbvcpI3GgIOdX0fSNlvLLDmkd3UGpJFiOhFb5gzyUB6HleJZapHcAtBt8tsvGYZ29oKscVKhvMrxqOsSsCbh8zd1CtVBzd5l8E25qGdmZizuLABljNsS7uWRpKYqfDj2/6nH6Sqjvf0nvPmdZx6YniGQzPlYeg9Qq/THc+k4tYUsI6mO59JXmV9PXzDrfoe/pjOY73Xt6fM+cemJ4hqfKw9B4N+uO/TysKnz6Y7n0mO5j0+Zjv9dfqJ9X1PSqoyxs/iVwsThiY4lcaiUXfzE43zGCncSy/vEK/YiN1E8MT4r7ytjZEu9Y3mK5+YL5q5Wave4+1wKLnRkMRo5zMshK0wxTbHmOrduWMhRoJvak6HXmIldQEcvsQQ4wS3NwgAuWwM0H1YNGY5gBXVxOYlbuaWXVmKEpNqOq2tabmjc3h/KNjmiAUcLfGoaRckawX94mN/MfEFL5NzEqy/MMFVM3U73mG5RvSTbX1iVOs1DdP0h9ZQy0fvOS5gBx8x5JdhzKim8M+UE0Pt3EWrPZ/mf3v5n97+Z/e/mf3v5n97+Z/e/mf3v5n97+Z/e/mf1v5n9b+Z/W/mf1v5n9b+Z/W/mf1v5n9b+Z/W/mf1v5n9b+Z/e/mf3v5n97+Z/e/mf3v5n97+Z/e/mf3v5n97+YAWr2MfQ/pZWxLl37HMTxb5H+Z/W/mf1v5n9b+Z/W/mf1v5n9b+Yf3P8z+1/M/rfzP7n8z+9/M7f6fef2v5n9z+Z/c/mf3P5n9T+Z/Q/mf0v5n9T+Z/U/mZP6fvP6n8z+p/M/qfzP6n8z+p/M/qfzP7n8xgoIWhgfDBuoHvcYRa7uZULTs+xzHX9Ffmf3H5h/W/zP6D8z+5/M/rfzP6j8z+t/M/ofzMP9n3n9Z+Z/Wfmf1n5n9r+Z/Yfmf2n5n95+Z/a/mf3n5n95+Z/efmf2n5n95+Z/Wfmf3n5n9Z+Z/Wfmf1n5n9Z+Z/WfmL5Li4fWBKvNljwwyevz66/T8fpb03+JYqsnWIn7x3XAxxnN+YuU3c6ZCC6jq5hdMrV7g0v2jsLqJnM0S7qOtmCctjk4nFf0l2F8y+SOHUVefaU1Q7ySjjmOCqpJzvmUZbz1DLGllZXg/vUWu6xFOnaUMzmgcoX7H3mQQLSfIazxKdKKQW0OCN2xUOSp43ETHETVGOpbglcXfiA43Ng2lHity+QaHfF2NH1lG9q5BXTfxMVPe2WrL92D6kjYCYS+8S86xxMs1XiKqaImk0wt2Z4htauN+3mbcuJq9M4vEyz+08QaOGLxAtYtBohnJifdEr7xoUlhxe/ERp4A0Oj/7wSIGxOJf1X1Tnr1cSk1lrt4I9Un0PB/8AeJcixOIBUAODvv5hMy8Q7xMU5NEZrTl/6BitLWeXZMiHZhjD/lohBWkdnTKZLXUcFD9JmOLrU1ojpkbiLgHuCtiYmnaS8LuvEM2ZiDBnzC00XKA4zDLg+szV3ZOF5jqrqo9qja2Fxaau8RsytEtTWt6na5tVEQTkBlxGrrcEYVpMZjyhywjaeHuMcLBxl58nGolErtaxPNc5nA1E/wDJu6joL+sV8zWcviFXcClQ3cORgwwq3ueCLsQNgoN01smbXtjTZZX1hcaOkpR2ezINy85pjTio4HhmtODhjY+Sbs/aOB5O4aO5RWHcXknv74nEMeICtVbMMPlg5qW0qRc7j5yVArqKEcOf0fx/0Leov7J6sVCc5/B/7/0Lddt8ifn0MY04Cz9v+iQJtR+kdenf/IQMvB2gTYlOZ8qlVms8S+GUVvMImNQdqcYiOctcsa795dLiIFJodDdEGFC7i008F6jyyqcjW2NKNc8QCEGwV4rUrAwYWpvKlGqiFGlg8VjcfGuptu/mPrpkK7VjS74mrxxfHR1EhImrCw1+ZY1Gtvk91KtHiIZvcqygxM/oTpeY1wXHtMTFv2qDiBxgQvyLgxQFJrsPHcb2OOpRnnqGWEzRY4viYty7fC8XcccXDduqhtzjuDu28xtL5Ji6uNe8cWhF7uU1nM4x8y8dwLaI1iHk9Q4MHGXzCqLywvBxFbqwjIrD+sP/AEP9V49Wfdf2P+h/oeSHxEj7z+s8f9F/XdT6/q4/RV/oz4mx2QpG1MWi8UVGk8xwXr3lHXMVbfeUsVFsbxiIGRuJddxC451ZOLvcLyBvrEdOa0T7j7RswT95dS6TglC12XHLVvt3EAHN1TZHs1XmaCu/pMBZm933OOUFs0NC1eCOUUNRl9vG4xpy7Cn27g09OmjoScXVwrnBE5Uss4hSXdzBpXiUNlzeHUFXWo61LkolrtTKyA04jz/LL71eoFFi3G5WWV2Frg4uKgV0qeP0Ua9o0bxOY868yjD4iRLiBxm8kqX4y+ZkeGDRUAhy8TA769Qc7zPMKxDGu+4VV3LBrc1uK/Z/s/pfg+wp8hGpjt4fD/8AX9+/j1Z9w/Y9XC9VjOrQXOhmm0KVNvo/qJqFo18AljY3QKROE/8Ap/peSGsw94z7n+HpQtSFtFs8NqB91fqr9Be6/HvKD4j+q0HZ4TD/APVteP7eh+j5nPp8/o4jLSPN8SlFLYbiOzNzDKlzDkwdRsNXepTUVFduYYKMQRLWql7WzJ7S0ClzLQdg6vmKObbq4WoSrhnAWuCE1ZQRMl2dXAgvaBE3QYheXGCuZlhqtTRqnGmVA78ypwUtvogIO5G+nR1HVs7n/wBIE9omHsvUsegDlSiWb3MhurxGzdU8VOKdzTkHEadsBVceIauvaOigRYDVFHzALIyXUVFaVuqgZCNEWhKthr8kNA6AYDdBzArBWEIFHyWm4UgPaGC/EqnmIrhzKKvSzbuU6rOIZ2DsYXT+8qGer/ibcagnvApb7DqNuXPcMQHfEN9eIeOSdIYd6g6q4r/r0/oM1C6kaD5Ie1zh9qfFAUuu2Y44i4GzsqqR8S9kAdI0/oZ3iVt3MgKRy8RPKmi2oWKNJwxJBrmAitDO4rHouKFtKNiA+F1FxTbV+hVNZq79FPOS6mwUF4LqB0kn0RehwtLeNRtpkSQmRBgF36bjY8uEqlM6X0mwOno1dkbYaUI8mKFO6HiJ5E0W1C1AteWHl+HVUsRHI8yiEfGcC1niHfoDLuQn0uWzdXfiGWRTVdCqJ81fr92/j1Z96/b101DAkbuMmeT5/QdQiyQcKrNy9gC0Kz+5XqsuAer2OOV0GWUkE0J71PgFiiKU5DCI6YPlJ73poU+T03XAPvaRpJfVN6MvLE1WBvJ3Ms0wfwLoL01foNIAWVMAuEeIfwqWHeAPL6b00nuAPdSVr4AxTBYssx5PQ6ilsTuFA8qEMYQ6w2qEDlqvRa0lWm/Cu+Dr03ZGsANDSY8np/a8kFz+5m3E+4/h6FIJAWsrRG2suVqdZWLrEeaXYuzj7Z8noLqF9DWvGMe6ToVhM6yAnvMpZMQA+5h9T+kNBtwrunULzN4K9wfSBSCJhHiPncAtToDuW5fHJ7cPhBjYfpznFjwmR5IwYuQVVhQLUM4la+Oe5LFTZq712RRyaWqClAZQ3zE2IiLaksUc9PpcOAeIAiKpOQ16a/X2SNUTpIBaWKDXlVXJ3CDMBb2NsPvMfNMWqsyYRERMIzPSNs4FKPMGvQUcqh3TRHyEEoGj8hrA5FMPr9m/b9J+mvTn1+T5gaaZQKyspfzi9ncaadzZZ9uI3VVgzApgmRzXiU9+5ZlggsFXnlqNJCni4lCVjo7gvr5OpYOU5qDO2m9MGWb7kwgeOe4WDi9kqsiwlsgko4qEgFyrHEC9IgDFZ5PiZvybhajQUhDhEdFo/dhTm87jjN0MNjiYFWQF8rvM7bzx5lXAugVcYl6iylHQBtjZ2aZtF3BboTJqUopMDREsN+ITJ9Fh0p9CAaI4PasFxjIlqJoR8p948n0lWGQ95XWjEdSyoFofEbCpmUNym94mvzE5HxCs8PE6i3btmdys8VM+Y1zMXBeYcrbKDjcbn/un1dzwGMmucdGvpejYTgvhy2zW44vmrzZXA5OI0IiwGfS9L+I7Zhse9wK8sd7ScCcI8iZH9FxwEXWQGdIxFLEdUBfuI/Mzsy84yP3gEiEU2FoKKA1dsGDhBXpky0dTJpr0BLAIIUbGilJdWnEAAsKubyTZTQpYSzPhYKI0glinswo9HILYFWDZWQmHYl9UoMDSl+WDoxVy2UOTwxSVAKjdy1fmvQ8QxrMoPuoruYoaU1hAC1aCWG1byZhksNTmnBEsD7FzdinF1aPGQpBEwjx6fffXSfd/29a5/wBhV3cAOeVY1b8f4PW98T5Uhqe5khDn9BK0rlyO/UJGTlUCF7eDkfUZtJDfZuPiFHVRQ7rwLPBgPBD3cBgia9DFVUNLzHijbQLZd2bZVRtfdjrsOXS7GVFOTu5ZbuxogsNVczhCVH/FCOVF+0oV9Ace4O4TUu0XDB+QGK3xAS/Pz9lSuoddhb5LGSlDs0s08Ph+inGWGSArhDOrCnMzReT9d5oNNlPGmNXq2hZHIzg6ibhdW1lSkwUnMdlhVQBawoiluRyqu30/u+SGvQZn3f8AD0pbAV1atG4U4cY+zWZ4low0Z90ar4Yzk8ZpXglHdKfZLvaQL2yZdt94Ki0g2hePBCGFojUavaR3w+tJCpyAhE0wBHSmuWNCyyzJuYpqKCgwYyXfNvMB62RdNXuAr5p4ixbL/bIgoKMmeblGygbIK/XDRi9NJ3BO0Pu7aUc9kUo+1E6q5HnP9d3msiYbNE/D5CKqMFWkC9jf/dQyFkBFG2lKNnBL2EqESlaGDB0T++6RkTmeCAzxZ9Wx9z/aKPKTqQq+Db4JjJz4aGiFXkATPEtpnlBq6Qqotd0eufsv2nFenvK/Ufqwr/bjjKXfmVWdsPMt7C8Z2S8eTqI8iLqZOCxw3lKlqaKmFtEB13H2E+8LKQNfSXtaZ45iHKsdMoL6KY3srgnJd/xEo6vgDmN1hb2Q2uBzdzJm9bGoDfHgllnZSVAI5E8qgFVRCxznqEgKkpDcdZXCsirvh5m8plMKOYu/aOr5Stjxcc3mq2h2UlKyWBhOg7hOAF71cvB5ZczQwGK911qCym1dDTZW85iAENiUx+zahq+S2IIgK01XFpKHwIxzcVt3ADTq+Zw3dR4qp9RXEc4HEorMcY2VE0umCstOprCUy1rFvUvr+M7Xcvc1hufSGMu5vNTBDqrZlzqXKzO6P/h9QPDRAutFusBa9Dv3Zgbjb7IEIAoIKKChy/PpfyIJQmCKtKmw+f0XJ19yBADoIiPBhEFvgA+ICrLY24H7Rr32jQsCisF5s4zShiedtMhbKzNrr0H0PqQ2gvkpzZVLuwwFgYU31QuaCLR2P0aE8XCpbKDB5YJIgFZu4avxfoep/wDW1WvfrJegPENkicmQeFAcYcRmqSx8wwNV/LBtQTVpyhSjUmY1GdW3Wcz+07em33+uk+//ALeoB5CgC4voZuvmf3b+Z/Yv5n9y/mCVQYD5L09oQcvCzzfJ+6/UvgAsG8DdqprjGzFrnS3Jc08y1UloGdQFCa2jBe+3zfoI/vu0ohyB2NkYqVOqXY2jGFDUbS6qtQoKBXyAXTA0DI0LL94Q5sKdmUU+0Z+Fi9KKkTACmxv0UttMCobEpaHIe5VHNh7FKTds69pQS84LFnhq5iG5mnBXlXBzQWlRASFEmDswAG7fd9AG4tgNT1mXBVcy0XCq0cJLHxDUo2Jw+n9Pyehyxn3L/HobtmC6tYHI+lPBKvjEwqdMOVY4+wdMZLzalT3e45N2Ft0yjsGV4S4JZSA308p/feIWal9x7pH4fUg4zWpKAcsC4w4RyhDBbRlrBBYDsFIeiwC+bOIyVyFCqW7VXto2kQsm76wYpEz45pGEwlhUoTXtnTiuvTTUGSvSfM6HgjGYqrANcLavKn9d3hNXU8tTOwR7GAzVQkAAqERlWNzOrHVrj5PyRyFkDBCmhbNvJLy1uEctKGTJ2T++6TnNLQsXwWPI6JdPmdoXfNF+bhIqA7na6JQEK5OwNLu9VecgxUAq4S4A0DaNC159c/bTiJ6cT4nMz66lV+ipVOrzubcLzDAhAFsHTniNHV4iNNh8SmEwal6aZTn3lhbQceYMW698x0N2XVR2YTVGyN4CrgdRChKeKvMYiZo4lFBsd/SBZKV1uIEG7W28V7zC4wdcxaFlXljtBMXKqrWM44hFtLW76oirzbzcrIvXWIjXZcUIuJWhRGo9YViNFyWz7xPaHjSA5WDwCbbNnErVtt48JHVy66wIZKNQCg0Wa+9Fn1lia25ywqI65YqLlbYUFzdar6kTgucL8j4uNeAJpY599xKQojxL8/zAlRA08rX2jfM1jZxE+ZQnJMgNxXeAOIMBVwBK0HiJjBdcSvFQgulsKCrWP9iWmoC13pKPZl8R1XMp95zkuFela+9T3JXmFrf7Th3P7Xv+g+Jh1u/mgiaS+AVc4AwH1/UzvErbuII2hk5ieVNFtaoALXgiwHYmqr8jm59MvgUsVuhds6XFgDYiPYZbzV+fQuZW2k9C7N6TCgYo6qwy1cpfonhojKgtEwsJv02B09G6pjZBx4TFZBs3l55ieRNFtapEaTkjO8ytq4gBQGDiUf2opTjFQbUPpaP/AAZGGg6yU4JWZHqBqmYpyi+ZZIZKq1y+m/3foffvUzbhDaMAUef/AD0wQtrfig4YMmuQtJ+0Te05VWGvAq14L59cbvbNXI8I8jYypj5Ae0foR87qFqdq9xpJ4A2hVOMIbjBmCt6CiH29MKI8OVdKD5KcEBFQX+aUQRwtp6N8a4y63kK7jzVhdUaRTYcRwE0iLW2gADwFTh9KtAwLgFt/dgDfCC+0iPslSwzFkMAaAaDiXRcpsQ4HEfASFla58gmgBqxYYi8yFXYBgAYDRFrSxab8qq4O/TdgawAWNrjy+n9jyTtHcZ/L/HoINoA7WZQsj5CjV9uoCiY7g1B/dr6BQGt01w+Ew+GW9Ffn7AX6rVh4Lg66F6sY9W02NBs7VVbruY11r6dA+GM2RaravcERSnIZETTKceCM8sV5sxD62/0MvBoNEYMXIaqgiNIOcRtpgyQGABgA1EXKQMaLARwjJzEmIiLa1oAPgjfCuBjdZFmW8vXRBEgWpRkR7ijAHoAowhyt9zUq+iQu2dBALSVQa8K75OoQZgKewop9piGC4WrWjG2KkspLdqBLJlY2dxClGke4BgQ1ArYX5uF9yrNA0DQXgKD1+xQ1Mfpf+B9o9F95iQ8pA9Ve5WUuuL4lkqkDl3K7V0x4N5u+ZtypSOBzexG6KKNTM5doRI1mkJVgt4MT2kNvEs7eN9ENErJplkIFNvcF4Wf4lNTCYZKOaruVYQN6mHZjupWTovgcVGC9MUwyL7lNMQ7RUMgoLLLkGX0FFLu+aYlW/TErW3qCOsB6zOYm1DvbwQRDABgMGeWNBX00DZEv2l20oI0zXB98ah6HSW1Ewtol9QBXH1AAK4aPpEyppFZXxMZCODLhMYns7MGiHFU0Wrzh8zs7jf8Akpw0TRy7jlDONSnJV47nS764jvz4ivXECuLgE5DmAQmEJlxaft1Kxmt4mzzAXzC/aZGGe5weYUOOfVMc3F9X8/8AQ/uvV/6Ktv8AWyU9/V+4/j0FGxpiIirtX9Bhsi1q2lr/APV9jOPWpz+o/RjuUOS9dz4BxHKLiZbv6RD8S/ZyQaKS75ILcFcmZw5RsxCVtQduHDcCofJqHBa2L76iXrL1mprfCrSBO3acwctngIGp2NmcQbnULQoxx3MWsK75JgFwp3XMsMLbsxWIIRbsxzBgr8WczJXZiNIhu+pdIae7qpqQmDIrxyxo1eXZCnJsiG9ZeNmG6bq4jKJIa+0ypyWHWCr95d8XRdKalWnmWW0jgRZaXh6gXJUGiV8nG43NN5lmH7QYdAWOAezHMLaXze+WovFkQtWREipnYBINdwVl0zY1UNVtvETNr4lraJDYHfMBV1V3Hip55Y+Ce3p1B2gGl5rc1+0x+IwzuV5hBAqHjXtC96hjReYbp1Pvfz/0P7f6H3v/AEO2CO4xff8A+iz9uGp7R3+jibhqH6XzBj8zGkoeo8hk2Mrmt6xG0ZMy6ggLP5jeGlVUorN4gaDbyDogEhlidgy1xNhfZM1er13cTOFniWbFvruNi2ZdNZjbRXLlhmjNY95VZDBpuW1Q2dwNpkDhEXBfZlrcDWP2iyCBcU0MMq2xpz7QoGmD9plXL2hNZQGVWYF4TzFguQa1CL3caB3UvJrVhTF5OviDSUNzDhMx7paG6me2VSdCmwKNidPxF1Bb768BbK7ZaEKnbLcEFddVG7HAj7G4jHa03kJmqr6TmNMiDjf7kFbVGMrqz7TIKbviohrrc0MX1mCs/RAFlv2hhbawCq0Oa5lwHBwR1ll5yXmUvdDibU8YlOJu7xE5JSGoY7mo8ExcN+ZtWicJRz/0KPQHq6lwOH/oWXwCvUx/F/0IKgbYwXqcanHofqPTic+mJZWVt14lU3WI3ZmyrW5kFm/aN5ar4hETmvYa1NlJWdxsEHyVGlCyjniIREu9+8tyuyEActZMai0ba7O5fYs6gsEPa4GBZ5eGWG8OmoB7l35gea3qWN1g8MfSK8jGyCrRw4lpXQLGVHbBwUU3wSz0ciBVy0gTZxGOVWmjmJX2GlgOcpBaKKOmuSC1GscWcnbj6TFtumqM4PErQo2Vq+j6RWsGlpjAuKpVpaFeIxslJr6dzIYK58xqm2ryFXqAVk1pBrXcHcDxWkbePbOY06FodHCcj7xlbpSUq93e5gZWGj2U/iEKIGyXD4eSJtqpNtV02CNZ1OLbx1F5mhX2gANV4PzHkblHOCOXojhXjc6CNJfhZkd4h5jvNQ3iDRW5d1A5g4pu4Ye7mDfbCjwn3iBXRP8A71qRh1bXfq6gOs3G2FO//vJCe8Mgyu4ejAf4ohFJ3/8AeCtAsEhQ0dwxv08ej6Hrz+rBkaqULi/dLxZgcVqKXs34mzf/ALBADBs8QEGg2L08wW004JSaWatg0Ii9YIrRuhw1g+YFUsZrUTjmzfI8ytpaG7cMyPRolEVszfbMOUy8XvMRQpVbs1LDRycYgXfA83CFFizHvKwRKaIOhaMdOyWG7v6Q1m6nNqvv4lyWLBNLwHcZgfwKwb4uoi/UKUGAe2+DcukFnZ37RbEBeeJTwCUqy0W+ZTCglhLDKeGAcF0zI4ylN+8UOFYTqMFFutB7qU+ITtPIpw+IEz04HnDGy+Cit9POoTCzS9vGXcu4orAO9UxIf1cOBk01emPc2ARtujNARyJ3N6T6y74S+2ZWr8vMQMbzDGsyjF6iTC/E3xZEXSYYiUeI+JwYuBnVy4CTepy4quZlvUHtGpW0lP55EuWj6xP5g4uQJ/dngzwZ4M8OeHPDnhzw54c8OeHPDnhzx5488OePPHnjzx5488eePPHnjzx54s8WAYD9BEguEv3l2azwZ4M8WeLPB9D4Mt4ehenPDmeeOsGjxfVM6s8eY9J40648aeNM+k8WPWJ4UOvNQECiOpiHUTGYQoCS1us8b6zLpPA9A9Angek8SHUmbX0HgTxJ4k7hPEnVHiTxPrM+k8aeN9Z4U8SeN9Z4EwafWeF9Z4UewPn0Aj6b9H059CPoQ9M9SrfuhzEGoJXvqIrReYpSDo2TBlJezGRnaV2JM+TRvUVotBrLANI23BNhhuuYnC8ucQMDV0XXUuhuhfBmIBYvhi0ZHaUAxE/mGheKcanAinMwWrjipk5SnkNsoAhY4A+0o21reMEQhBVi/p1HFgMLabH2mJbUVqdF+ZQlw7ZkpTfxAXIedUdQQFIlZIgHaQQFRpx/S4OdbotB6wxCR0YQ6+rEBWnFMEccVM74mEpzsFsuowCk0zEcc1w+YF0K6Fgb3FMStR7qzGzvxiusiXg0BNIOahLCNJLPZjn5jK1SzQ5dfMRdmvSHt5gvWADyF+2oWZc4gUJ34mAsSJedkzurJ3xWp+8pjtv3i6rMNzKcxMziBZl56h/k0VcCpbk+alaPOZWy5VO1/wBJXtKlSpUqVAlSpUrEo7lQJUrGJUAlSitSpWCV7SiVKiHiVKgfqouVKlSpRKlYlHcqBKlFSoBKlEolYlHiUSpXtKJUqVKJUqVKCFX6V+jj9B+jHpdcTlx7XKF7VyxMsMOZzSb3mWW85DiNOru84mMDgeLzBNF0zx4hYQr5mF7N989xL2Somlj3mNqrFblIPNGk+8Ok20+JkwGuCFtA52dxMKgVa6hWQ6zljgWg4pNxFEEOo8LyxjiWIoCYzFoWg3STK5hqr5iigUtAt5n0OzU37yyt3Fsb0y8AGlN33X/sEyVsycPG2DvAVGzvXzAAty1gqzBfMACtObM++bc9kEuHCcPP5hlRy9SyBFAiHhDt4LZARVa8HkZc0PdwMs6NhuEoqwKuX6c2m/5S8XOgpkd3ErylQl1njcHPNF4U4uWBGuEV1g4c7jRaiOWhwjyNSwXmdl8wLxqBVumO8fScUOCJ4GPxM0L7JWJ31PE4t+s+k+5KvP1hrXxCHe53wS1niC26gpe//V7zPrc7h6dcSsxq8Q1j05iQP08ehqE536ff9PMr/hrMdw/Rx/xcep+hnP8AwVHeJx+ijmCrn7ELl/5FWWPiUja75WUiOOMw1R9mY5L0GNS4rDjrrpjZji8Go1yw5zL03MXChYeGocVV1vqDbWjtJk0VW8FyvAorZxAjFXXBuUWOQ0bligBW2WAth4gy0O4lrreDWYgsZH6EoOSgT7x4FLzwxx+xcAzlxGpAobwF38S3QU7Dqq+oMQsHJqnHWY5GiNDWPExMhddDqBvL3zgUsMtMeIZz3ARTm987jV4XAt4Mcw813oDbKKDlh1ZuD8APrAPGq1UrbAVXBdEUQRLSGK8wvNaD6Q3hW39kLTCmyoFhRqjUuyGIAr1jJ4i04RdkX6TOvsvQTnZLrJ3epQ8pY02sXzuXnTXPo5lZxWZXXMSBvJBTjnMxuM4qeIPX1lnmiD4qHNSh8xgBibHJUS0s1B4BH6cf82PTHpj9OJj1x/xHvCuSNSsXv0zub9PieLmMZ9L5h59cTExCpj0xf6cd+nMx6fMxH0K9CYvPp8zE9vQ3MehVTExCYmJj9OPXE4neZiNTzMem/T4/TmbJ5jSE3qVZe4Ct1XUREyd5hjRd/EeBwU1UQZC2Kviy/MeBbUlqE3UqxyY87iWWwHjcyCoPLxAmrt8TLQcuSLdjZaquKhgoVmy5RWCc1AWty81M2st4SK5Vhm2NCFm75bigY5Lb56igb5MFcxeBXCwzQnl38kbfVcypxAEqthyVWHOTcAgsf+QCYVCButLxDfbN6QF4K6eZtWapLXF4ug+IcAG7FqtkpKFADbF5y5FHa3+JUsaQaBydZv4izzRM+A/vCSXAGbatX7RFTJRLRY5s8SkKXYdRVPgqtAREsoXkhdFj5dyqSwvzAEibYbg/GJleUHI0yH8/ETDHxldPGoqZjb2LZ7Zl+a7lY3iftK6sjjPELaBvQSsx2QX99T/GPzP8Y/M/zj8wvH7R+Z/nH5nlvg/M/wAo/M/yD8wLX0D8wD8Z+Yp/GfmBFfZPzHqKrqvynj+n8p/dP5nj+n8p4/p/KeP6Pyi9LdVH1NShCuTz+hgZiW0xFq98Ifdn+b+U8f0/lP8AF/KeH6fyn+L+U/xfyng/s8z/ABfyn+L+U/xfyn+L+U/zfyn+T+U/zfyn+b+U/wAn8p/m/lP838p/m/lP838p/k/lP8n8p/k/lP8AJ/Kf4P5T/B/Kf4P5T/B/Kf4/5T+ifzENXbyhP3j8fFx7nEK5hPEdQsAteIqUWGxXzqf5R+Z/k/lP8k/MA/GfmYP4fyn+F+U/wvyn+F+U/wAE/M/w/wAp/h/lP8L8p/h/lP8AC/Kf4X5T/P8Ayn+cfmf535T/ACvyn+V+U/yj8z/K/Kf5R+Z/lflP878p/nflP8o/M/xj8z/GPzP8b8p/jflP8Y/M/wAY/M/xj8z/ABz8w/8AGPzP8Y/M/wAY/M/zj8z/ADj8z/GPzP8AOPzP878p/nH5n+cfmf5x+Z/nH5n+cfmf4x+Z/nH5n+Mfmf4x+Z/jH5n+Mfmf4x+Z/iH5n+Mfmf4x+Z/iH5n+MfmJafKR+ZRsG62e5BvHpj0rEwReQrpgtmsaqA2QoVyNZlK5bZhMiRAMuyUbb5JwMoplyCs0eY7KeXLAZL8Zl5AZ1g5miuFccwOeXNjGYFbiAkBtQ+LlZFiMKUCFFXfMBhjeFXiGw7vCeJYAAcf1gyEOKG/vLKC05q47QIt+WIKKTAiAFufERkLaxYBguZHy2XtX1uXhDmyzTlzfUwhiJ4XyxUXrBelmDF8n7Ryl4Hk68NShc4OMOXPN3iIApLoRBRNA4V6xC0tQVfkfLEABNNfj3h2dOs1UFsC6NtwQUDVZ1jUNFo50pGoDDYp+/mUoA25gAhTo6gmWM49o6d51XiLVFXuxKEYyVpEHbh+ksYgiBk4Li2cTQ1uOMR8wMXL8yrwcxabcxTehtG64P/lzJY2t5dezD1o00bXolgOF1n5/6EwmNJodMtibI9j0OrmlwA1DaOnR/wB+GrJs4TpmhVsOuydfoK5ib8RMVpnAgVFgKI6cGOZssLvi+YloN3udaFmAQb4g+JKPJ3BRbbbjLcvzzhJVYxebiQBQMcrhrMMUA+IAbUGiIoqE6OKh2Hn/AGIG9G2BhsG6txXcvQsl8xyF0A06fa5WyLPN4lHIrfAXf2lvr3dtCnW5hRE0QG/4iUV0RmVZ/Fw6PAC4sscUhuFWbZLUOHix/eDSErY0NmRnMLjkWbR0JaCqu5QAiq4XVinIxlx1BvvILyXSruLaigwkQWua1jFsyVs3e9SrBzsDmtwKLX0ZCYrZypuYDi6v3gCFZNa/eX4CaufWXWT3j3FWGFIckZSiHoRzfitwmKPEGXHnOIUGYcq1HL8+IbRqtRANcVlrio5G5xGycVPatTF8xqr4fb/5WpNn7k1/L1VIf9HNXeKfeDOZhGtvh9v/AMA1Loj7Q16+IfM7K1BxYHtC+Tde0RqtOMy6Wtx4Rz+0BwujMTH9iAcu7ixzY4z11LwFcRENhqv3I5C0rq8RWRXZ0RC44CQ3RwmtRpTROC9wFt0NnGZ0GvJbBaBY0mv7cAhnZW2IKgYbdxVmWGKNRabct9MqtwVpQjtt3onhNoBzm9BUozBm01dUCnugSheYoU1WQMJkrWgMjDmuy4JFzukAALgCsQQupylsoXnAeIj2DNlqsTso9oZqOoDQ4tMNZ+ZWWbRVs/lhVbfsi+5n0AaV1UJhRhVl9pgAWPfN8zFcAOWLlBLbu1MkW24/GAcuuiAQbNmj9IAFadxlFF6Mr7QjJvgJUX9YziqArkFD9eYKGzFjs6xiJLGr+BcV8xTEp1OJkN/SaXx/83f2Xc+/ev3H9DNkUBavUsh3qqy6qeAxC2X+MWoujv8A+z7j90GJzO//AOB7h8v4mn6PpC8girECnjmUrD5iprUo4xW7g3wvUR2pXW9McFtXd68QYGrdkAqEO+IVVFMF3ZKGSs9wRREvGefE9yK8GDEKL3nHcsAiLUvlm1tg6axDIDQmGmN90DbM6MFlOWNlYXkNEwKULEMsXEKkvS4C+ITRN+KtnruFxFAyyYrsjT/Tb8vYH5UjdBO0u1X0pmAPschr2dkN8EFMwKnfZ3ZEX9tUEK2V0HUdGLtWEb7IaCdumPOfPUsSBQKzN46jZlgC1TYjg61KOJckwPt3EVwQpp54lJCx4VWAiN9Wc18S+RQ3UStoAPiWGohZgYMy1RTbVtfaA0kSlYH1JhAAViGoJoCIi7yL9oBQL4Df8xoiAbYK6zcdfDoDRjtzE4n4mjnUHjueH6MWR9XC/wB7lvx1quRMRyRHs6aX5Cn6Ss07bE7bIec6f+f7H+8+4ZxOJ9+/Re08IibLBmhy7mHmUFmqu4xw0VMxu+Lm76t0pXtxUAE8W7VIaTH/ANf3f7oQ/VwFaC1leNe6fw+HP/d/v/4mkJ36V5g05bxuKgofSU42+ZYozkzU0UzGpWx1HFlV5wzsML7yhNLlWql7LbzhrEDDAc4lRbA1Yu/aBkQDm+YralLwamaotc1zEQ0K+0DVFpZa69oAtXBrik7lbHFgvX4hCwGFrjcpIKDN+81dPBpy4mZKjS8a7RvYdliHEbWYdrxfMqN7oI1ggXDbMS0KkvBaufBLDNCCgldWW3F4Izd2Aozs43C5rDXSuz2yx8Hp59yEU4yturj7ds4V4PGJgqycb/8AEa5g50q9vmXdwBkvB1cYoLRaMe9wAkoOXLt94HtGun3ZcL3ZN/EFC/CGm9RAKCoKIN2d8/xKmqrI6b4itSMg0jAOxA9iWX7QEkNChaxqBVAyDy+InaohtMx2mZ1r5jqh9pVZQGQvv9ALfgQ42k5J0P2rnOWHvKD4iVAu/ozcCmpSw10HY/eEysaLSOh2fP6FhgEozq3AtNGVpoxG38Oti1IFD3V7egz2SNrWysZUbD9S5HIeUDz6HW0KDR7nB7w60BUCax4LSElZjVZp9h6fb/3j959OJ909cts5BOm0OJfxGwDQLl+f0E6KzEUurcwiFlQaPHqsMAlGdW4FpoytNGI2/h1sWpAoe6vb0JGrK0l0rbSYs5GopTl+htQKcqCHNehPECAnuFErzApBEwjxNojQYhW7lhfsnp/TP4gn8L1t2VlV4QumrphpoPVCYW8FpBuqmKFmfaNCEeAMFci/vw4RAsFq3if0z+ItzUK5UYruVXBFo0uXjAz+mfxDNEI0Ayc3i9fuH94emuf0AzIkK2zKHtMhAxncG1c1RUQB/gAsCeLlPdQPRNR3XObcY/S9ivX2dCufBb4iFK3QW0gQcoNGWj0xhG5sMnK1gGrLq4YULrI7QAdtUcvoBMzkJraqareoaaD1QmFvBaQbqpihZn2jdYMKroPFCf0z+Ji751VbTzgilQIbIYeKEKsSgrQrx0ehM2zezCLo90gn/wCdkZhYgkVlgafchgyICLVlYn9M/iU9XKuxr1QfcoDRAeayfIX6CrV8Uiz7DDrjR6/Wj7xR51Qp0nCPCWPEHZN3DUW8EeIw4LH6xLUVIGxVKw8iynqpd2tT+mfxE0IBnZyMNC001E3JAT+mfxHgEUlROQ1ggAaIlGgA2wa7cBeMDaKWbV+HSJgPCWMBBqkAW0UZDK9G5dIktMOgAvgbeIyuL8ZpQ5EeGJq1yuRYrsYJQCGiGTm1DA0EhYGF3lmzyDzqT6kvXKTbonDWD0OIvBZ3UfYAx1oVIMVaeGrLNl5PXd7/AOJSoenz6VQq85SbL64qDDKiUV/Mrcqrw/Mq9KPHEWRx4MXBCIB5xmUjXhzL2wpwPkgUNvuXDFwYp5OZY2BVVriNHCgUB1ElpwRVsDkPzEPWButvzEKU0VrOdw2722NJEpttH79fWI9iAFJbKV3N05eJhbDajNc+8IU69moysahgpOswrTBG8gSHF19Hc2AezAoeC/IIvusch9jZeMqwCQCfeqq5MIf3jEBuUrWB8zLeph3ev2guAmrVz6PpMwzAN21i/bcAKByFeFfeJbHuCo6fEqh8g793o8EehdJ8BQmoICiw94UwmWfMwYCYv3lqrutsVOhmvAQBhul0t8RCh4L3Ml8VwwEoFhCm+riOy1d0LxU5bvqLiisd8x4r9oucFEPXqxK2C+Ej+8tTDz4T4B8wx0I5tKG/JgoNdq5eGM7z7Ei1thBpdRzezeHL7fox3dFTUDIuE4E5jy6zVSYvasyP1sUc9CUAtbaDB7EcOWLSXhZxgi5oamrYLVYBNO2idqOd/wAYBPIIVr1/IieQlV7VLxKuCj4HT6svtP7zl7+nE+++qUsjVZect+Yi3xEmcB+hTqJohR7CtzexGigvgOvUTjqMFwTJwnAnLHl1mqkxe1ZkfrYo56EoBa20GD2IxXCxiZG6tJ0DWIVk29EALBYF9KQ6xY9M+gAfEBJ7HMDpUg8MpyM2jIdWisUVbTA0BDI9cWGHF1x6LLXem3TTuk+05F1dLC1SsLdnv0Ef1fT0kKUm6ZHsSFhRIrG2S2JF7KwfCz7vEayDK0tgmR4gzoREAVFKq2Hn1+9f3hM9fpN5vkH9p3lAdPcu3tUMDJsachxlqmtS2D2WfeCBQERpHj9BFPI1byGc2ycE1ZK3eQ5Pe4eFHaNikZ2hVtAH0MEpwRRs204WjS11EfJ4Og1gWy7MuIb6Bq20efnCWGqImV0PON5qHYTxhM9GTwU5T+r6Rwotoxe6GCGUrj2qOdsryFaJRWVgsp0LdgoHkeJiOaWu8EvsHo4yLdWbnFq8FOId4MFBgT9zfSJx6DjRAgKmqrqoEvMEGHAxKUVcq8+jtQg5MPuyxGQqqacr3lvuWjnaQ37yXz6RbEj8daapxURcmuUCy17laMW5/XdY3xEUqzFOMyzUfLS4XN2HalbZ/adI8vsqQqYd0/UQyldaV2VwfYAxqf2HcQaol0ZknGSMliVrgLQ033OrVqTA8FtLxd8QI16UrFYFKFnArqGV8rCGMABzgza5u4m3zYI5VrBFbPsjgNHyc6WnCo43Cy7apytzTNTLFwSi1Wr5YowJKXSFJvFNbUr2d3Yrn0FHG4pYmF8fW1HcRUQIR8ll2rDJoxImm20YqrdZxXpu900nMz6pSyqvMacNbwRFmcOK6hbWSr2xpgRm8XjCcQDXA2xxaPJFU6ZeVPEDCW3cmzcFFwlXV/zF1HHDBVag34JZQMde0Cxi8ZKhYhbrm6MygnYoJYoKvXHmZBbapxu5msW0eJjHkDXsCGQOt1qvmJtVY8h7c+0qPZeBQtMN99RiVxrDi+tx6ioViXSDtpj7Rp7L24T3p95VX+oC4HEl+Fipkfbi9ywIWujbQHg1K2NO2ZRSDsn2hWLQBu7H/jPxL86AAyeZXeAMUm2Yy0RgS+KjZDNs+f2hUqlJR7ywHdCX94DqCr7YrWDt/wBgrNadQRVXIywcdjeMsCAAl1VRSxKJzv7GJljXHO91+8tJ0+1uWbeWDQ0HO8xNDXvG9HHERv31AfriZXn1qmnIHY2SxxKDlJd2N2eSUqfrFJQ4s09fe8s3HcwJWPibQBaqL79U/DKQrl3uPyYPH6B3JUIYAt2dcKyHoE6EKgQUvK4AHN1Dg9G0DQLBp3kGAfb4QKy4sPmZw5ocmC1S42oAxEKuO7NPi69FVFY+Lp7Pi33Nepl9k/eG339OJ9/9c5Q1I07wiQYBZqm+owfoPxpwijAa2zfTMFZXOOPUUKVCGAW7OuFZD0CdCFQIKXlcADm6hwejaBoFg07yDEBBEnjA8tY5FWSp12ZEILIAqXGAzcHkAWxar+aE+ywFWhDRY/LoHg8UT7v6WCS70Wx3QHxD7vVdDujguuNw+Vojo1+0pq0eyoLDNrB1lg8DdEjLp6V6qOfT7L+70+7xECZalLAFF3C5bF9k2FVMz49V9d/eEP0KYm9Mlb00Bihe4Ipoqm6Egnyxsn7Ur8vpYg2EL8G5TlY5o6NlNUN65gGeRastk7qvVTRdMoGrotJd0C0lLrmthdZjha8OLcQgZKAKp3mEZGZrVqdo3DaKXLidCrismwBZdqBeafGXcpofAh6PgNLjsVFvqE/q+np9v9I2QbNaewSsLeLlNSRBJbRoleiPkAjSO+ciQpyS92jzT1HCP6vp6guFzmja8VcdCzLJsbRBRzipfwKIZQSnKH5+kVXcusa0MIjN8xiYZbysGmhIWT+u6x66GivbKlUhnqCsGEoZCflOChP7TpEPESA28QQD2RfeCXF0aM0VFnln9h3GUWYu82AzT9kXBtmcLSy1g+0O/iKgBaBvoGfgWFekJCzoN+SPGziEy6ms0D5sPdJEvjrqXQ4KvKi6ObEB7fjGBCLdU+7VzfT/AD7xdjZfNxlmgx1ge/2mC+jLxoKdKP0n9n0hJE18EodaW7HAJoGRW4V5qLbOuHLHgSnwMOnLolaIZQ4LhKR2Dbfch6mF0YF169vumn6MS2j72o1bGvPEzQ26mCzIxFVEh8wt3SjggHEutEREtt0XFiM1hRouORwr5Y1KN9MNQFwpTSdyh6WXSvtFiL0Zo3X7zCQJxbAGdm6NfeIvEDS3fUQKorVOcQC2A7o4d/H/AJKAPwPHvLSYupdV+sNUiiopDADm3Nx9asRKDTfi5d1SNqtHa37wcEoQFKPMsEvZVsArmVMpFRAcJERHMq/QvxMaVa635TWeeJdhhgsZuva+SAiGAqCDk3a8x1iGEM6x5mZ4YseXN+fmADqJSX8XHIoQwXqEJg0rR52ZWFGUOMYjdUNjD/7EYhw03ZxcSYCO/wBpZexOC5vAjg4/9mKVUVZxcIGpci96uDwQx/qBqtOpbFWiY1QiTKwkItsBFrrlxGo1zoCuMYrmOSw+Ioar6JWOK6jdbadwPDjmffetNBStTFBOeY7zBcWEFFgbWrGWUZuJYPccB7xEvMpWvILWhaAvOYB2BlY4XQfe/wBBwgQuh2KbPDiWMKtKcmAfK/Q8YpdOq0DjKvzHBVak9iaHz6BYGlB2tov7BEJCrT0RpMlinzKBEEKwFr0AfHp9s/ebPoz7p65Qux7p2Zj7JvZhEKWI7PTZQEvpARheYpVrGTAVOPmJKSR5XK+oFyoch01s8OJpc2lOTAPlfpd1Clq+gYHhshUMTDpNLQKeT0tMyaNjOh0fT0bwyzpdei8voJej0FWi8Wr8+rwdXMltyDLOIGGGGPq2B4K9L8Hl30NbPS08wq6qxNYWf1v+YVwKkFUC8Wny+ufvP7whNLn33qGDem/ex9oOEXgj4rT7zdCtXwYrfl4rzHPAQo9kX95/uE+l/QFOzLt6NbPDiNDgcVJpRQvlPQnREVY2AMDwxWfUaX4a1bzXoXhKUGo0F/bR/tq96I0msKfMG45I4FBb0el6PmaUUuig+D0QExkGA0OaD6RCxHkQpHOq9LtCL0wUXRQfSXfM9LrpreY73bNobVeVYlSRaUsR4RLg3HJHAoLej1vgVPVJh2UFPb36Kc0WopOgwv1ht6RwyUgnY1K8YptPqNx9XFyjtV2wlNKEmRE0xYjnxgf5jWhs6e1KsUEoUbE5gA2MwKpZ4tfrKTwosgs6bB9yICUjYz+t/wAzF+jAVWDzUbO4hSjSPcEmChsg/rzHjGYJNqrlXufMzHyLM14ldlkp6sCnh9H70rjLagPK3ABsZgVSzxa/WWfFrvtVsiUIiZE4jyKQ6xTC9XRfselcMCoehb6Khoqh04XuXI9P0BpH1zGtgIksEd6mbxSpdpN82TdYdLBMAL4TIyzQIXW9y0KVpXkjilI6sibKR/uJYFUM5cspYR3juUpYItp0EAhY0Kt02wUK5MwqQAGViQ6IrI4qn4hMnAfNq7ePOoGKqAJgMLBFWvaEOCY3QzoRWW4dYGC1WLsf1iYZbIb1f5ijtYBy+pAjW14Zf5FoTC7OjysfMohlunPr4uETDIXtMEFFljiAUyZKdVFVLrGG+b7Hj2jyCyeETZBCt8sGbaarO5guMvtLxf1IJqLy7ePtBlzi0TSs53MeWigzzuOiUQvqPhW+vUsxHsyR/QjCDqCqQvJm78TJWYNHONyh21s8+JegtTbcaMGlu0zvmKEHKN4RijNmCzfH7xTDYLj6uYcDK4ChGFVxTFoCliXmzmDb+ZfHU+6/QlfLbcH3NPzFSAlXc+pmPmK1E91/5/sXo4nH6QRiiFpANfaIsCTlSVX8x+3owcwfi51bXGoXYVr/AOzM+/8AMITlPuv/AMDGnoemIlq4MHA7wx39ioIZEUI5HBi7lJVo6DE8IFWygKy33LNTI8xCopF0sZ3ORxV/MwNBabrnxKGy3gMfL3DfDyLaF4hvFzoM4tq3+IwY+arMApkzydQ3qaaIM6q8lc1AngUWjaXnLmGBFdC+NtdQOyKBp+YIFAyxXJ9IarHlDKrtGyUUugf/ADn2irV5BwKD4Ne6wCAFXnablYBoyBcWADTDyHLALMgRvUvxJdW5HN+I1Gtc0Hu/d8SlEhR5GHk4hKakGgN60ZU5gxXBzgU2KvzFdSgy5ft7Q+MICGXj5mFwsef7uCNFLFmcwVFMtrcAUYAs0sFtuhUZg+Q7gNMygl8lpcav0KzBIAtQK9odCt0CaR+rA424a5/9jQUatA3Lau9LyLu/fEQjQXBzdB6qILsY6lNW5DqP29ifc/8Ay/bppOJxPtf+j/fhr023Puf/AMB93NNfppMqU4jQ0DfGYHnbMCnWju5SUrNcahTizemq8xtVsMKfeVTQKq2zUEitwVdxvszsSqUGwMn6S2/3x7TWcxpTFLgtXVg4TxUpQw5pDNkptsYlLYDh6bGzyRCyDKFbVuNNAF5LvWmClp5O/riGgtvSRbDS+Hj+kBqNYF7scGvpGFJizRlxDFRXw78zGJCOcIXh4Z96gMIFZPPn5ihLgKoaXi4mleKVyfEHVD0VAujUZQaN1jo7Yw3oHcvNrr5AlgWUspbyLS/+xTl59tl3/kF2Cxp8WYfWZlZKOS3bnjPkjxwBlSirXdxTDQBWL0a6mgCAimunVYh0CVdtfSZJA4Hb2zaqWOtyn0QVbo44Jc5mDKtwyVKdl5itS0bywhYKG0pyUII1gxwJLZseXmKACtgWta7jQNIc0GZTbGI5fu9QrXbeoBW3HE0cbjhe/wD5UOd3DQenEUzr/o2ATeYHqUr3/wDgGVG0GP0Y8QLU8Nys2hRlgE3Y5WUEpg6bVWStykaLphRXA5GLCWhwblL90Ou1eCaWkULOoZ7w5iu6WgY8gzY+JQWKqVosXRAsz7FaXutQQ0IjYYi1YKVRoTmc2FxZss/iLEJPY/EzGbWF5vxCq19lbv3hIBqpdeYsf5i0HCaEXWEuxq4cXMcL382jd9AC/iDl0ot5Wrlu3/yJUBKAKu+WUADkZurQuM5l0AWmAb9r+IOzhX5f+zKKKEcYqFAtAZ5nnHERhj4B/txJCsN4pVnuifSEkNQoAiLvpqzpedalxbaOvf6feFCFjRwfMoq20atMscNAo0ZWVDCyVHCyBVQ5pbqvpuWqcUSvG5kDHvXRLTvIMUZvxGUS0ZzCdksjwQ7MWS2Ne8BO3ChZqveCQJcwTK+GIBKFuVZULyGP2hoHa56jdI3k4mbXSrNyjVmYPVxAKfEp6ZT0ynplPTKemU9Mp6ZT0ynplPTKemU9Mp6ZT0ynplPTKemU9MapJ2yA9RcURWOyIOUfEp6ZT0ynplPTKemU9Mp6ZT0ynplPTKemU9Mp6ZT0ynplPTKemU9Mp6ZT0ynplPTKemU9Mp6ZT0ynplPTKemU9ME0n4h0agAAKD0IJT0H7xQISnplPTKemU9Mp6ZT0ynplPTKemU9Mp6ZT0ynplPTKemU9Mp6ZT0ynplPTKemU9Mp6ZT0ynplPTKemU9Mp6ZT0ynplPTKemU9Mp6ZT0ynplPTKemU9Mp6ZT0ynplPTKemU9Mp6ZT0ynplPTKemU9Mp6ZT0ynplPTKemU9Mp6ZT0wTQ/SD3yLCEqCcforwRrdJR9pY45uUW5vEfFBuC8slRdjMjySQ/UAaXZV2oHEr8S1bLxXZiymGWAEpLoxprZrcOJQIFoowAFRHDaabPMoSruq8/wCSpBYKUxqFVAVaktSJzG1zd78TXuUTXWbgEu6reYoGAUYKrmZE8YtxfcuFlUBZWNEBKw1+M0OdwqQKy9nNr+7B4wCUJuR5uhfAd5zSSNUIOafjERiIqnH33LMJtdnr3gx38nExgphbVPjxGkJVI4wZ17QC3mngrxGxb0tgML3G4XyiqNB2t5IJsHIP2FsAB24pdKwYmInlhjFpbJOD2hyDEEBK834l5QIXB8yrnbSgAFx/EW2/b4Yw/mWvBFjcpGYqQwClthnMqVTea0HvCzXZD6oqOxbvj4gOKQyhOj2+JfGYNpwH64zK2HI7AyPiFWJrRe4qUas8zJkpi93Fa8vmaY/fUBfPmKYFOyWsZPELf4IgG7xMofahy6OoU/xw/wDDmP8AhlisftMe5AszNe9tE8SeJPEniTxp40AaAgfoSJFtj6TwvpPCnhTwvpPCnhTw/pPDnhzwvpPC+k8KeF9J4f09EenP8aePPDnh/T0bx54/0nj/AEni/SeL9J4v0j1fpDZX6TNIFVd7TBAjCfvEeOYxgfcn+FMn8U/yp/hT/Cn+FP8AMn+BD/xJk/ilv4J/iT/An+JP8Sf4kw/wT/AmmvoT/An+JP8AEn+dP8yf5k/xJ/mR/wDMn+ZP8yf5kr/BP8yf5k/zJ/mT/Mn+ZP8AMn+JP8yZ/wCCf50/zZ/iT/En+NP8SYf4p/izR+1P8af4c/wJ/gTJ/FP8Kf4U/wAOP/hQTf25TxBj159UBxl6lAYW3UqAjuh8MVao3Kl0nOOSG/gMoraejg51ENotQvZCbsxmBWNVJNisjUN0Ece99R6IJnoe0cbTQVlmaWHm6SCxlurat94QsNmMZHMzFQJo/uIKwHALP2i2WYKTqyUa55DncqQC6Za4/wBjGICvKKP2wwEenmCmPDW26dOo28wlA8p42L1GqKRlslXo1g9ocmhaPRxKf2ggmXkl7LC8JncxqALUciYUNdra6+nmKO7opEVoJZNjzuZkFER81mIIIubX8viJWpQ86f8AkKhtsRipqgNOXX/kTRZiDnERRFuzWo1nN8ZmXZRdKYJBS17NAabDbTtxB8ujAEznXGazNiSSwzwdsq1kbKVbKb7KY9UQGX7VwO7SDXO6EeFwP9uXfh2DSvEtBhFQc2ZfHEci1rqbMXncCwEo4zqGNloCiuOphkc8tail6UHuIlnzKKbuvaA03o7gFP8AMAWse8DFQrU4lf3uFlmWoF6KhL4gag8BA6AEqVKlSpRK/XRKlEqVKJUqUSpUqVKlSiVKJRKlSiVKlEqVKlQCUSv1Eo8ypUCUXKlEolFXKJUqUSpRKJUolEo/pKJUrMolEqUalEqUSoCUe8olQJRKlEqVAJRKJR3KlEolSiUSv7UQlSiUZlFypRKSiAQ9T0PRI9auarOVqvGfMUUB9yG2xslC/JrVN4F9UeINIVaA7q46oWeYqmAHa3uK0xGAps8kTDKhgJveOsQ0cDGWWbDgXAbPeJSg1o5DqHGpEsvQTFOamhuiYCdqa0eZdQwAvT8wAYAVf3haFOgOfEJIMgbnv8zNRBDFZGCugyMasZVJfE8rrwoucdRrbEdmcA1FqNqqrxLNj2uWhJdZtTAApywVFcK8BVx3FBoXm87lmhRgS+4Ndtsb6alzGEVT6iIomTXjEtsvHVZ79oEjDQLo+JTbRwoWRqVikB8obdIOx7+IpzWnePpFzjpOa/eBS84KWVjxSwTst7lzF/u+COGMqsDgOA1Xpnfh9dexZb/1GZBxyijQxKCk2BwYOjqUIZqXae7LXEL3nUBTw6vUthUDmJkyBq4Gzq5QFYVtjV1VrAaW/rDRF97hpaxN7usEC3MwMS33nnBptlFFEMrvE87r/rPn05/V8Tj9XP8Awn6H9Fef1cevH6ufT4/UQjD0fUlZ/R7/APCyNrNKcqsqjVunMFMlV1qNuchXd3ALcAXCMKvdp8wORWk1uASi46zcXQ3VgMxFCoAoKlG7Awgc9+ZZUrsjV+0IXZi73c0KHRr5gAGgtBZ7S7MBMB9CO5guh8e0w+JRwsxUMvAuz78w3QP4gYvxcIkU0Bhx1iCU2NgFyqc+IphpFJdeGIQBjAfeM34Ouf7+0uNLJpzBlRqg/ogjVDwD9/rBNmWV6VDHwFr4jRCGec2MHMg0iUxMmstTxUEroAbREQW67mEAteD/AGCgPg69/pAgosENPswC3lqvHW50Vsol/JGeULnhHH2l+fy4oFICh58pXKhe0PCgDvQ+8oIyPsDusWl0MGmDDbFCKmYUOiUsIjozkfNSwiZcGBPoYgXRCuKYLsWTHiFIKUdusxUtG7GX0weGVAA1utktpy6mv5MC21m3NY7lPjcfpN4NkrM+PrB65gYHiC3MyaJ0SWjlX/qyV/yH/Hx+l9T/AIj1PQ9c3/xsPWv11+mpig5LzFWgoaqWteYKylsA0st1Dps2P0VBCo4j0Lc89EGzYTW9RYtXlyRcer4HiDd8Zt8wkMfVGCAFqx4gLVsbHTj/AMg1WYDhAENhbncAMOWVVIEEapnK9zAxBpov3igCKwQvVmaiNuqhV63yywc8mYtgAe1wGjke/meRmriR9YmUZdKPJhhgsfK9YguUYb9o6ytoY1qVTTdtcbJWYpTpKpSnjiOYbcb4uomND/eM2my8b/tS9WB+uI8Vtl9pdtODHETiF7OIvL5/irD98EtAOc0oafmAx8XVhRTQx4gwEvkYVvxFJStfN0tvcumCLt8TaGhUai8REmVq9RSjTxEZOLFTKz3GMcVNeWo4at3KGlzAyIbrzHQ8Qyp1M4byXNScDzAGowBoav8A4z0P08f/AA8/oP18T+JzDiOGBHcX05qcTgnXoTj1CbjivQhuOpw+iTmdehn05lZhmO4Fk5lw/ec+nE68+pqc+gQzHiMMwnE49HEN+hNzqcs5hOYFx3OD079AxP/Z";
var fileContent = Buffer.from(base64Data, "base64");
var main2 = async () => {
  uploadFileToIPFS("filename.jpg", fileContent).then((result) => {
    console.log("File uploaded to IPFS:", result);
    console.log("IPFS URL:", `https://cf-ipfs.io/${result.cid}`);
  }).catch((error3) => {
    console.error("Error uploading file to IPFS:", error3);
  }).finally(() => {
    process.exit();
  });
};
export {
  main2 as main
};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@fleek-platform/sdk/dist/browser/chunk-BOSPY7YV.js:
  (*! Bundled license information:
  
  @noble/ed25519/lib/esm/index.js:
    (*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)
  *)

web-streams-polyfill/dist/ponyfill.js:
  (**
   * @license
   * web-streams-polyfill v3.3.3
   * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
   * This code is released under the MIT license.
   * SPDX-License-Identifier: MIT
   *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
