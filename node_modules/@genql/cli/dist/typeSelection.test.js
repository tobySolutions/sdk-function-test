"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
describe('pick', () => {
    const req = {
        customScalar: true,
        category: {
            a: 1,
            b: 1,
            nested1: {
                a: 1,
            },
        },
        argumentSyntax: {
            __args: { x: 3 },
            a: 1,
            nesting: {
                __scalar: 1,
            },
        },
    };
    const z = {};
    test('response type picks from request type', dontExecute(() => {
        z.category;
        z.category.a;
        z.category.b;
        // @ts-expect-error
        z.category.c;
        z.category.nested1.a;
    }));
    test('response type does not have additional properties', dontExecute(() => {
        // TODO i can access keys with value type equal never
        // @ts-expect-error
        z.order;
        // @ts-expect-error
        z.category.nested1.b;
        // @ts-expect-error
        z.category.nested1.b;
        // @ts-expect-error
        z.category.nested1.c;
        // @ts-expect-error
        z.category.nested2;
    }));
    test('argument syntax', dontExecute(() => {
        z.argumentSyntax.a.toLocaleLowerCase;
    }));
    test('custom scalars', dontExecute(() => {
        const custom = z.customScalar;
        custom.json;
    }));
});
describe('__scalar', () => {
    const req = {
        __name: 'name',
        category: {
            __scalar: 1,
            nested1: {
                a: 1,
            },
        },
        argumentSyntax: {
            __args: { a: 7 },
            __scalar: 1,
        },
        argumentScalar: {
            __args: { x: 9 },
        },
    };
    const z = {};
    test('response type picks from request type', dontExecute(() => {
        z.category;
        z.category.a;
        z.category.b;
        z.category.c;
        z.category.nested1.a;
        z.category.a.getDate;
        z.category.b.getDate;
    }));
    test('response type does not have additional properties', dontExecute(() => {
        // TODO i can access keys with value type equal never
        // @ts-expect-error
        z.order;
        // @ts-expect-error
        z.category.nested1.b;
        // @ts-expect-error
        z.category.nested1.c;
        // @ts-expect-error
        z.category.nested2;
    }));
    test('__scalar is not present', dontExecute(() => {
        // @ts-expect-error
        z.category.__scalar;
    }));
    test('__name is not present', dontExecute(() => {
        // @ts-expect-error __name
        z.__name;
    }));
    test('argument syntax', dontExecute(() => {
        var _a;
        z.argumentSyntax.a.toLocaleLowerCase;
        (_a = z.argumentSyntax.optional) === null || _a === void 0 ? void 0 : _a.big;
        // @ts-expect-error
        z.argumentSyntax.nesting.x;
    }));
    test('argument syntax on scalar', dontExecute(() => {
        var _a;
        z.argumentScalar;
        (_a = z.argumentScalar) === null || _a === void 0 ? void 0 : _a.charAt;
        // @ts-expect-error
        z.argumentScalar.xx;
    }));
});
describe('optional fields', () => {
    const req = {
        optionalFields: {
            a: 1,
            b: 1,
        },
        category: {
            optionalFieldsNested: {
                __scalar: 1,
            },
        },
        argumentSyntax: {
            optional: 1,
        },
        optionalObject: {
            x: 1,
            optional: 1,
        },
    };
    const z = {};
    test('optional fields are preserved', dontExecute(() => {
        var _a, _b, _c;
        // @ts-expect-error
        z.optionalFields.a.toLocaleLowerCase;
        (_a = z.optionalFields.a) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase;
        // can use null
        z.optionalFields.a = null;
        // @ts-expect-error
        z.optionalFields.b.toLocaleLowerCase;
        (_b = z.optionalFields.b) === null || _b === void 0 ? void 0 : _b.toFixed;
        // @ts-expect-error
        z.category.optionalFieldsNested.a;
        // @ts-expect-error
        (_c = z.category) === null || _c === void 0 ? void 0 : _c.optionalFieldsNested.a;
    }));
    test('optional objects are preserved', dontExecute(() => {
        var _a;
        // @ts-expect-error
        z.optionalObject.x;
        (_a = z.optionalObject) === null || _a === void 0 ? void 0 : _a.x;
        // type is T | null
        z.optionalObject = null;
    }));
    test('optional fields are preserved in __scalar', dontExecute(() => {
        var _a, _b, _c, _d;
        // @ts-expect-error
        z.optionalFields.a.toLocaleLowerCase;
        (_a = z.optionalFields.a) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase;
        // @ts-expect-error
        z.optionalFields.b.toLocaleLowerCase;
        (_b = z.optionalFields.b) === null || _b === void 0 ? void 0 : _b.toFixed;
        // @ts-expect-error
        z.category.optionalFieldsNested.a;
        (_d = (_c = z.category.optionalFieldsNested) === null || _c === void 0 ? void 0 : _c.a) === null || _d === void 0 ? void 0 : _d.toLocaleLowerCase;
    }));
    test('argument syntax', dontExecute(() => {
        var _a;
        // @ts-expect-error optional
        z.argumentSyntax.optional.toLocaleLowerCase;
        (_a = z.argumentSyntax.optional) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase;
    }));
});
describe('unions', () => {
    const req = {
        union: {
            onX: {
                a: 1,
                __scalar: 1,
            },
        },
        nesting: {
            nestedUnion: {
                onX: {
                    a: 1,
                },
                onY: {
                    b: 1,
                },
            },
        },
        argumentSyntax: {
            union: {
                a: 1,
                onX: {
                    b: 1,
                },
            },
        },
    };
    const z = {};
    test('pick union fields', dontExecute(() => {
        z.union.a.toLocaleLowerCase;
        z.union.a.toLocaleLowerCase;
        z.nesting.nestedUnion.a.toLocaleLowerCase;
    }));
    test('does not have __isUnion', dontExecute(() => {
        // @ts-expect-error
        z.union.__isUnion;
        // @ts-expect-error
        z.nesting.nestedUnion.__isUnion;
    }));
    test('argument syntax', dontExecute(() => {
        z.argumentSyntax.union.a.charAt;
        // @ts-expect-error
        z.argumentSyntax.a;
    }));
});
describe('hide fields in request', () => {
    const SKIP = false;
    const req = {
        category: {
            a: 1,
            b: SKIP,
            c: false,
        },
    };
    const z = {};
    // test(
    //     'cannot access falsy fields',
    //     dontExecute(() => {
    //         z.category.a
    //         // @ts-expect-error inaccessible
    //         z.category.b
    //         // @ts-expect-error inaccessible
    //         z.category.c
    //     }),
    // )
});
describe('arrays', () => {
    const req = {
        list: {
            a: 1,
            x: 1,
            optional: 1,
        },
        nested: {
            __args: { x: 1 },
            __scalar: 1,
            list: {
                edges: {
                    x: 1,
                },
            },
        },
        argumentSyntax: {
            list: {
                x: 1,
                optional: 1,
            },
        },
    };
    const z = {};
    test('list', dontExecute(() => {
        z.list[0].a.charCodeAt;
        z.list[0].x.toFixed;
    }));
    test('nested', dontExecute(() => {
        var _a, _b, _c, _d, _e;
        (_e = (_d = (_c = (_b = (_a = z.nested) === null || _a === void 0 ? void 0 : _a.list) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.edges) === null || _d === void 0 ? void 0 : _d[0].x) === null || _e === void 0 ? void 0 : _e.toFixed;
    }));
    test('maintain optionals', dontExecute(() => {
        var _a;
        // @ts-expect-error optional
        z.list[0].optional.bold;
        (_a = z.list[0].optional) === null || _a === void 0 ? void 0 : _a.bold;
    }));
    test('args syntax', dontExecute(() => {
        var _a;
        z.argumentSyntax.list[0].x;
        (_a = z.argumentSyntax.list[0].optional) === null || _a === void 0 ? void 0 : _a.charAt;
        // @ts-expect-error optional
        z.argumentSyntax.list[0].optional.charAt;
    }));
});
describe('literals unions', () => {
    const req = {
        literalsUnion: 1,
    };
    const z = {};
    test('literals', dontExecute(() => {
        z.literalsUnion.blink;
        z.literalsUnion === 'a';
        z.literalsUnion === 'b';
        // @ts-expect-error
        z.literalsUnion === 'x';
    }));
});
describe('literals unions', () => {
    const req = {
        nullableField: {
            x: 1,
            optional: 1,
        },
    };
    const z = {};
    test('accessible', dontExecute(() => {
        var _a, _b, _c;
        (_a = z.nullableField) === null || _a === void 0 ? void 0 : _a.x;
        (_c = (_b = z.nullableField) === null || _b === void 0 ? void 0 : _b.optional) === null || _c === void 0 ? void 0 : _c.big;
        // @ts-expect-error optional
        z.nullableField.optional.big;
    }));
});
test('complex optional type with array', dontExecute(() => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    const x = {};
    (_d = (_c = (_b = (_a = x === null || x === void 0 ? void 0 : x.edges) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.node) === null || _c === void 0 ? void 0 : _c.x) === null || _d === void 0 ? void 0 : _d.toLocaleLowerCase;
    // @ts-expect-error not present
    (_h = (_g = (_f = (_e = x === null || x === void 0 ? void 0 : x.edges) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.node) === null || _g === void 0 ? void 0 : _g.y) === null || _h === void 0 ? void 0 : _h.toLocaleLowerCase;
    (_m = (_l = (_k = (_j = x === null || x === void 0 ? void 0 : x.edges) === null || _j === void 0 ? void 0 : _j[0]) === null || _k === void 0 ? void 0 : _k.nodes) === null || _l === void 0 ? void 0 : _l[0].x) === null || _m === void 0 ? void 0 : _m.toLocaleLowerCase;
    (_r = (_q = (_p = (_o = x === null || x === void 0 ? void 0 : x.edges) === null || _o === void 0 ? void 0 : _o[0]) === null || _p === void 0 ? void 0 : _p.nodes) === null || _q === void 0 ? void 0 : _q[0].y) === null || _r === void 0 ? void 0 : _r.toLocaleLowerCase;
}));
///////////////////////////////////// unions
// {
//     // only one union
//     type One = { one: string; __typename: string }
//     type Two = { two: string; __typename: string }
//     type SRC = {
//         union?: {
//             __union: One | Two
//             __resolve: {
//                 on_One: One
//                 on_Two: Two
//             }
//             __typename: 'One' | 'Two'
//         }
//     }
//     type DST = {
//         union?: {
//             on_One: {
//                 one: true
//             }
//             // on_Two: {
//             //     two: 1
//             // }
//         }
//     }
//     const z: FieldsSelection<SRC, DST> = {} as any
//     z.union?.one
// }
// {
//     // 2 unions together
//     type One = { one: string; __typename: string }
//     type Two = { two: string; __typename: string }
//     type SRC = {
//         union?: {
//             __union: One | Two
//             __resolve: {
//                 on_One: One
//                 on_Two: Two
//             }
//             __typename: 'One' | 'Two'
//         }
//     }
//     type DST = {
//         union?: {
//             on_One?: {
//                 one?: true
//             }
//             on_Two?: {
//                 two?: true
//             }
//         }
//     }
//     const z: FieldsSelection<SRC, DST> = {} as any
//     z.union // this is a union type, it cannot be directly be accessed without a guard
// }
// {
//     // without top level object
//     type One = { one?: string; __typename?: string }
//     type Two = { two?: string; __typename?: string }
//     type SRC = {
//         __union: One | Two
//         __resolve: {
//             on_One?: One
//             on_Two?: Two
//         }
//         __typename?: 'One' | 'Two'
//     }
//     type DST = {
//         on_One?: {
//             one?: true
//         }
//         __typename?: 1
//         // on_Two: {
//         //     two: 1
//         // }
//     }
//     const z: FieldsSelection<SRC, DST> = {} as any
//     z.one
// }
// {
//     type One = { one: string; __typename: string }
//     const x: ObjectFieldsSelection<One, { one?: true }> = {} as any
//     x.one
// }
function dontExecute(f) {
    return () => { };
}
//# sourceMappingURL=typeSelection.test.js.map