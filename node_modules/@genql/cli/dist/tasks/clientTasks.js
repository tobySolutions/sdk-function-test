"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.clientTasks = void 0;
const graphql_1 = require("graphql");
const listr2_1 = require("listr2");
const utils_1 = require("../utils");
const files_1 = require("../helpers/files");
const renderClient_1 = require("../render/client/renderClient");
const excludedTypes_1 = require("../render/common/excludedTypes");
const RenderContext_1 = require("../render/common/RenderContext");
const renderRequestTypes_1 = require("../render/requestTypes/renderRequestTypes");
const renderResponseTypes_1 = require("../render/responseTypes/renderResponseTypes");
const renderSchema_1 = require("../render/schema/renderSchema");
const renderTypeGuards_1 = require("../render/typeGuards/renderTypeGuards");
const renderTypeMap_1 = require("../render/typeMap/renderTypeMap");
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const schemaTypesFile = 'schema.ts';
const schemaGqlFile = 'schema.graphql';
const typeMapFileEsm = 'types.ts';
const cliRoot = path_1.default.resolve(require.resolve('../../package.json'), '..');
const runtimeFolderPath = path_1.default.resolve(cliRoot, 'src/runtime');
const clientTasks = (config) => {
    const clientFileEsm = 'index.ts';
    if (!config.output)
        throw new Error('`output` must be defined in the config');
    const output = config.output;
    const tasks = [
        {
            title: `writing ${schemaGqlFile}`,
            task: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
                const renderCtx = new RenderContext_1.RenderContext(ctx.schema, config);
                (0, renderSchema_1.renderSchema)(ctx.schema, renderCtx);
                yield (0, files_1.writeFileToPath)([output, schemaGqlFile], renderCtx.toCode('graphql'));
            }),
        },
        {
            title: `copy runtime files`,
            task: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
                // copy files from runtime folder to output
                yield fs_extra_1.default.ensureDir(path_1.default.resolve(output, 'runtime'));
                let files = yield fs_extra_1.default.readdir(runtimeFolderPath);
                for (let file of files) {
                    let contents = yield fs_extra_1.default.readFile(path_1.default.resolve(runtimeFolderPath, file), 'utf-8');
                    contents = '// @ts-nocheck\n' + contents;
                    yield fs_extra_1.default.writeFile(path_1.default.resolve(output, 'runtime', file), contents);
                }
                // await fsx.copy(
                //     runtimeFolderPath,
                //     path.resolve(output, 'runtime'),
                // )
            }),
        },
        {
            title: `writing ${schemaTypesFile}`,
            task: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
                const renderCtx = new RenderContext_1.RenderContext(ctx.schema, config);
                (0, renderResponseTypes_1.renderResponseTypes)(ctx.schema, renderCtx);
                (0, renderRequestTypes_1.renderRequestTypes)(ctx.schema, renderCtx);
                (0, renderTypeGuards_1.renderTypeGuards)(ctx.schema, renderCtx);
                renderEnumsMaps(ctx.schema, renderCtx);
                yield (0, files_1.writeFileToPath)([output, schemaTypesFile], '// @ts-nocheck\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\n\n' +
                    renderCtx.toCode('typescript'));
            }),
        },
        {
            title: `writing types map`,
            task: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
                const renderCtx = new RenderContext_1.RenderContext(ctx.schema, config);
                (0, renderTypeMap_1.renderTypeMap)(ctx.schema, renderCtx);
                yield (0, files_1.writeFileToPath)([output, typeMapFileEsm], `export default ${renderCtx.toCode()}`);
            }),
        },
        {
            title: `writing ${clientFileEsm}`,
            task: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
                const renderCtx = new RenderContext_1.RenderContext(ctx.schema, config);
                (0, renderClient_1.renderClientEsm)(ctx.schema, renderCtx);
                yield (0, files_1.writeFileToPath)([output, clientFileEsm], '// @ts-nocheck\n' + renderCtx.toCode('typescript', true));
            }),
        },
    ];
    return [
        {
            title: 'preparing client directory',
            task: () => (0, files_1.ensurePath)([output], true),
        },
        {
            title: `writing files`,
            task: () => new listr2_1.Listr(tasks.filter((x) => Boolean(x)), {
                concurrent: true,
            }),
        },
    ];
};
exports.clientTasks = clientTasks;
function renderEnumsMaps(schema, ctx) {
    let typeMap = schema.getTypeMap();
    const enums = [];
    for (const name in typeMap) {
        if (excludedTypes_1.excludedTypes.includes(name))
            continue;
        const type = typeMap[name];
        if ((0, graphql_1.isEnumType)(type)) {
            enums.push(type);
        }
    }
    if (enums.length === 0)
        return;
    ctx.addCodeBlock(enums
        .map((type) => `export const ${'enum' + (0, utils_1.capitalize)((0, utils_1.camelCase)(type.name))} = {\n` +
        type
            .getValues()
            .map((v) => {
            if (!(v === null || v === void 0 ? void 0 : v.name)) {
                return '';
            }
            return `   ${v.name}: '${v.name}' as const`;
        })
            .join(',\n') +
        `\n}\n`)
        .join('\n'));
}
//# sourceMappingURL=clientTasks.js.map