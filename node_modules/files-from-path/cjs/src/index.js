'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var gracefulfs = require('graceful-fs');
var util = require('util');
var path = require('path');
var stream = require('stream');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var gracefulfs__default = /*#__PURE__*/_interopDefaultLegacy(gracefulfs);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);

const defaultfs = {
  createReadStream: gracefulfs__default["default"].createReadStream,
  promises: {
    stat: util.promisify(gracefulfs__default["default"].stat),
    readdir: util.promisify(gracefulfs__default["default"].readdir)
  }
};
async function filesFromPaths(paths, options) {
  if (typeof paths === 'string') {
    paths = [paths];
  }
  let commonParts;
  const files = [];
  for (const p of paths) {
    for await (const file of filesFromPath(p, options)) {
      files.push(file);
      const nameParts = file.name.split(path__default["default"].sep);
      if (commonParts == null) {
        commonParts = nameParts.slice(0, -1);
        continue;
      }
      for (let i = 0; i < commonParts.length; i++) {
        if (commonParts[i] !== nameParts[i]) {
          commonParts = commonParts.slice(0, i);
          break;
        }
      }
    }
  }
  const commonPath = `${ commonParts ?? [].join('/') }/`;
  const commonPathFiles = files.map(f => ({
    ...f,
    name: f.name.slice(commonPath.length)
  }));
  return options?.sort == null || options?.sort === true ? commonPathFiles.sort((a, b) => a.name === b.name ? 0 : a.name > b.name ? 1 : -1) : commonPathFiles;
}
async function* filesFromPath(filepath, options) {
  filepath = path__default["default"].resolve(filepath);
  const fs = options?.fs ?? defaultfs;
  const hidden = options?.hidden ?? false;
  const filter = filepath => {
    if (!hidden && path__default["default"].basename(filepath).startsWith('.'))
      return false;
    return true;
  };
  const name = filepath;
  const stat = await fs.promises.stat(name);
  if (!filter(name)) {
    return;
  }
  if (stat.isFile()) {
    yield {
      name,
      stream: () => stream.Readable.toWeb(fs.createReadStream(name)),
      size: stat.size
    };
  } else if (stat.isDirectory()) {
    yield* filesFromDir(name, filter, options);
  }
}
async function* filesFromDir(dir, filter, options) {
  const fs = options?.fs ?? defaultfs;
  const entries = await fs.promises.readdir(path__default["default"].join(dir), { withFileTypes: true });
  for (const entry of entries) {
    if (!filter(entry.name)) {
      continue;
    }
    if (entry.isFile()) {
      const name = path__default["default"].join(dir, entry.name);
      const {size} = await fs.promises.stat(name);
      yield {
        name,
        stream: () => stream.Readable.toWeb(fs.createReadStream(name)),
        size
      };
    } else if (entry.isDirectory()) {
      yield* filesFromDir(path__default["default"].join(dir, entry.name), filter);
    }
  }
}

exports.filesFromPaths = filesFromPaths;
