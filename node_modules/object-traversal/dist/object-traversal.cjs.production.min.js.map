{"version":3,"file":"object-traversal.cjs.production.min.js","sources":["../src/constants.ts","../src/queue.ts","../src/stack.ts","../src/get-node-by-path.ts","../src/traverse.ts"],"sourcesContent":["import { TraversalOpts } from './types';\n\nexport const DEFAULT_SEPARATOR = '.';\n\nexport const DEFAULT_TRAVERSAL_OPTS: Required<TraversalOpts> = {\n  traversalType: 'depth-first',\n  maxNodes: Number.POSITIVE_INFINITY,\n  cycleHandling: true,\n  maxDepth: Number.POSITIVE_INFINITY,\n  haltOnTruthy: false,\n  pathSeparator: DEFAULT_SEPARATOR,\n};\n","import { _Stack } from './stack';\n\nexport class _Queue<T = any> {\n  private head?: Node<T> = undefined;\n  private tail?: Node<T> = undefined;\n\n  enqueue(v: T): void {\n    if (this.tail) {\n      this.tail = this.tail.next = { value: v };\n    } else {\n      this.head = this.tail = { value: v };\n    }\n  }\n\n  dequeue(): T {\n    const previousHeadValue = this.head!.value;\n    this.head = this.head!.next;\n    if (!this.head) {\n      this.tail = this.head;\n    }\n    return previousHeadValue;\n  }\n\n  isEmpty(): boolean {\n    return !this.head;\n  }\n\n  reset(): void {\n    this.head = this.tail = undefined;\n  }\n}\n\nexport class _QueueToStackAdapter<T = any> implements _Stack<T> {\n  constructor(private queue: _Queue<T>) {}\n\n  push(v: T): void {\n    this.queue.enqueue(v);\n  }\n\n  pop(): T {\n    return this.queue.dequeue();\n  }\n\n  isEmpty(): boolean {\n    return this.queue.isEmpty();\n  }\n\n  reset(): void {\n    return this.queue.reset();\n  }\n}\n\ninterface Node<T> {\n  value: any;\n  next?: Node<T>;\n}\n","export class _Stack<T = any> {\n  private tail?: Node<T> = undefined;\n\n  push(v: T): void {\n    this.tail = { value: v, prev: this.tail };\n  }\n\n  pop(): T {\n    const node = this.tail;\n    this.tail = this.tail!.prev;\n    return node!.value;\n  }\n\n  isEmpty(): boolean {\n    return !this.tail;\n  }\n\n  reset(): void {\n    this.tail = undefined;\n  }\n}\n\ninterface Node<T> {\n  value: any;\n  prev?: Node<T>;\n}\n","import { DEFAULT_SEPARATOR } from './constants';\nimport { ArbitraryObject } from './types';\n\nexport function getNodeByPath(\n  root: ArbitraryObject,\n  path: string,\n  separator: string = DEFAULT_SEPARATOR\n): any {\n  let node: any = root;\n  const segments: string[] = path.split(separator);\n\n  let index = 0;\n  let segment = segments[index];\n  while (node && segment) {\n    node = node[segment];\n    segment = segments[++index];\n  }\n\n  return node;\n}\n","import { DEFAULT_TRAVERSAL_OPTS } from './constants';\nimport { _Queue, _QueueToStackAdapter } from './queue';\nimport { _Stack } from './stack';\nimport {\n  ArbitraryObject,\n  FullTraversalOpts,\n  TraversalCallback,\n  TraversalCallbackContext,\n  TraversalMeta,\n  TraversalOpts,\n} from './types';\n\n/** Applies a given callback function to all properties of an object and its children */\nexport const traverse = (\n  root: ArbitraryObject,\n  callback: TraversalCallback,\n  opts?: TraversalOpts\n): void => {\n  if (!(root instanceof Object)) {\n    throw new Error('First argument must be an object');\n  }\n\n  const fullOpts = Object.assign(\n    {},\n    DEFAULT_TRAVERSAL_OPTS,\n    opts\n  ) as FullTraversalOpts;\n  fullOpts.disablePathTracking = typeof fullOpts.pathSeparator !== 'string';\n\n  let stackOrQueue: _Stack<TraversalCallbackContext>;\n  if (fullOpts.traversalType === 'depth-first') {\n    stackOrQueue = new _Stack();\n  } else {\n    stackOrQueue = new _QueueToStackAdapter(new _Queue());\n  }\n\n  const traversalMeta: TraversalMeta = {\n    visitedNodes: new WeakSet(),\n    depth: 0,\n  };\n  if (!fullOpts.disablePathTracking) {\n    traversalMeta.nodePath = null;\n  }\n\n  stackOrQueue.push({\n    parent: null,\n    key: null,\n    value: root,\n    meta: traversalMeta,\n  });\n\n  _traverse(callback, stackOrQueue, fullOpts);\n};\n\nconst _traverse = (\n  callback: TraversalCallback,\n  stackOrQueue: _Stack<TraversalCallbackContext>,\n  opts: FullTraversalOpts\n) => {\n  /**\n   * Using a stack instead of a queue to preserve the natural depth-first traversal order. Using a queue or traversing an array\n   *   in order would lead the depth-first to traverse the value.properties in reverse order.\n   * Breadth-first traversal uses queues as usual.\n   */\n  let newNodesToVisit: _Stack<TraversalCallbackContext>;\n  if (opts.traversalType === 'depth-first') {\n    newNodesToVisit = new _Stack();\n  } else {\n    newNodesToVisit = new _QueueToStackAdapter(new _Queue());\n  }\n\n  const {\n    maxNodes,\n    cycleHandling,\n    maxDepth,\n    haltOnTruthy,\n    pathSeparator,\n  } = opts;\n  let visitedNodeCount = 0;\n  while (!stackOrQueue.isEmpty() && maxNodes > visitedNodeCount) {\n    const callbackContext = stackOrQueue.pop()!;\n    const { value, meta } = callbackContext;\n    const { visitedNodes } = meta;\n    const nodeIsObject = value instanceof Object;\n\n    const skipNode = cycleHandling && nodeIsObject && visitedNodes.has(value);\n    if (skipNode) {\n      continue;\n    }\n\n    if (callback(callbackContext) && haltOnTruthy) {\n      break;\n    }\n    visitedNodeCount++;\n\n    if (nodeIsObject) {\n      visitedNodes.add(value);\n      const { depth, nodePath } = meta;\n      const newDepth = depth + 1;\n      if (newDepth > maxDepth) {\n        continue;\n      }\n\n      newNodesToVisit.reset();\n      const keys = Object.keys(value);\n      for (let i = 0; i < keys.length; i++) {\n        const property = keys[i];\n\n        const traversalMeta: TraversalMeta = {\n          visitedNodes,\n          depth: newDepth,\n        };\n\n        let newPath: string;\n        if (!opts.disablePathTracking) {\n          if (!nodePath) {\n            newPath = property;\n          } else {\n            newPath = `${nodePath}${pathSeparator}${property}`;\n          }\n\n          traversalMeta.nodePath = newPath;\n        }\n\n        newNodesToVisit.push({\n          value: value[property],\n          meta: traversalMeta,\n          key: property,\n          parent: value,\n        });\n      }\n\n      while (!newNodesToVisit.isEmpty()) {\n        stackOrQueue.push(newNodesToVisit.pop());\n      }\n    }\n  }\n};\n"],"names":["DEFAULT_TRAVERSAL_OPTS","traversalType","maxNodes","Number","POSITIVE_INFINITY","cycleHandling","maxDepth","haltOnTruthy","pathSeparator","_Queue","head","undefined","tail","enqueue","v","this","next","value","dequeue","previousHeadValue","isEmpty","reset","_QueueToStackAdapter","queue","push","pop","_Stack","prev","node","root","path","separator","segments","split","index","segment","callback","opts","Object","Error","stackOrQueue","fullOpts","assign","disablePathTracking","traversalMeta","visitedNodes","WeakSet","depth","nodePath","parent","key","meta","newNodesToVisit","visitedNodeCount","callbackContext","nodeIsObject","has","add","newDepth","keys","i","length","property","_traverse"],"mappings":"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"}