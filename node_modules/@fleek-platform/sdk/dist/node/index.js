"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod3) => function __require() {
  return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __export = (target, all5) => {
  for (var name20 in all5)
    __defProp(target, name20, { get: all5[name20], enumerable: true });
};
var __copyProps = (to, from21, except, desc) => {
  if (from21 && typeof from21 === "object" || typeof from21 === "function") {
    for (let key of __getOwnPropNames(from21))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from21[key], enumerable: !(desc = __getOwnPropDesc(from21, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
  mod3
));
var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/digest.js
var require_digest = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/digest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var digest6 = (algorithm2, data) => (0, crypto_1.createHash)(algorithm2).update(data).digest();
    exports2.default = digest6;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/buffer_utils.js
var require_buffer_utils = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/buffer_utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concatKdf = exports2.lengthAndInput = exports2.uint32be = exports2.uint64be = exports2.p2s = exports2.concat = exports2.decoder = exports2.encoder = void 0;
    var digest_js_1 = require_digest();
    exports2.encoder = new TextEncoder();
    exports2.decoder = new TextDecoder();
    var MAX_INT32 = 2 ** 32;
    function concat4(...buffers) {
      const size5 = buffers.reduce((acc, { length: length5 }) => acc + length5, 0);
      const buf3 = new Uint8Array(size5);
      let i = 0;
      buffers.forEach((buffer3) => {
        buf3.set(buffer3, i);
        i += buffer3.length;
      });
      return buf3;
    }
    exports2.concat = concat4;
    function p2s(alg, p2sInput) {
      return concat4(exports2.encoder.encode(alg), new Uint8Array([0]), p2sInput);
    }
    exports2.p2s = p2s;
    function writeUInt32BE(buf3, value, offset2) {
      if (value < 0 || value >= MAX_INT32) {
        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);
      }
      buf3.set([value >>> 24, value >>> 16, value >>> 8, value & 255], offset2);
    }
    function uint64be(value) {
      const high = Math.floor(value / MAX_INT32);
      const low = value % MAX_INT32;
      const buf3 = new Uint8Array(8);
      writeUInt32BE(buf3, high, 0);
      writeUInt32BE(buf3, low, 4);
      return buf3;
    }
    exports2.uint64be = uint64be;
    function uint32be(value) {
      const buf3 = new Uint8Array(4);
      writeUInt32BE(buf3, value);
      return buf3;
    }
    exports2.uint32be = uint32be;
    function lengthAndInput(input10) {
      return concat4(uint32be(input10.length), input10);
    }
    exports2.lengthAndInput = lengthAndInput;
    async function concatKdf(secret, bits, value) {
      const iterations = Math.ceil((bits >> 3) / 32);
      const res = new Uint8Array(iterations * 32);
      for (let iter = 0; iter < iterations; iter++) {
        const buf3 = new Uint8Array(4 + secret.length + value.length);
        buf3.set(uint32be(iter + 1));
        buf3.set(secret, 4);
        buf3.set(value, 4 + secret.length);
        res.set(await (0, digest_js_1.default)("sha256", buf3), iter * 32);
      }
      return res.slice(0, bits >> 3);
    }
    exports2.concatKdf = concatKdf;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/base64url.js
var require_base64url = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/base64url.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decode = exports2.encode = exports2.encodeBase64 = exports2.decodeBase64 = void 0;
    var buffer_1 = require("buffer");
    var buffer_utils_js_1 = require_buffer_utils();
    var encode45;
    exports2.encode = encode45;
    function normalize(input10) {
      let encoded = input10;
      if (encoded instanceof Uint8Array) {
        encoded = buffer_utils_js_1.decoder.decode(encoded);
      }
      return encoded;
    }
    if (buffer_1.Buffer.isEncoding("base64url")) {
      exports2.encode = encode45 = (input10) => buffer_1.Buffer.from(input10).toString("base64url");
    } else {
      exports2.encode = encode45 = (input10) => buffer_1.Buffer.from(input10).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    var decodeBase64 = (input10) => buffer_1.Buffer.from(input10, "base64");
    exports2.decodeBase64 = decodeBase64;
    var encodeBase64 = (input10) => buffer_1.Buffer.from(input10).toString("base64");
    exports2.encodeBase64 = encodeBase64;
    var decode53 = (input10) => buffer_1.Buffer.from(normalize(input10), "base64");
    exports2.decode = decode53;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/util/errors.js
var require_errors = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/util/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JWSSignatureVerificationFailed = exports2.JWKSTimeout = exports2.JWKSMultipleMatchingKeys = exports2.JWKSNoMatchingKey = exports2.JWKSInvalid = exports2.JWKInvalid = exports2.JWTInvalid = exports2.JWSInvalid = exports2.JWEInvalid = exports2.JWEDecryptionFailed = exports2.JOSENotSupported = exports2.JOSEAlgNotAllowed = exports2.JWTExpired = exports2.JWTClaimValidationFailed = exports2.JOSEError = void 0;
    var JOSEError = class extends Error {
      static get code() {
        return "ERR_JOSE_GENERIC";
      }
      constructor(message) {
        var _a;
        super(message);
        this.code = "ERR_JOSE_GENERIC";
        this.name = this.constructor.name;
        (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
      }
    };
    exports2.JOSEError = JOSEError;
    var JWTClaimValidationFailed = class extends JOSEError {
      static get code() {
        return "ERR_JWT_CLAIM_VALIDATION_FAILED";
      }
      constructor(message, claim = "unspecified", reason = "unspecified") {
        super(message);
        this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
        this.claim = claim;
        this.reason = reason;
      }
    };
    exports2.JWTClaimValidationFailed = JWTClaimValidationFailed;
    var JWTExpired = class extends JOSEError {
      static get code() {
        return "ERR_JWT_EXPIRED";
      }
      constructor(message, claim = "unspecified", reason = "unspecified") {
        super(message);
        this.code = "ERR_JWT_EXPIRED";
        this.claim = claim;
        this.reason = reason;
      }
    };
    exports2.JWTExpired = JWTExpired;
    var JOSEAlgNotAllowed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
      }
      static get code() {
        return "ERR_JOSE_ALG_NOT_ALLOWED";
      }
    };
    exports2.JOSEAlgNotAllowed = JOSEAlgNotAllowed;
    var JOSENotSupported = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_NOT_SUPPORTED";
      }
      static get code() {
        return "ERR_JOSE_NOT_SUPPORTED";
      }
    };
    exports2.JOSENotSupported = JOSENotSupported;
    var JWEDecryptionFailed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_DECRYPTION_FAILED";
        this.message = "decryption operation failed";
      }
      static get code() {
        return "ERR_JWE_DECRYPTION_FAILED";
      }
    };
    exports2.JWEDecryptionFailed = JWEDecryptionFailed;
    var JWEInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_INVALID";
      }
      static get code() {
        return "ERR_JWE_INVALID";
      }
    };
    exports2.JWEInvalid = JWEInvalid;
    var JWSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_INVALID";
      }
      static get code() {
        return "ERR_JWS_INVALID";
      }
    };
    exports2.JWSInvalid = JWSInvalid;
    var JWTInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWT_INVALID";
      }
      static get code() {
        return "ERR_JWT_INVALID";
      }
    };
    exports2.JWTInvalid = JWTInvalid;
    var JWKInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWK_INVALID";
      }
      static get code() {
        return "ERR_JWK_INVALID";
      }
    };
    exports2.JWKInvalid = JWKInvalid;
    var JWKSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_INVALID";
      }
      static get code() {
        return "ERR_JWKS_INVALID";
      }
    };
    exports2.JWKSInvalid = JWKSInvalid;
    var JWKSNoMatchingKey = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_NO_MATCHING_KEY";
        this.message = "no applicable key found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_NO_MATCHING_KEY";
      }
    };
    exports2.JWKSNoMatchingKey = JWKSNoMatchingKey;
    var JWKSMultipleMatchingKeys = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
        this.message = "multiple matching keys found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
      }
    };
    exports2.JWKSMultipleMatchingKeys = JWKSMultipleMatchingKeys;
    var JWKSTimeout = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_TIMEOUT";
        this.message = "request timed out";
      }
      static get code() {
        return "ERR_JWKS_TIMEOUT";
      }
    };
    exports2.JWKSTimeout = JWKSTimeout;
    var JWSSignatureVerificationFailed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
        this.message = "signature verification failed";
      }
      static get code() {
        return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
      }
    };
    exports2.JWSSignatureVerificationFailed = JWSSignatureVerificationFailed;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/random.js
var require_random = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/random.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = void 0;
    var crypto_1 = require("crypto");
    Object.defineProperty(exports2, "default", { enumerable: true, get: function() {
      return crypto_1.randomFillSync;
    } });
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/iv.js
var require_iv = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/iv.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bitLength = void 0;
    var errors_js_1 = require_errors();
    var random_js_1 = require_random();
    function bitLength(alg) {
      switch (alg) {
        case "A128GCM":
        case "A128GCMKW":
        case "A192GCM":
        case "A192GCMKW":
        case "A256GCM":
        case "A256GCMKW":
          return 96;
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          return 128;
        default:
          throw new errors_js_1.JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
      }
    }
    exports2.bitLength = bitLength;
    exports2.default = (alg) => (0, random_js_1.default)(new Uint8Array(bitLength(alg) >> 3));
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/check_iv_length.js
var require_check_iv_length = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/check_iv_length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors_js_1 = require_errors();
    var iv_js_1 = require_iv();
    var checkIvLength = (enc, iv) => {
      if (iv.length << 3 !== (0, iv_js_1.bitLength)(enc)) {
        throw new errors_js_1.JWEInvalid("Invalid Initialization Vector length");
      }
    };
    exports2.default = checkIvLength;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/is_key_object.js
var require_is_key_object = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/is_key_object.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var util = require("util");
    exports2.default = util.types.isKeyObject ? (obj) => util.types.isKeyObject(obj) : (obj) => obj != null && obj instanceof crypto_1.KeyObject;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/check_cek_length.js
var require_check_cek_length = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/check_cek_length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors_js_1 = require_errors();
    var is_key_object_js_1 = require_is_key_object();
    var checkCekLength = (enc, cek) => {
      let expected;
      switch (enc) {
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          expected = parseInt(enc.slice(-3), 10);
          break;
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          expected = parseInt(enc.slice(1, 4), 10);
          break;
        default:
          throw new errors_js_1.JOSENotSupported(`Content Encryption Algorithm ${enc} is not supported either by JOSE or your javascript runtime`);
      }
      if (cek instanceof Uint8Array) {
        const actual = cek.byteLength << 3;
        if (actual !== expected) {
          throw new errors_js_1.JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
        }
        return;
      }
      if ((0, is_key_object_js_1.default)(cek) && cek.type === "secret") {
        const actual = cek.symmetricKeySize << 3;
        if (actual !== expected) {
          throw new errors_js_1.JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
        }
        return;
      }
      throw new TypeError("Invalid Content Encryption Key type");
    };
    exports2.default = checkCekLength;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/timing_safe_equal.js
var require_timing_safe_equal = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/timing_safe_equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var timingSafeEqual = crypto_1.timingSafeEqual;
    exports2.default = timingSafeEqual;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/cbc_tag.js
var require_cbc_tag = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/cbc_tag.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var buffer_utils_js_1 = require_buffer_utils();
    function cbcTag(aad, iv, ciphertext, macSize, macKey, keySize) {
      const macData = (0, buffer_utils_js_1.concat)(aad, iv, ciphertext, (0, buffer_utils_js_1.uint64be)(aad.length << 3));
      const hmac = (0, crypto_1.createHmac)(`sha${macSize}`, macKey);
      hmac.update(macData);
      return hmac.digest().slice(0, keySize >> 3);
    }
    exports2.default = cbcTag;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/webcrypto.js
var require_webcrypto = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/webcrypto.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isCryptoKey = void 0;
    var crypto9 = require("crypto");
    var util = require("util");
    var webcrypto2 = crypto9.webcrypto;
    exports2.default = webcrypto2;
    exports2.isCryptoKey = util.types.isCryptoKey ? (key) => util.types.isCryptoKey(key) : (key) => false;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/env.js
var require_env = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/env.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isCloudflareWorkers = void 0;
    function isCloudflareWorkers() {
      return false;
    }
    exports2.isCloudflareWorkers = isCloudflareWorkers;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/crypto_key.js
var require_crypto_key = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/crypto_key.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkEncCryptoKey = exports2.checkSigCryptoKey = void 0;
    var env_js_1 = require_env();
    function unusable(name20, prop = "algorithm.name") {
      return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name20}`);
    }
    function isAlgorithm(algorithm2, name20) {
      return algorithm2.name === name20;
    }
    function getHashLength(hash) {
      return parseInt(hash.name.slice(4), 10);
    }
    function getNamedCurve(alg) {
      switch (alg) {
        case "ES256":
          return "P-256";
        case "ES384":
          return "P-384";
        case "ES512":
          return "P-521";
        default:
          throw new Error("unreachable");
      }
    }
    function checkUsage(key, usages) {
      if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
        let msg = "CryptoKey does not support this operation, its usages must include ";
        if (usages.length > 2) {
          const last5 = usages.pop();
          msg += `one of ${usages.join(", ")}, or ${last5}.`;
        } else if (usages.length === 2) {
          msg += `one of ${usages[0]} or ${usages[1]}.`;
        } else {
          msg += `${usages[0]}.`;
        }
        throw new TypeError(msg);
      }
    }
    function checkSigCryptoKey(key, alg, ...usages) {
      switch (alg) {
        case "HS256":
        case "HS384":
        case "HS512": {
          if (!isAlgorithm(key.algorithm, "HMAC"))
            throw unusable("HMAC");
          const expected = parseInt(alg.slice(2), 10);
          const actual = getHashLength(key.algorithm.hash);
          if (actual !== expected)
            throw unusable(`SHA-${expected}`, "algorithm.hash");
          break;
        }
        case "RS256":
        case "RS384":
        case "RS512": {
          if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
            throw unusable("RSASSA-PKCS1-v1_5");
          const expected = parseInt(alg.slice(2), 10);
          const actual = getHashLength(key.algorithm.hash);
          if (actual !== expected)
            throw unusable(`SHA-${expected}`, "algorithm.hash");
          break;
        }
        case "PS256":
        case "PS384":
        case "PS512": {
          if (!isAlgorithm(key.algorithm, "RSA-PSS"))
            throw unusable("RSA-PSS");
          const expected = parseInt(alg.slice(2), 10);
          const actual = getHashLength(key.algorithm.hash);
          if (actual !== expected)
            throw unusable(`SHA-${expected}`, "algorithm.hash");
          break;
        }
        case ((0, env_js_1.isCloudflareWorkers)() && "EdDSA"): {
          if (!isAlgorithm(key.algorithm, "NODE-ED25519"))
            throw unusable("NODE-ED25519");
          break;
        }
        case "EdDSA": {
          if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
            throw unusable("Ed25519 or Ed448");
          }
          break;
        }
        case "ES256":
        case "ES384":
        case "ES512": {
          if (!isAlgorithm(key.algorithm, "ECDSA"))
            throw unusable("ECDSA");
          const expected = getNamedCurve(alg);
          const actual = key.algorithm.namedCurve;
          if (actual !== expected)
            throw unusable(expected, "algorithm.namedCurve");
          break;
        }
        default:
          throw new TypeError("CryptoKey does not support this operation");
      }
      checkUsage(key, usages);
    }
    exports2.checkSigCryptoKey = checkSigCryptoKey;
    function checkEncCryptoKey(key, alg, ...usages) {
      switch (alg) {
        case "A128GCM":
        case "A192GCM":
        case "A256GCM": {
          if (!isAlgorithm(key.algorithm, "AES-GCM"))
            throw unusable("AES-GCM");
          const expected = parseInt(alg.slice(1, 4), 10);
          const actual = key.algorithm.length;
          if (actual !== expected)
            throw unusable(expected, "algorithm.length");
          break;
        }
        case "A128KW":
        case "A192KW":
        case "A256KW": {
          if (!isAlgorithm(key.algorithm, "AES-KW"))
            throw unusable("AES-KW");
          const expected = parseInt(alg.slice(1, 4), 10);
          const actual = key.algorithm.length;
          if (actual !== expected)
            throw unusable(expected, "algorithm.length");
          break;
        }
        case "ECDH": {
          switch (key.algorithm.name) {
            case "ECDH":
            case "X25519":
            case "X448":
              break;
            default:
              throw unusable("ECDH, X25519, or X448");
          }
          break;
        }
        case "PBES2-HS256+A128KW":
        case "PBES2-HS384+A192KW":
        case "PBES2-HS512+A256KW":
          if (!isAlgorithm(key.algorithm, "PBKDF2"))
            throw unusable("PBKDF2");
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512": {
          if (!isAlgorithm(key.algorithm, "RSA-OAEP"))
            throw unusable("RSA-OAEP");
          const expected = parseInt(alg.slice(9), 10) || 1;
          const actual = getHashLength(key.algorithm.hash);
          if (actual !== expected)
            throw unusable(`SHA-${expected}`, "algorithm.hash");
          break;
        }
        default:
          throw new TypeError("CryptoKey does not support this operation");
      }
      checkUsage(key, usages);
    }
    exports2.checkEncCryptoKey = checkEncCryptoKey;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/invalid_key_input.js
var require_invalid_key_input = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/invalid_key_input.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withAlg = void 0;
    function message(msg, actual, ...types) {
      if (types.length > 2) {
        const last5 = types.pop();
        msg += `one of type ${types.join(", ")}, or ${last5}.`;
      } else if (types.length === 2) {
        msg += `one of type ${types[0]} or ${types[1]}.`;
      } else {
        msg += `of type ${types[0]}.`;
      }
      if (actual == null) {
        msg += ` Received ${actual}`;
      } else if (typeof actual === "function" && actual.name) {
        msg += ` Received function ${actual.name}`;
      } else if (typeof actual === "object" && actual != null) {
        if (actual.constructor && actual.constructor.name) {
          msg += ` Received an instance of ${actual.constructor.name}`;
        }
      }
      return msg;
    }
    exports2.default = (actual, ...types) => {
      return message("Key must be ", actual, ...types);
    };
    function withAlg(alg, actual, ...types) {
      return message(`Key for the ${alg} algorithm must be `, actual, ...types);
    }
    exports2.withAlg = withAlg;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/ciphers.js
var require_ciphers = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/ciphers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var ciphers;
    exports2.default = (algorithm2) => {
      ciphers || (ciphers = new Set((0, crypto_1.getCiphers)()));
      return ciphers.has(algorithm2);
    };
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/is_key_like.js
var require_is_key_like = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/is_key_like.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.types = void 0;
    var webcrypto_js_1 = require_webcrypto();
    var is_key_object_js_1 = require_is_key_object();
    exports2.default = (key) => (0, is_key_object_js_1.default)(key) || (0, webcrypto_js_1.isCryptoKey)(key);
    var types = ["KeyObject"];
    exports2.types = types;
    if (globalThis.CryptoKey || (webcrypto_js_1.default === null || webcrypto_js_1.default === void 0 ? void 0 : webcrypto_js_1.default.CryptoKey)) {
      types.push("CryptoKey");
    }
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/decrypt.js
var require_decrypt = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/decrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var check_iv_length_js_1 = require_check_iv_length();
    var check_cek_length_js_1 = require_check_cek_length();
    var buffer_utils_js_1 = require_buffer_utils();
    var errors_js_1 = require_errors();
    var timing_safe_equal_js_1 = require_timing_safe_equal();
    var cbc_tag_js_1 = require_cbc_tag();
    var webcrypto_js_1 = require_webcrypto();
    var crypto_key_js_1 = require_crypto_key();
    var is_key_object_js_1 = require_is_key_object();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var ciphers_js_1 = require_ciphers();
    var is_key_like_js_1 = require_is_key_like();
    function cbcDecrypt(enc, cek, ciphertext, iv, tag2, aad) {
      const keySize = parseInt(enc.slice(1, 4), 10);
      if ((0, is_key_object_js_1.default)(cek)) {
        cek = cek.export();
      }
      const encKey = cek.subarray(keySize >> 3);
      const macKey = cek.subarray(0, keySize >> 3);
      const macSize = parseInt(enc.slice(-3), 10);
      const algorithm2 = `aes-${keySize}-cbc`;
      if (!(0, ciphers_js_1.default)(algorithm2)) {
        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
      }
      const expectedTag = (0, cbc_tag_js_1.default)(aad, iv, ciphertext, macSize, macKey, keySize);
      let macCheckPassed;
      try {
        macCheckPassed = (0, timing_safe_equal_js_1.default)(tag2, expectedTag);
      } catch {
      }
      if (!macCheckPassed) {
        throw new errors_js_1.JWEDecryptionFailed();
      }
      let plaintext;
      try {
        const decipher = (0, crypto_1.createDecipheriv)(algorithm2, encKey, iv);
        plaintext = (0, buffer_utils_js_1.concat)(decipher.update(ciphertext), decipher.final());
      } catch {
      }
      if (!plaintext) {
        throw new errors_js_1.JWEDecryptionFailed();
      }
      return plaintext;
    }
    function gcmDecrypt(enc, cek, ciphertext, iv, tag2, aad) {
      const keySize = parseInt(enc.slice(1, 4), 10);
      const algorithm2 = `aes-${keySize}-gcm`;
      if (!(0, ciphers_js_1.default)(algorithm2)) {
        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
      }
      try {
        const decipher = (0, crypto_1.createDecipheriv)(algorithm2, cek, iv, { authTagLength: 16 });
        decipher.setAuthTag(tag2);
        if (aad.byteLength) {
          decipher.setAAD(aad, { plaintextLength: ciphertext.length });
        }
        const plaintext = decipher.update(ciphertext);
        decipher.final();
        return plaintext;
      } catch {
        throw new errors_js_1.JWEDecryptionFailed();
      }
    }
    var decrypt = (enc, cek, ciphertext, iv, tag2, aad) => {
      let key;
      if ((0, webcrypto_js_1.isCryptoKey)(cek)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(cek, enc, "decrypt");
        key = crypto_1.KeyObject.from(cek);
      } else if (cek instanceof Uint8Array || (0, is_key_object_js_1.default)(cek)) {
        key = cek;
      } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(cek, ...is_key_like_js_1.types, "Uint8Array"));
      }
      (0, check_cek_length_js_1.default)(enc, key);
      (0, check_iv_length_js_1.default)(enc, iv);
      switch (enc) {
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          return cbcDecrypt(enc, key, ciphertext, iv, tag2, aad);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          return gcmDecrypt(enc, key, ciphertext, iv, tag2, aad);
        default:
          throw new errors_js_1.JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
      }
    };
    exports2.default = decrypt;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/zlib.js
var require_zlib = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/zlib.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deflate = exports2.inflate = void 0;
    var util_1 = require("util");
    var zlib_1 = require("zlib");
    var inflateRaw = (0, util_1.promisify)(zlib_1.inflateRaw);
    var deflateRaw = (0, util_1.promisify)(zlib_1.deflateRaw);
    var inflate = (input10) => inflateRaw(input10);
    exports2.inflate = inflate;
    var deflate = (input10) => deflateRaw(input10);
    exports2.deflate = deflate;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/is_disjoint.js
var require_is_disjoint = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/is_disjoint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var isDisjoint = (...headers) => {
      const sources = headers.filter(Boolean);
      if (sources.length === 0 || sources.length === 1) {
        return true;
      }
      let acc;
      for (const header of sources) {
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
          acc = new Set(parameters);
          continue;
        }
        for (const parameter of parameters) {
          if (acc.has(parameter)) {
            return false;
          }
          acc.add(parameter);
        }
      }
      return true;
    };
    exports2.default = isDisjoint;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/is_object.js
var require_is_object = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/is_object.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function isObjectLike(value) {
      return typeof value === "object" && value !== null;
    }
    function isObject(input10) {
      if (!isObjectLike(input10) || Object.prototype.toString.call(input10) !== "[object Object]") {
        return false;
      }
      if (Object.getPrototypeOf(input10) === null) {
        return true;
      }
      let proto = input10;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(input10) === proto;
    }
    exports2.default = isObject;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/aeskw.js
var require_aeskw = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/aeskw.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unwrap = exports2.wrap = void 0;
    var buffer_1 = require("buffer");
    var crypto_1 = require("crypto");
    var errors_js_1 = require_errors();
    var buffer_utils_js_1 = require_buffer_utils();
    var webcrypto_js_1 = require_webcrypto();
    var crypto_key_js_1 = require_crypto_key();
    var is_key_object_js_1 = require_is_key_object();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var ciphers_js_1 = require_ciphers();
    var is_key_like_js_1 = require_is_key_like();
    function checkKeySize(key, alg) {
      if (key.symmetricKeySize << 3 !== parseInt(alg.slice(1, 4), 10)) {
        throw new TypeError(`Invalid key size for alg: ${alg}`);
      }
    }
    function ensureKeyObject(key, alg, usage) {
      if ((0, is_key_object_js_1.default)(key)) {
        return key;
      }
      if (key instanceof Uint8Array) {
        return (0, crypto_1.createSecretKey)(key);
      }
      if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, usage);
        return crypto_1.KeyObject.from(key);
      }
      throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, "Uint8Array"));
    }
    var wrap = (alg, key, cek) => {
      const size5 = parseInt(alg.slice(1, 4), 10);
      const algorithm2 = `aes${size5}-wrap`;
      if (!(0, ciphers_js_1.default)(algorithm2)) {
        throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
      }
      const keyObject = ensureKeyObject(key, alg, "wrapKey");
      checkKeySize(keyObject, alg);
      const cipher = (0, crypto_1.createCipheriv)(algorithm2, keyObject, buffer_1.Buffer.alloc(8, 166));
      return (0, buffer_utils_js_1.concat)(cipher.update(cek), cipher.final());
    };
    exports2.wrap = wrap;
    var unwrap = (alg, key, encryptedKey) => {
      const size5 = parseInt(alg.slice(1, 4), 10);
      const algorithm2 = `aes${size5}-wrap`;
      if (!(0, ciphers_js_1.default)(algorithm2)) {
        throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
      }
      const keyObject = ensureKeyObject(key, alg, "unwrapKey");
      checkKeySize(keyObject, alg);
      const cipher = (0, crypto_1.createDecipheriv)(algorithm2, keyObject, buffer_1.Buffer.alloc(8, 166));
      return (0, buffer_utils_js_1.concat)(cipher.update(encryptedKey), cipher.final());
    };
    exports2.unwrap = unwrap;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/get_named_curve.js
var require_get_named_curve = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/get_named_curve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setCurve = exports2.weakMap = void 0;
    var buffer_1 = require("buffer");
    var crypto_1 = require("crypto");
    var errors_js_1 = require_errors();
    var webcrypto_js_1 = require_webcrypto();
    var is_key_object_js_1 = require_is_key_object();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var is_key_like_js_1 = require_is_key_like();
    var p256 = buffer_1.Buffer.from([42, 134, 72, 206, 61, 3, 1, 7]);
    var p384 = buffer_1.Buffer.from([43, 129, 4, 0, 34]);
    var p521 = buffer_1.Buffer.from([43, 129, 4, 0, 35]);
    var secp256k1 = buffer_1.Buffer.from([43, 129, 4, 0, 10]);
    exports2.weakMap = /* @__PURE__ */ new WeakMap();
    var namedCurveToJOSE = (namedCurve) => {
      switch (namedCurve) {
        case "prime256v1":
          return "P-256";
        case "secp384r1":
          return "P-384";
        case "secp521r1":
          return "P-521";
        case "secp256k1":
          return "secp256k1";
        default:
          throw new errors_js_1.JOSENotSupported("Unsupported key curve for this operation");
      }
    };
    var getNamedCurve = (kee, raw) => {
      var _a;
      let key;
      if ((0, webcrypto_js_1.isCryptoKey)(kee)) {
        key = crypto_1.KeyObject.from(kee);
      } else if ((0, is_key_object_js_1.default)(kee)) {
        key = kee;
      } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(kee, ...is_key_like_js_1.types));
      }
      if (key.type === "secret") {
        throw new TypeError('only "private" or "public" type keys can be used for this operation');
      }
      switch (key.asymmetricKeyType) {
        case "ed25519":
        case "ed448":
          return `Ed${key.asymmetricKeyType.slice(2)}`;
        case "x25519":
        case "x448":
          return `X${key.asymmetricKeyType.slice(1)}`;
        case "ec": {
          if (exports2.weakMap.has(key)) {
            return exports2.weakMap.get(key);
          }
          let namedCurve = (_a = key.asymmetricKeyDetails) === null || _a === void 0 ? void 0 : _a.namedCurve;
          if (!namedCurve && key.type === "private") {
            namedCurve = getNamedCurve((0, crypto_1.createPublicKey)(key), true);
          } else if (!namedCurve) {
            const buf3 = key.export({ format: "der", type: "spki" });
            const i = buf3[1] < 128 ? 14 : 15;
            const len = buf3[i];
            const curveOid = buf3.slice(i + 1, i + 1 + len);
            if (curveOid.equals(p256)) {
              namedCurve = "prime256v1";
            } else if (curveOid.equals(p384)) {
              namedCurve = "secp384r1";
            } else if (curveOid.equals(p521)) {
              namedCurve = "secp521r1";
            } else if (curveOid.equals(secp256k1)) {
              namedCurve = "secp256k1";
            } else {
              throw new errors_js_1.JOSENotSupported("Unsupported key curve for this operation");
            }
          }
          if (raw)
            return namedCurve;
          const curve = namedCurveToJOSE(namedCurve);
          exports2.weakMap.set(key, curve);
          return curve;
        }
        default:
          throw new TypeError("Invalid asymmetric key type for this operation");
      }
    };
    function setCurve(keyObject, curve) {
      exports2.weakMap.set(keyObject, curve);
    }
    exports2.setCurve = setCurve;
    exports2.default = getNamedCurve;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/ecdhes.js
var require_ecdhes = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/ecdhes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ecdhAllowed = exports2.generateEpk = exports2.deriveKey = void 0;
    var crypto_1 = require("crypto");
    var util_1 = require("util");
    var get_named_curve_js_1 = require_get_named_curve();
    var buffer_utils_js_1 = require_buffer_utils();
    var errors_js_1 = require_errors();
    var webcrypto_js_1 = require_webcrypto();
    var crypto_key_js_1 = require_crypto_key();
    var is_key_object_js_1 = require_is_key_object();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var is_key_like_js_1 = require_is_key_like();
    var generateKeyPair = (0, util_1.promisify)(crypto_1.generateKeyPair);
    async function deriveKey(publicKee, privateKee, algorithm2, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {
      let publicKey;
      if ((0, webcrypto_js_1.isCryptoKey)(publicKee)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(publicKee, "ECDH");
        publicKey = crypto_1.KeyObject.from(publicKee);
      } else if ((0, is_key_object_js_1.default)(publicKee)) {
        publicKey = publicKee;
      } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(publicKee, ...is_key_like_js_1.types));
      }
      let privateKey;
      if ((0, webcrypto_js_1.isCryptoKey)(privateKee)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(privateKee, "ECDH", "deriveBits");
        privateKey = crypto_1.KeyObject.from(privateKee);
      } else if ((0, is_key_object_js_1.default)(privateKee)) {
        privateKey = privateKee;
      } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(privateKee, ...is_key_like_js_1.types));
      }
      const value = (0, buffer_utils_js_1.concat)((0, buffer_utils_js_1.lengthAndInput)(buffer_utils_js_1.encoder.encode(algorithm2)), (0, buffer_utils_js_1.lengthAndInput)(apu), (0, buffer_utils_js_1.lengthAndInput)(apv), (0, buffer_utils_js_1.uint32be)(keyLength));
      const sharedSecret = (0, crypto_1.diffieHellman)({ privateKey, publicKey });
      return (0, buffer_utils_js_1.concatKdf)(sharedSecret, keyLength, value);
    }
    exports2.deriveKey = deriveKey;
    async function generateEpk(kee) {
      let key;
      if ((0, webcrypto_js_1.isCryptoKey)(kee)) {
        key = crypto_1.KeyObject.from(kee);
      } else if ((0, is_key_object_js_1.default)(kee)) {
        key = kee;
      } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(kee, ...is_key_like_js_1.types));
      }
      switch (key.asymmetricKeyType) {
        case "x25519":
          return generateKeyPair("x25519");
        case "x448": {
          return generateKeyPair("x448");
        }
        case "ec": {
          const namedCurve = (0, get_named_curve_js_1.default)(key);
          return generateKeyPair("ec", { namedCurve });
        }
        default:
          throw new errors_js_1.JOSENotSupported("Invalid or unsupported EPK");
      }
    }
    exports2.generateEpk = generateEpk;
    var ecdhAllowed = (key) => ["P-256", "P-384", "P-521", "X25519", "X448"].includes((0, get_named_curve_js_1.default)(key));
    exports2.ecdhAllowed = ecdhAllowed;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/check_p2s.js
var require_check_p2s = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/check_p2s.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors_js_1 = require_errors();
    function checkP2s(p2s) {
      if (!(p2s instanceof Uint8Array) || p2s.length < 8) {
        throw new errors_js_1.JWEInvalid("PBES2 Salt Input must be 8 or more octets");
      }
    }
    exports2.default = checkP2s;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/pbes2kw.js
var require_pbes2kw = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/pbes2kw.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decrypt = exports2.encrypt = void 0;
    var util_1 = require("util");
    var crypto_1 = require("crypto");
    var random_js_1 = require_random();
    var buffer_utils_js_1 = require_buffer_utils();
    var base64url_js_1 = require_base64url();
    var aeskw_js_1 = require_aeskw();
    var check_p2s_js_1 = require_check_p2s();
    var webcrypto_js_1 = require_webcrypto();
    var crypto_key_js_1 = require_crypto_key();
    var is_key_object_js_1 = require_is_key_object();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var is_key_like_js_1 = require_is_key_like();
    var pbkdf2 = (0, util_1.promisify)(crypto_1.pbkdf2);
    function getPassword(key, alg) {
      if ((0, is_key_object_js_1.default)(key)) {
        return key.export();
      }
      if (key instanceof Uint8Array) {
        return key;
      }
      if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, "deriveBits", "deriveKey");
        return crypto_1.KeyObject.from(key).export();
      }
      throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, "Uint8Array"));
    }
    var encrypt = async (alg, key, cek, p2c = 2048, p2s = (0, random_js_1.default)(new Uint8Array(16))) => {
      (0, check_p2s_js_1.default)(p2s);
      const salt = (0, buffer_utils_js_1.p2s)(alg, p2s);
      const keylen = parseInt(alg.slice(13, 16), 10) >> 3;
      const password = getPassword(key, alg);
      const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.slice(8, 11)}`);
      const encryptedKey = await (0, aeskw_js_1.wrap)(alg.slice(-6), derivedKey, cek);
      return { encryptedKey, p2c, p2s: (0, base64url_js_1.encode)(p2s) };
    };
    exports2.encrypt = encrypt;
    var decrypt = async (alg, key, encryptedKey, p2c, p2s) => {
      (0, check_p2s_js_1.default)(p2s);
      const salt = (0, buffer_utils_js_1.p2s)(alg, p2s);
      const keylen = parseInt(alg.slice(13, 16), 10) >> 3;
      const password = getPassword(key, alg);
      const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.slice(8, 11)}`);
      return (0, aeskw_js_1.unwrap)(alg.slice(-6), derivedKey, encryptedKey);
    };
    exports2.decrypt = decrypt;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/check_modulus_length.js
var require_check_modulus_length = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/check_modulus_length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setModulusLength = exports2.weakMap = void 0;
    exports2.weakMap = /* @__PURE__ */ new WeakMap();
    var getLength = (buf3, index2) => {
      let len = buf3.readUInt8(1);
      if ((len & 128) === 0) {
        if (index2 === 0) {
          return len;
        }
        return getLength(buf3.subarray(2 + len), index2 - 1);
      }
      const num = len & 127;
      len = 0;
      for (let i = 0; i < num; i++) {
        len <<= 8;
        const j = buf3.readUInt8(2 + i);
        len |= j;
      }
      if (index2 === 0) {
        return len;
      }
      return getLength(buf3.subarray(2 + len), index2 - 1);
    };
    var getLengthOfSeqIndex = (sequence, index2) => {
      const len = sequence.readUInt8(1);
      if ((len & 128) === 0) {
        return getLength(sequence.subarray(2), index2);
      }
      const num = len & 127;
      return getLength(sequence.subarray(2 + num), index2);
    };
    var getModulusLength = (key) => {
      var _a, _b;
      if (exports2.weakMap.has(key)) {
        return exports2.weakMap.get(key);
      }
      const modulusLength = (_b = (_a = key.asymmetricKeyDetails) === null || _a === void 0 ? void 0 : _a.modulusLength) !== null && _b !== void 0 ? _b : getLengthOfSeqIndex(key.export({ format: "der", type: "pkcs1" }), key.type === "private" ? 1 : 0) - 1 << 3;
      exports2.weakMap.set(key, modulusLength);
      return modulusLength;
    };
    var setModulusLength = (keyObject, modulusLength) => {
      exports2.weakMap.set(keyObject, modulusLength);
    };
    exports2.setModulusLength = setModulusLength;
    exports2.default = (key, alg) => {
      if (getModulusLength(key) < 2048) {
        throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
      }
    };
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/rsaes.js
var require_rsaes = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/rsaes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decrypt = exports2.encrypt = void 0;
    var crypto_1 = require("crypto");
    var check_modulus_length_js_1 = require_check_modulus_length();
    var webcrypto_js_1 = require_webcrypto();
    var crypto_key_js_1 = require_crypto_key();
    var is_key_object_js_1 = require_is_key_object();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var is_key_like_js_1 = require_is_key_like();
    var checkKey = (key, alg) => {
      if (key.asymmetricKeyType !== "rsa") {
        throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");
      }
      (0, check_modulus_length_js_1.default)(key, alg);
    };
    var resolvePadding = (alg) => {
      switch (alg) {
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          return crypto_1.constants.RSA_PKCS1_OAEP_PADDING;
        case "RSA1_5":
          return crypto_1.constants.RSA_PKCS1_PADDING;
        default:
          return void 0;
      }
    };
    var resolveOaepHash = (alg) => {
      switch (alg) {
        case "RSA-OAEP":
          return "sha1";
        case "RSA-OAEP-256":
          return "sha256";
        case "RSA-OAEP-384":
          return "sha384";
        case "RSA-OAEP-512":
          return "sha512";
        default:
          return void 0;
      }
    };
    function ensureKeyObject(key, alg, ...usages) {
      if ((0, is_key_object_js_1.default)(key)) {
        return key;
      }
      if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, ...usages);
        return crypto_1.KeyObject.from(key);
      }
      throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
    }
    var encrypt = (alg, key, cek) => {
      const padding2 = resolvePadding(alg);
      const oaepHash = resolveOaepHash(alg);
      const keyObject = ensureKeyObject(key, alg, "wrapKey", "encrypt");
      checkKey(keyObject, alg);
      return (0, crypto_1.publicEncrypt)({ key: keyObject, oaepHash, padding: padding2 }, cek);
    };
    exports2.encrypt = encrypt;
    var decrypt = (alg, key, encryptedKey) => {
      const padding2 = resolvePadding(alg);
      const oaepHash = resolveOaepHash(alg);
      const keyObject = ensureKeyObject(key, alg, "unwrapKey", "decrypt");
      checkKey(keyObject, alg);
      return (0, crypto_1.privateDecrypt)({ key: keyObject, oaepHash, padding: padding2 }, encryptedKey);
    };
    exports2.decrypt = decrypt;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/cek.js
var require_cek = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/cek.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bitLength = void 0;
    var errors_js_1 = require_errors();
    var random_js_1 = require_random();
    function bitLength(alg) {
      switch (alg) {
        case "A128GCM":
          return 128;
        case "A192GCM":
          return 192;
        case "A256GCM":
        case "A128CBC-HS256":
          return 256;
        case "A192CBC-HS384":
          return 384;
        case "A256CBC-HS512":
          return 512;
        default:
          throw new errors_js_1.JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
      }
    }
    exports2.bitLength = bitLength;
    exports2.default = (alg) => (0, random_js_1.default)(new Uint8Array(bitLength(alg) >> 3));
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/asn1.js
var require_asn1 = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/asn1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromSPKI = exports2.fromPKCS8 = exports2.toPKCS8 = exports2.toSPKI = void 0;
    var crypto_1 = require("crypto");
    var buffer_1 = require("buffer");
    var webcrypto_js_1 = require_webcrypto();
    var is_key_object_js_1 = require_is_key_object();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var is_key_like_js_1 = require_is_key_like();
    var genericExport = (keyType, keyFormat, key) => {
      let keyObject;
      if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        if (!key.extractable) {
          throw new TypeError("CryptoKey is not extractable");
        }
        keyObject = crypto_1.KeyObject.from(key);
      } else if ((0, is_key_object_js_1.default)(key)) {
        keyObject = key;
      } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
      }
      if (keyObject.type !== keyType) {
        throw new TypeError(`key is not a ${keyType} key`);
      }
      return keyObject.export({ format: "pem", type: keyFormat });
    };
    var toSPKI = (key) => {
      return genericExport("public", "spki", key);
    };
    exports2.toSPKI = toSPKI;
    var toPKCS8 = (key) => {
      return genericExport("private", "pkcs8", key);
    };
    exports2.toPKCS8 = toPKCS8;
    var fromPKCS8 = (pem) => (0, crypto_1.createPrivateKey)({
      key: buffer_1.Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, ""), "base64"),
      type: "pkcs8",
      format: "der"
    });
    exports2.fromPKCS8 = fromPKCS8;
    var fromSPKI = (pem) => (0, crypto_1.createPublicKey)({
      key: buffer_1.Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, ""), "base64"),
      type: "spki",
      format: "der"
    });
    exports2.fromSPKI = fromSPKI;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/asn1_sequence_encoder.js
var require_asn1_sequence_encoder = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/asn1_sequence_encoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var buffer_1 = require("buffer");
    var errors_js_1 = require_errors();
    var tagInteger = 2;
    var tagBitStr = 3;
    var tagOctStr = 4;
    var tagSequence = 48;
    var bZero = buffer_1.Buffer.from([0]);
    var bTagInteger = buffer_1.Buffer.from([tagInteger]);
    var bTagBitStr = buffer_1.Buffer.from([tagBitStr]);
    var bTagSequence = buffer_1.Buffer.from([tagSequence]);
    var bTagOctStr = buffer_1.Buffer.from([tagOctStr]);
    var encodeLength = (len) => {
      if (len < 128)
        return buffer_1.Buffer.from([len]);
      const buffer3 = buffer_1.Buffer.alloc(5);
      buffer3.writeUInt32BE(len, 1);
      let offset2 = 1;
      while (buffer3[offset2] === 0)
        offset2++;
      buffer3[offset2 - 1] = 128 | 5 - offset2;
      return buffer3.slice(offset2 - 1);
    };
    var oids = /* @__PURE__ */ new Map([
      ["P-256", buffer_1.Buffer.from("06 08 2A 86 48 CE 3D 03 01 07".replace(/ /g, ""), "hex")],
      ["secp256k1", buffer_1.Buffer.from("06 05 2B 81 04 00 0A".replace(/ /g, ""), "hex")],
      ["P-384", buffer_1.Buffer.from("06 05 2B 81 04 00 22".replace(/ /g, ""), "hex")],
      ["P-521", buffer_1.Buffer.from("06 05 2B 81 04 00 23".replace(/ /g, ""), "hex")],
      ["ecPublicKey", buffer_1.Buffer.from("06 07 2A 86 48 CE 3D 02 01".replace(/ /g, ""), "hex")],
      ["X25519", buffer_1.Buffer.from("06 03 2B 65 6E".replace(/ /g, ""), "hex")],
      ["X448", buffer_1.Buffer.from("06 03 2B 65 6F".replace(/ /g, ""), "hex")],
      ["Ed25519", buffer_1.Buffer.from("06 03 2B 65 70".replace(/ /g, ""), "hex")],
      ["Ed448", buffer_1.Buffer.from("06 03 2B 65 71".replace(/ /g, ""), "hex")]
    ]);
    var DumbAsn1Encoder = class {
      constructor() {
        this.length = 0;
        this.elements = [];
      }
      oidFor(oid) {
        const bOid = oids.get(oid);
        if (!bOid) {
          throw new errors_js_1.JOSENotSupported("Invalid or unsupported OID");
        }
        this.elements.push(bOid);
        this.length += bOid.length;
      }
      zero() {
        this.elements.push(bTagInteger, buffer_1.Buffer.from([1]), bZero);
        this.length += 3;
      }
      one() {
        this.elements.push(bTagInteger, buffer_1.Buffer.from([1]), buffer_1.Buffer.from([1]));
        this.length += 3;
      }
      unsignedInteger(integer2) {
        if (integer2[0] & 128) {
          const len = encodeLength(integer2.length + 1);
          this.elements.push(bTagInteger, len, bZero, integer2);
          this.length += 2 + len.length + integer2.length;
        } else {
          let i = 0;
          while (integer2[i] === 0 && (integer2[i + 1] & 128) === 0)
            i++;
          const len = encodeLength(integer2.length - i);
          this.elements.push(bTagInteger, encodeLength(integer2.length - i), integer2.slice(i));
          this.length += 1 + len.length + integer2.length - i;
        }
      }
      octStr(octStr) {
        const len = encodeLength(octStr.length);
        this.elements.push(bTagOctStr, encodeLength(octStr.length), octStr);
        this.length += 1 + len.length + octStr.length;
      }
      bitStr(bitS) {
        const len = encodeLength(bitS.length + 1);
        this.elements.push(bTagBitStr, encodeLength(bitS.length + 1), bZero, bitS);
        this.length += 1 + len.length + bitS.length + 1;
      }
      add(seq) {
        this.elements.push(seq);
        this.length += seq.length;
      }
      end(tag2 = bTagSequence) {
        const len = encodeLength(this.length);
        return buffer_1.Buffer.concat([tag2, len, ...this.elements], 1 + len.length + this.length);
      }
    };
    exports2.default = DumbAsn1Encoder;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/flags.js
var require_flags = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/flags.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.jwkImport = exports2.jwkExport = exports2.rsaPssParams = exports2.oneShotCallback = void 0;
    var [major, minor] = process.versions.node.split(".").map((str) => parseInt(str, 10));
    exports2.oneShotCallback = major >= 16 || major === 15 && minor >= 13;
    exports2.rsaPssParams = !("electron" in process.versions) && (major >= 17 || major === 16 && minor >= 9);
    exports2.jwkExport = major >= 16 || major === 15 && minor >= 9;
    exports2.jwkImport = major >= 16 || major === 15 && minor >= 12;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/jwk_to_key.js
var require_jwk_to_key = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/jwk_to_key.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var buffer_1 = require("buffer");
    var crypto_1 = require("crypto");
    var base64url_js_1 = require_base64url();
    var errors_js_1 = require_errors();
    var get_named_curve_js_1 = require_get_named_curve();
    var check_modulus_length_js_1 = require_check_modulus_length();
    var asn1_sequence_encoder_js_1 = require_asn1_sequence_encoder();
    var flags_js_1 = require_flags();
    var parse8 = (jwk) => {
      if (flags_js_1.jwkImport && jwk.kty !== "oct") {
        return jwk.d ? (0, crypto_1.createPrivateKey)({ format: "jwk", key: jwk }) : (0, crypto_1.createPublicKey)({ format: "jwk", key: jwk });
      }
      switch (jwk.kty) {
        case "oct": {
          return (0, crypto_1.createSecretKey)((0, base64url_js_1.decode)(jwk.k));
        }
        case "RSA": {
          const enc = new asn1_sequence_encoder_js_1.default();
          const isPrivate = jwk.d !== void 0;
          const modulus = buffer_1.Buffer.from(jwk.n, "base64");
          const exponent = buffer_1.Buffer.from(jwk.e, "base64");
          if (isPrivate) {
            enc.zero();
            enc.unsignedInteger(modulus);
            enc.unsignedInteger(exponent);
            enc.unsignedInteger(buffer_1.Buffer.from(jwk.d, "base64"));
            enc.unsignedInteger(buffer_1.Buffer.from(jwk.p, "base64"));
            enc.unsignedInteger(buffer_1.Buffer.from(jwk.q, "base64"));
            enc.unsignedInteger(buffer_1.Buffer.from(jwk.dp, "base64"));
            enc.unsignedInteger(buffer_1.Buffer.from(jwk.dq, "base64"));
            enc.unsignedInteger(buffer_1.Buffer.from(jwk.qi, "base64"));
          } else {
            enc.unsignedInteger(modulus);
            enc.unsignedInteger(exponent);
          }
          const der = enc.end();
          const createInput = {
            key: der,
            format: "der",
            type: "pkcs1"
          };
          const keyObject = isPrivate ? (0, crypto_1.createPrivateKey)(createInput) : (0, crypto_1.createPublicKey)(createInput);
          (0, check_modulus_length_js_1.setModulusLength)(keyObject, modulus.length << 3);
          return keyObject;
        }
        case "EC": {
          const enc = new asn1_sequence_encoder_js_1.default();
          const isPrivate = jwk.d !== void 0;
          const pub = buffer_1.Buffer.concat([
            buffer_1.Buffer.alloc(1, 4),
            buffer_1.Buffer.from(jwk.x, "base64"),
            buffer_1.Buffer.from(jwk.y, "base64")
          ]);
          if (isPrivate) {
            enc.zero();
            const enc$12 = new asn1_sequence_encoder_js_1.default();
            enc$12.oidFor("ecPublicKey");
            enc$12.oidFor(jwk.crv);
            enc.add(enc$12.end());
            const enc$2 = new asn1_sequence_encoder_js_1.default();
            enc$2.one();
            enc$2.octStr(buffer_1.Buffer.from(jwk.d, "base64"));
            const enc$3 = new asn1_sequence_encoder_js_1.default();
            enc$3.bitStr(pub);
            const f2 = enc$3.end(buffer_1.Buffer.from([161]));
            enc$2.add(f2);
            const f = enc$2.end();
            const enc$4 = new asn1_sequence_encoder_js_1.default();
            enc$4.add(f);
            const f3 = enc$4.end(buffer_1.Buffer.from([4]));
            enc.add(f3);
            const der2 = enc.end();
            const keyObject2 = (0, crypto_1.createPrivateKey)({ key: der2, format: "der", type: "pkcs8" });
            (0, get_named_curve_js_1.setCurve)(keyObject2, jwk.crv);
            return keyObject2;
          }
          const enc$1 = new asn1_sequence_encoder_js_1.default();
          enc$1.oidFor("ecPublicKey");
          enc$1.oidFor(jwk.crv);
          enc.add(enc$1.end());
          enc.bitStr(pub);
          const der = enc.end();
          const keyObject = (0, crypto_1.createPublicKey)({ key: der, format: "der", type: "spki" });
          (0, get_named_curve_js_1.setCurve)(keyObject, jwk.crv);
          return keyObject;
        }
        case "OKP": {
          const enc = new asn1_sequence_encoder_js_1.default();
          const isPrivate = jwk.d !== void 0;
          if (isPrivate) {
            enc.zero();
            const enc$12 = new asn1_sequence_encoder_js_1.default();
            enc$12.oidFor(jwk.crv);
            enc.add(enc$12.end());
            const enc$2 = new asn1_sequence_encoder_js_1.default();
            enc$2.octStr(buffer_1.Buffer.from(jwk.d, "base64"));
            const f = enc$2.end(buffer_1.Buffer.from([4]));
            enc.add(f);
            const der2 = enc.end();
            return (0, crypto_1.createPrivateKey)({ key: der2, format: "der", type: "pkcs8" });
          }
          const enc$1 = new asn1_sequence_encoder_js_1.default();
          enc$1.oidFor(jwk.crv);
          enc.add(enc$1.end());
          enc.bitStr(buffer_1.Buffer.from(jwk.x, "base64"));
          const der = enc.end();
          return (0, crypto_1.createPublicKey)({ key: der, format: "der", type: "spki" });
        }
        default:
          throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
      }
    };
    exports2.default = parse8;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/format_pem.js
var require_format_pem = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/format_pem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = (b64, descriptor) => {
      const newlined = (b64.match(/.{1,64}/g) || []).join("\n");
      return `-----BEGIN ${descriptor}-----
${newlined}
-----END ${descriptor}-----`;
    };
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/key/import.js
var require_import = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/key/import.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.importJWK = exports2.importPKCS8 = exports2.importX509 = exports2.importSPKI = void 0;
    var base64url_js_1 = require_base64url();
    var asn1_js_1 = require_asn1();
    var asn1_js_2 = require_asn1();
    var jwk_to_key_js_1 = require_jwk_to_key();
    var errors_js_1 = require_errors();
    var format_pem_js_1 = require_format_pem();
    var is_object_js_1 = require_is_object();
    function getElement(seq) {
      let result = [];
      let next = 0;
      while (next < seq.length) {
        let nextPart = parseElement(seq.subarray(next));
        result.push(nextPart);
        next += nextPart.byteLength;
      }
      return result;
    }
    function parseElement(bytes2) {
      let position = 0;
      let tag2 = bytes2[0] & 31;
      position++;
      if (tag2 === 31) {
        tag2 = 0;
        while (bytes2[position] >= 128) {
          tag2 = tag2 * 128 + bytes2[position] - 128;
          position++;
        }
        tag2 = tag2 * 128 + bytes2[position] - 128;
        position++;
      }
      let length5 = 0;
      if (bytes2[position] < 128) {
        length5 = bytes2[position];
        position++;
      } else if (length5 === 128) {
        length5 = 0;
        while (bytes2[position + length5] !== 0 || bytes2[position + length5 + 1] !== 0) {
          if (length5 > bytes2.byteLength) {
            throw new TypeError("invalid indefinite form length");
          }
          length5++;
        }
        const byteLength2 = position + length5 + 2;
        return {
          byteLength: byteLength2,
          contents: bytes2.subarray(position, position + length5),
          raw: bytes2.subarray(0, byteLength2)
        };
      } else {
        let numberOfDigits = bytes2[position] & 127;
        position++;
        length5 = 0;
        for (let i = 0; i < numberOfDigits; i++) {
          length5 = length5 * 256 + bytes2[position];
          position++;
        }
      }
      const byteLength = position + length5;
      return {
        byteLength,
        contents: bytes2.subarray(position, byteLength),
        raw: bytes2.subarray(0, byteLength)
      };
    }
    function spkiFromX509(buf3) {
      const tbsCertificate = getElement(getElement(parseElement(buf3).contents)[0].contents);
      return (0, base64url_js_1.encodeBase64)(tbsCertificate[tbsCertificate[0].raw[0] === 160 ? 6 : 5].raw);
    }
    function getSPKI(x509) {
      const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g, "");
      const raw = (0, base64url_js_1.decodeBase64)(pem);
      return (0, format_pem_js_1.default)(spkiFromX509(raw), "PUBLIC KEY");
    }
    async function importSPKI(spki, alg, options) {
      if (typeof spki !== "string" || spki.indexOf("-----BEGIN PUBLIC KEY-----") !== 0) {
        throw new TypeError('"spki" must be SPKI formatted string');
      }
      return (0, asn1_js_1.fromSPKI)(spki, alg, options);
    }
    exports2.importSPKI = importSPKI;
    async function importX509(x509, alg, options) {
      if (typeof x509 !== "string" || x509.indexOf("-----BEGIN CERTIFICATE-----") !== 0) {
        throw new TypeError('"x509" must be X.509 formatted string');
      }
      let spki;
      try {
        spki = getSPKI(x509);
      } catch (cause) {
        throw new TypeError("failed to parse the X.509 certificate", { cause });
      }
      return (0, asn1_js_1.fromSPKI)(spki, alg, options);
    }
    exports2.importX509 = importX509;
    async function importPKCS8(pkcs8, alg, options) {
      if (typeof pkcs8 !== "string" || pkcs8.indexOf("-----BEGIN PRIVATE KEY-----") !== 0) {
        throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
      }
      return (0, asn1_js_2.fromPKCS8)(pkcs8, alg, options);
    }
    exports2.importPKCS8 = importPKCS8;
    async function importJWK(jwk, alg, octAsKeyObject) {
      var _a;
      if (!(0, is_object_js_1.default)(jwk)) {
        throw new TypeError("JWK must be an object");
      }
      alg || (alg = jwk.alg);
      if (typeof alg !== "string" || !alg) {
        throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
      }
      switch (jwk.kty) {
        case "oct":
          if (typeof jwk.k !== "string" || !jwk.k) {
            throw new TypeError('missing "k" (Key Value) Parameter value');
          }
          octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : octAsKeyObject = jwk.ext !== true;
          if (octAsKeyObject) {
            return (0, jwk_to_key_js_1.default)({ ...jwk, alg, ext: (_a = jwk.ext) !== null && _a !== void 0 ? _a : false });
          }
          return (0, base64url_js_1.decode)(jwk.k);
        case "RSA":
          if (jwk.oth !== void 0) {
            throw new errors_js_1.JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
          }
        case "EC":
        case "OKP":
          return (0, jwk_to_key_js_1.default)({ ...jwk, alg });
        default:
          throw new errors_js_1.JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
      }
    }
    exports2.importJWK = importJWK;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/check_key_type.js
var require_check_key_type = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/check_key_type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var invalid_key_input_js_1 = require_invalid_key_input();
    var is_key_like_js_1 = require_is_key_like();
    var symmetricTypeCheck = (alg, key) => {
      if (key instanceof Uint8Array)
        return;
      if (!(0, is_key_like_js_1.default)(key)) {
        throw new TypeError((0, invalid_key_input_js_1.withAlg)(alg, key, ...is_key_like_js_1.types, "Uint8Array"));
      }
      if (key.type !== "secret") {
        throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
      }
    };
    var asymmetricTypeCheck = (alg, key, usage) => {
      if (!(0, is_key_like_js_1.default)(key)) {
        throw new TypeError((0, invalid_key_input_js_1.withAlg)(alg, key, ...is_key_like_js_1.types));
      }
      if (key.type === "secret") {
        throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
      }
      if (usage === "sign" && key.type === "public") {
        throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
      }
      if (usage === "decrypt" && key.type === "public") {
        throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
      }
      if (key.algorithm && usage === "verify" && key.type === "private") {
        throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
      }
      if (key.algorithm && usage === "encrypt" && key.type === "private") {
        throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
      }
    };
    var checkKeyType = (alg, key, usage) => {
      const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
      if (symmetric) {
        symmetricTypeCheck(alg, key);
      } else {
        asymmetricTypeCheck(alg, key, usage);
      }
    };
    exports2.default = checkKeyType;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/encrypt.js
var require_encrypt = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/encrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var check_iv_length_js_1 = require_check_iv_length();
    var check_cek_length_js_1 = require_check_cek_length();
    var buffer_utils_js_1 = require_buffer_utils();
    var cbc_tag_js_1 = require_cbc_tag();
    var webcrypto_js_1 = require_webcrypto();
    var crypto_key_js_1 = require_crypto_key();
    var is_key_object_js_1 = require_is_key_object();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var errors_js_1 = require_errors();
    var ciphers_js_1 = require_ciphers();
    var is_key_like_js_1 = require_is_key_like();
    function cbcEncrypt(enc, plaintext, cek, iv, aad) {
      const keySize = parseInt(enc.slice(1, 4), 10);
      if ((0, is_key_object_js_1.default)(cek)) {
        cek = cek.export();
      }
      const encKey = cek.subarray(keySize >> 3);
      const macKey = cek.subarray(0, keySize >> 3);
      const algorithm2 = `aes-${keySize}-cbc`;
      if (!(0, ciphers_js_1.default)(algorithm2)) {
        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
      }
      const cipher = (0, crypto_1.createCipheriv)(algorithm2, encKey, iv);
      const ciphertext = (0, buffer_utils_js_1.concat)(cipher.update(plaintext), cipher.final());
      const macSize = parseInt(enc.slice(-3), 10);
      const tag2 = (0, cbc_tag_js_1.default)(aad, iv, ciphertext, macSize, macKey, keySize);
      return { ciphertext, tag: tag2 };
    }
    function gcmEncrypt(enc, plaintext, cek, iv, aad) {
      const keySize = parseInt(enc.slice(1, 4), 10);
      const algorithm2 = `aes-${keySize}-gcm`;
      if (!(0, ciphers_js_1.default)(algorithm2)) {
        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
      }
      const cipher = (0, crypto_1.createCipheriv)(algorithm2, cek, iv, { authTagLength: 16 });
      if (aad.byteLength) {
        cipher.setAAD(aad, { plaintextLength: plaintext.length });
      }
      const ciphertext = cipher.update(plaintext);
      cipher.final();
      const tag2 = cipher.getAuthTag();
      return { ciphertext, tag: tag2 };
    }
    var encrypt = (enc, plaintext, cek, iv, aad) => {
      let key;
      if ((0, webcrypto_js_1.isCryptoKey)(cek)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(cek, enc, "encrypt");
        key = crypto_1.KeyObject.from(cek);
      } else if (cek instanceof Uint8Array || (0, is_key_object_js_1.default)(cek)) {
        key = cek;
      } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(cek, ...is_key_like_js_1.types, "Uint8Array"));
      }
      (0, check_cek_length_js_1.default)(enc, key);
      (0, check_iv_length_js_1.default)(enc, iv);
      switch (enc) {
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          return cbcEncrypt(enc, plaintext, key, iv, aad);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          return gcmEncrypt(enc, plaintext, key, iv, aad);
        default:
          throw new errors_js_1.JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
      }
    };
    exports2.default = encrypt;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/aesgcmkw.js
var require_aesgcmkw = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/aesgcmkw.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unwrap = exports2.wrap = void 0;
    var encrypt_js_1 = require_encrypt();
    var decrypt_js_1 = require_decrypt();
    var iv_js_1 = require_iv();
    var base64url_js_1 = require_base64url();
    async function wrap(alg, key, cek, iv) {
      const jweAlgorithm = alg.slice(0, 7);
      iv || (iv = (0, iv_js_1.default)(jweAlgorithm));
      const { ciphertext: encryptedKey, tag: tag2 } = await (0, encrypt_js_1.default)(jweAlgorithm, cek, key, iv, new Uint8Array(0));
      return { encryptedKey, iv: (0, base64url_js_1.encode)(iv), tag: (0, base64url_js_1.encode)(tag2) };
    }
    exports2.wrap = wrap;
    async function unwrap(alg, key, encryptedKey, iv, tag2) {
      const jweAlgorithm = alg.slice(0, 7);
      return (0, decrypt_js_1.default)(jweAlgorithm, key, encryptedKey, iv, tag2, new Uint8Array(0));
    }
    exports2.unwrap = unwrap;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/decrypt_key_management.js
var require_decrypt_key_management = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/decrypt_key_management.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var aeskw_js_1 = require_aeskw();
    var ECDH = require_ecdhes();
    var pbes2kw_js_1 = require_pbes2kw();
    var rsaes_js_1 = require_rsaes();
    var base64url_js_1 = require_base64url();
    var errors_js_1 = require_errors();
    var cek_js_1 = require_cek();
    var import_js_1 = require_import();
    var check_key_type_js_1 = require_check_key_type();
    var is_object_js_1 = require_is_object();
    var aesgcmkw_js_1 = require_aesgcmkw();
    async function decryptKeyManagement(alg, key, encryptedKey, joseHeader, options) {
      (0, check_key_type_js_1.default)(alg, key, "decrypt");
      switch (alg) {
        case "dir": {
          if (encryptedKey !== void 0)
            throw new errors_js_1.JWEInvalid("Encountered unexpected JWE Encrypted Key");
          return key;
        }
        case "ECDH-ES":
          if (encryptedKey !== void 0)
            throw new errors_js_1.JWEInvalid("Encountered unexpected JWE Encrypted Key");
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW": {
          if (!(0, is_object_js_1.default)(joseHeader.epk))
            throw new errors_js_1.JWEInvalid(`JOSE Header "epk" (Ephemeral Public Key) missing or invalid`);
          if (!ECDH.ecdhAllowed(key))
            throw new errors_js_1.JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
          const epk = await (0, import_js_1.importJWK)(joseHeader.epk, alg);
          let partyUInfo;
          let partyVInfo;
          if (joseHeader.apu !== void 0) {
            if (typeof joseHeader.apu !== "string")
              throw new errors_js_1.JWEInvalid(`JOSE Header "apu" (Agreement PartyUInfo) invalid`);
            partyUInfo = (0, base64url_js_1.decode)(joseHeader.apu);
          }
          if (joseHeader.apv !== void 0) {
            if (typeof joseHeader.apv !== "string")
              throw new errors_js_1.JWEInvalid(`JOSE Header "apv" (Agreement PartyVInfo) invalid`);
            partyVInfo = (0, base64url_js_1.decode)(joseHeader.apv);
          }
          const sharedSecret = await ECDH.deriveKey(epk, key, alg === "ECDH-ES" ? joseHeader.enc : alg, alg === "ECDH-ES" ? (0, cek_js_1.bitLength)(joseHeader.enc) : parseInt(alg.slice(-5, -2), 10), partyUInfo, partyVInfo);
          if (alg === "ECDH-ES")
            return sharedSecret;
          if (encryptedKey === void 0)
            throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
          return (0, aeskw_js_1.unwrap)(alg.slice(-6), sharedSecret, encryptedKey);
        }
        case "RSA1_5":
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512": {
          if (encryptedKey === void 0)
            throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
          return (0, rsaes_js_1.decrypt)(alg, key, encryptedKey);
        }
        case "PBES2-HS256+A128KW":
        case "PBES2-HS384+A192KW":
        case "PBES2-HS512+A256KW": {
          if (encryptedKey === void 0)
            throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
          if (typeof joseHeader.p2c !== "number")
            throw new errors_js_1.JWEInvalid(`JOSE Header "p2c" (PBES2 Count) missing or invalid`);
          const p2cLimit = (options === null || options === void 0 ? void 0 : options.maxPBES2Count) || 1e4;
          if (joseHeader.p2c > p2cLimit)
            throw new errors_js_1.JWEInvalid(`JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds`);
          if (typeof joseHeader.p2s !== "string")
            throw new errors_js_1.JWEInvalid(`JOSE Header "p2s" (PBES2 Salt) missing or invalid`);
          return (0, pbes2kw_js_1.decrypt)(alg, key, encryptedKey, joseHeader.p2c, (0, base64url_js_1.decode)(joseHeader.p2s));
        }
        case "A128KW":
        case "A192KW":
        case "A256KW": {
          if (encryptedKey === void 0)
            throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
          return (0, aeskw_js_1.unwrap)(alg, key, encryptedKey);
        }
        case "A128GCMKW":
        case "A192GCMKW":
        case "A256GCMKW": {
          if (encryptedKey === void 0)
            throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
          if (typeof joseHeader.iv !== "string")
            throw new errors_js_1.JWEInvalid(`JOSE Header "iv" (Initialization Vector) missing or invalid`);
          if (typeof joseHeader.tag !== "string")
            throw new errors_js_1.JWEInvalid(`JOSE Header "tag" (Authentication Tag) missing or invalid`);
          const iv = (0, base64url_js_1.decode)(joseHeader.iv);
          const tag2 = (0, base64url_js_1.decode)(joseHeader.tag);
          return (0, aesgcmkw_js_1.unwrap)(alg, key, encryptedKey, iv, tag2);
        }
        default: {
          throw new errors_js_1.JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
        }
      }
    }
    exports2.default = decryptKeyManagement;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/validate_crit.js
var require_validate_crit = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/validate_crit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors_js_1 = require_errors();
    function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
      if (joseHeader.crit !== void 0 && protectedHeader.crit === void 0) {
        throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
      }
      if (!protectedHeader || protectedHeader.crit === void 0) {
        return /* @__PURE__ */ new Set();
      }
      if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input10) => typeof input10 !== "string" || input10.length === 0)) {
        throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
      }
      let recognized;
      if (recognizedOption !== void 0) {
        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
      } else {
        recognized = recognizedDefault;
      }
      for (const parameter of protectedHeader.crit) {
        if (!recognized.has(parameter)) {
          throw new errors_js_1.JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
        }
        if (joseHeader[parameter] === void 0) {
          throw new Err(`Extension Header Parameter "${parameter}" is missing`);
        } else if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
          throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
        }
      }
      return new Set(protectedHeader.crit);
    }
    exports2.default = validateCrit;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/validate_algorithms.js
var require_validate_algorithms = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/validate_algorithms.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var validateAlgorithms = (option, algorithms) => {
      if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
        throw new TypeError(`"${option}" option must be an array of strings`);
      }
      if (!algorithms) {
        return void 0;
      }
      return new Set(algorithms);
    };
    exports2.default = validateAlgorithms;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwe/flattened/decrypt.js
var require_decrypt2 = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwe/flattened/decrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.flattenedDecrypt = void 0;
    var base64url_js_1 = require_base64url();
    var decrypt_js_1 = require_decrypt();
    var zlib_js_1 = require_zlib();
    var errors_js_1 = require_errors();
    var is_disjoint_js_1 = require_is_disjoint();
    var is_object_js_1 = require_is_object();
    var decrypt_key_management_js_1 = require_decrypt_key_management();
    var buffer_utils_js_1 = require_buffer_utils();
    var cek_js_1 = require_cek();
    var validate_crit_js_1 = require_validate_crit();
    var validate_algorithms_js_1 = require_validate_algorithms();
    async function flattenedDecrypt(jwe, key, options) {
      var _a;
      if (!(0, is_object_js_1.default)(jwe)) {
        throw new errors_js_1.JWEInvalid("Flattened JWE must be an object");
      }
      if (jwe.protected === void 0 && jwe.header === void 0 && jwe.unprotected === void 0) {
        throw new errors_js_1.JWEInvalid("JOSE Header missing");
      }
      if (typeof jwe.iv !== "string") {
        throw new errors_js_1.JWEInvalid("JWE Initialization Vector missing or incorrect type");
      }
      if (typeof jwe.ciphertext !== "string") {
        throw new errors_js_1.JWEInvalid("JWE Ciphertext missing or incorrect type");
      }
      if (typeof jwe.tag !== "string") {
        throw new errors_js_1.JWEInvalid("JWE Authentication Tag missing or incorrect type");
      }
      if (jwe.protected !== void 0 && typeof jwe.protected !== "string") {
        throw new errors_js_1.JWEInvalid("JWE Protected Header incorrect type");
      }
      if (jwe.encrypted_key !== void 0 && typeof jwe.encrypted_key !== "string") {
        throw new errors_js_1.JWEInvalid("JWE Encrypted Key incorrect type");
      }
      if (jwe.aad !== void 0 && typeof jwe.aad !== "string") {
        throw new errors_js_1.JWEInvalid("JWE AAD incorrect type");
      }
      if (jwe.header !== void 0 && !(0, is_object_js_1.default)(jwe.header)) {
        throw new errors_js_1.JWEInvalid("JWE Shared Unprotected Header incorrect type");
      }
      if (jwe.unprotected !== void 0 && !(0, is_object_js_1.default)(jwe.unprotected)) {
        throw new errors_js_1.JWEInvalid("JWE Per-Recipient Unprotected Header incorrect type");
      }
      let parsedProt;
      if (jwe.protected) {
        try {
          const protectedHeader2 = (0, base64url_js_1.decode)(jwe.protected);
          parsedProt = JSON.parse(buffer_utils_js_1.decoder.decode(protectedHeader2));
        } catch {
          throw new errors_js_1.JWEInvalid("JWE Protected Header is invalid");
        }
      }
      if (!(0, is_disjoint_js_1.default)(parsedProt, jwe.header, jwe.unprotected)) {
        throw new errors_js_1.JWEInvalid("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");
      }
      const joseHeader = {
        ...parsedProt,
        ...jwe.header,
        ...jwe.unprotected
      };
      (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, /* @__PURE__ */ new Map(), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
      if (joseHeader.zip !== void 0) {
        if (!parsedProt || !parsedProt.zip) {
          throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
        }
        if (joseHeader.zip !== "DEF") {
          throw new errors_js_1.JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
        }
      }
      const { alg, enc } = joseHeader;
      if (typeof alg !== "string" || !alg) {
        throw new errors_js_1.JWEInvalid("missing JWE Algorithm (alg) in JWE Header");
      }
      if (typeof enc !== "string" || !enc) {
        throw new errors_js_1.JWEInvalid("missing JWE Encryption Algorithm (enc) in JWE Header");
      }
      const keyManagementAlgorithms = options && (0, validate_algorithms_js_1.default)("keyManagementAlgorithms", options.keyManagementAlgorithms);
      const contentEncryptionAlgorithms = options && (0, validate_algorithms_js_1.default)("contentEncryptionAlgorithms", options.contentEncryptionAlgorithms);
      if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {
        throw new errors_js_1.JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
      }
      if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {
        throw new errors_js_1.JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter not allowed');
      }
      let encryptedKey;
      if (jwe.encrypted_key !== void 0) {
        encryptedKey = (0, base64url_js_1.decode)(jwe.encrypted_key);
      }
      let resolvedKey = false;
      if (typeof key === "function") {
        key = await key(parsedProt, jwe);
        resolvedKey = true;
      }
      let cek;
      try {
        cek = await (0, decrypt_key_management_js_1.default)(alg, key, encryptedKey, joseHeader, options);
      } catch (err) {
        if (err instanceof TypeError || err instanceof errors_js_1.JWEInvalid || err instanceof errors_js_1.JOSENotSupported) {
          throw err;
        }
        cek = (0, cek_js_1.default)(enc);
      }
      const iv = (0, base64url_js_1.decode)(jwe.iv);
      const tag2 = (0, base64url_js_1.decode)(jwe.tag);
      const protectedHeader = buffer_utils_js_1.encoder.encode((_a = jwe.protected) !== null && _a !== void 0 ? _a : "");
      let additionalData;
      if (jwe.aad !== void 0) {
        additionalData = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode("."), buffer_utils_js_1.encoder.encode(jwe.aad));
      } else {
        additionalData = protectedHeader;
      }
      let plaintext = await (0, decrypt_js_1.default)(enc, cek, (0, base64url_js_1.decode)(jwe.ciphertext), iv, tag2, additionalData);
      if (joseHeader.zip === "DEF") {
        plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || zlib_js_1.inflate)(plaintext);
      }
      const result = { plaintext };
      if (jwe.protected !== void 0) {
        result.protectedHeader = parsedProt;
      }
      if (jwe.aad !== void 0) {
        result.additionalAuthenticatedData = (0, base64url_js_1.decode)(jwe.aad);
      }
      if (jwe.unprotected !== void 0) {
        result.sharedUnprotectedHeader = jwe.unprotected;
      }
      if (jwe.header !== void 0) {
        result.unprotectedHeader = jwe.header;
      }
      if (resolvedKey) {
        return { ...result, key };
      }
      return result;
    }
    exports2.flattenedDecrypt = flattenedDecrypt;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwe/compact/decrypt.js
var require_decrypt3 = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwe/compact/decrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compactDecrypt = void 0;
    var decrypt_js_1 = require_decrypt2();
    var errors_js_1 = require_errors();
    var buffer_utils_js_1 = require_buffer_utils();
    async function compactDecrypt(jwe, key, options) {
      if (jwe instanceof Uint8Array) {
        jwe = buffer_utils_js_1.decoder.decode(jwe);
      }
      if (typeof jwe !== "string") {
        throw new errors_js_1.JWEInvalid("Compact JWE must be a string or Uint8Array");
      }
      const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag2, length: length5 } = jwe.split(".");
      if (length5 !== 5) {
        throw new errors_js_1.JWEInvalid("Invalid Compact JWE");
      }
      const decrypted = await (0, decrypt_js_1.flattenedDecrypt)({
        ciphertext,
        iv: iv || void 0,
        protected: protectedHeader || void 0,
        tag: tag2 || void 0,
        encrypted_key: encryptedKey || void 0
      }, key, options);
      const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };
      if (typeof key === "function") {
        return { ...result, key: decrypted.key };
      }
      return result;
    }
    exports2.compactDecrypt = compactDecrypt;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwe/general/decrypt.js
var require_decrypt4 = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwe/general/decrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generalDecrypt = void 0;
    var decrypt_js_1 = require_decrypt2();
    var errors_js_1 = require_errors();
    var is_object_js_1 = require_is_object();
    async function generalDecrypt(jwe, key, options) {
      if (!(0, is_object_js_1.default)(jwe)) {
        throw new errors_js_1.JWEInvalid("General JWE must be an object");
      }
      if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(is_object_js_1.default)) {
        throw new errors_js_1.JWEInvalid("JWE Recipients missing or incorrect type");
      }
      if (!jwe.recipients.length) {
        throw new errors_js_1.JWEInvalid("JWE Recipients has no members");
      }
      for (const recipient of jwe.recipients) {
        try {
          return await (0, decrypt_js_1.flattenedDecrypt)({
            aad: jwe.aad,
            ciphertext: jwe.ciphertext,
            encrypted_key: recipient.encrypted_key,
            header: recipient.header,
            iv: jwe.iv,
            protected: jwe.protected,
            tag: jwe.tag,
            unprotected: jwe.unprotected
          }, key, options);
        } catch {
        }
      }
      throw new errors_js_1.JWEDecryptionFailed();
    }
    exports2.generalDecrypt = generalDecrypt;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/asn1_sequence_decoder.js
var require_asn1_sequence_decoder = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/asn1_sequence_decoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tagInteger = 2;
    var tagSequence = 48;
    var Asn1SequenceDecoder = class {
      constructor(buffer3) {
        if (buffer3[0] !== tagSequence) {
          throw new TypeError();
        }
        this.buffer = buffer3;
        this.offset = 1;
        const len = this.decodeLength();
        if (len !== buffer3.length - this.offset) {
          throw new TypeError();
        }
      }
      decodeLength() {
        let length5 = this.buffer[this.offset++];
        if (length5 & 128) {
          const nBytes = length5 & ~128;
          length5 = 0;
          for (let i = 0; i < nBytes; i++)
            length5 = length5 << 8 | this.buffer[this.offset + i];
          this.offset += nBytes;
        }
        return length5;
      }
      unsignedInteger() {
        if (this.buffer[this.offset++] !== tagInteger) {
          throw new TypeError();
        }
        let length5 = this.decodeLength();
        if (this.buffer[this.offset] === 0) {
          this.offset++;
          length5--;
        }
        const result = this.buffer.slice(this.offset, this.offset + length5);
        this.offset += length5;
        return result;
      }
      end() {
        if (this.offset !== this.buffer.length) {
          throw new TypeError();
        }
      }
    };
    exports2.default = Asn1SequenceDecoder;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/key_to_jwk.js
var require_key_to_jwk = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/key_to_jwk.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var base64url_js_1 = require_base64url();
    var asn1_sequence_decoder_js_1 = require_asn1_sequence_decoder();
    var errors_js_1 = require_errors();
    var get_named_curve_js_1 = require_get_named_curve();
    var webcrypto_js_1 = require_webcrypto();
    var is_key_object_js_1 = require_is_key_object();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var is_key_like_js_1 = require_is_key_like();
    var flags_js_1 = require_flags();
    var keyToJWK = (key) => {
      let keyObject;
      if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        if (!key.extractable) {
          throw new TypeError("CryptoKey is not extractable");
        }
        keyObject = crypto_1.KeyObject.from(key);
      } else if ((0, is_key_object_js_1.default)(key)) {
        keyObject = key;
      } else if (key instanceof Uint8Array) {
        return {
          kty: "oct",
          k: (0, base64url_js_1.encode)(key)
        };
      } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, "Uint8Array"));
      }
      if (flags_js_1.jwkExport) {
        if (keyObject.type !== "secret" && !["rsa", "ec", "ed25519", "x25519", "ed448", "x448"].includes(keyObject.asymmetricKeyType)) {
          throw new errors_js_1.JOSENotSupported("Unsupported key asymmetricKeyType");
        }
        return keyObject.export({ format: "jwk" });
      }
      switch (keyObject.type) {
        case "secret":
          return {
            kty: "oct",
            k: (0, base64url_js_1.encode)(keyObject.export())
          };
        case "private":
        case "public": {
          switch (keyObject.asymmetricKeyType) {
            case "rsa": {
              const der = keyObject.export({ format: "der", type: "pkcs1" });
              const dec = new asn1_sequence_decoder_js_1.default(der);
              if (keyObject.type === "private") {
                dec.unsignedInteger();
              }
              const n = (0, base64url_js_1.encode)(dec.unsignedInteger());
              const e = (0, base64url_js_1.encode)(dec.unsignedInteger());
              let jwk;
              if (keyObject.type === "private") {
                jwk = {
                  d: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                  p: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                  q: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                  dp: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                  dq: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                  qi: (0, base64url_js_1.encode)(dec.unsignedInteger())
                };
              }
              dec.end();
              return { kty: "RSA", n, e, ...jwk };
            }
            case "ec": {
              const crv = (0, get_named_curve_js_1.default)(keyObject);
              let len;
              let offset2;
              let correction;
              switch (crv) {
                case "secp256k1":
                  len = 64;
                  offset2 = 31 + 2;
                  correction = -1;
                  break;
                case "P-256":
                  len = 64;
                  offset2 = 34 + 2;
                  correction = -1;
                  break;
                case "P-384":
                  len = 96;
                  offset2 = 33 + 2;
                  correction = -3;
                  break;
                case "P-521":
                  len = 132;
                  offset2 = 33 + 2;
                  correction = -3;
                  break;
                default:
                  throw new errors_js_1.JOSENotSupported("Unsupported curve");
              }
              if (keyObject.type === "public") {
                const der2 = keyObject.export({ type: "spki", format: "der" });
                return {
                  kty: "EC",
                  crv,
                  x: (0, base64url_js_1.encode)(der2.subarray(-len, -len / 2)),
                  y: (0, base64url_js_1.encode)(der2.subarray(-len / 2))
                };
              }
              const der = keyObject.export({ type: "pkcs8", format: "der" });
              if (der.length < 100) {
                offset2 += correction;
              }
              return {
                ...keyToJWK((0, crypto_1.createPublicKey)(keyObject)),
                d: (0, base64url_js_1.encode)(der.subarray(offset2, offset2 + len / 2))
              };
            }
            case "ed25519":
            case "x25519": {
              const crv = (0, get_named_curve_js_1.default)(keyObject);
              if (keyObject.type === "public") {
                const der2 = keyObject.export({ type: "spki", format: "der" });
                return {
                  kty: "OKP",
                  crv,
                  x: (0, base64url_js_1.encode)(der2.subarray(-32))
                };
              }
              const der = keyObject.export({ type: "pkcs8", format: "der" });
              return {
                ...keyToJWK((0, crypto_1.createPublicKey)(keyObject)),
                d: (0, base64url_js_1.encode)(der.subarray(-32))
              };
            }
            case "ed448":
            case "x448": {
              const crv = (0, get_named_curve_js_1.default)(keyObject);
              if (keyObject.type === "public") {
                const der2 = keyObject.export({ type: "spki", format: "der" });
                return {
                  kty: "OKP",
                  crv,
                  x: (0, base64url_js_1.encode)(der2.subarray(crv === "Ed448" ? -57 : -56))
                };
              }
              const der = keyObject.export({ type: "pkcs8", format: "der" });
              return {
                ...keyToJWK((0, crypto_1.createPublicKey)(keyObject)),
                d: (0, base64url_js_1.encode)(der.subarray(crv === "Ed448" ? -57 : -56))
              };
            }
            default:
              throw new errors_js_1.JOSENotSupported("Unsupported key asymmetricKeyType");
          }
        }
        default:
          throw new errors_js_1.JOSENotSupported("Unsupported key type");
      }
    };
    exports2.default = keyToJWK;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/key/export.js
var require_export = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/key/export.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exportJWK = exports2.exportPKCS8 = exports2.exportSPKI = void 0;
    var asn1_js_1 = require_asn1();
    var asn1_js_2 = require_asn1();
    var key_to_jwk_js_1 = require_key_to_jwk();
    async function exportSPKI(key) {
      return (0, asn1_js_1.toSPKI)(key);
    }
    exports2.exportSPKI = exportSPKI;
    async function exportPKCS8(key) {
      return (0, asn1_js_2.toPKCS8)(key);
    }
    exports2.exportPKCS8 = exportPKCS8;
    async function exportJWK(key) {
      return (0, key_to_jwk_js_1.default)(key);
    }
    exports2.exportJWK = exportJWK;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/encrypt_key_management.js
var require_encrypt_key_management = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/encrypt_key_management.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var aeskw_js_1 = require_aeskw();
    var ECDH = require_ecdhes();
    var pbes2kw_js_1 = require_pbes2kw();
    var rsaes_js_1 = require_rsaes();
    var base64url_js_1 = require_base64url();
    var cek_js_1 = require_cek();
    var errors_js_1 = require_errors();
    var export_js_1 = require_export();
    var check_key_type_js_1 = require_check_key_type();
    var aesgcmkw_js_1 = require_aesgcmkw();
    async function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {
      let encryptedKey;
      let parameters;
      let cek;
      (0, check_key_type_js_1.default)(alg, key, "encrypt");
      switch (alg) {
        case "dir": {
          cek = key;
          break;
        }
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW": {
          if (!ECDH.ecdhAllowed(key)) {
            throw new errors_js_1.JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
          }
          const { apu, apv } = providedParameters;
          let { epk: ephemeralKey } = providedParameters;
          ephemeralKey || (ephemeralKey = (await ECDH.generateEpk(key)).privateKey);
          const { x, y, crv, kty } = await (0, export_js_1.exportJWK)(ephemeralKey);
          const sharedSecret = await ECDH.deriveKey(key, ephemeralKey, alg === "ECDH-ES" ? enc : alg, alg === "ECDH-ES" ? (0, cek_js_1.bitLength)(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);
          parameters = { epk: { x, crv, kty } };
          if (kty === "EC")
            parameters.epk.y = y;
          if (apu)
            parameters.apu = (0, base64url_js_1.encode)(apu);
          if (apv)
            parameters.apv = (0, base64url_js_1.encode)(apv);
          if (alg === "ECDH-ES") {
            cek = sharedSecret;
            break;
          }
          cek = providedCek || (0, cek_js_1.default)(enc);
          const kwAlg = alg.slice(-6);
          encryptedKey = await (0, aeskw_js_1.wrap)(kwAlg, sharedSecret, cek);
          break;
        }
        case "RSA1_5":
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512": {
          cek = providedCek || (0, cek_js_1.default)(enc);
          encryptedKey = await (0, rsaes_js_1.encrypt)(alg, key, cek);
          break;
        }
        case "PBES2-HS256+A128KW":
        case "PBES2-HS384+A192KW":
        case "PBES2-HS512+A256KW": {
          cek = providedCek || (0, cek_js_1.default)(enc);
          const { p2c, p2s } = providedParameters;
          ({ encryptedKey, ...parameters } = await (0, pbes2kw_js_1.encrypt)(alg, key, cek, p2c, p2s));
          break;
        }
        case "A128KW":
        case "A192KW":
        case "A256KW": {
          cek = providedCek || (0, cek_js_1.default)(enc);
          encryptedKey = await (0, aeskw_js_1.wrap)(alg, key, cek);
          break;
        }
        case "A128GCMKW":
        case "A192GCMKW":
        case "A256GCMKW": {
          cek = providedCek || (0, cek_js_1.default)(enc);
          const { iv } = providedParameters;
          ({ encryptedKey, ...parameters } = await (0, aesgcmkw_js_1.wrap)(alg, key, cek, iv));
          break;
        }
        default: {
          throw new errors_js_1.JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
        }
      }
      return { cek, encryptedKey, parameters };
    }
    exports2.default = encryptKeyManagement;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwe/flattened/encrypt.js
var require_encrypt2 = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwe/flattened/encrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FlattenedEncrypt = exports2.unprotected = void 0;
    var base64url_js_1 = require_base64url();
    var encrypt_js_1 = require_encrypt();
    var zlib_js_1 = require_zlib();
    var iv_js_1 = require_iv();
    var encrypt_key_management_js_1 = require_encrypt_key_management();
    var errors_js_1 = require_errors();
    var is_disjoint_js_1 = require_is_disjoint();
    var buffer_utils_js_1 = require_buffer_utils();
    var validate_crit_js_1 = require_validate_crit();
    exports2.unprotected = Symbol();
    var FlattenedEncrypt = class {
      constructor(plaintext) {
        if (!(plaintext instanceof Uint8Array)) {
          throw new TypeError("plaintext must be an instance of Uint8Array");
        }
        this._plaintext = plaintext;
      }
      setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
          throw new TypeError("setKeyManagementParameters can only be called once");
        }
        this._keyManagementParameters = parameters;
        return this;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._sharedUnprotectedHeader) {
          throw new TypeError("setSharedUnprotectedHeader can only be called once");
        }
        this._sharedUnprotectedHeader = sharedUnprotectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
      }
      setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
      }
      setContentEncryptionKey(cek) {
        if (this._cek) {
          throw new TypeError("setContentEncryptionKey can only be called once");
        }
        this._cek = cek;
        return this;
      }
      setInitializationVector(iv) {
        if (this._iv) {
          throw new TypeError("setInitializationVector can only be called once");
        }
        this._iv = iv;
        return this;
      }
      async encrypt(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {
          throw new errors_js_1.JWEInvalid("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");
        }
        if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {
          throw new errors_js_1.JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader,
          ...this._sharedUnprotectedHeader
        };
        (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, /* @__PURE__ */ new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        if (joseHeader.zip !== void 0) {
          if (!this._protectedHeader || !this._protectedHeader.zip) {
            throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
          }
          if (joseHeader.zip !== "DEF") {
            throw new errors_js_1.JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
          }
        }
        const { alg, enc } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new errors_js_1.JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
        }
        if (typeof enc !== "string" || !enc) {
          throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
        }
        let encryptedKey;
        if (alg === "dir") {
          if (this._cek) {
            throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption");
          }
        } else if (alg === "ECDH-ES") {
          if (this._cek) {
            throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");
          }
        }
        let cek;
        {
          let parameters;
          ({ cek, encryptedKey, parameters } = await (0, encrypt_key_management_js_1.default)(alg, enc, key, this._cek, this._keyManagementParameters));
          if (parameters) {
            if (options && exports2.unprotected in options) {
              if (!this._unprotectedHeader) {
                this.setUnprotectedHeader(parameters);
              } else {
                this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };
              }
            } else {
              if (!this._protectedHeader) {
                this.setProtectedHeader(parameters);
              } else {
                this._protectedHeader = { ...this._protectedHeader, ...parameters };
              }
            }
          }
        }
        this._iv || (this._iv = (0, iv_js_1.default)(enc));
        let additionalData;
        let protectedHeader;
        let aadMember;
        if (this._protectedHeader) {
          protectedHeader = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(JSON.stringify(this._protectedHeader)));
        } else {
          protectedHeader = buffer_utils_js_1.encoder.encode("");
        }
        if (this._aad) {
          aadMember = (0, base64url_js_1.encode)(this._aad);
          additionalData = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode("."), buffer_utils_js_1.encoder.encode(aadMember));
        } else {
          additionalData = protectedHeader;
        }
        let ciphertext;
        let tag2;
        if (joseHeader.zip === "DEF") {
          const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || zlib_js_1.deflate)(this._plaintext);
          ({ ciphertext, tag: tag2 } = await (0, encrypt_js_1.default)(enc, deflated, cek, this._iv, additionalData));
        } else {
          ;
          ({ ciphertext, tag: tag2 } = await (0, encrypt_js_1.default)(enc, this._plaintext, cek, this._iv, additionalData));
        }
        const jwe = {
          ciphertext: (0, base64url_js_1.encode)(ciphertext),
          iv: (0, base64url_js_1.encode)(this._iv),
          tag: (0, base64url_js_1.encode)(tag2)
        };
        if (encryptedKey) {
          jwe.encrypted_key = (0, base64url_js_1.encode)(encryptedKey);
        }
        if (aadMember) {
          jwe.aad = aadMember;
        }
        if (this._protectedHeader) {
          jwe.protected = buffer_utils_js_1.decoder.decode(protectedHeader);
        }
        if (this._sharedUnprotectedHeader) {
          jwe.unprotected = this._sharedUnprotectedHeader;
        }
        if (this._unprotectedHeader) {
          jwe.header = this._unprotectedHeader;
        }
        return jwe;
      }
    };
    exports2.FlattenedEncrypt = FlattenedEncrypt;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwe/general/encrypt.js
var require_encrypt3 = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwe/general/encrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GeneralEncrypt = void 0;
    var encrypt_js_1 = require_encrypt2();
    var errors_js_1 = require_errors();
    var cek_js_1 = require_cek();
    var is_disjoint_js_1 = require_is_disjoint();
    var encrypt_key_management_js_1 = require_encrypt_key_management();
    var base64url_js_1 = require_base64url();
    var validate_crit_js_1 = require_validate_crit();
    var IndividualRecipient = class {
      constructor(enc, key, options) {
        this.parent = enc;
        this.key = key;
        this.options = options;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
      }
      addRecipient(...args) {
        return this.parent.addRecipient(...args);
      }
      encrypt(...args) {
        return this.parent.encrypt(...args);
      }
      done() {
        return this.parent;
      }
    };
    var GeneralEncrypt = class {
      constructor(plaintext) {
        this._recipients = [];
        this._plaintext = plaintext;
      }
      addRecipient(key, options) {
        const recipient = new IndividualRecipient(this, key, { crit: options === null || options === void 0 ? void 0 : options.crit });
        this._recipients.push(recipient);
        return recipient;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setSharedUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = sharedUnprotectedHeader;
        return this;
      }
      setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
      }
      async encrypt(options) {
        var _a, _b, _c;
        if (!this._recipients.length) {
          throw new errors_js_1.JWEInvalid("at least one recipient must be added");
        }
        options = { deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw };
        if (this._recipients.length === 1) {
          const [recipient] = this._recipients;
          const flattened = await new encrypt_js_1.FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).encrypt(recipient.key, { ...recipient.options, ...options });
          let jwe2 = {
            ciphertext: flattened.ciphertext,
            iv: flattened.iv,
            recipients: [{}],
            tag: flattened.tag
          };
          if (flattened.aad)
            jwe2.aad = flattened.aad;
          if (flattened.protected)
            jwe2.protected = flattened.protected;
          if (flattened.unprotected)
            jwe2.unprotected = flattened.unprotected;
          if (flattened.encrypted_key)
            jwe2.recipients[0].encrypted_key = flattened.encrypted_key;
          if (flattened.header)
            jwe2.recipients[0].header = flattened.header;
          return jwe2;
        }
        let enc;
        for (let i = 0; i < this._recipients.length; i++) {
          const recipient = this._recipients[i];
          if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {
            throw new errors_js_1.JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
          }
          const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...recipient.unprotectedHeader
          };
          const { alg } = joseHeader;
          if (typeof alg !== "string" || !alg) {
            throw new errors_js_1.JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
          }
          if (alg === "dir" || alg === "ECDH-ES") {
            throw new errors_js_1.JWEInvalid('"dir" and "ECDH-ES" alg may only be used with a single recipient');
          }
          if (typeof joseHeader.enc !== "string" || !joseHeader.enc) {
            throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
          }
          if (!enc) {
            enc = joseHeader.enc;
          } else if (enc !== joseHeader.enc) {
            throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');
          }
          (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, /* @__PURE__ */ new Map(), recipient.options.crit, this._protectedHeader, joseHeader);
          if (joseHeader.zip !== void 0) {
            if (!this._protectedHeader || !this._protectedHeader.zip) {
              throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
            }
          }
        }
        const cek = (0, cek_js_1.default)(enc);
        let jwe = {
          ciphertext: "",
          iv: "",
          recipients: [],
          tag: ""
        };
        for (let i = 0; i < this._recipients.length; i++) {
          const recipient = this._recipients[i];
          const target = {};
          jwe.recipients.push(target);
          const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...recipient.unprotectedHeader
          };
          const p2c = joseHeader.alg.startsWith("PBES2") ? 2048 + i : void 0;
          if (i === 0) {
            const flattened = await new encrypt_js_1.FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(cek).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).setKeyManagementParameters({ p2c }).encrypt(recipient.key, {
              ...recipient.options,
              ...options,
              [encrypt_js_1.unprotected]: true
            });
            jwe.ciphertext = flattened.ciphertext;
            jwe.iv = flattened.iv;
            jwe.tag = flattened.tag;
            if (flattened.aad)
              jwe.aad = flattened.aad;
            if (flattened.protected)
              jwe.protected = flattened.protected;
            if (flattened.unprotected)
              jwe.unprotected = flattened.unprotected;
            target.encrypted_key = flattened.encrypted_key;
            if (flattened.header)
              target.header = flattened.header;
            continue;
          }
          const { encryptedKey, parameters } = await (0, encrypt_key_management_js_1.default)(((_a = recipient.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) || ((_b = this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) || ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient.key, cek, { p2c });
          target.encrypted_key = (0, base64url_js_1.encode)(encryptedKey);
          if (recipient.unprotectedHeader || parameters)
            target.header = { ...recipient.unprotectedHeader, ...parameters };
        }
        return jwe;
      }
    };
    exports2.GeneralEncrypt = GeneralEncrypt;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/dsa_digest.js
var require_dsa_digest = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/dsa_digest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors_js_1 = require_errors();
    function dsaDigest(alg) {
      switch (alg) {
        case "PS256":
        case "RS256":
        case "ES256":
        case "ES256K":
          return "sha256";
        case "PS384":
        case "RS384":
        case "ES384":
          return "sha384";
        case "PS512":
        case "RS512":
        case "ES512":
          return "sha512";
        case "EdDSA":
          return void 0;
        default:
          throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
      }
    }
    exports2.default = dsaDigest;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/node_key.js
var require_node_key = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/node_key.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var get_named_curve_js_1 = require_get_named_curve();
    var errors_js_1 = require_errors();
    var check_modulus_length_js_1 = require_check_modulus_length();
    var flags_js_1 = require_flags();
    var PSS = {
      padding: crypto_1.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto_1.constants.RSA_PSS_SALTLEN_DIGEST
    };
    var ecCurveAlgMap = /* @__PURE__ */ new Map([
      ["ES256", "P-256"],
      ["ES256K", "secp256k1"],
      ["ES384", "P-384"],
      ["ES512", "P-521"]
    ]);
    function keyForCrypto(alg, key) {
      switch (alg) {
        case "EdDSA":
          if (!["ed25519", "ed448"].includes(key.asymmetricKeyType)) {
            throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be ed25519 or ed448");
          }
          return key;
        case "RS256":
        case "RS384":
        case "RS512":
          if (key.asymmetricKeyType !== "rsa") {
            throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");
          }
          (0, check_modulus_length_js_1.default)(key, alg);
          return key;
        case (flags_js_1.rsaPssParams && "PS256"):
        case (flags_js_1.rsaPssParams && "PS384"):
        case (flags_js_1.rsaPssParams && "PS512"):
          if (key.asymmetricKeyType === "rsa-pss") {
            const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
            const length5 = parseInt(alg.slice(-3), 10);
            if (hashAlgorithm !== void 0 && (hashAlgorithm !== `sha${length5}` || mgf1HashAlgorithm !== hashAlgorithm)) {
              throw new TypeError(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${alg}`);
            }
            if (saltLength !== void 0 && saltLength > length5 >> 3) {
              throw new TypeError(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${alg}`);
            }
          } else if (key.asymmetricKeyType !== "rsa") {
            throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa or rsa-pss");
          }
          (0, check_modulus_length_js_1.default)(key, alg);
          return { key, ...PSS };
        case (!flags_js_1.rsaPssParams && "PS256"):
        case (!flags_js_1.rsaPssParams && "PS384"):
        case (!flags_js_1.rsaPssParams && "PS512"):
          if (key.asymmetricKeyType !== "rsa") {
            throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");
          }
          (0, check_modulus_length_js_1.default)(key, alg);
          return { key, ...PSS };
        case "ES256":
        case "ES256K":
        case "ES384":
        case "ES512": {
          if (key.asymmetricKeyType !== "ec") {
            throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be ec");
          }
          const actual = (0, get_named_curve_js_1.default)(key);
          const expected = ecCurveAlgMap.get(alg);
          if (actual !== expected) {
            throw new TypeError(`Invalid key curve for the algorithm, its curve must be ${expected}, got ${actual}`);
          }
          return { dsaEncoding: "ieee-p1363", key };
        }
        default:
          throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
      }
    }
    exports2.default = keyForCrypto;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/hmac_digest.js
var require_hmac_digest = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/hmac_digest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors_js_1 = require_errors();
    function hmacDigest(alg) {
      switch (alg) {
        case "HS256":
          return "sha256";
        case "HS384":
          return "sha384";
        case "HS512":
          return "sha512";
        default:
          throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
      }
    }
    exports2.default = hmacDigest;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/get_sign_verify_key.js
var require_get_sign_verify_key = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/get_sign_verify_key.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var webcrypto_js_1 = require_webcrypto();
    var crypto_key_js_1 = require_crypto_key();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var is_key_like_js_1 = require_is_key_like();
    function getSignVerifyKey(alg, key, usage) {
      if (key instanceof Uint8Array) {
        if (!alg.startsWith("HS")) {
          throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
        }
        return (0, crypto_1.createSecretKey)(key);
      }
      if (key instanceof crypto_1.KeyObject) {
        return key;
      }
      if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        (0, crypto_key_js_1.checkSigCryptoKey)(key, alg, usage);
        return crypto_1.KeyObject.from(key);
      }
      throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, "Uint8Array"));
    }
    exports2.default = getSignVerifyKey;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/sign.js
var require_sign = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/sign.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto9 = require("crypto");
    var util_1 = require("util");
    var dsa_digest_js_1 = require_dsa_digest();
    var hmac_digest_js_1 = require_hmac_digest();
    var node_key_js_1 = require_node_key();
    var get_sign_verify_key_js_1 = require_get_sign_verify_key();
    var oneShotSign;
    if (crypto9.sign.length > 3) {
      oneShotSign = (0, util_1.promisify)(crypto9.sign);
    } else {
      oneShotSign = crypto9.sign;
    }
    var sign2 = async (alg, key, data) => {
      const keyObject = (0, get_sign_verify_key_js_1.default)(alg, key, "sign");
      if (alg.startsWith("HS")) {
        const hmac = crypto9.createHmac((0, hmac_digest_js_1.default)(alg), keyObject);
        hmac.update(data);
        return hmac.digest();
      }
      return oneShotSign((0, dsa_digest_js_1.default)(alg), data, (0, node_key_js_1.default)(alg, keyObject));
    };
    exports2.default = sign2;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/verify.js
var require_verify = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/verify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto9 = require("crypto");
    var util_1 = require("util");
    var dsa_digest_js_1 = require_dsa_digest();
    var node_key_js_1 = require_node_key();
    var sign_js_1 = require_sign();
    var get_sign_verify_key_js_1 = require_get_sign_verify_key();
    var flags_js_1 = require_flags();
    var oneShotVerify;
    if (crypto9.verify.length > 4 && flags_js_1.oneShotCallback) {
      oneShotVerify = (0, util_1.promisify)(crypto9.verify);
    } else {
      oneShotVerify = crypto9.verify;
    }
    var verify2 = async (alg, key, signature, data) => {
      const keyObject = (0, get_sign_verify_key_js_1.default)(alg, key, "verify");
      if (alg.startsWith("HS")) {
        const expected = await (0, sign_js_1.default)(alg, keyObject, data);
        const actual = signature;
        try {
          return crypto9.timingSafeEqual(actual, expected);
        } catch {
          return false;
        }
      }
      const algorithm2 = (0, dsa_digest_js_1.default)(alg);
      const keyInput = (0, node_key_js_1.default)(alg, keyObject);
      try {
        return await oneShotVerify(algorithm2, data, keyInput, signature);
      } catch {
        return false;
      }
    };
    exports2.default = verify2;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jws/flattened/verify.js
var require_verify2 = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jws/flattened/verify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.flattenedVerify = void 0;
    var base64url_js_1 = require_base64url();
    var verify_js_1 = require_verify();
    var errors_js_1 = require_errors();
    var buffer_utils_js_1 = require_buffer_utils();
    var is_disjoint_js_1 = require_is_disjoint();
    var is_object_js_1 = require_is_object();
    var check_key_type_js_1 = require_check_key_type();
    var validate_crit_js_1 = require_validate_crit();
    var validate_algorithms_js_1 = require_validate_algorithms();
    async function flattenedVerify(jws, key, options) {
      var _a;
      if (!(0, is_object_js_1.default)(jws)) {
        throw new errors_js_1.JWSInvalid("Flattened JWS must be an object");
      }
      if (jws.protected === void 0 && jws.header === void 0) {
        throw new errors_js_1.JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
      }
      if (jws.protected !== void 0 && typeof jws.protected !== "string") {
        throw new errors_js_1.JWSInvalid("JWS Protected Header incorrect type");
      }
      if (jws.payload === void 0) {
        throw new errors_js_1.JWSInvalid("JWS Payload missing");
      }
      if (typeof jws.signature !== "string") {
        throw new errors_js_1.JWSInvalid("JWS Signature missing or incorrect type");
      }
      if (jws.header !== void 0 && !(0, is_object_js_1.default)(jws.header)) {
        throw new errors_js_1.JWSInvalid("JWS Unprotected Header incorrect type");
      }
      let parsedProt = {};
      if (jws.protected) {
        try {
          const protectedHeader = (0, base64url_js_1.decode)(jws.protected);
          parsedProt = JSON.parse(buffer_utils_js_1.decoder.decode(protectedHeader));
        } catch {
          throw new errors_js_1.JWSInvalid("JWS Protected Header is invalid");
        }
      }
      if (!(0, is_disjoint_js_1.default)(parsedProt, jws.header)) {
        throw new errors_js_1.JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
      }
      const joseHeader = {
        ...parsedProt,
        ...jws.header
      };
      const extensions = (0, validate_crit_js_1.default)(errors_js_1.JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
      let b64 = true;
      if (extensions.has("b64")) {
        b64 = parsedProt.b64;
        if (typeof b64 !== "boolean") {
          throw new errors_js_1.JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
        }
      }
      const { alg } = joseHeader;
      if (typeof alg !== "string" || !alg) {
        throw new errors_js_1.JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
      }
      const algorithms = options && (0, validate_algorithms_js_1.default)("algorithms", options.algorithms);
      if (algorithms && !algorithms.has(alg)) {
        throw new errors_js_1.JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
      }
      if (b64) {
        if (typeof jws.payload !== "string") {
          throw new errors_js_1.JWSInvalid("JWS Payload must be a string");
        }
      } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
        throw new errors_js_1.JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
      }
      let resolvedKey = false;
      if (typeof key === "function") {
        key = await key(parsedProt, jws);
        resolvedKey = true;
      }
      (0, check_key_type_js_1.default)(alg, key, "verify");
      const data = (0, buffer_utils_js_1.concat)(buffer_utils_js_1.encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ""), buffer_utils_js_1.encoder.encode("."), typeof jws.payload === "string" ? buffer_utils_js_1.encoder.encode(jws.payload) : jws.payload);
      const signature = (0, base64url_js_1.decode)(jws.signature);
      const verified = await (0, verify_js_1.default)(alg, key, signature, data);
      if (!verified) {
        throw new errors_js_1.JWSSignatureVerificationFailed();
      }
      let payload;
      if (b64) {
        payload = (0, base64url_js_1.decode)(jws.payload);
      } else if (typeof jws.payload === "string") {
        payload = buffer_utils_js_1.encoder.encode(jws.payload);
      } else {
        payload = jws.payload;
      }
      const result = { payload };
      if (jws.protected !== void 0) {
        result.protectedHeader = parsedProt;
      }
      if (jws.header !== void 0) {
        result.unprotectedHeader = jws.header;
      }
      if (resolvedKey) {
        return { ...result, key };
      }
      return result;
    }
    exports2.flattenedVerify = flattenedVerify;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jws/compact/verify.js
var require_verify3 = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jws/compact/verify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compactVerify = void 0;
    var verify_js_1 = require_verify2();
    var errors_js_1 = require_errors();
    var buffer_utils_js_1 = require_buffer_utils();
    async function compactVerify(jws, key, options) {
      if (jws instanceof Uint8Array) {
        jws = buffer_utils_js_1.decoder.decode(jws);
      }
      if (typeof jws !== "string") {
        throw new errors_js_1.JWSInvalid("Compact JWS must be a string or Uint8Array");
      }
      const { 0: protectedHeader, 1: payload, 2: signature, length: length5 } = jws.split(".");
      if (length5 !== 3) {
        throw new errors_js_1.JWSInvalid("Invalid Compact JWS");
      }
      const verified = await (0, verify_js_1.flattenedVerify)({ payload, protected: protectedHeader, signature }, key, options);
      const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
      if (typeof key === "function") {
        return { ...result, key: verified.key };
      }
      return result;
    }
    exports2.compactVerify = compactVerify;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jws/general/verify.js
var require_verify4 = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jws/general/verify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generalVerify = void 0;
    var verify_js_1 = require_verify2();
    var errors_js_1 = require_errors();
    var is_object_js_1 = require_is_object();
    async function generalVerify(jws, key, options) {
      if (!(0, is_object_js_1.default)(jws)) {
        throw new errors_js_1.JWSInvalid("General JWS must be an object");
      }
      if (!Array.isArray(jws.signatures) || !jws.signatures.every(is_object_js_1.default)) {
        throw new errors_js_1.JWSInvalid("JWS Signatures missing or incorrect type");
      }
      for (const signature of jws.signatures) {
        try {
          return await (0, verify_js_1.flattenedVerify)({
            header: signature.header,
            payload: jws.payload,
            protected: signature.protected,
            signature: signature.signature
          }, key, options);
        } catch {
        }
      }
      throw new errors_js_1.JWSSignatureVerificationFailed();
    }
    exports2.generalVerify = generalVerify;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/epoch.js
var require_epoch = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/epoch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = (date) => Math.floor(date.getTime() / 1e3);
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/secs.js
var require_secs = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/secs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var minute = 60;
    var hour = minute * 60;
    var day = hour * 24;
    var week = day * 7;
    var year = day * 365.25;
    var REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
    exports2.default = (str) => {
      const matched = REGEX.exec(str);
      if (!matched) {
        throw new TypeError("Invalid time period format");
      }
      const value = parseFloat(matched[1]);
      const unit = matched[2].toLowerCase();
      switch (unit) {
        case "sec":
        case "secs":
        case "second":
        case "seconds":
        case "s":
          return Math.round(value);
        case "minute":
        case "minutes":
        case "min":
        case "mins":
        case "m":
          return Math.round(value * minute);
        case "hour":
        case "hours":
        case "hr":
        case "hrs":
        case "h":
          return Math.round(value * hour);
        case "day":
        case "days":
        case "d":
          return Math.round(value * day);
        case "week":
        case "weeks":
        case "w":
          return Math.round(value * week);
        default:
          return Math.round(value * year);
      }
    };
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/jwt_claims_set.js
var require_jwt_claims_set = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/lib/jwt_claims_set.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors_js_1 = require_errors();
    var buffer_utils_js_1 = require_buffer_utils();
    var epoch_js_1 = require_epoch();
    var secs_js_1 = require_secs();
    var is_object_js_1 = require_is_object();
    var normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
    var checkAudiencePresence = (audPayload, audOption) => {
      if (typeof audPayload === "string") {
        return audOption.includes(audPayload);
      }
      if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
      }
      return false;
    };
    exports2.default = (protectedHeader, encodedPayload, options = {}) => {
      const { typ } = options;
      if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
      }
      let payload;
      try {
        payload = JSON.parse(buffer_utils_js_1.decoder.decode(encodedPayload));
      } catch {
      }
      if (!(0, is_object_js_1.default)(payload)) {
        throw new errors_js_1.JWTInvalid("JWT Claims Set must be a top-level JSON object");
      }
      const { issuer } = options;
      if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
      }
      const { subject } = options;
      if (subject && payload.sub !== subject) {
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
      }
      const { audience } = options;
      if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
      }
      let tolerance;
      switch (typeof options.clockTolerance) {
        case "string":
          tolerance = (0, secs_js_1.default)(options.clockTolerance);
          break;
        case "number":
          tolerance = options.clockTolerance;
          break;
        case "undefined":
          tolerance = 0;
          break;
        default:
          throw new TypeError("Invalid clockTolerance option type");
      }
      const { currentDate } = options;
      const now2 = (0, epoch_js_1.default)(currentDate || /* @__PURE__ */ new Date());
      if ((payload.iat !== void 0 || options.maxTokenAge) && typeof payload.iat !== "number") {
        throw new errors_js_1.JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
      }
      if (payload.nbf !== void 0) {
        if (typeof payload.nbf !== "number") {
          throw new errors_js_1.JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
        }
        if (payload.nbf > now2 + tolerance) {
          throw new errors_js_1.JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
        }
      }
      if (payload.exp !== void 0) {
        if (typeof payload.exp !== "number") {
          throw new errors_js_1.JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
        }
        if (payload.exp <= now2 - tolerance) {
          throw new errors_js_1.JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
        }
      }
      if (options.maxTokenAge) {
        const age = now2 - payload.iat;
        const max = typeof options.maxTokenAge === "number" ? options.maxTokenAge : (0, secs_js_1.default)(options.maxTokenAge);
        if (age - tolerance > max) {
          throw new errors_js_1.JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
        }
        if (age < 0 - tolerance) {
          throw new errors_js_1.JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
        }
      }
      return payload;
    };
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwt/verify.js
var require_verify5 = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwt/verify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.jwtVerify = void 0;
    var verify_js_1 = require_verify3();
    var jwt_claims_set_js_1 = require_jwt_claims_set();
    var errors_js_1 = require_errors();
    async function jwtVerify(jwt, key, options) {
      var _a;
      const verified = await (0, verify_js_1.compactVerify)(jwt, key, options);
      if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes("b64")) && verified.protectedHeader.b64 === false) {
        throw new errors_js_1.JWTInvalid("JWTs MUST NOT use unencoded payload");
      }
      const payload = (0, jwt_claims_set_js_1.default)(verified.protectedHeader, verified.payload, options);
      const result = { payload, protectedHeader: verified.protectedHeader };
      if (typeof key === "function") {
        return { ...result, key: verified.key };
      }
      return result;
    }
    exports2.jwtVerify = jwtVerify;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwt/decrypt.js
var require_decrypt5 = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwt/decrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.jwtDecrypt = void 0;
    var decrypt_js_1 = require_decrypt3();
    var jwt_claims_set_js_1 = require_jwt_claims_set();
    var errors_js_1 = require_errors();
    async function jwtDecrypt(jwt, key, options) {
      const decrypted = await (0, decrypt_js_1.compactDecrypt)(jwt, key, options);
      const payload = (0, jwt_claims_set_js_1.default)(decrypted.protectedHeader, decrypted.plaintext, options);
      const { protectedHeader } = decrypted;
      if (protectedHeader.iss !== void 0 && protectedHeader.iss !== payload.iss) {
        throw new errors_js_1.JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch', "iss", "mismatch");
      }
      if (protectedHeader.sub !== void 0 && protectedHeader.sub !== payload.sub) {
        throw new errors_js_1.JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch', "sub", "mismatch");
      }
      if (protectedHeader.aud !== void 0 && JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {
        throw new errors_js_1.JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch', "aud", "mismatch");
      }
      const result = { payload, protectedHeader };
      if (typeof key === "function") {
        return { ...result, key: decrypted.key };
      }
      return result;
    }
    exports2.jwtDecrypt = jwtDecrypt;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwe/compact/encrypt.js
var require_encrypt4 = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwe/compact/encrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompactEncrypt = void 0;
    var encrypt_js_1 = require_encrypt2();
    var CompactEncrypt = class {
      constructor(plaintext) {
        this._flattened = new encrypt_js_1.FlattenedEncrypt(plaintext);
      }
      setContentEncryptionKey(cek) {
        this._flattened.setContentEncryptionKey(cek);
        return this;
      }
      setInitializationVector(iv) {
        this._flattened.setInitializationVector(iv);
        return this;
      }
      setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
      }
      setKeyManagementParameters(parameters) {
        this._flattened.setKeyManagementParameters(parameters);
        return this;
      }
      async encrypt(key, options) {
        const jwe = await this._flattened.encrypt(key, options);
        return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join(".");
      }
    };
    exports2.CompactEncrypt = CompactEncrypt;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jws/flattened/sign.js
var require_sign2 = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jws/flattened/sign.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FlattenedSign = void 0;
    var base64url_js_1 = require_base64url();
    var sign_js_1 = require_sign();
    var is_disjoint_js_1 = require_is_disjoint();
    var errors_js_1 = require_errors();
    var buffer_utils_js_1 = require_buffer_utils();
    var check_key_type_js_1 = require_check_key_type();
    var validate_crit_js_1 = require_validate_crit();
    var FlattenedSign = class {
      constructor(payload) {
        if (!(payload instanceof Uint8Array)) {
          throw new TypeError("payload must be an instance of Uint8Array");
        }
        this._payload = payload;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
      }
      async sign(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader) {
          throw new errors_js_1.JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
        }
        if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader)) {
          throw new errors_js_1.JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader
        };
        const extensions = (0, validate_crit_js_1.default)(errors_js_1.JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        let b64 = true;
        if (extensions.has("b64")) {
          b64 = this._protectedHeader.b64;
          if (typeof b64 !== "boolean") {
            throw new errors_js_1.JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
          }
        }
        const { alg } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new errors_js_1.JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
        }
        (0, check_key_type_js_1.default)(alg, key, "sign");
        let payload = this._payload;
        if (b64) {
          payload = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(payload));
        }
        let protectedHeader;
        if (this._protectedHeader) {
          protectedHeader = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(JSON.stringify(this._protectedHeader)));
        } else {
          protectedHeader = buffer_utils_js_1.encoder.encode("");
        }
        const data = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode("."), payload);
        const signature = await (0, sign_js_1.default)(alg, key, data);
        const jws = {
          signature: (0, base64url_js_1.encode)(signature),
          payload: ""
        };
        if (b64) {
          jws.payload = buffer_utils_js_1.decoder.decode(payload);
        }
        if (this._unprotectedHeader) {
          jws.header = this._unprotectedHeader;
        }
        if (this._protectedHeader) {
          jws.protected = buffer_utils_js_1.decoder.decode(protectedHeader);
        }
        return jws;
      }
    };
    exports2.FlattenedSign = FlattenedSign;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jws/compact/sign.js
var require_sign3 = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jws/compact/sign.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompactSign = void 0;
    var sign_js_1 = require_sign2();
    var CompactSign = class {
      constructor(payload) {
        this._flattened = new sign_js_1.FlattenedSign(payload);
      }
      setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
      }
      async sign(key, options) {
        const jws = await this._flattened.sign(key, options);
        if (jws.payload === void 0) {
          throw new TypeError("use the flattened module for creating JWS with b64: false");
        }
        return `${jws.protected}.${jws.payload}.${jws.signature}`;
      }
    };
    exports2.CompactSign = CompactSign;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jws/general/sign.js
var require_sign4 = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jws/general/sign.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GeneralSign = void 0;
    var sign_js_1 = require_sign2();
    var errors_js_1 = require_errors();
    var IndividualSignature = class {
      constructor(sig, key, options) {
        this.parent = sig;
        this.key = key;
        this.options = options;
      }
      setProtectedHeader(protectedHeader) {
        if (this.protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this.protectedHeader = protectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
      }
      addSignature(...args) {
        return this.parent.addSignature(...args);
      }
      sign(...args) {
        return this.parent.sign(...args);
      }
      done() {
        return this.parent;
      }
    };
    var GeneralSign = class {
      constructor(payload) {
        this._signatures = [];
        this._payload = payload;
      }
      addSignature(key, options) {
        const signature = new IndividualSignature(this, key, options);
        this._signatures.push(signature);
        return signature;
      }
      async sign() {
        if (!this._signatures.length) {
          throw new errors_js_1.JWSInvalid("at least one signature must be added");
        }
        const jws = {
          signatures: [],
          payload: ""
        };
        for (let i = 0; i < this._signatures.length; i++) {
          const signature = this._signatures[i];
          const flattened = new sign_js_1.FlattenedSign(this._payload);
          flattened.setProtectedHeader(signature.protectedHeader);
          flattened.setUnprotectedHeader(signature.unprotectedHeader);
          const { payload, ...rest } = await flattened.sign(signature.key, signature.options);
          if (i === 0) {
            jws.payload = payload;
          } else if (jws.payload !== payload) {
            throw new errors_js_1.JWSInvalid("inconsistent use of JWS Unencoded Payload Option (RFC7797)");
          }
          jws.signatures.push(rest);
        }
        return jws;
      }
    };
    exports2.GeneralSign = GeneralSign;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwt/produce.js
var require_produce = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwt/produce.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProduceJWT = void 0;
    var epoch_js_1 = require_epoch();
    var is_object_js_1 = require_is_object();
    var secs_js_1 = require_secs();
    var ProduceJWT = class {
      constructor(payload) {
        if (!(0, is_object_js_1.default)(payload)) {
          throw new TypeError("JWT Claims Set MUST be an object");
        }
        this._payload = payload;
      }
      setIssuer(issuer) {
        this._payload = { ...this._payload, iss: issuer };
        return this;
      }
      setSubject(subject) {
        this._payload = { ...this._payload, sub: subject };
        return this;
      }
      setAudience(audience) {
        this._payload = { ...this._payload, aud: audience };
        return this;
      }
      setJti(jwtId) {
        this._payload = { ...this._payload, jti: jwtId };
        return this;
      }
      setNotBefore(input10) {
        if (typeof input10 === "number") {
          this._payload = { ...this._payload, nbf: input10 };
        } else {
          this._payload = { ...this._payload, nbf: (0, epoch_js_1.default)(/* @__PURE__ */ new Date()) + (0, secs_js_1.default)(input10) };
        }
        return this;
      }
      setExpirationTime(input10) {
        if (typeof input10 === "number") {
          this._payload = { ...this._payload, exp: input10 };
        } else {
          this._payload = { ...this._payload, exp: (0, epoch_js_1.default)(/* @__PURE__ */ new Date()) + (0, secs_js_1.default)(input10) };
        }
        return this;
      }
      setIssuedAt(input10) {
        if (typeof input10 === "undefined") {
          this._payload = { ...this._payload, iat: (0, epoch_js_1.default)(/* @__PURE__ */ new Date()) };
        } else {
          this._payload = { ...this._payload, iat: input10 };
        }
        return this;
      }
    };
    exports2.ProduceJWT = ProduceJWT;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwt/sign.js
var require_sign5 = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwt/sign.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SignJWT = void 0;
    var sign_js_1 = require_sign3();
    var errors_js_1 = require_errors();
    var buffer_utils_js_1 = require_buffer_utils();
    var produce_js_1 = require_produce();
    var SignJWT = class extends produce_js_1.ProduceJWT {
      setProtectedHeader(protectedHeader) {
        this._protectedHeader = protectedHeader;
        return this;
      }
      async sign(key, options) {
        var _a;
        const sig = new sign_js_1.CompactSign(buffer_utils_js_1.encoder.encode(JSON.stringify(this._payload)));
        sig.setProtectedHeader(this._protectedHeader);
        if (Array.isArray((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
          throw new errors_js_1.JWTInvalid("JWTs MUST NOT use unencoded payload");
        }
        return sig.sign(key, options);
      }
    };
    exports2.SignJWT = SignJWT;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwt/encrypt.js
var require_encrypt5 = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwt/encrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EncryptJWT = void 0;
    var encrypt_js_1 = require_encrypt4();
    var buffer_utils_js_1 = require_buffer_utils();
    var produce_js_1 = require_produce();
    var EncryptJWT = class extends produce_js_1.ProduceJWT {
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
          throw new TypeError("setKeyManagementParameters can only be called once");
        }
        this._keyManagementParameters = parameters;
        return this;
      }
      setContentEncryptionKey(cek) {
        if (this._cek) {
          throw new TypeError("setContentEncryptionKey can only be called once");
        }
        this._cek = cek;
        return this;
      }
      setInitializationVector(iv) {
        if (this._iv) {
          throw new TypeError("setInitializationVector can only be called once");
        }
        this._iv = iv;
        return this;
      }
      replicateIssuerAsHeader() {
        this._replicateIssuerAsHeader = true;
        return this;
      }
      replicateSubjectAsHeader() {
        this._replicateSubjectAsHeader = true;
        return this;
      }
      replicateAudienceAsHeader() {
        this._replicateAudienceAsHeader = true;
        return this;
      }
      async encrypt(key, options) {
        const enc = new encrypt_js_1.CompactEncrypt(buffer_utils_js_1.encoder.encode(JSON.stringify(this._payload)));
        if (this._replicateIssuerAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };
        }
        if (this._replicateSubjectAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };
        }
        if (this._replicateAudienceAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };
        }
        enc.setProtectedHeader(this._protectedHeader);
        if (this._iv) {
          enc.setInitializationVector(this._iv);
        }
        if (this._cek) {
          enc.setContentEncryptionKey(this._cek);
        }
        if (this._keyManagementParameters) {
          enc.setKeyManagementParameters(this._keyManagementParameters);
        }
        return enc.encrypt(key, options);
      }
    };
    exports2.EncryptJWT = EncryptJWT;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwk/thumbprint.js
var require_thumbprint = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwk/thumbprint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.calculateJwkThumbprintUri = exports2.calculateJwkThumbprint = void 0;
    var digest_js_1 = require_digest();
    var base64url_js_1 = require_base64url();
    var errors_js_1 = require_errors();
    var buffer_utils_js_1 = require_buffer_utils();
    var is_object_js_1 = require_is_object();
    var check = (value, description) => {
      if (typeof value !== "string" || !value) {
        throw new errors_js_1.JWKInvalid(`${description} missing or invalid`);
      }
    };
    async function calculateJwkThumbprint(jwk, digestAlgorithm) {
      if (!(0, is_object_js_1.default)(jwk)) {
        throw new TypeError("JWK must be an object");
      }
      digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = "sha256";
      if (digestAlgorithm !== "sha256" && digestAlgorithm !== "sha384" && digestAlgorithm !== "sha512") {
        throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');
      }
      let components;
      switch (jwk.kty) {
        case "EC":
          check(jwk.crv, '"crv" (Curve) Parameter');
          check(jwk.x, '"x" (X Coordinate) Parameter');
          check(jwk.y, '"y" (Y Coordinate) Parameter');
          components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
          break;
        case "OKP":
          check(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
          check(jwk.x, '"x" (Public Key) Parameter');
          components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
          break;
        case "RSA":
          check(jwk.e, '"e" (Exponent) Parameter');
          check(jwk.n, '"n" (Modulus) Parameter');
          components = { e: jwk.e, kty: jwk.kty, n: jwk.n };
          break;
        case "oct":
          check(jwk.k, '"k" (Key Value) Parameter');
          components = { k: jwk.k, kty: jwk.kty };
          break;
        default:
          throw new errors_js_1.JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported');
      }
      const data = buffer_utils_js_1.encoder.encode(JSON.stringify(components));
      return (0, base64url_js_1.encode)(await (0, digest_js_1.default)(digestAlgorithm, data));
    }
    exports2.calculateJwkThumbprint = calculateJwkThumbprint;
    async function calculateJwkThumbprintUri(jwk, digestAlgorithm) {
      digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = "sha256";
      const thumbprint = await calculateJwkThumbprint(jwk, digestAlgorithm);
      return `urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`;
    }
    exports2.calculateJwkThumbprintUri = calculateJwkThumbprintUri;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwk/embedded.js
var require_embedded = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwk/embedded.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EmbeddedJWK = void 0;
    var import_js_1 = require_import();
    var is_object_js_1 = require_is_object();
    var errors_js_1 = require_errors();
    async function EmbeddedJWK(protectedHeader, token) {
      const joseHeader = {
        ...protectedHeader,
        ...token.header
      };
      if (!(0, is_object_js_1.default)(joseHeader.jwk)) {
        throw new errors_js_1.JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a JSON object');
      }
      const key = await (0, import_js_1.importJWK)({ ...joseHeader.jwk, ext: true }, joseHeader.alg, true);
      if (key instanceof Uint8Array || key.type !== "public") {
        throw new errors_js_1.JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a public key');
      }
      return key;
    }
    exports2.EmbeddedJWK = EmbeddedJWK;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwks/local.js
var require_local = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwks/local.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createLocalJWKSet = exports2.LocalJWKSet = exports2.isJWKSLike = void 0;
    var import_js_1 = require_import();
    var errors_js_1 = require_errors();
    var is_object_js_1 = require_is_object();
    function getKtyFromAlg(alg) {
      switch (typeof alg === "string" && alg.slice(0, 2)) {
        case "RS":
        case "PS":
          return "RSA";
        case "ES":
          return "EC";
        case "Ed":
          return "OKP";
        default:
          throw new errors_js_1.JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
      }
    }
    function isJWKSLike(jwks) {
      return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
    }
    exports2.isJWKSLike = isJWKSLike;
    function isJWKLike(key) {
      return (0, is_object_js_1.default)(key);
    }
    function clone(obj) {
      if (typeof structuredClone === "function") {
        return structuredClone(obj);
      }
      return JSON.parse(JSON.stringify(obj));
    }
    var LocalJWKSet = class {
      constructor(jwks) {
        this._cached = /* @__PURE__ */ new WeakMap();
        if (!isJWKSLike(jwks)) {
          throw new errors_js_1.JWKSInvalid("JSON Web Key Set malformed");
        }
        this._jwks = clone(jwks);
      }
      async getKey(protectedHeader, token) {
        const { alg, kid } = { ...protectedHeader, ...token.header };
        const kty = getKtyFromAlg(alg);
        const candidates = this._jwks.keys.filter((jwk2) => {
          let candidate = kty === jwk2.kty;
          if (candidate && typeof kid === "string") {
            candidate = kid === jwk2.kid;
          }
          if (candidate && typeof jwk2.alg === "string") {
            candidate = alg === jwk2.alg;
          }
          if (candidate && typeof jwk2.use === "string") {
            candidate = jwk2.use === "sig";
          }
          if (candidate && Array.isArray(jwk2.key_ops)) {
            candidate = jwk2.key_ops.includes("verify");
          }
          if (candidate && alg === "EdDSA") {
            candidate = jwk2.crv === "Ed25519" || jwk2.crv === "Ed448";
          }
          if (candidate) {
            switch (alg) {
              case "ES256":
                candidate = jwk2.crv === "P-256";
                break;
              case "ES256K":
                candidate = jwk2.crv === "secp256k1";
                break;
              case "ES384":
                candidate = jwk2.crv === "P-384";
                break;
              case "ES512":
                candidate = jwk2.crv === "P-521";
                break;
            }
          }
          return candidate;
        });
        const { 0: jwk, length: length5 } = candidates;
        if (length5 === 0) {
          throw new errors_js_1.JWKSNoMatchingKey();
        } else if (length5 !== 1) {
          throw new errors_js_1.JWKSMultipleMatchingKeys();
        }
        const cached = this._cached.get(jwk) || this._cached.set(jwk, {}).get(jwk);
        if (cached[alg] === void 0) {
          const keyObject = await (0, import_js_1.importJWK)({ ...jwk, ext: true }, alg);
          if (keyObject instanceof Uint8Array || keyObject.type !== "public") {
            throw new errors_js_1.JWKSInvalid("JSON Web Key Set members must be public keys");
          }
          cached[alg] = keyObject;
        }
        return cached[alg];
      }
    };
    exports2.LocalJWKSet = LocalJWKSet;
    function createLocalJWKSet(jwks) {
      return LocalJWKSet.prototype.getKey.bind(new LocalJWKSet(jwks));
    }
    exports2.createLocalJWKSet = createLocalJWKSet;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/fetch_jwks.js
var require_fetch_jwks = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/fetch_jwks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var http2 = require("http");
    var https2 = require("https");
    var events_1 = require("events");
    var errors_js_1 = require_errors();
    var buffer_utils_js_1 = require_buffer_utils();
    var fetchJwks = async (url, timeout, options) => {
      let get15;
      switch (url.protocol) {
        case "https:":
          get15 = https2.get;
          break;
        case "http:":
          get15 = http2.get;
          break;
        default:
          throw new TypeError("Unsupported URL protocol.");
      }
      const { agent, headers } = options;
      const req = get15(url.href, {
        agent,
        timeout,
        headers
      });
      const [response] = await Promise.race([(0, events_1.once)(req, "response"), (0, events_1.once)(req, "timeout")]);
      if (!response) {
        req.destroy();
        throw new errors_js_1.JWKSTimeout();
      }
      if (response.statusCode !== 200) {
        throw new errors_js_1.JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
      }
      const parts = [];
      for await (const part of response) {
        parts.push(part);
      }
      try {
        return JSON.parse(buffer_utils_js_1.decoder.decode((0, buffer_utils_js_1.concat)(...parts)));
      } catch {
        throw new errors_js_1.JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
      }
    };
    exports2.default = fetchJwks;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwks/remote.js
var require_remote = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwks/remote.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createRemoteJWKSet = void 0;
    var fetch_jwks_js_1 = require_fetch_jwks();
    var env_js_1 = require_env();
    var errors_js_1 = require_errors();
    var local_js_1 = require_local();
    var RemoteJWKSet = class extends local_js_1.LocalJWKSet {
      constructor(url, options) {
        super({ keys: [] });
        this._jwks = void 0;
        if (!(url instanceof URL)) {
          throw new TypeError("url must be an instance of URL");
        }
        this._url = new URL(url.href);
        this._options = { agent: options === null || options === void 0 ? void 0 : options.agent, headers: options === null || options === void 0 ? void 0 : options.headers };
        this._timeoutDuration = typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === "number" ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5e3;
        this._cooldownDuration = typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === "number" ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 3e4;
        this._cacheMaxAge = typeof (options === null || options === void 0 ? void 0 : options.cacheMaxAge) === "number" ? options === null || options === void 0 ? void 0 : options.cacheMaxAge : 6e5;
      }
      coolingDown() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cooldownDuration : false;
      }
      fresh() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cacheMaxAge : false;
      }
      async getKey(protectedHeader, token) {
        if (!this._jwks || !this.fresh()) {
          await this.reload();
        }
        try {
          return await super.getKey(protectedHeader, token);
        } catch (err) {
          if (err instanceof errors_js_1.JWKSNoMatchingKey) {
            if (this.coolingDown() === false) {
              await this.reload();
              return super.getKey(protectedHeader, token);
            }
          }
          throw err;
        }
      }
      async reload() {
        if (this._pendingFetch && (0, env_js_1.isCloudflareWorkers)()) {
          return new Promise((resolve2) => {
            const isDone = () => {
              if (this._pendingFetch === void 0) {
                resolve2();
              } else {
                setTimeout(isDone, 5);
              }
            };
            isDone();
          });
        }
        if (!this._pendingFetch) {
          this._pendingFetch = (0, fetch_jwks_js_1.default)(this._url, this._timeoutDuration, this._options).then((json) => {
            if (!(0, local_js_1.isJWKSLike)(json)) {
              throw new errors_js_1.JWKSInvalid("JSON Web Key Set malformed");
            }
            this._jwks = { keys: json.keys };
            this._jwksTimestamp = Date.now();
            this._pendingFetch = void 0;
          }).catch((err) => {
            this._pendingFetch = void 0;
            throw err;
          });
        }
        await this._pendingFetch;
      }
    };
    function createRemoteJWKSet(url, options) {
      return RemoteJWKSet.prototype.getKey.bind(new RemoteJWKSet(url, options));
    }
    exports2.createRemoteJWKSet = createRemoteJWKSet;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwt/unsecured.js
var require_unsecured = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/jwt/unsecured.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnsecuredJWT = void 0;
    var base64url4 = require_base64url();
    var buffer_utils_js_1 = require_buffer_utils();
    var errors_js_1 = require_errors();
    var jwt_claims_set_js_1 = require_jwt_claims_set();
    var produce_js_1 = require_produce();
    var UnsecuredJWT = class extends produce_js_1.ProduceJWT {
      encode() {
        const header = base64url4.encode(JSON.stringify({ alg: "none" }));
        const payload = base64url4.encode(JSON.stringify(this._payload));
        return `${header}.${payload}.`;
      }
      static decode(jwt, options) {
        if (typeof jwt !== "string") {
          throw new errors_js_1.JWTInvalid("Unsecured JWT must be a string");
        }
        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length: length5 } = jwt.split(".");
        if (length5 !== 3 || signature !== "") {
          throw new errors_js_1.JWTInvalid("Invalid Unsecured JWT");
        }
        let header;
        try {
          header = JSON.parse(buffer_utils_js_1.decoder.decode(base64url4.decode(encodedHeader)));
          if (header.alg !== "none")
            throw new Error();
        } catch {
          throw new errors_js_1.JWTInvalid("Invalid Unsecured JWT");
        }
        const payload = (0, jwt_claims_set_js_1.default)(header, base64url4.decode(encodedPayload), options);
        return { payload, header };
      }
    };
    exports2.UnsecuredJWT = UnsecuredJWT;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/util/base64url.js
var require_base64url2 = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/util/base64url.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decode = exports2.encode = void 0;
    var base64url4 = require_base64url();
    exports2.encode = base64url4.encode;
    exports2.decode = base64url4.decode;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/util/decode_protected_header.js
var require_decode_protected_header = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/util/decode_protected_header.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeProtectedHeader = void 0;
    var base64url_js_1 = require_base64url2();
    var buffer_utils_js_1 = require_buffer_utils();
    var is_object_js_1 = require_is_object();
    function decodeProtectedHeader(token) {
      let protectedB64u;
      if (typeof token === "string") {
        const parts = token.split(".");
        if (parts.length === 3 || parts.length === 5) {
          ;
          [protectedB64u] = parts;
        }
      } else if (typeof token === "object" && token) {
        if ("protected" in token) {
          protectedB64u = token.protected;
        } else {
          throw new TypeError("Token does not contain a Protected Header");
        }
      }
      try {
        if (typeof protectedB64u !== "string" || !protectedB64u) {
          throw new Error();
        }
        const result = JSON.parse(buffer_utils_js_1.decoder.decode((0, base64url_js_1.decode)(protectedB64u)));
        if (!(0, is_object_js_1.default)(result)) {
          throw new Error();
        }
        return result;
      } catch {
        throw new TypeError("Invalid Token or Protected Header formatting");
      }
    }
    exports2.decodeProtectedHeader = decodeProtectedHeader;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/util/decode_jwt.js
var require_decode_jwt = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/util/decode_jwt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeJwt = void 0;
    var base64url_js_1 = require_base64url2();
    var buffer_utils_js_1 = require_buffer_utils();
    var is_object_js_1 = require_is_object();
    var errors_js_1 = require_errors();
    function decodeJwt(jwt) {
      if (typeof jwt !== "string")
        throw new errors_js_1.JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
      const { 1: payload, length: length5 } = jwt.split(".");
      if (length5 === 5)
        throw new errors_js_1.JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
      if (length5 !== 3)
        throw new errors_js_1.JWTInvalid("Invalid JWT");
      if (!payload)
        throw new errors_js_1.JWTInvalid("JWTs must contain a payload");
      let decoded;
      try {
        decoded = (0, base64url_js_1.decode)(payload);
      } catch {
        throw new errors_js_1.JWTInvalid("Failed to parse the base64url encoded payload");
      }
      let result;
      try {
        result = JSON.parse(buffer_utils_js_1.decoder.decode(decoded));
      } catch {
        throw new errors_js_1.JWTInvalid("Failed to parse the decoded payload as JSON");
      }
      if (!(0, is_object_js_1.default)(result))
        throw new errors_js_1.JWTInvalid("Invalid JWT Claims Set");
      return result;
    }
    exports2.decodeJwt = decodeJwt;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/generate.js
var require_generate = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/runtime/generate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateKeyPair = exports2.generateSecret = void 0;
    var crypto_1 = require("crypto");
    var util_1 = require("util");
    var random_js_1 = require_random();
    var check_modulus_length_js_1 = require_check_modulus_length();
    var errors_js_1 = require_errors();
    var generate3 = (0, util_1.promisify)(crypto_1.generateKeyPair);
    async function generateSecret(alg, options) {
      let length5;
      switch (alg) {
        case "HS256":
        case "HS384":
        case "HS512":
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          length5 = parseInt(alg.slice(-3), 10);
          break;
        case "A128KW":
        case "A192KW":
        case "A256KW":
        case "A128GCMKW":
        case "A192GCMKW":
        case "A256GCMKW":
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          length5 = parseInt(alg.slice(1, 4), 10);
          break;
        default:
          throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      return (0, crypto_1.createSecretKey)((0, random_js_1.default)(new Uint8Array(length5 >> 3)));
    }
    exports2.generateSecret = generateSecret;
    async function generateKeyPair(alg, options) {
      var _a, _b;
      switch (alg) {
        case "RS256":
        case "RS384":
        case "RS512":
        case "PS256":
        case "PS384":
        case "PS512":
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
        case "RSA1_5": {
          const modulusLength = (_a = options === null || options === void 0 ? void 0 : options.modulusLength) !== null && _a !== void 0 ? _a : 2048;
          if (typeof modulusLength !== "number" || modulusLength < 2048) {
            throw new errors_js_1.JOSENotSupported("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");
          }
          const keypair = await generate3("rsa", {
            modulusLength,
            publicExponent: 65537
          });
          (0, check_modulus_length_js_1.setModulusLength)(keypair.privateKey, modulusLength);
          (0, check_modulus_length_js_1.setModulusLength)(keypair.publicKey, modulusLength);
          return keypair;
        }
        case "ES256":
          return generate3("ec", { namedCurve: "P-256" });
        case "ES256K":
          return generate3("ec", { namedCurve: "secp256k1" });
        case "ES384":
          return generate3("ec", { namedCurve: "P-384" });
        case "ES512":
          return generate3("ec", { namedCurve: "P-521" });
        case "EdDSA": {
          switch (options === null || options === void 0 ? void 0 : options.crv) {
            case void 0:
            case "Ed25519":
              return generate3("ed25519");
            case "Ed448":
              return generate3("ed448");
            default:
              throw new errors_js_1.JOSENotSupported("Invalid or unsupported crv option provided, supported values are Ed25519 and Ed448");
          }
        }
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          const crv = (_b = options === null || options === void 0 ? void 0 : options.crv) !== null && _b !== void 0 ? _b : "P-256";
          switch (crv) {
            case void 0:
            case "P-256":
            case "P-384":
            case "P-521":
              return generate3("ec", { namedCurve: crv });
            case "X25519":
              return generate3("x25519");
            case "X448":
              return generate3("x448");
            default:
              throw new errors_js_1.JOSENotSupported("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448");
          }
        default:
          throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
    }
    exports2.generateKeyPair = generateKeyPair;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/key/generate_key_pair.js
var require_generate_key_pair = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/key/generate_key_pair.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateKeyPair = void 0;
    var generate_js_1 = require_generate();
    async function generateKeyPair(alg, options) {
      return (0, generate_js_1.generateKeyPair)(alg, options);
    }
    exports2.generateKeyPair = generateKeyPair;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/key/generate_secret.js
var require_generate_secret = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/key/generate_secret.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateSecret = void 0;
    var generate_js_1 = require_generate();
    async function generateSecret(alg, options) {
      return (0, generate_js_1.generateSecret)(alg, options);
    }
    exports2.generateSecret = generateSecret;
  }
});

// ../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/index.js
var require_cjs = __commonJS({
  "../../node_modules/.pnpm/jose@4.11.2/node_modules/jose/dist/node/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.base64url = exports2.generateSecret = exports2.generateKeyPair = exports2.errors = exports2.decodeJwt = exports2.decodeProtectedHeader = exports2.importJWK = exports2.importX509 = exports2.importPKCS8 = exports2.importSPKI = exports2.exportJWK = exports2.exportSPKI = exports2.exportPKCS8 = exports2.UnsecuredJWT = exports2.createRemoteJWKSet = exports2.createLocalJWKSet = exports2.EmbeddedJWK = exports2.calculateJwkThumbprintUri = exports2.calculateJwkThumbprint = exports2.EncryptJWT = exports2.SignJWT = exports2.GeneralSign = exports2.FlattenedSign = exports2.CompactSign = exports2.FlattenedEncrypt = exports2.CompactEncrypt = exports2.jwtDecrypt = exports2.jwtVerify = exports2.generalVerify = exports2.flattenedVerify = exports2.compactVerify = exports2.GeneralEncrypt = exports2.generalDecrypt = exports2.flattenedDecrypt = exports2.compactDecrypt = void 0;
    var decrypt_js_1 = require_decrypt3();
    Object.defineProperty(exports2, "compactDecrypt", { enumerable: true, get: function() {
      return decrypt_js_1.compactDecrypt;
    } });
    var decrypt_js_2 = require_decrypt2();
    Object.defineProperty(exports2, "flattenedDecrypt", { enumerable: true, get: function() {
      return decrypt_js_2.flattenedDecrypt;
    } });
    var decrypt_js_3 = require_decrypt4();
    Object.defineProperty(exports2, "generalDecrypt", { enumerable: true, get: function() {
      return decrypt_js_3.generalDecrypt;
    } });
    var encrypt_js_1 = require_encrypt3();
    Object.defineProperty(exports2, "GeneralEncrypt", { enumerable: true, get: function() {
      return encrypt_js_1.GeneralEncrypt;
    } });
    var verify_js_1 = require_verify3();
    Object.defineProperty(exports2, "compactVerify", { enumerable: true, get: function() {
      return verify_js_1.compactVerify;
    } });
    var verify_js_2 = require_verify2();
    Object.defineProperty(exports2, "flattenedVerify", { enumerable: true, get: function() {
      return verify_js_2.flattenedVerify;
    } });
    var verify_js_3 = require_verify4();
    Object.defineProperty(exports2, "generalVerify", { enumerable: true, get: function() {
      return verify_js_3.generalVerify;
    } });
    var verify_js_4 = require_verify5();
    Object.defineProperty(exports2, "jwtVerify", { enumerable: true, get: function() {
      return verify_js_4.jwtVerify;
    } });
    var decrypt_js_4 = require_decrypt5();
    Object.defineProperty(exports2, "jwtDecrypt", { enumerable: true, get: function() {
      return decrypt_js_4.jwtDecrypt;
    } });
    var encrypt_js_2 = require_encrypt4();
    Object.defineProperty(exports2, "CompactEncrypt", { enumerable: true, get: function() {
      return encrypt_js_2.CompactEncrypt;
    } });
    var encrypt_js_3 = require_encrypt2();
    Object.defineProperty(exports2, "FlattenedEncrypt", { enumerable: true, get: function() {
      return encrypt_js_3.FlattenedEncrypt;
    } });
    var sign_js_1 = require_sign3();
    Object.defineProperty(exports2, "CompactSign", { enumerable: true, get: function() {
      return sign_js_1.CompactSign;
    } });
    var sign_js_2 = require_sign2();
    Object.defineProperty(exports2, "FlattenedSign", { enumerable: true, get: function() {
      return sign_js_2.FlattenedSign;
    } });
    var sign_js_3 = require_sign4();
    Object.defineProperty(exports2, "GeneralSign", { enumerable: true, get: function() {
      return sign_js_3.GeneralSign;
    } });
    var sign_js_4 = require_sign5();
    Object.defineProperty(exports2, "SignJWT", { enumerable: true, get: function() {
      return sign_js_4.SignJWT;
    } });
    var encrypt_js_4 = require_encrypt5();
    Object.defineProperty(exports2, "EncryptJWT", { enumerable: true, get: function() {
      return encrypt_js_4.EncryptJWT;
    } });
    var thumbprint_js_1 = require_thumbprint();
    Object.defineProperty(exports2, "calculateJwkThumbprint", { enumerable: true, get: function() {
      return thumbprint_js_1.calculateJwkThumbprint;
    } });
    Object.defineProperty(exports2, "calculateJwkThumbprintUri", { enumerable: true, get: function() {
      return thumbprint_js_1.calculateJwkThumbprintUri;
    } });
    var embedded_js_1 = require_embedded();
    Object.defineProperty(exports2, "EmbeddedJWK", { enumerable: true, get: function() {
      return embedded_js_1.EmbeddedJWK;
    } });
    var local_js_1 = require_local();
    Object.defineProperty(exports2, "createLocalJWKSet", { enumerable: true, get: function() {
      return local_js_1.createLocalJWKSet;
    } });
    var remote_js_1 = require_remote();
    Object.defineProperty(exports2, "createRemoteJWKSet", { enumerable: true, get: function() {
      return remote_js_1.createRemoteJWKSet;
    } });
    var unsecured_js_1 = require_unsecured();
    Object.defineProperty(exports2, "UnsecuredJWT", { enumerable: true, get: function() {
      return unsecured_js_1.UnsecuredJWT;
    } });
    var export_js_1 = require_export();
    Object.defineProperty(exports2, "exportPKCS8", { enumerable: true, get: function() {
      return export_js_1.exportPKCS8;
    } });
    Object.defineProperty(exports2, "exportSPKI", { enumerable: true, get: function() {
      return export_js_1.exportSPKI;
    } });
    Object.defineProperty(exports2, "exportJWK", { enumerable: true, get: function() {
      return export_js_1.exportJWK;
    } });
    var import_js_1 = require_import();
    Object.defineProperty(exports2, "importSPKI", { enumerable: true, get: function() {
      return import_js_1.importSPKI;
    } });
    Object.defineProperty(exports2, "importPKCS8", { enumerable: true, get: function() {
      return import_js_1.importPKCS8;
    } });
    Object.defineProperty(exports2, "importX509", { enumerable: true, get: function() {
      return import_js_1.importX509;
    } });
    Object.defineProperty(exports2, "importJWK", { enumerable: true, get: function() {
      return import_js_1.importJWK;
    } });
    var decode_protected_header_js_1 = require_decode_protected_header();
    Object.defineProperty(exports2, "decodeProtectedHeader", { enumerable: true, get: function() {
      return decode_protected_header_js_1.decodeProtectedHeader;
    } });
    var decode_jwt_js_1 = require_decode_jwt();
    Object.defineProperty(exports2, "decodeJwt", { enumerable: true, get: function() {
      return decode_jwt_js_1.decodeJwt;
    } });
    exports2.errors = require_errors();
    var generate_key_pair_js_1 = require_generate_key_pair();
    Object.defineProperty(exports2, "generateKeyPair", { enumerable: true, get: function() {
      return generate_key_pair_js_1.generateKeyPair;
    } });
    var generate_secret_js_1 = require_generate_secret();
    Object.defineProperty(exports2, "generateSecret", { enumerable: true, get: function() {
      return generate_secret_js_1.generateSecret;
    } });
    exports2.base64url = require_base64url2();
  }
});

// ../auth/dist/createToken.js
var require_createToken = __commonJS({
  "../auth/dist/createToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createToken = void 0;
    var jose_1 = require_cjs();
    var textEncoder9 = new TextEncoder();
    var createToken3 = async ({ payload, secret, expiration }) => {
      const secretKey = textEncoder9.encode(secret);
      const jwt = new jose_1.SignJWT(payload).setProtectedHeader({ alg: "HS256" });
      if (expiration) {
        jwt.setExpirationTime(expiration);
      }
      return jwt.sign(secretKey);
    };
    exports2.createToken = createToken3;
  }
});

// ../auth/dist/createAccessToken.js
var require_createAccessToken = __commonJS({
  "../auth/dist/createAccessToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAccessToken = void 0;
    var createToken_1 = require_createToken();
    var createAccessToken = async (args) => (0, createToken_1.createToken)(args);
    exports2.createAccessToken = createAccessToken;
  }
});

// ../auth/dist/createAssetsAccessToken.js
var require_createAssetsAccessToken = __commonJS({
  "../auth/dist/createAssetsAccessToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAssetsAccessToken = void 0;
    var createToken_1 = require_createToken();
    var createAssetsAccessToken = async (args) => (0, createToken_1.createToken)(args);
    exports2.createAssetsAccessToken = createAssetsAccessToken;
  }
});

// ../auth/dist/createMigrationToken.js
var require_createMigrationToken = __commonJS({
  "../auth/dist/createMigrationToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMigrationToken = void 0;
    var createToken_1 = require_createToken();
    var createMigrationToken = async (args) => (0, createToken_1.createToken)(args);
    exports2.createMigrationToken = createMigrationToken;
  }
});

// ../errors/dist/FleekError.js
var require_FleekError = __commonJS({
  "../errors/dist/FleekError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekError = void 0;
    var FleekError2 = class extends Error {
      // eslint-disable-next-line fleek-custom/valid-argument-types
      constructor(data) {
        super();
        this.data = data;
      }
      get message() {
        return this.toString();
      }
    };
    exports2.FleekError = FleekError2;
  }
});

// ../errors/dist/BunnyPullZoneNotFoundError.js
var require_BunnyPullZoneNotFoundError = __commonJS({
  "../errors/dist/BunnyPullZoneNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BunnyPullZoneNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var BunnyPullZoneNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "BunnyPullZoneNotFoundError";
        this.toString = () => `PullZone with name ${this.data.name} was not found on BunnyCDN.`;
      }
    };
    exports2.BunnyPullZoneNotFoundError = BunnyPullZoneNotFoundError;
  }
});

// ../errors/dist/DomainNotFoundError.js
var require_DomainNotFoundError = __commonJS({
  "../errors/dist/DomainNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainNotFoundError";
        this.toString = () => {
          if (this.data.domain.hostname) {
            return `Domain ${this.data.domain.hostname} was not found.`;
          }
          return "Domain was not found.";
        };
      }
    };
    exports2.DomainNotFoundError = DomainNotFoundError2;
  }
});

// ../errors/dist/DomainsNotFoundError.js
var require_DomainsNotFoundError = __commonJS({
  "../errors/dist/DomainsNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainsNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainsNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "DomainsNotFoundError";
        this.toString = () => "No domains found.";
      }
    };
    exports2.DomainsNotFoundError = DomainsNotFoundError2;
  }
});

// ../errors/dist/DomainAlreadyExistsInProjectError.js
var require_DomainAlreadyExistsInProjectError = __commonJS({
  "../errors/dist/DomainAlreadyExistsInProjectError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainAlreadyExistsInProjectError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainAlreadyExistsInProjectError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainAlreadyExistsInProjectError";
        this.toString = () => {
          return `Domain ${this.data.domain.hostname} already exists under the project.`;
        };
      }
    };
    exports2.DomainAlreadyExistsInProjectError = DomainAlreadyExistsInProjectError;
  }
});

// ../errors/dist/DomainInPendingStateError.js
var require_DomainInPendingStateError = __commonJS({
  "../errors/dist/DomainInPendingStateError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainInPendingStateError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainInPendingStateError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainInPendingStateError";
        this.toString = () => {
          return "Domain is in pending state. Please wait and try action again later.";
        };
      }
    };
    exports2.DomainInPendingStateError = DomainInPendingStateError;
  }
});

// ../errors/dist/DomainHostnameInvalidError.js
var require_DomainHostnameInvalidError = __commonJS({
  "../errors/dist/DomainHostnameInvalidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainHostnameInvalidError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainHostnameInvalidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainHostnameInvalidError";
        this.toString = () => {
          return `The domain ${this.data.hostname} is invalid`;
        };
      }
    };
    exports2.DomainHostnameInvalidError = DomainHostnameInvalidError;
  }
});

// ../errors/dist/UnknownError.js
var require_UnknownError = __commonJS({
  "../errors/dist/UnknownError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnknownError = void 0;
    var FleekError_1 = require_FleekError();
    var UnknownError3 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "UnknownError";
        this.toString = () => `Unexpected error. Repeat the action or contact support.`;
      }
    };
    exports2.UnknownError = UnknownError3;
  }
});

// ../errors/dist/SiteNotFoundError.js
var require_SiteNotFoundError = __commonJS({
  "../errors/dist/SiteNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteNotFoundError3 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteNotFoundError";
        this.toString = () => {
          if (this.data.site.slug) {
            return `Site ${this.data.site.slug} not found.`;
          }
          return `Site not found.`;
        };
      }
    };
    exports2.SiteNotFoundError = SiteNotFoundError3;
  }
});

// ../errors/dist/SitesNotFoundError.js
var require_SitesNotFoundError = __commonJS({
  "../errors/dist/SitesNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SitesNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var SitesNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "SitesNotFoundError";
        this.toString = () => "No sites found.";
      }
    };
    exports2.SitesNotFoundError = SitesNotFoundError2;
  }
});

// ../errors/dist/SiteAlreadyExistsError.js
var require_SiteAlreadyExistsError = __commonJS({
  "../errors/dist/SiteAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteAlreadyExistsError";
        this.toString = () => {
          if ("name" in this.data.site) {
            return `Site ${this.data.site.name} already exists in the project.`;
          }
          return `Site slug must be unique within Fleek but ${this.data.site.slug} already exists.`;
        };
      }
    };
    exports2.SiteAlreadyExistsError = SiteAlreadyExistsError;
  }
});

// ../errors/dist/SiteDeploymentNotFoundError.js
var require_SiteDeploymentNotFoundError = __commonJS({
  "../errors/dist/SiteDeploymentNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteDeploymentNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteDeploymentNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteDeploymentNotFoundError";
        this.toString = () => `Deployment not found.`;
      }
    };
    exports2.SiteDeploymentNotFoundError = SiteDeploymentNotFoundError2;
  }
});

// ../errors/dist/SiteHasDependentsError.js
var require_SiteHasDependentsError = __commonJS({
  "../errors/dist/SiteHasDependentsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteHasDependentsError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteHasDependentsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteHasDependentsError";
        this.toString = () => {
          const dependentsInfo = [];
          if (this.data.domains.length > 0) {
            dependentsInfo.push(`${this.data.domains.length} domains`);
          }
          if (this.data.ipnsRecords.length > 0) {
            dependentsInfo.push(`${this.data.ipnsRecords.length} IPNS records`);
          }
          return `Site has assigned ${dependentsInfo}. You have to delete them first.`;
        };
      }
    };
    exports2.SiteHasDependentsError = SiteHasDependentsError;
  }
});

// ../errors/dist/SiteHasNoSourceProviderError.js
var require_SiteHasNoSourceProviderError = __commonJS({
  "../errors/dist/SiteHasNoSourceProviderError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteHasNoSourceProviderError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteHasNoSourceProviderError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteHasNoSourceProviderError";
        this.toString = () => {
          if (this.data.site.slug) {
            return `Site ${this.data.site.slug} does not have a source provider.`;
          }
          return `Site does not have a source provider.`;
        };
      }
    };
    exports2.SiteHasNoSourceProviderError = SiteHasNoSourceProviderError;
  }
});

// ../errors/dist/SiteNotDeployedError.js
var require_SiteNotDeployedError = __commonJS({
  "../errors/dist/SiteNotDeployedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteNotDeployedError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteNotDeployedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteNotDeployedError";
        this.toString = () => {
          if (this.data.site.slug) {
            return `Site ${this.data.site.slug} does not have released deployments.`;
          }
          return `Site does not have released deployments.`;
        };
      }
    };
    exports2.SiteNotDeployedError = SiteNotDeployedError;
  }
});

// ../errors/dist/IpnsRecordNotFoundError.js
var require_IpnsRecordNotFoundError = __commonJS({
  "../errors/dist/IpnsRecordNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IpnsRecordNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var IpnsRecordNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "IpnsRecordNotFoundError";
        this.toString = () => `IPNS record not found.`;
      }
    };
    exports2.IpnsRecordNotFoundError = IpnsRecordNotFoundError;
  }
});

// ../errors/dist/IpnsRecordsNotFoundError.js
var require_IpnsRecordsNotFoundError = __commonJS({
  "../errors/dist/IpnsRecordsNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IpnsRecordsNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var IpnsRecordsNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "IpnsRecordsNotFoundError";
        this.toString = () => "No IPNS records found.";
      }
    };
    exports2.IpnsRecordsNotFoundError = IpnsRecordsNotFoundError;
  }
});

// ../errors/dist/IpnsFailToDecryptKeyError.js
var require_IpnsFailToDecryptKeyError = __commonJS({
  "../errors/dist/IpnsFailToDecryptKeyError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IpnsFailToDecryptKeyError = void 0;
    var FleekError_1 = require_FleekError();
    var IpnsFailToDecryptKeyError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "IpnsFailToDecryptKeyError";
        this.toString = () => `Failed to decrypt IPNS key.`;
      }
    };
    exports2.IpnsFailToDecryptKeyError = IpnsFailToDecryptKeyError;
  }
});

// ../errors/dist/IpnsRecordsForSiteLimitError.js
var require_IpnsRecordsForSiteLimitError = __commonJS({
  "../errors/dist/IpnsRecordsForSiteLimitError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IpnsRecordsForSiteLimitError = void 0;
    var FleekError_1 = require_FleekError();
    var IpnsRecordsForSiteLimitError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "IpnsRecordsForSiteLimitError";
        this.toString = () => {
          if (this.data.site.name) {
            return `Maximum amount of IPNS records that may be assigned to the ${this.data.site.name} site was exceeded.`;
          }
          return `Maximum amount of IPNS records that may be assigned to the site was exceeded.`;
        };
      }
    };
    exports2.IpnsRecordsForSiteLimitError = IpnsRecordsForSiteLimitError;
  }
});

// ../errors/dist/StorageIpfsUploadFailedError.js
var require_StorageIpfsUploadFailedError = __commonJS({
  "../errors/dist/StorageIpfsUploadFailedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StorageIpfsUploadFailedError = void 0;
    var FleekError_1 = require_FleekError();
    var StorageIpfsUploadFailedError3 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "StorageIpfsUploadFailedError";
        this.toString = () => `Upload failed.`;
      }
    };
    exports2.StorageIpfsUploadFailedError = StorageIpfsUploadFailedError3;
  }
});

// ../errors/dist/SdkRequiredNodeRuntimeError.js
var require_SdkRequiredNodeRuntimeError = __commonJS({
  "../errors/dist/SdkRequiredNodeRuntimeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SdkRequiredNodeRuntimeError = void 0;
    var FleekError_1 = require_FleekError();
    var SdkRequiredNodeRuntimeError6 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "SdkRequiredNodeRuntimeError";
        this.toString = () => `The functionality of this SDK feature is dependent on the Node.js runtime.`;
      }
    };
    exports2.SdkRequiredNodeRuntimeError = SdkRequiredNodeRuntimeError6;
  }
});

// ../errors/dist/AuthorizationError.js
var require_AuthorizationError = __commonJS({
  "../errors/dist/AuthorizationError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuthorizationError = void 0;
    var FleekError_1 = require_FleekError();
    var AuthorizationError5 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "AuthorizationError";
        this.toString = () => `Authorization with provided credentials is invalid.`;
      }
    };
    exports2.AuthorizationError = AuthorizationError5;
  }
});

// ../errors/dist/ProjectMembershipNotFoundError.js
var require_ProjectMembershipNotFoundError = __commonJS({
  "../errors/dist/ProjectMembershipNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectMembershipNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectMembershipNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectMembershipNotFoundError";
        this.toString = () => `Membership not found for project.`;
      }
    };
    exports2.ProjectMembershipNotFoundError = ProjectMembershipNotFoundError;
  }
});

// ../errors/dist/GithubAppInstallationNotFoundError.js
var require_GithubAppInstallationNotFoundError = __commonJS({
  "../errors/dist/GithubAppInstallationNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GithubAppInstallationNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var GithubAppInstallationNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GithubAppInstallationNotFoundError";
        this.toString = () => {
          return "No GitHub App installation found for given project.";
        };
      }
    };
    exports2.GithubAppInstallationNotFoundError = GithubAppInstallationNotFoundError;
  }
});

// ../errors/dist/UserNotFoundError.js
var require_UserNotFoundError = __commonJS({
  "../errors/dist/UserNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var UserNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UserNotFoundError";
        this.toString = () => {
          if (this.data.email) {
            return `User with email ${this.data.email} not found.`;
          }
          return `User not found.`;
        };
      }
    };
    exports2.UserNotFoundError = UserNotFoundError;
  }
});

// ../errors/dist/UserAlreadyExistsError.js
var require_UserAlreadyExistsError = __commonJS({
  "../errors/dist/UserAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var UserAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UserAlreadyExistsError";
        this.toString = () => "The username is already in use, please select another one";
      }
    };
    exports2.UserAlreadyExistsError = UserAlreadyExistsError;
  }
});

// ../errors/dist/ProjectNotFoundError.js
var require_ProjectNotFoundError = __commonJS({
  "../errors/dist/ProjectNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectNotFoundError";
        this.toString = () => "Project not found.";
      }
    };
    exports2.ProjectNotFoundError = ProjectNotFoundError;
  }
});

// ../errors/dist/ProjectsNotFoundError.js
var require_ProjectsNotFoundError = __commonJS({
  "../errors/dist/ProjectsNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectsNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectsNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "ProjectsNotFoundError";
        this.toString = () => "No projects found.";
      }
    };
    exports2.ProjectsNotFoundError = ProjectsNotFoundError;
  }
});

// ../errors/dist/ProjectHasDependentsError.js
var require_ProjectHasDependentsError = __commonJS({
  "../errors/dist/ProjectHasDependentsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectHasDependentsError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectHasDependentsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectHasDependentsError";
        this.toString = () => {
          const dependentsInfo = [];
          if (this.data.sites.length > 0) {
            dependentsInfo.push(`${this.data.sites.length} sites`);
          }
          if (this.data.privateGateways.length > 0) {
            dependentsInfo.push(`${this.data.privateGateways.length} private gateways`);
          }
          if (this.data.ipnsRecords.length > 0) {
            dependentsInfo.push(`${this.data.ipnsRecords.length} IPNS records`);
          }
          return `Project has assigned ${dependentsInfo.join(", ")}. You have to delete them first.`;
        };
      }
    };
    exports2.ProjectHasDependentsError = ProjectHasDependentsError;
  }
});

// ../errors/dist/ProjectInvalidNameError.js
var require_ProjectInvalidNameError = __commonJS({
  "../errors/dist/ProjectInvalidNameError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectInvalidNameError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectInvalidNameError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectInvalidNameError";
        this.toString = () => `The project name ${this.data.name} is invalid.`;
      }
    };
    exports2.ProjectInvalidNameError = ProjectInvalidNameError;
  }
});

// ../errors/dist/PublicKeyAlreadyExistsError.js
var require_PublicKeyAlreadyExistsError = __commonJS({
  "../errors/dist/PublicKeyAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PublicKeyAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var PublicKeyAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PublicKeyAlreadyExistsError";
        this.toString = () => `Public key already exists.`;
      }
    };
    exports2.PublicKeyAlreadyExistsError = PublicKeyAlreadyExistsError;
  }
});

// ../errors/dist/VerificationSessionAlreadyExistsError.js
var require_VerificationSessionAlreadyExistsError = __commonJS({
  "../errors/dist/VerificationSessionAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VerificationSessionAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var VerificationSessionAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "VerificationSessionAlreadyExistsError";
        this.toString = () => `Verification session already exists.`;
      }
    };
    exports2.VerificationSessionAlreadyExistsError = VerificationSessionAlreadyExistsError;
  }
});

// ../errors/dist/UnauthenticatedError.js
var require_UnauthenticatedError = __commonJS({
  "../errors/dist/UnauthenticatedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnauthenticatedError = void 0;
    var FleekError_1 = require_FleekError();
    var UnauthenticatedError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "UnauthenticatedError";
        this.toString = () => `The request is not authenticated.`;
      }
    };
    exports2.UnauthenticatedError = UnauthenticatedError;
  }
});

// ../errors/dist/DomainZoneNotFoundError.js
var require_DomainZoneNotFoundError = __commonJS({
  "../errors/dist/DomainZoneNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainZoneNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainZoneNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainZoneNotFoundError";
        this.toString = () => {
          return "Domain zone not found.";
        };
      }
    };
    exports2.DomainZoneNotFoundError = DomainZoneNotFoundError;
  }
});

// ../errors/dist/DomainZoneHasDependentsError.js
var require_DomainZoneHasDependentsError = __commonJS({
  "../errors/dist/DomainZoneHasDependentsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainZoneHasDependentsError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainZoneHasDependentsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainZoneHasDependentsError";
        this.toString = () => "Domain zone has assigned domains or private gateways. You have to delete them first.";
      }
    };
    exports2.DomainZoneHasDependentsError = DomainZoneHasDependentsError;
  }
});

// ../errors/dist/DomainZoneInPendingStateError.js
var require_DomainZoneInPendingStateError = __commonJS({
  "../errors/dist/DomainZoneInPendingStateError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainZoneInPendingStateError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainZoneInPendingStateError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ZoneInPendingStateError";
        this.toString = () => {
          return "Domain zone is in pending state. Please wait and try action again later.";
        };
      }
    };
    exports2.DomainZoneInPendingStateError = DomainZoneInPendingStateError;
  }
});

// ../errors/dist/DomainNotFoundUnderPullzoneError.js
var require_DomainNotFoundUnderPullzoneError = __commonJS({
  "../errors/dist/DomainNotFoundUnderPullzoneError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainNotFoundUnderPullzoneError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainNotFoundUnderPullzoneError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainNotFoundUnderPullzoneError";
        this.toString = () => {
          return "Domain zone not found.";
        };
      }
    };
    exports2.DomainNotFoundUnderPullzoneError = DomainNotFoundUnderPullzoneError;
  }
});

// ../errors/dist/DomainZoneInvalidTypeError.js
var require_DomainZoneInvalidTypeError = __commonJS({
  "../errors/dist/DomainZoneInvalidTypeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomainZoneInvalidTypeError = void 0;
    var FleekError_1 = require_FleekError();
    var DomainZoneInvalidTypeError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DomainZoneInvalidTypeError";
        this.toString = () => "Domain zone has different purpose of use.";
      }
    };
    exports2.DomainZoneInvalidTypeError = DomainZoneInvalidTypeError;
  }
});

// ../errors/dist/UnauthorizedError.js
var require_UnauthorizedError = __commonJS({
  "../errors/dist/UnauthorizedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnauthorizedError = void 0;
    var FleekError_1 = require_FleekError();
    var UnauthorizedError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UnauthorizedError";
        this.toString = () => {
          if (this.data.scopes) {
            return `You are not authorized to access this resource because of missing permissions: ${this.data.scopes.join(", ")}.`;
          }
          return `You are not authorized to access this resource.`;
        };
      }
    };
    exports2.UnauthorizedError = UnauthorizedError2;
  }
});

// ../errors/dist/FleekConfigInvalidContentError.js
var require_FleekConfigInvalidContentError = __commonJS({
  "../errors/dist/FleekConfigInvalidContentError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekConfigInvalidContentError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekConfigInvalidContentError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekConfigInvalidContentError";
        this.toString = () => {
          if (this.data.validationResult) {
            return `Validation of loaded ${this.data.configPath} failed. ${this.data.validationResult}`;
          }
          return `Loaded ${this.data.configPath} file is corrupted.`;
        };
      }
    };
    exports2.FleekConfigInvalidContentError = FleekConfigInvalidContentError;
  }
});

// ../errors/dist/FleekConfigMissingFileError.js
var require_FleekConfigMissingFileError = __commonJS({
  "../errors/dist/FleekConfigMissingFileError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekConfigMissingFileError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekConfigMissingFileError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekConfigMissingFileError";
        this.toString = () => {
          return `Unable to access or find the configuration file${this.data.configPath && " " + this.data.configPath + "." || "."}`;
        };
      }
    };
    exports2.FleekConfigMissingFileError = FleekConfigMissingFileError;
  }
});

// ../errors/dist/ApplicationWhitelistDomainDuplicityError.js
var require_ApplicationWhitelistDomainDuplicityError = __commonJS({
  "../errors/dist/ApplicationWhitelistDomainDuplicityError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationWhitelistDomainDuplicityError = void 0;
    var FleekError_1 = require_FleekError();
    var ApplicationWhitelistDomainDuplicityError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ApplicationWhitelistDomainDuplicityError";
        this.toString = () => `Application ${this.data.application.name} doesn't have unique white label domains.`;
      }
    };
    exports2.ApplicationWhitelistDomainDuplicityError = ApplicationWhitelistDomainDuplicityError;
  }
});

// ../errors/dist/ApplicationAlreadyExistsError.js
var require_ApplicationAlreadyExistsError = __commonJS({
  "../errors/dist/ApplicationAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var ApplicationAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ApplicationAlreadyExistsError";
        this.toString = () => `Application ${this.data.application.name} already exists.`;
      }
    };
    exports2.ApplicationAlreadyExistsError = ApplicationAlreadyExistsError;
  }
});

// ../errors/dist/ApplicationsNotFoundError.js
var require_ApplicationsNotFoundError = __commonJS({
  "../errors/dist/ApplicationsNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationsNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var ApplicationsNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ApplicationsNotFoundError";
        this.toString = () => "No applications found.";
      }
    };
    exports2.ApplicationsNotFoundError = ApplicationsNotFoundError;
  }
});

// ../errors/dist/ApplicationNotFoundError.js
var require_ApplicationNotFoundError = __commonJS({
  "../errors/dist/ApplicationNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var ApplicationNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ApplicationNotFoundError";
        this.toString = () => "Application not found.";
      }
    };
    exports2.ApplicationNotFoundError = ApplicationNotFoundError;
  }
});

// ../errors/dist/ApplicationNameInvalidError.js
var require_ApplicationNameInvalidError = __commonJS({
  "../errors/dist/ApplicationNameInvalidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationNameInvalidError = void 0;
    var FleekError_1 = require_FleekError();
    var ApplicationNameInvalidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ApplicationNameInvalidError";
        this.toString = () => `The application name ${this.data.name} is invalid.`;
      }
    };
    exports2.ApplicationNameInvalidError = ApplicationNameInvalidError;
  }
});

// ../errors/dist/EnsRecordNotFoundError.js
var require_EnsRecordNotFoundError = __commonJS({
  "../errors/dist/EnsRecordNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsRecordNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var EnsRecordNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnsRecordNotFoundError";
        this.toString = () => {
          if (this.data.site?.id) {
            return `No site associated with this ENS record.`;
          }
          return `ENS record was not found.`;
        };
      }
    };
    exports2.EnsRecordNotFoundError = EnsRecordNotFoundError;
  }
});

// ../errors/dist/EnsRecordAlreadyExistsInProjectError.js
var require_EnsRecordAlreadyExistsInProjectError = __commonJS({
  "../errors/dist/EnsRecordAlreadyExistsInProjectError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsRecordAlreadyExistsInProjectError = void 0;
    var FleekError_1 = require_FleekError();
    var EnsRecordAlreadyExistsInProjectError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnsRecordAlreadyExistsInProjectError";
        this.toString = () => {
          return `ENS record already exists under the project.`;
        };
      }
    };
    exports2.EnsRecordAlreadyExistsInProjectError = EnsRecordAlreadyExistsInProjectError;
  }
});

// ../errors/dist/EnsNameInvalidError.js
var require_EnsNameInvalidError = __commonJS({
  "../errors/dist/EnsNameInvalidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsNameInvalidError = void 0;
    var FleekError_1 = require_FleekError();
    var EnsNameInvalidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnsNameInvalidError";
        this.toString = () => {
          return `ENS record name "${this.data.ensRecord.name}" is invalid.`;
        };
      }
    };
    exports2.EnsNameInvalidError = EnsNameInvalidError;
  }
});

// ../errors/dist/EnsRecordInPendingStateError.js
var require_EnsRecordInPendingStateError = __commonJS({
  "../errors/dist/EnsRecordInPendingStateError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsRecordInPendingStateError = void 0;
    var FleekError_1 = require_FleekError();
    var EnsRecordInPendingStateError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnsRecordInPendingStateError";
        this.toString = () => {
          return "ENS Record is in pending state. Please wait and try action again later.";
        };
      }
    };
    exports2.EnsRecordInPendingStateError = EnsRecordInPendingStateError;
  }
});

// ../errors/dist/InvalidPersonalAccessTokenError.js
var require_InvalidPersonalAccessTokenError = __commonJS({
  "../errors/dist/InvalidPersonalAccessTokenError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidPersonalAccessTokenError = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidPersonalAccessTokenError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidPersonalAccessTokenError";
        this.toString = () => "Personal access token is invalid.";
      }
    };
    exports2.InvalidPersonalAccessTokenError = InvalidPersonalAccessTokenError;
  }
});

// ../errors/dist/PersonalAccessTokenNotFoundError.js
var require_PersonalAccessTokenNotFoundError = __commonJS({
  "../errors/dist/PersonalAccessTokenNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PersonalAccessTokenNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var PersonalAccessTokenNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PersonalAccessTokenNotFoundError";
        this.toString = () => `Personal access token with ID ${this.data.personalAccessToken.id} not found.`;
      }
    };
    exports2.PersonalAccessTokenNotFoundError = PersonalAccessTokenNotFoundError;
  }
});

// ../errors/dist/PrivateGatewayNotFoundError.js
var require_PrivateGatewayNotFoundError = __commonJS({
  "../errors/dist/PrivateGatewayNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrivateGatewayNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var PrivateGatewayNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PrivateGatewayNotFoundError";
        this.toString = () => `Private gateway not found.`;
      }
    };
    exports2.PrivateGatewayNotFoundError = PrivateGatewayNotFoundError2;
  }
});

// ../errors/dist/PrivateGatewayAlreadyExistsError.js
var require_PrivateGatewayAlreadyExistsError = __commonJS({
  "../errors/dist/PrivateGatewayAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrivateGatewayAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var PrivateGatewayAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PrivateGatewayAlreadyExistsError";
        this.toString = () => `Private gateway already exists. Please choose different name for the private gateway.`;
      }
    };
    exports2.PrivateGatewayAlreadyExistsError = PrivateGatewayAlreadyExistsError;
  }
});

// ../errors/dist/PrivateGatewayNameInvalidError.js
var require_PrivateGatewayNameInvalidError = __commonJS({
  "../errors/dist/PrivateGatewayNameInvalidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrivateGatewayNameInvalidError = void 0;
    var FleekError_1 = require_FleekError();
    var PrivateGatewayNameInvalidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PrivateGatewayNameInvalidError";
        this.toString = () => `The private gateway name ${this.data.name} is invalid.`;
      }
    };
    exports2.PrivateGatewayNameInvalidError = PrivateGatewayNameInvalidError;
  }
});

// ../errors/dist/PrivateGatewaysNotFoundError.js
var require_PrivateGatewaysNotFoundError = __commonJS({
  "../errors/dist/PrivateGatewaysNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrivateGatewaysNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var PrivateGatewaysNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PrivateGatewaysNotFoundError";
        this.toString = () => "No private gateways found.";
      }
    };
    exports2.PrivateGatewaysNotFoundError = PrivateGatewaysNotFoundError2;
  }
});

// ../errors/dist/TemplateAlreadyExistsError.js
var require_TemplateAlreadyExistsError = __commonJS({
  "../errors/dist/TemplateAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var TemplateAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "TemplateAlreadyExistsError";
        this.toString = () => `Template already exists.`;
      }
    };
    exports2.TemplateAlreadyExistsError = TemplateAlreadyExistsError;
  }
});

// ../errors/dist/TemplateNotFoundError.js
var require_TemplateNotFoundError = __commonJS({
  "../errors/dist/TemplateNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var TemplateNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "TemplateNotFoundError";
        this.toString = () => `Template not found.`;
      }
    };
    exports2.TemplateNotFoundError = TemplateNotFoundError;
  }
});

// ../errors/dist/UserHasNoAccessToAnotherUserError.js
var require_UserHasNoAccessToAnotherUserError = __commonJS({
  "../errors/dist/UserHasNoAccessToAnotherUserError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserHasNoAccessToAnotherUserError = void 0;
    var FleekError_1 = require_FleekError();
    var UserHasNoAccessToAnotherUserError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "UserHasNoAccessToAnotherUserError";
        this.toString = () => "You don`t have access to user you try to fetch data for.";
      }
    };
    exports2.UserHasNoAccessToAnotherUserError = UserHasNoAccessToAnotherUserError;
  }
});

// ../errors/dist/SiteFrameworkAlreadyExistsError.js
var require_SiteFrameworkAlreadyExistsError = __commonJS({
  "../errors/dist/SiteFrameworkAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteFrameworkAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteFrameworkAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteFrameworkAlreadyExistsError";
        this.toString = () => `Site framework already exists.`;
      }
    };
    exports2.SiteFrameworkAlreadyExistsError = SiteFrameworkAlreadyExistsError;
  }
});

// ../errors/dist/SiteFrameworkNotFoundError.js
var require_SiteFrameworkNotFoundError = __commonJS({
  "../errors/dist/SiteFrameworkNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteFrameworkNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteFrameworkNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteFrameworkNotFoundError";
        this.toString = () => `Site framework not found.`;
      }
    };
    exports2.SiteFrameworkNotFoundError = SiteFrameworkNotFoundError;
  }
});

// ../errors/dist/TemplateCategoryNotFoundError.js
var require_TemplateCategoryNotFoundError = __commonJS({
  "../errors/dist/TemplateCategoryNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateCategoryNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var TemplateCategoryNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "TemplateCategoryNotFoundError";
        this.toString = () => `Template category not found.`;
      }
    };
    exports2.TemplateCategoryNotFoundError = TemplateCategoryNotFoundError;
  }
});

// ../errors/dist/TemplateDeploymentNotFoundError.js
var require_TemplateDeploymentNotFoundError = __commonJS({
  "../errors/dist/TemplateDeploymentNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemplateDeploymentNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var TemplateDeploymentNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "TemplateDeploymentNotFoundError";
        this.toString = () => `Template deployment not found.`;
      }
    };
    exports2.TemplateDeploymentNotFoundError = TemplateDeploymentNotFoundError;
  }
});

// ../errors/dist/ProjectMembershipHasInefficientRoleError.js
var require_ProjectMembershipHasInefficientRoleError = __commonJS({
  "../errors/dist/ProjectMembershipHasInefficientRoleError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectMembershipHasInefficientRoleError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectMembershipHasInefficientRoleError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectMembershipHasInefficientRoleError";
        this.toString = () => `Membership has inefficient role for this action.`;
      }
    };
    exports2.ProjectMembershipHasInefficientRoleError = ProjectMembershipHasInefficientRoleError;
  }
});

// ../errors/dist/SecretGroupNotFoundError.js
var require_SecretGroupNotFoundError = __commonJS({
  "../errors/dist/SecretGroupNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecretGroupNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var SecretGroupNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SecretGroupNotFoundError";
        this.toString = () => {
          return "Secret group was not found.";
        };
      }
    };
    exports2.SecretGroupNotFoundError = SecretGroupNotFoundError;
  }
});

// ../errors/dist/SecretNotFoundError.js
var require_SecretNotFoundError = __commonJS({
  "../errors/dist/SecretNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecretNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var SecretNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SecretNotFoundError";
        this.toString = () => {
          return "Secret was not found.";
        };
      }
    };
    exports2.SecretNotFoundError = SecretNotFoundError;
  }
});

// ../errors/dist/SecretVisibilityAlreadyEncryptedError.js
var require_SecretVisibilityAlreadyEncryptedError = __commonJS({
  "../errors/dist/SecretVisibilityAlreadyEncryptedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecretVisibilityAlreadyEncryptedError = void 0;
    var FleekError_1 = require_FleekError();
    var SecretVisibilityAlreadyEncryptedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SecretVisibilityAlreadyEncryptedError";
        this.toString = () => {
          return "You cannot change visibility of already encrypted secret.";
        };
      }
    };
    exports2.SecretVisibilityAlreadyEncryptedError = SecretVisibilityAlreadyEncryptedError;
  }
});

// ../errors/dist/SecretKeyAlreadyExistsError.js
var require_SecretKeyAlreadyExistsError = __commonJS({
  "../errors/dist/SecretKeyAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecretKeyAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var SecretKeyAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SecretKeyAlreadyExistsError";
        this.toString = () => {
          return "Variable with this key is already set.";
        };
      }
    };
    exports2.SecretKeyAlreadyExistsError = SecretKeyAlreadyExistsError;
  }
});

// ../errors/dist/SecretFailToEncryptError.js
var require_SecretFailToEncryptError = __commonJS({
  "../errors/dist/SecretFailToEncryptError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecretFailToEncryptError = void 0;
    var FleekError_1 = require_FleekError();
    var SecretFailToEncryptError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SecretFailToEncryptError";
        this.toString = () => {
          return "Failed to encrypt secret.";
        };
      }
    };
    exports2.SecretFailToEncryptError = SecretFailToEncryptError;
  }
});

// ../errors/dist/PinNotFoundError.js
var require_PinNotFoundError = __commonJS({
  "../errors/dist/PinNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PinNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var PinNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PinNotFoundError";
        this.toString = () => {
          return "Pin was not found.";
        };
      }
    };
    exports2.PinNotFoundError = PinNotFoundError2;
  }
});

// ../errors/dist/PinAlreadyExistsInProjectError.js
var require_PinAlreadyExistsInProjectError = __commonJS({
  "../errors/dist/PinAlreadyExistsInProjectError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PinAlreadyExistsInProjectError = void 0;
    var FleekError_1 = require_FleekError();
    var PinAlreadyExistsInProjectError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PinAlreadyExistsInProjectError";
        this.toString = () => {
          return `Pin with the same '${this.data.pin.cid ? "cid" : "path"}' already exists within the project.`;
        };
      }
    };
    exports2.PinAlreadyExistsInProjectError = PinAlreadyExistsInProjectError;
  }
});

// ../errors/dist/UnstoppableDeploymentError.js
var require_UnstoppableDeploymentError = __commonJS({
  "../errors/dist/UnstoppableDeploymentError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnstoppableDeploymentError = void 0;
    var FleekError_1 = require_FleekError();
    var UnstoppableDeploymentError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UnstoppableDeploymentError";
        this.toString = () => `Deployment cannot be stopped.`;
      }
    };
    exports2.UnstoppableDeploymentError = UnstoppableDeploymentError;
  }
});

// ../errors/dist/SiteDeploymentNotReleasedError.js
var require_SiteDeploymentNotReleasedError = __commonJS({
  "../errors/dist/SiteDeploymentNotReleasedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteDeploymentNotReleasedError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteDeploymentNotReleasedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "SiteDeploymentNotReleasedError";
        this.toString = () => `Deployment not released.`;
      }
    };
    exports2.SiteDeploymentNotReleasedError = SiteDeploymentNotReleasedError;
  }
});

// ../errors/dist/InvalidDeploymentTriggerError.js
var require_InvalidDeploymentTriggerError = __commonJS({
  "../errors/dist/InvalidDeploymentTriggerError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidDeploymentTriggerError = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidDeploymentTriggerError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidDeploymentTriggerError";
        this.toString = () => `Deployment can not be triggered, source provider integrations missing.`;
      }
    };
    exports2.InvalidDeploymentTriggerError = InvalidDeploymentTriggerError;
  }
});

// ../errors/dist/IpfsGatewayContentUnreachableError.js
var require_IpfsGatewayContentUnreachableError = __commonJS({
  "../errors/dist/IpfsGatewayContentUnreachableError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IpfsGatewayContentUnreachableError = void 0;
    var FleekError_1 = require_FleekError();
    var IpfsGatewayContentUnreachableError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "IpfsGatewayContentUnreachableError";
        this.toString = () => "Cannot get IPFS content through Fleek gateway.";
      }
    };
    exports2.IpfsGatewayContentUnreachableError = IpfsGatewayContentUnreachableError;
  }
});

// ../errors/dist/InvitationNotFoundError.js
var require_InvitationNotFoundError = __commonJS({
  "../errors/dist/InvitationNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvitationNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var InvitationNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvitationNotFoundError";
        this.toString = () => {
          return "Invitation was not found.";
        };
      }
    };
    exports2.InvitationNotFoundError = InvitationNotFoundError;
  }
});

// ../errors/dist/MigrationTokenInvalidError.js
var require_MigrationTokenInvalidError = __commonJS({
  "../errors/dist/MigrationTokenInvalidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MigrationTokenInvalidError = void 0;
    var FleekError_1 = require_FleekError();
    var MigrationTokenInvalidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "MigrationTokenInvalidError";
        this.toString = () => "Migration token is invalid or expired.";
      }
    };
    exports2.MigrationTokenInvalidError = MigrationTokenInvalidError;
  }
});

// ../errors/dist/MigrationRequestsAlreadyExistError.js
var require_MigrationRequestsAlreadyExistError = __commonJS({
  "../errors/dist/MigrationRequestsAlreadyExistError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MigrationRequestsAlreadyExistError = void 0;
    var FleekError_1 = require_FleekError();
    var MigrationRequestsAlreadyExistError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "MigrationRequestsAlreadyExistError";
        this.toString = () => `All migration requests specified in token are either completed or in progress.`;
      }
    };
    exports2.MigrationRequestsAlreadyExistError = MigrationRequestsAlreadyExistError;
  }
});

// ../errors/dist/MigrationRequestNotFoundError.js
var require_MigrationRequestNotFoundError = __commonJS({
  "../errors/dist/MigrationRequestNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MigrationRequestNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var MigrationRequestNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "MigrationRequestNotFoundError";
        this.toString = () => `Migration request ${this.data.migrationRequest.id} not found.`;
      }
    };
    exports2.MigrationRequestNotFoundError = MigrationRequestNotFoundError;
  }
});

// ../errors/dist/MigrationRequestInPendingStateError.js
var require_MigrationRequestInPendingStateError = __commonJS({
  "../errors/dist/MigrationRequestInPendingStateError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MigrationRequestInPendingStateError = void 0;
    var FleekError_1 = require_FleekError();
    var MigrationRequestInPendingStateError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "MigrationRequestInPendingStateError";
        this.toString = () => "Migration request is in pending state. Please wait and try action again later.";
      }
    };
    exports2.MigrationRequestInPendingStateError = MigrationRequestInPendingStateError;
  }
});

// ../errors/dist/ProjectInvitationAlreadyExistError.js
var require_ProjectInvitationAlreadyExistError = __commonJS({
  "../errors/dist/ProjectInvitationAlreadyExistError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectInvitationAlreadyExistError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectInvitationAlreadyExistError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectInvitationAlreadyExistError";
        this.toString = () => `Project invitation with email ${this.data.user.email} for this project already exist.`;
      }
    };
    exports2.ProjectInvitationAlreadyExistError = ProjectInvitationAlreadyExistError;
  }
});

// ../errors/dist/ProjectMembershipAlreadyExistError.js
var require_ProjectMembershipAlreadyExistError = __commonJS({
  "../errors/dist/ProjectMembershipAlreadyExistError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectMembershipAlreadyExistError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectMembershipAlreadyExistError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectMembershipAlreadyExistError";
        this.toString = () => `Project membership already exists.`;
      }
    };
    exports2.ProjectMembershipAlreadyExistError = ProjectMembershipAlreadyExistError;
  }
});

// ../errors/dist/ProjectMembershipNoOwnersError.js
var require_ProjectMembershipNoOwnersError = __commonJS({
  "../errors/dist/ProjectMembershipNoOwnersError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectMembershipNoOwnersError = void 0;
    var FleekError_1 = require_FleekError();
    var ProjectMembershipNoOwnersError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ProjectMembershipNoOwnersError";
        this.toString = () => `Each project must have at least OWNER-role one membership.`;
      }
    };
    exports2.ProjectMembershipNoOwnersError = ProjectMembershipNoOwnersError;
  }
});

// ../errors/dist/UploadedS3KeyNotFoundError.js
var require_UploadedS3KeyNotFoundError = __commonJS({
  "../errors/dist/UploadedS3KeyNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UploadedS3KeyNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var UploadedS3KeyNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UploadedS3KeyNotFoundError";
        this.toString = () => "Uploaded S3 Key not found.";
      }
    };
    exports2.UploadedS3KeyNotFoundError = UploadedS3KeyNotFoundError;
  }
});

// ../errors/dist/PathIsNotADirectoryError.js
var require_PathIsNotADirectoryError = __commonJS({
  "../errors/dist/PathIsNotADirectoryError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathIsNotADirectoryError = void 0;
    var FleekError_1 = require_FleekError();
    var PathIsNotADirectoryError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PathIsNotADirectoryError";
        this.toString = () => {
          return `Given path ${this.data.path} is not a directory.`;
        };
      }
    };
    exports2.PathIsNotADirectoryError = PathIsNotADirectoryError2;
  }
});

// ../errors/dist/FleekFunctionAlreadyExistsError.js
var require_FleekFunctionAlreadyExistsError = __commonJS({
  "../errors/dist/FleekFunctionAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionAlreadyExistsError";
        this.toString = () => {
          if ("name" in this.data.function || "slug" in this.data.function) {
            return `Function ${this.data.function.name || this.data.function.slug} already exists.`;
          }
          return `Unexpected Function data structure ${JSON.stringify(this.data.function)}`;
        };
      }
    };
    exports2.FleekFunctionAlreadyExistsError = FleekFunctionAlreadyExistsError;
  }
});

// ../errors/dist/FleekFunctionNotFoundError.js
var require_FleekFunctionNotFoundError = __commonJS({
  "../errors/dist/FleekFunctionNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionNotFoundError";
        this.toString = () => {
          if (this.data.function?.name) {
            return `Function ${this.data.function.name} not found.`;
          }
          return `Function not found.`;
        };
      }
    };
    exports2.FleekFunctionNotFoundError = FleekFunctionNotFoundError2;
  }
});

// ../errors/dist/FleekFunctionDeploymentNotFoundError.js
var require_FleekFunctionDeploymentNotFoundError = __commonJS({
  "../errors/dist/FleekFunctionDeploymentNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionDeploymentNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionDeploymentNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionDeploymentNotFoundError";
        this.toString = () => {
          return `Deployment not found.`;
        };
      }
    };
    exports2.FleekFunctionDeploymentNotFoundError = FleekFunctionDeploymentNotFoundError;
  }
});

// ../errors/dist/FleekFunctionsNotFoundError.js
var require_FleekFunctionsNotFoundError = __commonJS({
  "../errors/dist/FleekFunctionsNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionsNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionsNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionsNotFoundError";
        this.toString = () => "No functions found.";
      }
    };
    exports2.FleekFunctionsNotFoundError = FleekFunctionsNotFoundError;
  }
});

// ../errors/dist/FleekFunctionPathNotValidError.js
var require_FleekFunctionPathNotValidError = __commonJS({
  "../errors/dist/FleekFunctionPathNotValidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionPathNotValidError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionPathNotValidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionPathNotValidError";
        this.toString = () => {
          return `File or folder at path, ${this.data.path} is invalid. Please refer to our documentation for more information on function file conventions.`;
        };
      }
    };
    exports2.FleekFunctionPathNotValidError = FleekFunctionPathNotValidError;
  }
});

// ../errors/dist/FleekFunctionNameNotValidError.js
var require_FleekFunctionNameNotValidError = __commonJS({
  "../errors/dist/FleekFunctionNameNotValidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionNameNotValidError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionNameNotValidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionNameNotValidError";
        this.toString = () => {
          return `The name, ${this.data.name}, is invalid`;
        };
      }
    };
    exports2.FleekFunctionNameNotValidError = FleekFunctionNameNotValidError;
  }
});

// ../errors/dist/FleekFunctionStatusNotValidError.js
var require_FleekFunctionStatusNotValidError = __commonJS({
  "../errors/dist/FleekFunctionStatusNotValidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionStatusNotValidError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionStatusNotValidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionStatusNotValidError";
        this.toString = () => {
          return `The function status is invalid. Must be one of ACTIVE and INACTIVE`;
        };
      }
    };
    exports2.FleekFunctionStatusNotValidError = FleekFunctionStatusNotValidError;
  }
});

// ../errors/dist/FleekFunctionSlugNotValidError.js
var require_FleekFunctionSlugNotValidError = __commonJS({
  "../errors/dist/FleekFunctionSlugNotValidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionSlugNotValidError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionSlugNotValidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionSlugNotValidError";
        this.toString = () => {
          return `The slug, ${this.data.slug}, is invalid`;
        };
      }
    };
    exports2.FleekFunctionSlugNotValidError = FleekFunctionSlugNotValidError;
  }
});

// ../errors/dist/MaintenanceError.js
var require_MaintenanceError = __commonJS({
  "../errors/dist/MaintenanceError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MaintenanceError = void 0;
    var FleekError_1 = require_FleekError();
    var MaintenanceError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "MaintenanceError";
        this.extensions = {
          http: {
            status: 503
            // Service Unavailable
          }
        };
        this.toString = () => "The platform is under maintenance. Please try again later.";
      }
    };
    exports2.MaintenanceError = MaintenanceError;
  }
});

// ../errors/dist/UserHasNoAccessToFeatureError.js
var require_UserHasNoAccessToFeatureError = __commonJS({
  "../errors/dist/UserHasNoAccessToFeatureError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserHasNoAccessToFeatureError = void 0;
    var FleekError_1 = require_FleekError();
    var UserHasNoAccessToFeatureError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UserHasNoAccessToFeatureError";
        this.toString = () => `User has no access to this feature.`;
      }
    };
    exports2.UserHasNoAccessToFeatureError = UserHasNoAccessToFeatureError;
  }
});

// ../errors/dist/InvalidCidError.js
var require_InvalidCidError = __commonJS({
  "../errors/dist/InvalidCidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidCidError = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidCidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidCidError";
        this.toString = () => `The cid ${this.data.name} is invalid.`;
      }
    };
    exports2.InvalidCidError = InvalidCidError;
  }
});

// ../errors/dist/ValidationError.js
var require_ValidationError = __commonJS({
  "../errors/dist/ValidationError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValidationError = void 0;
    var FleekError_1 = require_FleekError();
    var ValidationError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ValidationError";
        this.toString = () => `${JSON.stringify(this.data)}`;
      }
    };
    exports2.ValidationError = ValidationError;
  }
});

// ../errors/dist/UserInBlocklistError.js
var require_UserInBlocklistError = __commonJS({
  "../errors/dist/UserInBlocklistError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserInBlocklistError = void 0;
    var FleekError_1 = require_FleekError();
    var UserInBlocklistError = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "UserInBlocklistError";
        this.toString = () => "User is in the blocklist.";
      }
    };
    exports2.UserInBlocklistError = UserInBlocklistError;
  }
});

// ../errors/dist/EnsNameContentHashCodecMistmatchError.js
var require_EnsNameContentHashCodecMistmatchError = __commonJS({
  "../errors/dist/EnsNameContentHashCodecMistmatchError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsNameContentHashCodecMistmatchError = void 0;
    var FleekError_1 = require_FleekError();
    var EnsNameContentHashCodecMistmatchError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnsNameContentHashCodecMistmatchError";
        this.toString = () => {
          return `The content hash does not match or does not corresponds to ${this.data.codec} protocol`;
        };
      }
    };
    exports2.EnsNameContentHashCodecMistmatchError = EnsNameContentHashCodecMistmatchError;
  }
});

// ../errors/dist/EnsNameContentHashUndefinedError.js
var require_EnsNameContentHashUndefinedError = __commonJS({
  "../errors/dist/EnsNameContentHashUndefinedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsNameContentHashUndefinedError = void 0;
    var FleekError_1 = require_FleekError();
    var EnsNameContentHashUndefinedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnsNameContentHashUndefinedError";
        this.toString = () => {
          return `The content hash for ENS record name "${this.data.ensRecord.name}" is undefined.`;
        };
      }
    };
    exports2.EnsNameContentHashUndefinedError = EnsNameContentHashUndefinedError;
  }
});

// ../errors/dist/DnsConfigAlreadyExistsError.js
var require_DnsConfigAlreadyExistsError = __commonJS({
  "../errors/dist/DnsConfigAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DnsConfigAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var DnsConfigAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DnsConfigAlreadyExistsError";
        this.toString = () => `DNS config already exists for "${this.data.name}".`;
      }
    };
    exports2.DnsConfigAlreadyExistsError = DnsConfigAlreadyExistsError;
  }
});

// ../errors/dist/DnsConfigNotFoundError.js
var require_DnsConfigNotFoundError = __commonJS({
  "../errors/dist/DnsConfigNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DnsConfigNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var DnsConfigNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DnsConfigNotFoundError";
        this.toString = () => `DNS config for the "${this.data.name}" name doesn't exist.`;
      }
    };
    exports2.DnsConfigNotFoundError = DnsConfigNotFoundError;
  }
});

// ../errors/dist/TwoFactorSecretKeyFailedToEncryptError.js
var require_TwoFactorSecretKeyFailedToEncryptError = __commonJS({
  "../errors/dist/TwoFactorSecretKeyFailedToEncryptError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TwoFactorSecretKeyFailedToEncryptError = void 0;
    var FleekError_1 = require_FleekError();
    var TwoFactorSecretKeyFailedToEncryptError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "TwoFactorSecretKeyFailedToEncryptError";
        this.toString = () => "Failed to encrypt 2FA secret key.";
      }
    };
    exports2.TwoFactorSecretKeyFailedToEncryptError = TwoFactorSecretKeyFailedToEncryptError;
  }
});

// ../errors/dist/UserSecretKeyAlreadyExistsError.js
var require_UserSecretKeyAlreadyExistsError = __commonJS({
  "../errors/dist/UserSecretKeyAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserSecretKeyAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var UserSecretKeyAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UserSecretKeyAlreadyExistsError";
        this.toString = () => "A secret key for this user already exists.";
      }
    };
    exports2.UserSecretKeyAlreadyExistsError = UserSecretKeyAlreadyExistsError;
  }
});

// ../errors/dist/UserSecretKeyNotFoundError.js
var require_UserSecretKeyNotFoundError = __commonJS({
  "../errors/dist/UserSecretKeyNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserSecretKeyNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var UserSecretKeyNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "UserSecretKeyNotFoundError";
        this.toString = () => "A secret key for this user not found.";
      }
    };
    exports2.UserSecretKeyNotFoundError = UserSecretKeyNotFoundError;
  }
});

// ../errors/dist/TwoFactorSecretKeyFailedToDecryptError.js
var require_TwoFactorSecretKeyFailedToDecryptError = __commonJS({
  "../errors/dist/TwoFactorSecretKeyFailedToDecryptError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TwoFactorSecretKeyFailedToDecryptError = void 0;
    var FleekError_1 = require_FleekError();
    var TwoFactorSecretKeyFailedToDecryptError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "TwoFactorSecretKeyFailedToDecryptError";
        this.toString = () => "Failed to decrypt 2FA secret key.";
      }
    };
    exports2.TwoFactorSecretKeyFailedToDecryptError = TwoFactorSecretKeyFailedToDecryptError;
  }
});

// ../errors/dist/RecoveryCodesAlreadyExistsError.js
var require_RecoveryCodesAlreadyExistsError = __commonJS({
  "../errors/dist/RecoveryCodesAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecoveryCodesAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var RecoveryCodesAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "RecoveryCodesAlreadyExistsError";
        this.toString = () => "Recovery codes already exists.";
      }
    };
    exports2.RecoveryCodesAlreadyExistsError = RecoveryCodesAlreadyExistsError;
  }
});

// ../errors/dist/WriteFileFromStreamError.js
var require_WriteFileFromStreamError = __commonJS({
  "../errors/dist/WriteFileFromStreamError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteFileFromStreamError = void 0;
    var FleekError_1 = require_FleekError();
    var WriteFileFromStreamError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "WriteFileFromStreamError";
        this.toString = () => `There was an error while writing file from stream in globSource`;
      }
    };
    exports2.WriteFileFromStreamError = WriteFileFromStreamError2;
  }
});

// ../errors/dist/InvalidTOTPTokenError.js
var require_InvalidTOTPTokenError = __commonJS({
  "../errors/dist/InvalidTOTPTokenError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidTOTPTokenError = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidTOTPTokenError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidTOTPTokenError";
        this.toString = () => "TOTP token is invalid.";
      }
    };
    exports2.InvalidTOTPTokenError = InvalidTOTPTokenError;
  }
});

// ../errors/dist/InvalidRecoveryCodeError.js
var require_InvalidRecoveryCodeError = __commonJS({
  "../errors/dist/InvalidRecoveryCodeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidRecoveryCodeError = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidRecoveryCodeError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidRecoveryCodeError";
        this.toString = () => "Recovery code is invalid.";
      }
    };
    exports2.InvalidRecoveryCodeError = InvalidRecoveryCodeError;
  }
});

// ../errors/dist/MissingTwoFactorProtectionCredentialsError.js
var require_MissingTwoFactorProtectionCredentialsError = __commonJS({
  "../errors/dist/MissingTwoFactorProtectionCredentialsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingTwoFactorProtectionCredentialsError = void 0;
    var FleekError_1 = require_FleekError();
    var MissingTwoFactorProtectionCredentialsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "MissingTwoFactorProtectionCredentialsError";
        this.toString = () => "Missing two factor protection credentials. Either a token or a recovery key should be provided.";
      }
    };
    exports2.MissingTwoFactorProtectionCredentialsError = MissingTwoFactorProtectionCredentialsError;
  }
});

// ../errors/dist/DeploymentInProgressError.js
var require_DeploymentInProgressError = __commonJS({
  "../errors/dist/DeploymentInProgressError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeploymentInProgressError = void 0;
    var FleekError_1 = require_FleekError();
    var DeploymentInProgressError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "DeploymentInProgressError";
        this.toString = () => "Deployment is already in progress.";
      }
    };
    exports2.DeploymentInProgressError = DeploymentInProgressError;
  }
});

// ../errors/dist/PullzoneNotFoundForZoneIdError.js
var require_PullzoneNotFoundForZoneIdError = __commonJS({
  "../errors/dist/PullzoneNotFoundForZoneIdError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PullzoneNotFoundForZoneIdError = void 0;
    var FleekError_1 = require_FleekError();
    var PullzoneNotFoundForZoneIdError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PullzoneNotFoundForZoneIdError";
        this.toString = () => {
          return `The pullzone is not found for zone id: ${this.data.id}`;
        };
      }
    };
    exports2.PullzoneNotFoundForZoneIdError = PullzoneNotFoundForZoneIdError;
  }
});

// ../errors/dist/RecoveryCodeFailedToEncryptError.js
var require_RecoveryCodeFailedToEncryptError = __commonJS({
  "../errors/dist/RecoveryCodeFailedToEncryptError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecoveryCodeFailedToEncryptError = void 0;
    var FleekError_1 = require_FleekError();
    var RecoveryCodeFailedToEncryptError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "RecoveryCodeFailedToEncryptError";
        this.toString = () => "Failed to encrypt recovery code.";
      }
    };
    exports2.RecoveryCodeFailedToEncryptError = RecoveryCodeFailedToEncryptError;
  }
});

// ../errors/dist/RecoveryCodeFailedToDecryptError.js
var require_RecoveryCodeFailedToDecryptError = __commonJS({
  "../errors/dist/RecoveryCodeFailedToDecryptError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecoveryCodeFailedToDecryptError = void 0;
    var FleekError_1 = require_FleekError();
    var RecoveryCodeFailedToDecryptError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "RecoveryCodeFailedToDecryptError";
        this.toString = () => "Failed to decrypt recovery code.";
      }
    };
    exports2.RecoveryCodeFailedToDecryptError = RecoveryCodeFailedToDecryptError;
  }
});

// ../errors/dist/PermissionGroupNotFoundError.js
var require_PermissionGroupNotFoundError = __commonJS({
  "../errors/dist/PermissionGroupNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PermissionGroupNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var PermissionGroupNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PermissionGroupNotFoundError";
        this.toString = () => "Permission group not found";
      }
    };
    exports2.PermissionGroupNotFoundError = PermissionGroupNotFoundError;
  }
});

// ../errors/dist/PermissionScopeError.js
var require_PermissionScopeError = __commonJS({
  "../errors/dist/PermissionScopeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PermissionScopeError = void 0;
    var FleekError_1 = require_FleekError();
    var PermissionScopeError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PermissionScopeError";
        this.toString = () => `Permission scope ${this.data.scope} doesn't exist.`;
      }
    };
    exports2.PermissionScopeError = PermissionScopeError;
  }
});

// ../errors/dist/InvalidAdminAccessTokenError.js
var require_InvalidAdminAccessTokenError = __commonJS({
  "../errors/dist/InvalidAdminAccessTokenError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidAdminAccessTokenError = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidAdminAccessTokenError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidAdminAccessTokenError";
        this.toString = () => "Admin access token is invalid.";
      }
    };
    exports2.InvalidAdminAccessTokenError = InvalidAdminAccessTokenError;
  }
});

// ../errors/dist/MissingExpectedDataError.js
var require_MissingExpectedDataError = __commonJS({
  "../errors/dist/MissingExpectedDataError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingExpectedDataError = void 0;
    var FleekError_1 = require_FleekError();
    var MissingExpectedDataError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "MissingExpectedDataError";
        this.toString = () => "Oops! This is embarassing but the app is missing important data. Please report this issue to the team.";
      }
    };
    exports2.MissingExpectedDataError = MissingExpectedDataError;
  }
});

// ../errors/dist/EnvNotSetError.js
var require_EnvNotSetError = __commonJS({
  "../errors/dist/EnvNotSetError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnvNotSetError = void 0;
    var FleekError_1 = require_FleekError();
    var EnvNotSetError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "EnvNotSetError";
        this.toString = () => this.data ? `Environment variable "${this.data}" is not set.` : `Missing the defined object key pair values.`;
      }
    };
    exports2.EnvNotSetError = EnvNotSetError;
  }
});

// ../errors/dist/GitSecretsFailedToEncryptError.js
var require_GitSecretsFailedToEncryptError = __commonJS({
  "../errors/dist/GitSecretsFailedToEncryptError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitSecretsFailedToEncryptError = void 0;
    var FleekError_1 = require_FleekError();
    var GitSecretsFailedToEncryptError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitSecretsFailedToEncryptError";
        this.toString = () => "Failed to encrypt Git Secrets.";
      }
    };
    exports2.GitSecretsFailedToEncryptError = GitSecretsFailedToEncryptError;
  }
});

// ../errors/dist/GitConfigFailedToParseError.js
var require_GitConfigFailedToParseError = __commonJS({
  "../errors/dist/GitConfigFailedToParseError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitConfigFailedToParseError = void 0;
    var FleekError_1 = require_FleekError();
    var GitConfigFailedToParseError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitSecretsFailedToEncryptError";
        this.toString = () => "Failed to parse Git Configs.";
      }
    };
    exports2.GitConfigFailedToParseError = GitConfigFailedToParseError;
  }
});

// ../errors/dist/PathIsNotAFileError.js
var require_PathIsNotAFileError = __commonJS({
  "../errors/dist/PathIsNotAFileError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathIsNotAFileError = void 0;
    var FleekError_1 = require_FleekError();
    var PathIsNotAFileError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PathIsNotAFileError";
        this.toString = () => {
          return `Given path ${this.data.path} is not a file.`;
        };
      }
    };
    exports2.PathIsNotAFileError = PathIsNotAFileError2;
  }
});

// ../errors/dist/FleekFunctionBundlingFailedError.js
var require_FleekFunctionBundlingFailedError = __commonJS({
  "../errors/dist/FleekFunctionBundlingFailedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionBundlingFailedError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionBundlingFailedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionBundlingFailedError";
        this.toString = () => {
          return `Bundle creation failed. For information on supported packages, please consult our documentation.
Error: ${this.data.error}`;
        };
      }
    };
    exports2.FleekFunctionBundlingFailedError = FleekFunctionBundlingFailedError;
  }
});

// ../errors/dist/GitIntegrationNotFoundError.js
var require_GitIntegrationNotFoundError = __commonJS({
  "../errors/dist/GitIntegrationNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitIntegrationNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var GitIntegrationNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitIntegrationNotFoundError";
        this.toString = () => {
          let infix = "";
          if ("siteId" in this.data) {
            infix = `for site ${this.data.siteId}`;
          } else if ("id" in this.data) {
            infix = `with id ${this.data.id}`;
          }
          return `Git Integration ${infix} not found`;
        };
      }
    };
    exports2.GitIntegrationNotFoundError = GitIntegrationNotFoundError;
  }
});

// ../errors/dist/GitProviderNotFoundError.js
var require_GitProviderNotFoundError = __commonJS({
  "../errors/dist/GitProviderNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitProviderNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var GitProviderNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitProviderNotFoundError";
        this.toString = () => {
          return `No Git Provider found with id: ${this.data.providerId}`;
        };
      }
    };
    exports2.GitProviderNotFoundError = GitProviderNotFoundError;
  }
});

// ../errors/dist/ExpectedOneOfValuesError.js
var require_ExpectedOneOfValuesError = __commonJS({
  "../errors/dist/ExpectedOneOfValuesError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExpectedOneOfValuesError = void 0;
    var FleekError_1 = require_FleekError();
    var ExpectedOneOfValuesError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "ExpectedOneOfValuesError";
        this.toString = () => `Expected one of ${this.data.expectedValues.join(", ")} but got ${this.data.receivedValue}`;
      }
    };
    exports2.ExpectedOneOfValuesError = ExpectedOneOfValuesError;
  }
});

// ../errors/dist/InvalidJSONFormat.js
var require_InvalidJSONFormat = __commonJS({
  "../errors/dist/InvalidJSONFormat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidJSONFormat = void 0;
    var FleekError_1 = require_FleekError();
    var InvalidJSONFormat = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "InvalidJSONFormat";
        this.toString = () => `Invalid JSON format.`;
      }
    };
    exports2.InvalidJSONFormat = InvalidJSONFormat;
  }
});

// ../errors/dist/StorageUploadFileCountQuotaExceededError.js
var require_StorageUploadFileCountQuotaExceededError = __commonJS({
  "../errors/dist/StorageUploadFileCountQuotaExceededError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StorageUploadFileCountQuotaExceededError = void 0;
    var FleekError_1 = require_FleekError();
    var StorageUploadFileCountQuotaExceededError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "StorageUploadFileCountQuotaExceededError";
        this.toString = () => `You have exceeded your storage upload quota for total number of files for the last 24 hours.`;
      }
    };
    exports2.StorageUploadFileCountQuotaExceededError = StorageUploadFileCountQuotaExceededError2;
  }
});

// ../errors/dist/StorageUploadTotalSizeQuotaExceededError.js
var require_StorageUploadTotalSizeQuotaExceededError = __commonJS({
  "../errors/dist/StorageUploadTotalSizeQuotaExceededError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StorageUploadTotalSizeQuotaExceededError = void 0;
    var FleekError_1 = require_FleekError();
    var StorageUploadTotalSizeQuotaExceededError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "StorageUploadTotalSizeQuotaExceededError";
        this.toString = () => `You have exceeded your storage upload quota for total size for the last 24 hours.`;
      }
    };
    exports2.StorageUploadTotalSizeQuotaExceededError = StorageUploadTotalSizeQuotaExceededError2;
  }
});

// ../errors/dist/GitProviderNotSupportedError.js
var require_GitProviderNotSupportedError = __commonJS({
  "../errors/dist/GitProviderNotSupportedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitProviderNotSupportedError = void 0;
    var FleekError_1 = require_FleekError();
    var GitProviderNotSupportedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitProviderNotSupportedError";
        this.toString = () => `Git provider: ${this.data.provider} not Supported`;
      }
    };
    exports2.GitProviderNotSupportedError = GitProviderNotSupportedError;
  }
});

// ../errors/dist/GitProviderNotAuthorizedError.js
var require_GitProviderNotAuthorizedError = __commonJS({
  "../errors/dist/GitProviderNotAuthorizedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitProviderNotAuthorizedError = void 0;
    var FleekError_1 = require_FleekError();
    var GitProviderNotAuthorizedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitProviderNotAuthorizedError";
        this.toString = () => `The user has not authorized the Git provider: ${this.data.provider}`;
      }
    };
    exports2.GitProviderNotAuthorizedError = GitProviderNotAuthorizedError;
  }
});

// ../errors/dist/GitAccessTokenInvalidError.js
var require_GitAccessTokenInvalidError = __commonJS({
  "../errors/dist/GitAccessTokenInvalidError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitAccessTokenInvalidError = void 0;
    var FleekError_1 = require_FleekError();
    var GitAccessTokenInvalidError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitAccessTokenInvalidError";
        this.toString = () => {
          return "The git access token for the user is invalid";
        };
      }
    };
    exports2.GitAccessTokenInvalidError = GitAccessTokenInvalidError;
  }
});

// ../errors/dist/QueuedDeploymentsLimitError.js
var require_QueuedDeploymentsLimitError = __commonJS({
  "../errors/dist/QueuedDeploymentsLimitError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueuedDeploymentsLimitError = void 0;
    var FleekError_1 = require_FleekError();
    var QueuedDeploymentsLimitError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "QueuedDeploymentsLimitError";
        this.toString = () => `You've reached the limit of ${this.data.limit} queued deployments.`;
      }
    };
    exports2.QueuedDeploymentsLimitError = QueuedDeploymentsLimitError;
  }
});

// ../errors/dist/GitIntegrationInstallationConflictError.js
var require_GitIntegrationInstallationConflictError = __commonJS({
  "../errors/dist/GitIntegrationInstallationConflictError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitIntegrationInstallationConflictError = void 0;
    var FleekError_1 = require_FleekError();
    var GitIntegrationInstallationConflictError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitIntegrationInstallationConflictError";
        this.toString = () => `The Git Integration installation for this provider already exists in this project`;
      }
    };
    exports2.GitIntegrationInstallationConflictError = GitIntegrationInstallationConflictError;
  }
});

// ../errors/dist/GitLinkMultipleAccountError.js
var require_GitLinkMultipleAccountError = __commonJS({
  "../errors/dist/GitLinkMultipleAccountError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitLinkMultipleAccountError = void 0;
    var FleekError_1 = require_FleekError();
    var GitLinkMultipleAccountError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitLinkMultipleAccountError";
        this.toString = () => `Oops! You already have a Git profile linked to your Fleek account. We don't allow multiple connections`;
      }
    };
    exports2.GitLinkMultipleAccountError = GitLinkMultipleAccountError;
  }
});

// ../errors/dist/GitRepoByNameAndOwnerNotFoundError.js
var require_GitRepoByNameAndOwnerNotFoundError = __commonJS({
  "../errors/dist/GitRepoByNameAndOwnerNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitRepoByNameAndOwnerNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var GitRepoByNameAndOwnerNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitRepoByNameAndOwnerNotFoundError";
        this.toString = () => `Git repo "${this.data.owner}/${this.data.repo}" not found`;
      }
    };
    exports2.GitRepoByNameAndOwnerNotFoundError = GitRepoByNameAndOwnerNotFoundError;
  }
});

// ../errors/dist/GitAccessTokenNotFoundError.js
var require_GitAccessTokenNotFoundError = __commonJS({
  "../errors/dist/GitAccessTokenNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitAccessTokenNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var GitAccessTokenNotFoundError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "GitAccessTokenNotFoundError";
        this.toString = () => {
          return "The git access token for the user is not found";
        };
      }
    };
    exports2.GitAccessTokenNotFoundError = GitAccessTokenNotFoundError;
  }
});

// ../errors/dist/FolderNotFoundError.js
var require_FolderNotFoundError = __commonJS({
  "../errors/dist/FolderNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FolderNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var FolderNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FolderNotFoundError";
        this.toString = () => `Folder was not found.`;
      }
    };
    exports2.FolderNotFoundError = FolderNotFoundError2;
  }
});

// ../errors/dist/FolderAlreadyExistsError.js
var require_FolderAlreadyExistsError = __commonJS({
  "../errors/dist/FolderAlreadyExistsError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FolderAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    var FolderAlreadyExistsError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FolderAlreadyExistsError";
        this.toString = () => `Folder ${this.data.folder.name} already exists in ${this.data.folder.parentFolderId ? "parent" : "root project"} folder.`;
      }
    };
    exports2.FolderAlreadyExistsError = FolderAlreadyExistsError;
  }
});

// ../errors/dist/PinsNotFoundError.js
var require_PinsNotFoundError = __commonJS({
  "../errors/dist/PinsNotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PinsNotFoundError = void 0;
    var FleekError_1 = require_FleekError();
    var PinsNotFoundError2 = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "PinsNotFoundError";
        this.toString = () => {
          return "No pins found.";
        };
      }
    };
    exports2.PinsNotFoundError = PinsNotFoundError2;
  }
});

// ../errors/dist/SiteCreationFailedError.js
var require_SiteCreationFailedError = __commonJS({
  "../errors/dist/SiteCreationFailedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiteCreationFailedError = void 0;
    var FleekError_1 = require_FleekError();
    var SiteCreationFailedError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "SiteCreationFailedError";
        this.toString = () => `Site creation failed.`;
      }
    };
    exports2.SiteCreationFailedError = SiteCreationFailedError2;
  }
});

// ../errors/dist/FleekFunctionInvalidWasmCodeError.js
var require_FleekFunctionInvalidWasmCodeError = __commonJS({
  "../errors/dist/FleekFunctionInvalidWasmCodeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionInvalidWasmCodeError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionInvalidWasmCodeError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionInvalidWasmCodeError";
        this.toString = () => {
          return `Fleek function encountered corrupt or invalid WASM code.`;
        };
      }
    };
    exports2.FleekFunctionInvalidWasmCodeError = FleekFunctionInvalidWasmCodeError;
  }
});

// ../errors/dist/FleekFunctionWasmEncryptionFailedError.js
var require_FleekFunctionWasmEncryptionFailedError = __commonJS({
  "../errors/dist/FleekFunctionWasmEncryptionFailedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FleekFunctionWasmEncryptionFailedError = void 0;
    var FleekError_1 = require_FleekError();
    var FleekFunctionWasmEncryptionFailedError = class extends FleekError_1.FleekError {
      constructor() {
        super(...arguments);
        this.name = "FleekFunctionWasmEncryptionFailedError";
        this.toString = () => {
          return `Unable to encrypt WASM code for Fleek function`;
        };
      }
    };
    exports2.FleekFunctionWasmEncryptionFailedError = FleekFunctionWasmEncryptionFailedError;
  }
});

// ../errors/dist/UploadProxyStoreAsCarError.js
var require_UploadProxyStoreAsCarError = __commonJS({
  "../errors/dist/UploadProxyStoreAsCarError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UploadProxyStoreAsCarError = void 0;
    var FleekError_1 = require_FleekError();
    var UploadProxyStoreAsCarError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "UploadProxyStoreAsCarError";
        this.toString = () => `Failed to Store as a CAR file.`;
      }
    };
    exports2.UploadProxyStoreAsCarError = UploadProxyStoreAsCarError2;
  }
});

// ../errors/dist/UploadProxyUploadFileError.js
var require_UploadProxyUploadFileError = __commonJS({
  "../errors/dist/UploadProxyUploadFileError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UploadProxyUploadFileError = void 0;
    var FleekError_1 = require_FleekError();
    var UploadProxyUploadFileError2 = class extends FleekError_1.FleekError {
      constructor() {
        super({});
        this.name = "UploadProxyUploadFileError";
        this.toString = () => `Failed to Upload file.`;
      }
    };
    exports2.UploadProxyUploadFileError = UploadProxyUploadFileError2;
  }
});

// ../errors/dist/index.js
var require_dist = __commonJS({
  "../errors/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnsRecordInPendingStateError = exports2.EnsNameInvalidError = exports2.EnsRecordAlreadyExistsInProjectError = exports2.EnsRecordNotFoundError = exports2.ApplicationNameInvalidError = exports2.ApplicationNotFoundError = exports2.ApplicationsNotFoundError = exports2.ApplicationAlreadyExistsError = exports2.ApplicationWhitelistDomainDuplicityError = exports2.FleekConfigMissingFileError = exports2.FleekConfigInvalidContentError = exports2.UnauthorizedError = exports2.DomainZoneInvalidTypeError = exports2.DomainNotFoundUnderPullzoneError = exports2.DomainZoneInPendingStateError = exports2.DomainZoneHasDependentsError = exports2.DomainZoneNotFoundError = exports2.UnauthenticatedError = exports2.VerificationSessionAlreadyExistsError = exports2.PublicKeyAlreadyExistsError = exports2.ProjectInvalidNameError = exports2.ProjectHasDependentsError = exports2.ProjectsNotFoundError = exports2.ProjectNotFoundError = exports2.UserAlreadyExistsError = exports2.UserNotFoundError = exports2.GithubAppInstallationNotFoundError = exports2.ProjectMembershipNotFoundError = exports2.AuthorizationError = exports2.SdkRequiredNodeRuntimeError = exports2.StorageIpfsUploadFailedError = exports2.IpnsRecordsForSiteLimitError = exports2.IpnsFailToDecryptKeyError = exports2.IpnsRecordsNotFoundError = exports2.IpnsRecordNotFoundError = exports2.SiteNotDeployedError = exports2.SiteHasNoSourceProviderError = exports2.SiteHasDependentsError = exports2.SiteDeploymentNotFoundError = exports2.SiteAlreadyExistsError = exports2.SitesNotFoundError = exports2.SiteNotFoundError = exports2.UnknownError = exports2.DomainHostnameInvalidError = exports2.DomainInPendingStateError = exports2.DomainAlreadyExistsInProjectError = exports2.DomainsNotFoundError = exports2.DomainNotFoundError = exports2.BunnyPullZoneNotFoundError = exports2.FleekError = void 0;
    exports2.EnsNameContentHashUndefinedError = exports2.EnsNameContentHashCodecMistmatchError = exports2.UserInBlocklistError = exports2.ValidationError = exports2.InvalidCidError = exports2.UserHasNoAccessToFeatureError = exports2.MaintenanceError = exports2.FleekFunctionSlugNotValidError = exports2.FleekFunctionStatusNotValidError = exports2.FleekFunctionNameNotValidError = exports2.FleekFunctionPathNotValidError = exports2.FleekFunctionsNotFoundError = exports2.FleekFunctionDeploymentNotFoundError = exports2.FleekFunctionNotFoundError = exports2.FleekFunctionAlreadyExistsError = exports2.PathIsNotADirectoryError = exports2.UploadedS3KeyNotFoundError = exports2.ProjectMembershipNoOwnersError = exports2.ProjectMembershipAlreadyExistError = exports2.ProjectInvitationAlreadyExistError = exports2.MigrationRequestInPendingStateError = exports2.MigrationRequestNotFoundError = exports2.MigrationRequestsAlreadyExistError = exports2.MigrationTokenInvalidError = exports2.InvitationNotFoundError = exports2.IpfsGatewayContentUnreachableError = exports2.InvalidDeploymentTriggerError = exports2.SiteDeploymentNotReleasedError = exports2.UnstoppableDeploymentError = exports2.PinAlreadyExistsInProjectError = exports2.PinNotFoundError = exports2.SecretFailToEncryptError = exports2.SecretKeyAlreadyExistsError = exports2.SecretVisibilityAlreadyEncryptedError = exports2.SecretNotFoundError = exports2.SecretGroupNotFoundError = exports2.ProjectMembershipHasInefficientRoleError = exports2.TemplateDeploymentNotFoundError = exports2.TemplateCategoryNotFoundError = exports2.SiteFrameworkNotFoundError = exports2.SiteFrameworkAlreadyExistsError = exports2.UserHasNoAccessToAnotherUserError = exports2.TemplateNotFoundError = exports2.TemplateAlreadyExistsError = exports2.PrivateGatewaysNotFoundError = exports2.PrivateGatewayNameInvalidError = exports2.PrivateGatewayAlreadyExistsError = exports2.PrivateGatewayNotFoundError = exports2.PersonalAccessTokenNotFoundError = exports2.InvalidPersonalAccessTokenError = void 0;
    exports2.UploadProxyUploadFileError = exports2.UploadProxyStoreAsCarError = exports2.FleekFunctionWasmEncryptionFailedError = exports2.FleekFunctionInvalidWasmCodeError = exports2.SiteCreationFailedError = exports2.PinsNotFoundError = exports2.FolderAlreadyExistsError = exports2.FolderNotFoundError = exports2.GitAccessTokenNotFoundError = exports2.GitRepoByNameAndOwnerNotFoundError = exports2.GitLinkMultipleAccountError = exports2.GitIntegrationInstallationConflictError = exports2.QueuedDeploymentsLimitError = exports2.GitAccessTokenInvalidError = exports2.GitProviderNotAuthorizedError = exports2.GitProviderNotSupportedError = exports2.StorageUploadTotalSizeQuotaExceededError = exports2.StorageUploadFileCountQuotaExceededError = exports2.InvalidJSONFormat = exports2.ExpectedOneOfValuesError = exports2.GitProviderNotFoundError = exports2.GitIntegrationNotFoundError = exports2.FleekFunctionBundlingFailedError = exports2.PathIsNotAFileError = exports2.GitConfigFailedToParseError = exports2.GitSecretsFailedToEncryptError = exports2.EnvNotSetError = exports2.MissingExpectedDataError = exports2.InvalidAdminAccessTokenError = exports2.PermissionScopeError = exports2.PermissionGroupNotFoundError = exports2.RecoveryCodeFailedToDecryptError = exports2.RecoveryCodeFailedToEncryptError = exports2.PullzoneNotFoundForZoneIdError = exports2.DeploymentInProgressError = exports2.MissingTwoFactorProtectionCredentialsError = exports2.InvalidRecoveryCodeError = exports2.InvalidTOTPTokenError = exports2.WriteFileFromStreamError = exports2.RecoveryCodesAlreadyExistsError = exports2.TwoFactorSecretKeyFailedToDecryptError = exports2.UserSecretKeyNotFoundError = exports2.UserSecretKeyAlreadyExistsError = exports2.TwoFactorSecretKeyFailedToEncryptError = exports2.DnsConfigNotFoundError = exports2.DnsConfigAlreadyExistsError = void 0;
    var FleekError_1 = require_FleekError();
    Object.defineProperty(exports2, "FleekError", { enumerable: true, get: function() {
      return FleekError_1.FleekError;
    } });
    var BunnyPullZoneNotFoundError_1 = require_BunnyPullZoneNotFoundError();
    Object.defineProperty(exports2, "BunnyPullZoneNotFoundError", { enumerable: true, get: function() {
      return BunnyPullZoneNotFoundError_1.BunnyPullZoneNotFoundError;
    } });
    var DomainNotFoundError_1 = require_DomainNotFoundError();
    Object.defineProperty(exports2, "DomainNotFoundError", { enumerable: true, get: function() {
      return DomainNotFoundError_1.DomainNotFoundError;
    } });
    var DomainsNotFoundError_1 = require_DomainsNotFoundError();
    Object.defineProperty(exports2, "DomainsNotFoundError", { enumerable: true, get: function() {
      return DomainsNotFoundError_1.DomainsNotFoundError;
    } });
    var DomainAlreadyExistsInProjectError_1 = require_DomainAlreadyExistsInProjectError();
    Object.defineProperty(exports2, "DomainAlreadyExistsInProjectError", { enumerable: true, get: function() {
      return DomainAlreadyExistsInProjectError_1.DomainAlreadyExistsInProjectError;
    } });
    var DomainInPendingStateError_1 = require_DomainInPendingStateError();
    Object.defineProperty(exports2, "DomainInPendingStateError", { enumerable: true, get: function() {
      return DomainInPendingStateError_1.DomainInPendingStateError;
    } });
    var DomainHostnameInvalidError_1 = require_DomainHostnameInvalidError();
    Object.defineProperty(exports2, "DomainHostnameInvalidError", { enumerable: true, get: function() {
      return DomainHostnameInvalidError_1.DomainHostnameInvalidError;
    } });
    var UnknownError_1 = require_UnknownError();
    Object.defineProperty(exports2, "UnknownError", { enumerable: true, get: function() {
      return UnknownError_1.UnknownError;
    } });
    var SiteNotFoundError_1 = require_SiteNotFoundError();
    Object.defineProperty(exports2, "SiteNotFoundError", { enumerable: true, get: function() {
      return SiteNotFoundError_1.SiteNotFoundError;
    } });
    var SitesNotFoundError_1 = require_SitesNotFoundError();
    Object.defineProperty(exports2, "SitesNotFoundError", { enumerable: true, get: function() {
      return SitesNotFoundError_1.SitesNotFoundError;
    } });
    var SiteAlreadyExistsError_1 = require_SiteAlreadyExistsError();
    Object.defineProperty(exports2, "SiteAlreadyExistsError", { enumerable: true, get: function() {
      return SiteAlreadyExistsError_1.SiteAlreadyExistsError;
    } });
    var SiteDeploymentNotFoundError_1 = require_SiteDeploymentNotFoundError();
    Object.defineProperty(exports2, "SiteDeploymentNotFoundError", { enumerable: true, get: function() {
      return SiteDeploymentNotFoundError_1.SiteDeploymentNotFoundError;
    } });
    var SiteHasDependentsError_1 = require_SiteHasDependentsError();
    Object.defineProperty(exports2, "SiteHasDependentsError", { enumerable: true, get: function() {
      return SiteHasDependentsError_1.SiteHasDependentsError;
    } });
    var SiteHasNoSourceProviderError_1 = require_SiteHasNoSourceProviderError();
    Object.defineProperty(exports2, "SiteHasNoSourceProviderError", { enumerable: true, get: function() {
      return SiteHasNoSourceProviderError_1.SiteHasNoSourceProviderError;
    } });
    var SiteNotDeployedError_1 = require_SiteNotDeployedError();
    Object.defineProperty(exports2, "SiteNotDeployedError", { enumerable: true, get: function() {
      return SiteNotDeployedError_1.SiteNotDeployedError;
    } });
    var IpnsRecordNotFoundError_1 = require_IpnsRecordNotFoundError();
    Object.defineProperty(exports2, "IpnsRecordNotFoundError", { enumerable: true, get: function() {
      return IpnsRecordNotFoundError_1.IpnsRecordNotFoundError;
    } });
    var IpnsRecordsNotFoundError_1 = require_IpnsRecordsNotFoundError();
    Object.defineProperty(exports2, "IpnsRecordsNotFoundError", { enumerable: true, get: function() {
      return IpnsRecordsNotFoundError_1.IpnsRecordsNotFoundError;
    } });
    var IpnsFailToDecryptKeyError_1 = require_IpnsFailToDecryptKeyError();
    Object.defineProperty(exports2, "IpnsFailToDecryptKeyError", { enumerable: true, get: function() {
      return IpnsFailToDecryptKeyError_1.IpnsFailToDecryptKeyError;
    } });
    var IpnsRecordsForSiteLimitError_1 = require_IpnsRecordsForSiteLimitError();
    Object.defineProperty(exports2, "IpnsRecordsForSiteLimitError", { enumerable: true, get: function() {
      return IpnsRecordsForSiteLimitError_1.IpnsRecordsForSiteLimitError;
    } });
    var StorageIpfsUploadFailedError_1 = require_StorageIpfsUploadFailedError();
    Object.defineProperty(exports2, "StorageIpfsUploadFailedError", { enumerable: true, get: function() {
      return StorageIpfsUploadFailedError_1.StorageIpfsUploadFailedError;
    } });
    var SdkRequiredNodeRuntimeError_1 = require_SdkRequiredNodeRuntimeError();
    Object.defineProperty(exports2, "SdkRequiredNodeRuntimeError", { enumerable: true, get: function() {
      return SdkRequiredNodeRuntimeError_1.SdkRequiredNodeRuntimeError;
    } });
    var AuthorizationError_1 = require_AuthorizationError();
    Object.defineProperty(exports2, "AuthorizationError", { enumerable: true, get: function() {
      return AuthorizationError_1.AuthorizationError;
    } });
    var ProjectMembershipNotFoundError_1 = require_ProjectMembershipNotFoundError();
    Object.defineProperty(exports2, "ProjectMembershipNotFoundError", { enumerable: true, get: function() {
      return ProjectMembershipNotFoundError_1.ProjectMembershipNotFoundError;
    } });
    var GithubAppInstallationNotFoundError_1 = require_GithubAppInstallationNotFoundError();
    Object.defineProperty(exports2, "GithubAppInstallationNotFoundError", { enumerable: true, get: function() {
      return GithubAppInstallationNotFoundError_1.GithubAppInstallationNotFoundError;
    } });
    var UserNotFoundError_1 = require_UserNotFoundError();
    Object.defineProperty(exports2, "UserNotFoundError", { enumerable: true, get: function() {
      return UserNotFoundError_1.UserNotFoundError;
    } });
    var UserAlreadyExistsError_1 = require_UserAlreadyExistsError();
    Object.defineProperty(exports2, "UserAlreadyExistsError", { enumerable: true, get: function() {
      return UserAlreadyExistsError_1.UserAlreadyExistsError;
    } });
    var ProjectNotFoundError_1 = require_ProjectNotFoundError();
    Object.defineProperty(exports2, "ProjectNotFoundError", { enumerable: true, get: function() {
      return ProjectNotFoundError_1.ProjectNotFoundError;
    } });
    var ProjectsNotFoundError_1 = require_ProjectsNotFoundError();
    Object.defineProperty(exports2, "ProjectsNotFoundError", { enumerable: true, get: function() {
      return ProjectsNotFoundError_1.ProjectsNotFoundError;
    } });
    var ProjectHasDependentsError_1 = require_ProjectHasDependentsError();
    Object.defineProperty(exports2, "ProjectHasDependentsError", { enumerable: true, get: function() {
      return ProjectHasDependentsError_1.ProjectHasDependentsError;
    } });
    var ProjectInvalidNameError_1 = require_ProjectInvalidNameError();
    Object.defineProperty(exports2, "ProjectInvalidNameError", { enumerable: true, get: function() {
      return ProjectInvalidNameError_1.ProjectInvalidNameError;
    } });
    var PublicKeyAlreadyExistsError_1 = require_PublicKeyAlreadyExistsError();
    Object.defineProperty(exports2, "PublicKeyAlreadyExistsError", { enumerable: true, get: function() {
      return PublicKeyAlreadyExistsError_1.PublicKeyAlreadyExistsError;
    } });
    var VerificationSessionAlreadyExistsError_1 = require_VerificationSessionAlreadyExistsError();
    Object.defineProperty(exports2, "VerificationSessionAlreadyExistsError", { enumerable: true, get: function() {
      return VerificationSessionAlreadyExistsError_1.VerificationSessionAlreadyExistsError;
    } });
    var UnauthenticatedError_1 = require_UnauthenticatedError();
    Object.defineProperty(exports2, "UnauthenticatedError", { enumerable: true, get: function() {
      return UnauthenticatedError_1.UnauthenticatedError;
    } });
    var DomainZoneNotFoundError_1 = require_DomainZoneNotFoundError();
    Object.defineProperty(exports2, "DomainZoneNotFoundError", { enumerable: true, get: function() {
      return DomainZoneNotFoundError_1.DomainZoneNotFoundError;
    } });
    var DomainZoneHasDependentsError_1 = require_DomainZoneHasDependentsError();
    Object.defineProperty(exports2, "DomainZoneHasDependentsError", { enumerable: true, get: function() {
      return DomainZoneHasDependentsError_1.DomainZoneHasDependentsError;
    } });
    var DomainZoneInPendingStateError_1 = require_DomainZoneInPendingStateError();
    Object.defineProperty(exports2, "DomainZoneInPendingStateError", { enumerable: true, get: function() {
      return DomainZoneInPendingStateError_1.DomainZoneInPendingStateError;
    } });
    var DomainNotFoundUnderPullzoneError_1 = require_DomainNotFoundUnderPullzoneError();
    Object.defineProperty(exports2, "DomainNotFoundUnderPullzoneError", { enumerable: true, get: function() {
      return DomainNotFoundUnderPullzoneError_1.DomainNotFoundUnderPullzoneError;
    } });
    var DomainZoneInvalidTypeError_1 = require_DomainZoneInvalidTypeError();
    Object.defineProperty(exports2, "DomainZoneInvalidTypeError", { enumerable: true, get: function() {
      return DomainZoneInvalidTypeError_1.DomainZoneInvalidTypeError;
    } });
    var UnauthorizedError_1 = require_UnauthorizedError();
    Object.defineProperty(exports2, "UnauthorizedError", { enumerable: true, get: function() {
      return UnauthorizedError_1.UnauthorizedError;
    } });
    var FleekConfigInvalidContentError_1 = require_FleekConfigInvalidContentError();
    Object.defineProperty(exports2, "FleekConfigInvalidContentError", { enumerable: true, get: function() {
      return FleekConfigInvalidContentError_1.FleekConfigInvalidContentError;
    } });
    var FleekConfigMissingFileError_1 = require_FleekConfigMissingFileError();
    Object.defineProperty(exports2, "FleekConfigMissingFileError", { enumerable: true, get: function() {
      return FleekConfigMissingFileError_1.FleekConfigMissingFileError;
    } });
    var ApplicationWhitelistDomainDuplicityError_1 = require_ApplicationWhitelistDomainDuplicityError();
    Object.defineProperty(exports2, "ApplicationWhitelistDomainDuplicityError", { enumerable: true, get: function() {
      return ApplicationWhitelistDomainDuplicityError_1.ApplicationWhitelistDomainDuplicityError;
    } });
    var ApplicationAlreadyExistsError_1 = require_ApplicationAlreadyExistsError();
    Object.defineProperty(exports2, "ApplicationAlreadyExistsError", { enumerable: true, get: function() {
      return ApplicationAlreadyExistsError_1.ApplicationAlreadyExistsError;
    } });
    var ApplicationsNotFoundError_1 = require_ApplicationsNotFoundError();
    Object.defineProperty(exports2, "ApplicationsNotFoundError", { enumerable: true, get: function() {
      return ApplicationsNotFoundError_1.ApplicationsNotFoundError;
    } });
    var ApplicationNotFoundError_1 = require_ApplicationNotFoundError();
    Object.defineProperty(exports2, "ApplicationNotFoundError", { enumerable: true, get: function() {
      return ApplicationNotFoundError_1.ApplicationNotFoundError;
    } });
    var ApplicationNameInvalidError_1 = require_ApplicationNameInvalidError();
    Object.defineProperty(exports2, "ApplicationNameInvalidError", { enumerable: true, get: function() {
      return ApplicationNameInvalidError_1.ApplicationNameInvalidError;
    } });
    var EnsRecordNotFoundError_1 = require_EnsRecordNotFoundError();
    Object.defineProperty(exports2, "EnsRecordNotFoundError", { enumerable: true, get: function() {
      return EnsRecordNotFoundError_1.EnsRecordNotFoundError;
    } });
    var EnsRecordAlreadyExistsInProjectError_1 = require_EnsRecordAlreadyExistsInProjectError();
    Object.defineProperty(exports2, "EnsRecordAlreadyExistsInProjectError", { enumerable: true, get: function() {
      return EnsRecordAlreadyExistsInProjectError_1.EnsRecordAlreadyExistsInProjectError;
    } });
    var EnsNameInvalidError_1 = require_EnsNameInvalidError();
    Object.defineProperty(exports2, "EnsNameInvalidError", { enumerable: true, get: function() {
      return EnsNameInvalidError_1.EnsNameInvalidError;
    } });
    var EnsRecordInPendingStateError_1 = require_EnsRecordInPendingStateError();
    Object.defineProperty(exports2, "EnsRecordInPendingStateError", { enumerable: true, get: function() {
      return EnsRecordInPendingStateError_1.EnsRecordInPendingStateError;
    } });
    var InvalidPersonalAccessTokenError_1 = require_InvalidPersonalAccessTokenError();
    Object.defineProperty(exports2, "InvalidPersonalAccessTokenError", { enumerable: true, get: function() {
      return InvalidPersonalAccessTokenError_1.InvalidPersonalAccessTokenError;
    } });
    var PersonalAccessTokenNotFoundError_1 = require_PersonalAccessTokenNotFoundError();
    Object.defineProperty(exports2, "PersonalAccessTokenNotFoundError", { enumerable: true, get: function() {
      return PersonalAccessTokenNotFoundError_1.PersonalAccessTokenNotFoundError;
    } });
    var PrivateGatewayNotFoundError_1 = require_PrivateGatewayNotFoundError();
    Object.defineProperty(exports2, "PrivateGatewayNotFoundError", { enumerable: true, get: function() {
      return PrivateGatewayNotFoundError_1.PrivateGatewayNotFoundError;
    } });
    var PrivateGatewayAlreadyExistsError_1 = require_PrivateGatewayAlreadyExistsError();
    Object.defineProperty(exports2, "PrivateGatewayAlreadyExistsError", { enumerable: true, get: function() {
      return PrivateGatewayAlreadyExistsError_1.PrivateGatewayAlreadyExistsError;
    } });
    var PrivateGatewayNameInvalidError_1 = require_PrivateGatewayNameInvalidError();
    Object.defineProperty(exports2, "PrivateGatewayNameInvalidError", { enumerable: true, get: function() {
      return PrivateGatewayNameInvalidError_1.PrivateGatewayNameInvalidError;
    } });
    var PrivateGatewaysNotFoundError_1 = require_PrivateGatewaysNotFoundError();
    Object.defineProperty(exports2, "PrivateGatewaysNotFoundError", { enumerable: true, get: function() {
      return PrivateGatewaysNotFoundError_1.PrivateGatewaysNotFoundError;
    } });
    var TemplateAlreadyExistsError_1 = require_TemplateAlreadyExistsError();
    Object.defineProperty(exports2, "TemplateAlreadyExistsError", { enumerable: true, get: function() {
      return TemplateAlreadyExistsError_1.TemplateAlreadyExistsError;
    } });
    var TemplateNotFoundError_1 = require_TemplateNotFoundError();
    Object.defineProperty(exports2, "TemplateNotFoundError", { enumerable: true, get: function() {
      return TemplateNotFoundError_1.TemplateNotFoundError;
    } });
    var UserHasNoAccessToAnotherUserError_1 = require_UserHasNoAccessToAnotherUserError();
    Object.defineProperty(exports2, "UserHasNoAccessToAnotherUserError", { enumerable: true, get: function() {
      return UserHasNoAccessToAnotherUserError_1.UserHasNoAccessToAnotherUserError;
    } });
    var SiteFrameworkAlreadyExistsError_1 = require_SiteFrameworkAlreadyExistsError();
    Object.defineProperty(exports2, "SiteFrameworkAlreadyExistsError", { enumerable: true, get: function() {
      return SiteFrameworkAlreadyExistsError_1.SiteFrameworkAlreadyExistsError;
    } });
    var SiteFrameworkNotFoundError_1 = require_SiteFrameworkNotFoundError();
    Object.defineProperty(exports2, "SiteFrameworkNotFoundError", { enumerable: true, get: function() {
      return SiteFrameworkNotFoundError_1.SiteFrameworkNotFoundError;
    } });
    var TemplateCategoryNotFoundError_1 = require_TemplateCategoryNotFoundError();
    Object.defineProperty(exports2, "TemplateCategoryNotFoundError", { enumerable: true, get: function() {
      return TemplateCategoryNotFoundError_1.TemplateCategoryNotFoundError;
    } });
    var TemplateDeploymentNotFoundError_1 = require_TemplateDeploymentNotFoundError();
    Object.defineProperty(exports2, "TemplateDeploymentNotFoundError", { enumerable: true, get: function() {
      return TemplateDeploymentNotFoundError_1.TemplateDeploymentNotFoundError;
    } });
    var ProjectMembershipHasInefficientRoleError_1 = require_ProjectMembershipHasInefficientRoleError();
    Object.defineProperty(exports2, "ProjectMembershipHasInefficientRoleError", { enumerable: true, get: function() {
      return ProjectMembershipHasInefficientRoleError_1.ProjectMembershipHasInefficientRoleError;
    } });
    var SecretGroupNotFoundError_1 = require_SecretGroupNotFoundError();
    Object.defineProperty(exports2, "SecretGroupNotFoundError", { enumerable: true, get: function() {
      return SecretGroupNotFoundError_1.SecretGroupNotFoundError;
    } });
    var SecretNotFoundError_1 = require_SecretNotFoundError();
    Object.defineProperty(exports2, "SecretNotFoundError", { enumerable: true, get: function() {
      return SecretNotFoundError_1.SecretNotFoundError;
    } });
    var SecretVisibilityAlreadyEncryptedError_1 = require_SecretVisibilityAlreadyEncryptedError();
    Object.defineProperty(exports2, "SecretVisibilityAlreadyEncryptedError", { enumerable: true, get: function() {
      return SecretVisibilityAlreadyEncryptedError_1.SecretVisibilityAlreadyEncryptedError;
    } });
    var SecretKeyAlreadyExistsError_1 = require_SecretKeyAlreadyExistsError();
    Object.defineProperty(exports2, "SecretKeyAlreadyExistsError", { enumerable: true, get: function() {
      return SecretKeyAlreadyExistsError_1.SecretKeyAlreadyExistsError;
    } });
    var SecretFailToEncryptError_1 = require_SecretFailToEncryptError();
    Object.defineProperty(exports2, "SecretFailToEncryptError", { enumerable: true, get: function() {
      return SecretFailToEncryptError_1.SecretFailToEncryptError;
    } });
    var PinNotFoundError_1 = require_PinNotFoundError();
    Object.defineProperty(exports2, "PinNotFoundError", { enumerable: true, get: function() {
      return PinNotFoundError_1.PinNotFoundError;
    } });
    var PinAlreadyExistsInProjectError_1 = require_PinAlreadyExistsInProjectError();
    Object.defineProperty(exports2, "PinAlreadyExistsInProjectError", { enumerable: true, get: function() {
      return PinAlreadyExistsInProjectError_1.PinAlreadyExistsInProjectError;
    } });
    var UnstoppableDeploymentError_1 = require_UnstoppableDeploymentError();
    Object.defineProperty(exports2, "UnstoppableDeploymentError", { enumerable: true, get: function() {
      return UnstoppableDeploymentError_1.UnstoppableDeploymentError;
    } });
    var SiteDeploymentNotReleasedError_1 = require_SiteDeploymentNotReleasedError();
    Object.defineProperty(exports2, "SiteDeploymentNotReleasedError", { enumerable: true, get: function() {
      return SiteDeploymentNotReleasedError_1.SiteDeploymentNotReleasedError;
    } });
    var InvalidDeploymentTriggerError_1 = require_InvalidDeploymentTriggerError();
    Object.defineProperty(exports2, "InvalidDeploymentTriggerError", { enumerable: true, get: function() {
      return InvalidDeploymentTriggerError_1.InvalidDeploymentTriggerError;
    } });
    var IpfsGatewayContentUnreachableError_1 = require_IpfsGatewayContentUnreachableError();
    Object.defineProperty(exports2, "IpfsGatewayContentUnreachableError", { enumerable: true, get: function() {
      return IpfsGatewayContentUnreachableError_1.IpfsGatewayContentUnreachableError;
    } });
    var InvitationNotFoundError_1 = require_InvitationNotFoundError();
    Object.defineProperty(exports2, "InvitationNotFoundError", { enumerable: true, get: function() {
      return InvitationNotFoundError_1.InvitationNotFoundError;
    } });
    var MigrationTokenInvalidError_1 = require_MigrationTokenInvalidError();
    Object.defineProperty(exports2, "MigrationTokenInvalidError", { enumerable: true, get: function() {
      return MigrationTokenInvalidError_1.MigrationTokenInvalidError;
    } });
    var MigrationRequestsAlreadyExistError_1 = require_MigrationRequestsAlreadyExistError();
    Object.defineProperty(exports2, "MigrationRequestsAlreadyExistError", { enumerable: true, get: function() {
      return MigrationRequestsAlreadyExistError_1.MigrationRequestsAlreadyExistError;
    } });
    var MigrationRequestNotFoundError_1 = require_MigrationRequestNotFoundError();
    Object.defineProperty(exports2, "MigrationRequestNotFoundError", { enumerable: true, get: function() {
      return MigrationRequestNotFoundError_1.MigrationRequestNotFoundError;
    } });
    var MigrationRequestInPendingStateError_1 = require_MigrationRequestInPendingStateError();
    Object.defineProperty(exports2, "MigrationRequestInPendingStateError", { enumerable: true, get: function() {
      return MigrationRequestInPendingStateError_1.MigrationRequestInPendingStateError;
    } });
    var ProjectInvitationAlreadyExistError_1 = require_ProjectInvitationAlreadyExistError();
    Object.defineProperty(exports2, "ProjectInvitationAlreadyExistError", { enumerable: true, get: function() {
      return ProjectInvitationAlreadyExistError_1.ProjectInvitationAlreadyExistError;
    } });
    var ProjectMembershipAlreadyExistError_1 = require_ProjectMembershipAlreadyExistError();
    Object.defineProperty(exports2, "ProjectMembershipAlreadyExistError", { enumerable: true, get: function() {
      return ProjectMembershipAlreadyExistError_1.ProjectMembershipAlreadyExistError;
    } });
    var ProjectMembershipNoOwnersError_1 = require_ProjectMembershipNoOwnersError();
    Object.defineProperty(exports2, "ProjectMembershipNoOwnersError", { enumerable: true, get: function() {
      return ProjectMembershipNoOwnersError_1.ProjectMembershipNoOwnersError;
    } });
    var UploadedS3KeyNotFoundError_1 = require_UploadedS3KeyNotFoundError();
    Object.defineProperty(exports2, "UploadedS3KeyNotFoundError", { enumerable: true, get: function() {
      return UploadedS3KeyNotFoundError_1.UploadedS3KeyNotFoundError;
    } });
    var PathIsNotADirectoryError_1 = require_PathIsNotADirectoryError();
    Object.defineProperty(exports2, "PathIsNotADirectoryError", { enumerable: true, get: function() {
      return PathIsNotADirectoryError_1.PathIsNotADirectoryError;
    } });
    var FleekFunctionAlreadyExistsError_1 = require_FleekFunctionAlreadyExistsError();
    Object.defineProperty(exports2, "FleekFunctionAlreadyExistsError", { enumerable: true, get: function() {
      return FleekFunctionAlreadyExistsError_1.FleekFunctionAlreadyExistsError;
    } });
    var FleekFunctionNotFoundError_1 = require_FleekFunctionNotFoundError();
    Object.defineProperty(exports2, "FleekFunctionNotFoundError", { enumerable: true, get: function() {
      return FleekFunctionNotFoundError_1.FleekFunctionNotFoundError;
    } });
    var FleekFunctionDeploymentNotFoundError_1 = require_FleekFunctionDeploymentNotFoundError();
    Object.defineProperty(exports2, "FleekFunctionDeploymentNotFoundError", { enumerable: true, get: function() {
      return FleekFunctionDeploymentNotFoundError_1.FleekFunctionDeploymentNotFoundError;
    } });
    var FleekFunctionsNotFoundError_1 = require_FleekFunctionsNotFoundError();
    Object.defineProperty(exports2, "FleekFunctionsNotFoundError", { enumerable: true, get: function() {
      return FleekFunctionsNotFoundError_1.FleekFunctionsNotFoundError;
    } });
    var FleekFunctionPathNotValidError_1 = require_FleekFunctionPathNotValidError();
    Object.defineProperty(exports2, "FleekFunctionPathNotValidError", { enumerable: true, get: function() {
      return FleekFunctionPathNotValidError_1.FleekFunctionPathNotValidError;
    } });
    var FleekFunctionNameNotValidError_1 = require_FleekFunctionNameNotValidError();
    Object.defineProperty(exports2, "FleekFunctionNameNotValidError", { enumerable: true, get: function() {
      return FleekFunctionNameNotValidError_1.FleekFunctionNameNotValidError;
    } });
    var FleekFunctionStatusNotValidError_1 = require_FleekFunctionStatusNotValidError();
    Object.defineProperty(exports2, "FleekFunctionStatusNotValidError", { enumerable: true, get: function() {
      return FleekFunctionStatusNotValidError_1.FleekFunctionStatusNotValidError;
    } });
    var FleekFunctionSlugNotValidError_1 = require_FleekFunctionSlugNotValidError();
    Object.defineProperty(exports2, "FleekFunctionSlugNotValidError", { enumerable: true, get: function() {
      return FleekFunctionSlugNotValidError_1.FleekFunctionSlugNotValidError;
    } });
    var MaintenanceError_1 = require_MaintenanceError();
    Object.defineProperty(exports2, "MaintenanceError", { enumerable: true, get: function() {
      return MaintenanceError_1.MaintenanceError;
    } });
    var UserHasNoAccessToFeatureError_1 = require_UserHasNoAccessToFeatureError();
    Object.defineProperty(exports2, "UserHasNoAccessToFeatureError", { enumerable: true, get: function() {
      return UserHasNoAccessToFeatureError_1.UserHasNoAccessToFeatureError;
    } });
    var InvalidCidError_1 = require_InvalidCidError();
    Object.defineProperty(exports2, "InvalidCidError", { enumerable: true, get: function() {
      return InvalidCidError_1.InvalidCidError;
    } });
    var ValidationError_1 = require_ValidationError();
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return ValidationError_1.ValidationError;
    } });
    var UserInBlocklistError_1 = require_UserInBlocklistError();
    Object.defineProperty(exports2, "UserInBlocklistError", { enumerable: true, get: function() {
      return UserInBlocklistError_1.UserInBlocklistError;
    } });
    var EnsNameContentHashCodecMistmatchError_1 = require_EnsNameContentHashCodecMistmatchError();
    Object.defineProperty(exports2, "EnsNameContentHashCodecMistmatchError", { enumerable: true, get: function() {
      return EnsNameContentHashCodecMistmatchError_1.EnsNameContentHashCodecMistmatchError;
    } });
    var EnsNameContentHashUndefinedError_1 = require_EnsNameContentHashUndefinedError();
    Object.defineProperty(exports2, "EnsNameContentHashUndefinedError", { enumerable: true, get: function() {
      return EnsNameContentHashUndefinedError_1.EnsNameContentHashUndefinedError;
    } });
    var DnsConfigAlreadyExistsError_1 = require_DnsConfigAlreadyExistsError();
    Object.defineProperty(exports2, "DnsConfigAlreadyExistsError", { enumerable: true, get: function() {
      return DnsConfigAlreadyExistsError_1.DnsConfigAlreadyExistsError;
    } });
    var DnsConfigNotFoundError_1 = require_DnsConfigNotFoundError();
    Object.defineProperty(exports2, "DnsConfigNotFoundError", { enumerable: true, get: function() {
      return DnsConfigNotFoundError_1.DnsConfigNotFoundError;
    } });
    var TwoFactorSecretKeyFailedToEncryptError_1 = require_TwoFactorSecretKeyFailedToEncryptError();
    Object.defineProperty(exports2, "TwoFactorSecretKeyFailedToEncryptError", { enumerable: true, get: function() {
      return TwoFactorSecretKeyFailedToEncryptError_1.TwoFactorSecretKeyFailedToEncryptError;
    } });
    var UserSecretKeyAlreadyExistsError_1 = require_UserSecretKeyAlreadyExistsError();
    Object.defineProperty(exports2, "UserSecretKeyAlreadyExistsError", { enumerable: true, get: function() {
      return UserSecretKeyAlreadyExistsError_1.UserSecretKeyAlreadyExistsError;
    } });
    var UserSecretKeyNotFoundError_1 = require_UserSecretKeyNotFoundError();
    Object.defineProperty(exports2, "UserSecretKeyNotFoundError", { enumerable: true, get: function() {
      return UserSecretKeyNotFoundError_1.UserSecretKeyNotFoundError;
    } });
    var TwoFactorSecretKeyFailedToDecryptError_1 = require_TwoFactorSecretKeyFailedToDecryptError();
    Object.defineProperty(exports2, "TwoFactorSecretKeyFailedToDecryptError", { enumerable: true, get: function() {
      return TwoFactorSecretKeyFailedToDecryptError_1.TwoFactorSecretKeyFailedToDecryptError;
    } });
    var RecoveryCodesAlreadyExistsError_1 = require_RecoveryCodesAlreadyExistsError();
    Object.defineProperty(exports2, "RecoveryCodesAlreadyExistsError", { enumerable: true, get: function() {
      return RecoveryCodesAlreadyExistsError_1.RecoveryCodesAlreadyExistsError;
    } });
    var WriteFileFromStreamError_1 = require_WriteFileFromStreamError();
    Object.defineProperty(exports2, "WriteFileFromStreamError", { enumerable: true, get: function() {
      return WriteFileFromStreamError_1.WriteFileFromStreamError;
    } });
    var InvalidTOTPTokenError_1 = require_InvalidTOTPTokenError();
    Object.defineProperty(exports2, "InvalidTOTPTokenError", { enumerable: true, get: function() {
      return InvalidTOTPTokenError_1.InvalidTOTPTokenError;
    } });
    var InvalidRecoveryCodeError_1 = require_InvalidRecoveryCodeError();
    Object.defineProperty(exports2, "InvalidRecoveryCodeError", { enumerable: true, get: function() {
      return InvalidRecoveryCodeError_1.InvalidRecoveryCodeError;
    } });
    var MissingTwoFactorProtectionCredentialsError_1 = require_MissingTwoFactorProtectionCredentialsError();
    Object.defineProperty(exports2, "MissingTwoFactorProtectionCredentialsError", { enumerable: true, get: function() {
      return MissingTwoFactorProtectionCredentialsError_1.MissingTwoFactorProtectionCredentialsError;
    } });
    var DeploymentInProgressError_1 = require_DeploymentInProgressError();
    Object.defineProperty(exports2, "DeploymentInProgressError", { enumerable: true, get: function() {
      return DeploymentInProgressError_1.DeploymentInProgressError;
    } });
    var PullzoneNotFoundForZoneIdError_1 = require_PullzoneNotFoundForZoneIdError();
    Object.defineProperty(exports2, "PullzoneNotFoundForZoneIdError", { enumerable: true, get: function() {
      return PullzoneNotFoundForZoneIdError_1.PullzoneNotFoundForZoneIdError;
    } });
    var RecoveryCodeFailedToEncryptError_1 = require_RecoveryCodeFailedToEncryptError();
    Object.defineProperty(exports2, "RecoveryCodeFailedToEncryptError", { enumerable: true, get: function() {
      return RecoveryCodeFailedToEncryptError_1.RecoveryCodeFailedToEncryptError;
    } });
    var RecoveryCodeFailedToDecryptError_1 = require_RecoveryCodeFailedToDecryptError();
    Object.defineProperty(exports2, "RecoveryCodeFailedToDecryptError", { enumerable: true, get: function() {
      return RecoveryCodeFailedToDecryptError_1.RecoveryCodeFailedToDecryptError;
    } });
    var PermissionGroupNotFoundError_1 = require_PermissionGroupNotFoundError();
    Object.defineProperty(exports2, "PermissionGroupNotFoundError", { enumerable: true, get: function() {
      return PermissionGroupNotFoundError_1.PermissionGroupNotFoundError;
    } });
    var PermissionScopeError_1 = require_PermissionScopeError();
    Object.defineProperty(exports2, "PermissionScopeError", { enumerable: true, get: function() {
      return PermissionScopeError_1.PermissionScopeError;
    } });
    var InvalidAdminAccessTokenError_1 = require_InvalidAdminAccessTokenError();
    Object.defineProperty(exports2, "InvalidAdminAccessTokenError", { enumerable: true, get: function() {
      return InvalidAdminAccessTokenError_1.InvalidAdminAccessTokenError;
    } });
    var MissingExpectedDataError_1 = require_MissingExpectedDataError();
    Object.defineProperty(exports2, "MissingExpectedDataError", { enumerable: true, get: function() {
      return MissingExpectedDataError_1.MissingExpectedDataError;
    } });
    var EnvNotSetError_1 = require_EnvNotSetError();
    Object.defineProperty(exports2, "EnvNotSetError", { enumerable: true, get: function() {
      return EnvNotSetError_1.EnvNotSetError;
    } });
    var GitSecretsFailedToEncryptError_1 = require_GitSecretsFailedToEncryptError();
    Object.defineProperty(exports2, "GitSecretsFailedToEncryptError", { enumerable: true, get: function() {
      return GitSecretsFailedToEncryptError_1.GitSecretsFailedToEncryptError;
    } });
    var GitConfigFailedToParseError_1 = require_GitConfigFailedToParseError();
    Object.defineProperty(exports2, "GitConfigFailedToParseError", { enumerable: true, get: function() {
      return GitConfigFailedToParseError_1.GitConfigFailedToParseError;
    } });
    var PathIsNotAFileError_1 = require_PathIsNotAFileError();
    Object.defineProperty(exports2, "PathIsNotAFileError", { enumerable: true, get: function() {
      return PathIsNotAFileError_1.PathIsNotAFileError;
    } });
    var FleekFunctionBundlingFailedError_1 = require_FleekFunctionBundlingFailedError();
    Object.defineProperty(exports2, "FleekFunctionBundlingFailedError", { enumerable: true, get: function() {
      return FleekFunctionBundlingFailedError_1.FleekFunctionBundlingFailedError;
    } });
    var GitIntegrationNotFoundError_1 = require_GitIntegrationNotFoundError();
    Object.defineProperty(exports2, "GitIntegrationNotFoundError", { enumerable: true, get: function() {
      return GitIntegrationNotFoundError_1.GitIntegrationNotFoundError;
    } });
    var GitProviderNotFoundError_1 = require_GitProviderNotFoundError();
    Object.defineProperty(exports2, "GitProviderNotFoundError", { enumerable: true, get: function() {
      return GitProviderNotFoundError_1.GitProviderNotFoundError;
    } });
    var ExpectedOneOfValuesError_1 = require_ExpectedOneOfValuesError();
    Object.defineProperty(exports2, "ExpectedOneOfValuesError", { enumerable: true, get: function() {
      return ExpectedOneOfValuesError_1.ExpectedOneOfValuesError;
    } });
    var InvalidJSONFormat_1 = require_InvalidJSONFormat();
    Object.defineProperty(exports2, "InvalidJSONFormat", { enumerable: true, get: function() {
      return InvalidJSONFormat_1.InvalidJSONFormat;
    } });
    var StorageUploadFileCountQuotaExceededError_1 = require_StorageUploadFileCountQuotaExceededError();
    Object.defineProperty(exports2, "StorageUploadFileCountQuotaExceededError", { enumerable: true, get: function() {
      return StorageUploadFileCountQuotaExceededError_1.StorageUploadFileCountQuotaExceededError;
    } });
    var StorageUploadTotalSizeQuotaExceededError_1 = require_StorageUploadTotalSizeQuotaExceededError();
    Object.defineProperty(exports2, "StorageUploadTotalSizeQuotaExceededError", { enumerable: true, get: function() {
      return StorageUploadTotalSizeQuotaExceededError_1.StorageUploadTotalSizeQuotaExceededError;
    } });
    var GitProviderNotSupportedError_1 = require_GitProviderNotSupportedError();
    Object.defineProperty(exports2, "GitProviderNotSupportedError", { enumerable: true, get: function() {
      return GitProviderNotSupportedError_1.GitProviderNotSupportedError;
    } });
    var GitProviderNotAuthorizedError_1 = require_GitProviderNotAuthorizedError();
    Object.defineProperty(exports2, "GitProviderNotAuthorizedError", { enumerable: true, get: function() {
      return GitProviderNotAuthorizedError_1.GitProviderNotAuthorizedError;
    } });
    var GitAccessTokenInvalidError_1 = require_GitAccessTokenInvalidError();
    Object.defineProperty(exports2, "GitAccessTokenInvalidError", { enumerable: true, get: function() {
      return GitAccessTokenInvalidError_1.GitAccessTokenInvalidError;
    } });
    var QueuedDeploymentsLimitError_1 = require_QueuedDeploymentsLimitError();
    Object.defineProperty(exports2, "QueuedDeploymentsLimitError", { enumerable: true, get: function() {
      return QueuedDeploymentsLimitError_1.QueuedDeploymentsLimitError;
    } });
    var GitIntegrationInstallationConflictError_1 = require_GitIntegrationInstallationConflictError();
    Object.defineProperty(exports2, "GitIntegrationInstallationConflictError", { enumerable: true, get: function() {
      return GitIntegrationInstallationConflictError_1.GitIntegrationInstallationConflictError;
    } });
    var GitLinkMultipleAccountError_1 = require_GitLinkMultipleAccountError();
    Object.defineProperty(exports2, "GitLinkMultipleAccountError", { enumerable: true, get: function() {
      return GitLinkMultipleAccountError_1.GitLinkMultipleAccountError;
    } });
    var GitRepoByNameAndOwnerNotFoundError_1 = require_GitRepoByNameAndOwnerNotFoundError();
    Object.defineProperty(exports2, "GitRepoByNameAndOwnerNotFoundError", { enumerable: true, get: function() {
      return GitRepoByNameAndOwnerNotFoundError_1.GitRepoByNameAndOwnerNotFoundError;
    } });
    var GitAccessTokenNotFoundError_1 = require_GitAccessTokenNotFoundError();
    Object.defineProperty(exports2, "GitAccessTokenNotFoundError", { enumerable: true, get: function() {
      return GitAccessTokenNotFoundError_1.GitAccessTokenNotFoundError;
    } });
    var FolderNotFoundError_1 = require_FolderNotFoundError();
    Object.defineProperty(exports2, "FolderNotFoundError", { enumerable: true, get: function() {
      return FolderNotFoundError_1.FolderNotFoundError;
    } });
    var FolderAlreadyExistsError_1 = require_FolderAlreadyExistsError();
    Object.defineProperty(exports2, "FolderAlreadyExistsError", { enumerable: true, get: function() {
      return FolderAlreadyExistsError_1.FolderAlreadyExistsError;
    } });
    var PinsNotFoundError_1 = require_PinsNotFoundError();
    Object.defineProperty(exports2, "PinsNotFoundError", { enumerable: true, get: function() {
      return PinsNotFoundError_1.PinsNotFoundError;
    } });
    var SiteCreationFailedError_1 = require_SiteCreationFailedError();
    Object.defineProperty(exports2, "SiteCreationFailedError", { enumerable: true, get: function() {
      return SiteCreationFailedError_1.SiteCreationFailedError;
    } });
    var FleekFunctionInvalidWasmCodeError_1 = require_FleekFunctionInvalidWasmCodeError();
    Object.defineProperty(exports2, "FleekFunctionInvalidWasmCodeError", { enumerable: true, get: function() {
      return FleekFunctionInvalidWasmCodeError_1.FleekFunctionInvalidWasmCodeError;
    } });
    var FleekFunctionWasmEncryptionFailedError_1 = require_FleekFunctionWasmEncryptionFailedError();
    Object.defineProperty(exports2, "FleekFunctionWasmEncryptionFailedError", { enumerable: true, get: function() {
      return FleekFunctionWasmEncryptionFailedError_1.FleekFunctionWasmEncryptionFailedError;
    } });
    var UploadProxyStoreAsCarError_1 = require_UploadProxyStoreAsCarError();
    Object.defineProperty(exports2, "UploadProxyStoreAsCarError", { enumerable: true, get: function() {
      return UploadProxyStoreAsCarError_1.UploadProxyStoreAsCarError;
    } });
    var UploadProxyUploadFileError_1 = require_UploadProxyUploadFileError();
    Object.defineProperty(exports2, "UploadProxyUploadFileError", { enumerable: true, get: function() {
      return UploadProxyUploadFileError_1.UploadProxyUploadFileError;
    } });
  }
});

// ../auth/dist/verifyToken.js
var require_verifyToken = __commonJS({
  "../auth/dist/verifyToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyToken = void 0;
    var errors_1 = require_dist();
    var jose_1 = require_cjs();
    var textEncoder9 = new TextEncoder();
    var verifyToken = async ({ secret, token }) => {
      const secretKey = textEncoder9.encode(secret);
      const verifiedToken = await (0, jose_1.jwtVerify)(token, secretKey).catch(() => {
        throw new errors_1.AuthorizationError();
      });
      return verifiedToken.payload;
    };
    exports2.verifyToken = verifyToken;
  }
});

// ../auth/dist/verifyAccessToken.js
var require_verifyAccessToken = __commonJS({
  "../auth/dist/verifyAccessToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyAccessToken = void 0;
    var verifyToken_1 = require_verifyToken();
    var verifyAccessToken = (args) => (0, verifyToken_1.verifyToken)(args);
    exports2.verifyAccessToken = verifyAccessToken;
  }
});

// ../auth/dist/verifyMigrationToken.js
var require_verifyMigrationToken = __commonJS({
  "../auth/dist/verifyMigrationToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyMigrationToken = void 0;
    var verifyToken_1 = require_verifyToken();
    var verifyMigrationToken = (args) => (0, verifyToken_1.verifyToken)(args);
    exports2.verifyMigrationToken = verifyMigrationToken;
  }
});

// ../../node_modules/.pnpm/jscrypto@1.0.3/node_modules/jscrypto/index.js
var require_jscrypto = __commonJS({
  "../../node_modules/.pnpm/jscrypto@1.0.3/node_modules/jscrypto/index.js"(exports2, module2) {
    !function(n, t) {
      if ("object" == typeof exports2 && "object" == typeof module2) module2.exports = t();
      else if ("function" == typeof define && define.amd) define([], t);
      else if ("object" == typeof exports2) exports2.JsCrypto = t();
      else {
        var r = t();
        for (var i in n.JsCrypto = n.JsCrypto || {}, r) n.JsCrypto[i] = r[i];
      }
    }(exports2, function() {
      return function() {
        "use strict";
        var n = { 9691: function(n2, t2, r2) {
          r2.d(t2, { AES: function() {
            return _;
          } });
          var i2, e = r2(9456), o = r2(787), u = r2(5693), f = r2(9109), c = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), s = function() {
            return (s = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, a = [], h = [], v = [], w = [], l = [], b = [], d = [], y = [], p = [], O = [];
          !function() {
            for (var n3 = [], t3 = 0; t3 < 256; t3++) n3[t3] = t3 < 128 ? t3 << 1 : t3 << 1 ^ 283;
            var r3 = 0, i3 = 0;
            for (t3 = 0; t3 < 256; t3++) {
              var e2 = i3 ^ i3 << 1 ^ i3 << 2 ^ i3 << 3 ^ i3 << 4;
              e2 = e2 >>> 8 ^ 255 & e2 ^ 99, a[r3] = e2, h[e2] = r3;
              var o2 = n3[r3], u2 = n3[o2], f2 = n3[u2], c2 = 257 * n3[e2] ^ 16843008 * e2;
              v[r3] = c2 << 24 | c2 >>> 8, w[r3] = c2 << 16 | c2 >>> 16, l[r3] = c2 << 8 | c2 >>> 24, b[r3] = c2, c2 = 16843009 * f2 ^ 65537 * u2 ^ 257 * o2 ^ 16843008 * r3, d[e2] = c2 << 24 | c2 >>> 8, y[e2] = c2 << 16 | c2 >>> 16, p[e2] = c2 << 8 | c2 >>> 24, O[e2] = c2, r3 ? (r3 = o2 ^ n3[n3[n3[f2 ^ o2]]], i3 ^= n3[n3[i3]]) : r3 = i3 = 1;
            }
          }();
          var j = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], _ = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.u = 0, r3.h = [], r3.v = [], r3.O = t4, r3.A(), r3;
            }
            return c(t3, n3), t3.prototype.A = function() {
              var n4;
              if (!this.u || this.k !== this.H) {
                for (var t4 = this.k = this.H, r3 = t4.words, i3 = t4.nSigBytes / 4, e2 = 4 * ((this.u = i3 + 6) + 1), o2 = this.h = [], u2 = 0; u2 < e2; u2++) u2 < i3 ? o2[u2] = r3[u2] : (n4 = o2[u2 - 1], u2 % i3 ? i3 > 6 && u2 % i3 == 4 && (n4 = a[n4 >>> 24] << 24 | a[n4 >>> 16 & 255] << 16 | a[n4 >>> 8 & 255] << 8 | a[255 & n4]) : (n4 = a[(n4 = n4 << 8 | n4 >>> 24) >>> 24] << 24 | a[n4 >>> 16 & 255] << 16 | a[n4 >>> 8 & 255] << 8 | a[255 & n4], n4 ^= j[u2 / i3 | 0] << 24), o2[u2] = o2[u2 - i3] ^ n4);
                this.v = [];
                for (var f2 = 0; f2 < e2; f2++) {
                  u2 = e2 - f2;
                  n4 = f2 % 4 ? o2[u2] : o2[u2 - 4], this.v[f2] = f2 < 4 || u2 <= 4 ? n4 : d[a[n4 >>> 24]] ^ y[a[n4 >>> 16 & 255]] ^ p[a[n4 >>> 8 & 255]] ^ O[a[255 & n4]];
                }
              }
            }, t3.prototype.encryptBlock = function(n4, t4) {
              this.B(n4, t4, this.h, v, w, l, b, a);
            }, t3.prototype.decryptBlock = function(n4, t4) {
              var r3 = n4[t4 + 1];
              n4[t4 + 1] = n4[t4 + 3], n4[t4 + 3] = r3, this.B(n4, t4, this.v, d, y, p, O, h), r3 = n4[t4 + 1], n4[t4 + 1] = n4[t4 + 3], n4[t4 + 3] = r3;
            }, t3.prototype.B = function(n4, t4, r3, i3, e2, o2, u2, f2) {
              for (var c2 = this.u, s2 = n4[t4] ^ r3[0], a2 = n4[t4 + 1] ^ r3[1], h2 = n4[t4 + 2] ^ r3[2], v2 = n4[t4 + 3] ^ r3[3], w2 = 4, l2 = 1; l2 < c2; l2++) {
                var b2 = i3[s2 >>> 24] ^ e2[a2 >>> 16 & 255] ^ o2[h2 >>> 8 & 255] ^ u2[255 & v2] ^ r3[w2++], d2 = i3[a2 >>> 24] ^ e2[h2 >>> 16 & 255] ^ o2[v2 >>> 8 & 255] ^ u2[255 & s2] ^ r3[w2++], y2 = i3[h2 >>> 24] ^ e2[v2 >>> 16 & 255] ^ o2[s2 >>> 8 & 255] ^ u2[255 & a2] ^ r3[w2++], p2 = i3[v2 >>> 24] ^ e2[s2 >>> 16 & 255] ^ o2[a2 >>> 8 & 255] ^ u2[255 & h2] ^ r3[w2++];
                s2 = b2, a2 = d2, h2 = y2, v2 = p2;
              }
              var O2 = (f2[s2 >>> 24] << 24 | f2[a2 >>> 16 & 255] << 16 | f2[h2 >>> 8 & 255] << 8 | f2[255 & v2]) ^ r3[w2++], j2 = (f2[a2 >>> 24] << 24 | f2[h2 >>> 16 & 255] << 16 | f2[v2 >>> 8 & 255] << 8 | f2[255 & s2]) ^ r3[w2++], _2 = (f2[h2 >>> 24] << 24 | f2[v2 >>> 16 & 255] << 16 | f2[s2 >>> 8 & 255] << 8 | f2[255 & a2]) ^ r3[w2++], m = (f2[v2 >>> 24] << 24 | f2[s2 >>> 16 & 255] << 16 | f2[a2 >>> 8 & 255] << 8 | f2[255 & h2]) ^ r3[w2++];
              n4[t4] = O2, n4[t4 + 1] = j2, n4[t4 + 2] = _2, n4[t4 + 3] = m;
            }, t3.createEncryptor = function(n4, r3) {
              return new t3(s(s({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: e.t.ENC_TRANSFORM_MODE }));
            }, t3.createDecryptor = function(n4, r3) {
              return new t3(s(s({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: e.t.DEC_TRANSFORM_MODE }));
            }, t3.encrypt = function(n4, r3, i3) {
              if ("string" == typeof r3) return u.E.encrypt(t3, n4, r3, i3);
              if (r3.nSigBytes % 4 != 0) throw new Error("Key size must be multiple of 32bit/4byte/1word");
              return f.D.encrypt(t3, n4, r3, i3);
            }, t3.decrypt = function(n4, r3, i3) {
              if ("string" == typeof r3) return u.E.decrypt(t3, n4, r3, i3);
              if (r3.nSigBytes % 4 != 0) throw new Error("Key size must be multiple of 32bit/4byte/1word");
              return f.D.decrypt(t3, n4, r3, i3);
            }, t3.keySize = 8, t3;
          }(o.G);
        }, 3967: function(n2, t2, r2) {
          r2.d(t2, { CBCMAC: function() {
            return f;
          } });
          var i2 = r2(4768), e = r2(3354), o = r2(9691), u = r2(3664);
          function f(n3, t3, r3, f2, c, s) {
            var a = s && s.Cipher ? s.Cipher : o.AES, h = "string" == typeof r3 ? i2.d.parse(r3) : r3, v = f2 || new e.e([0, 0]), w = "string" == typeof t3 ? i2.d.parse(t3) : t3, l = "string" == typeof n3 ? i2.d.parse(n3) : n3, b = c || 16;
            return u.K.mac(a, h, v, w, l, b);
          }
        }, 9910: function(n2, t2, r2) {
          r2.d(t2, { DES: function() {
            return b;
          } });
          var i2, e = r2(787), o = r2(9456), u = r2(5693), f = r2(9109), c = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), s = function() {
            return (s = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, a = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4], h = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32], v = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28], w = [{ 0: 8421888, 268435456: 32768, 536870912: 8421378, 805306368: 2, 1073741824: 512, 1342177280: 8421890, 1610612736: 8389122, 1879048192: 8388608, 2147483648: 514, 2415919104: 8389120, 2684354560: 33280, 2952790016: 8421376, 3221225472: 32770, 3489660928: 8388610, 3758096384: 0, 4026531840: 33282, 134217728: 0, 402653184: 8421890, 671088640: 33282, 939524096: 32768, 1207959552: 8421888, 1476395008: 512, 1744830464: 8421378, 2013265920: 2, 2281701376: 8389120, 2550136832: 33280, 2818572288: 8421376, 3087007744: 8389122, 3355443200: 8388610, 3623878656: 32770, 3892314112: 514, 4160749568: 8388608, 1: 32768, 268435457: 2, 536870913: 8421888, 805306369: 8388608, 1073741825: 8421378, 1342177281: 33280, 1610612737: 512, 1879048193: 8389122, 2147483649: 8421890, 2415919105: 8421376, 2684354561: 8388610, 2952790017: 33282, 3221225473: 514, 3489660929: 8389120, 3758096385: 32770, 4026531841: 0, 134217729: 8421890, 402653185: 8421376, 671088641: 8388608, 939524097: 512, 1207959553: 32768, 1476395009: 8388610, 1744830465: 2, 2013265921: 33282, 2281701377: 32770, 2550136833: 8389122, 2818572289: 514, 3087007745: 8421888, 3355443201: 8389120, 3623878657: 0, 3892314113: 33280, 4160749569: 8421378 }, { 0: 1074282512, 16777216: 16384, 33554432: 524288, 50331648: 1074266128, 67108864: 1073741840, 83886080: 1074282496, 100663296: 1073758208, 117440512: 16, 134217728: 540672, 150994944: 1073758224, 167772160: 1073741824, 184549376: 540688, 201326592: 524304, 218103808: 0, 234881024: 16400, 251658240: 1074266112, 8388608: 1073758208, 25165824: 540688, 41943040: 16, 58720256: 1073758224, 75497472: 1074282512, 92274688: 1073741824, 109051904: 524288, 125829120: 1074266128, 142606336: 524304, 159383552: 0, 176160768: 16384, 192937984: 1074266112, 209715200: 1073741840, 226492416: 540672, 243269632: 1074282496, 260046848: 16400, 268435456: 0, 285212672: 1074266128, 301989888: 1073758224, 318767104: 1074282496, 335544320: 1074266112, 352321536: 16, 369098752: 540688, 385875968: 16384, 402653184: 16400, 419430400: 524288, 436207616: 524304, 452984832: 1073741840, 469762048: 540672, 486539264: 1073758208, 503316480: 1073741824, 520093696: 1074282512, 276824064: 540688, 293601280: 524288, 310378496: 1074266112, 327155712: 16384, 343932928: 1073758208, 360710144: 1074282512, 377487360: 16, 394264576: 1073741824, 411041792: 1074282496, 427819008: 1073741840, 444596224: 1073758224, 461373440: 524304, 478150656: 0, 494927872: 16400, 511705088: 1074266128, 528482304: 540672 }, { 0: 260, 1048576: 0, 2097152: 67109120, 3145728: 65796, 4194304: 65540, 5242880: 67108868, 6291456: 67174660, 7340032: 67174400, 8388608: 67108864, 9437184: 67174656, 10485760: 65792, 11534336: 67174404, 12582912: 67109124, 13631488: 65536, 14680064: 4, 15728640: 256, 524288: 67174656, 1572864: 67174404, 2621440: 0, 3670016: 67109120, 4718592: 67108868, 5767168: 65536, 6815744: 65540, 7864320: 260, 8912896: 4, 9961472: 256, 11010048: 67174400, 12058624: 65796, 13107200: 65792, 14155776: 67109124, 15204352: 67174660, 16252928: 67108864, 16777216: 67174656, 17825792: 65540, 18874368: 65536, 19922944: 67109120, 20971520: 256, 22020096: 67174660, 23068672: 67108868, 24117248: 0, 25165824: 67109124, 26214400: 67108864, 27262976: 4, 28311552: 65792, 29360128: 67174400, 30408704: 260, 31457280: 65796, 32505856: 67174404, 17301504: 67108864, 18350080: 260, 19398656: 67174656, 20447232: 0, 21495808: 65540, 22544384: 67109120, 23592960: 256, 24641536: 67174404, 25690112: 65536, 26738688: 67174660, 27787264: 65796, 28835840: 67108868, 29884416: 67109124, 30932992: 67174400, 31981568: 4, 33030144: 65792 }, { 0: 2151682048, 65536: 2147487808, 131072: 4198464, 196608: 2151677952, 262144: 0, 327680: 4198400, 393216: 2147483712, 458752: 4194368, 524288: 2147483648, 589824: 4194304, 655360: 64, 720896: 2147487744, 786432: 2151678016, 851968: 4160, 917504: 4096, 983040: 2151682112, 32768: 2147487808, 98304: 64, 163840: 2151678016, 229376: 2147487744, 294912: 4198400, 360448: 2151682112, 425984: 0, 491520: 2151677952, 557056: 4096, 622592: 2151682048, 688128: 4194304, 753664: 4160, 819200: 2147483648, 884736: 4194368, 950272: 4198464, 1015808: 2147483712, 1048576: 4194368, 1114112: 4198400, 1179648: 2147483712, 1245184: 0, 1310720: 4160, 1376256: 2151678016, 1441792: 2151682048, 1507328: 2147487808, 1572864: 2151682112, 1638400: 2147483648, 1703936: 2151677952, 1769472: 4198464, 1835008: 2147487744, 1900544: 4194304, 1966080: 64, 2031616: 4096, 1081344: 2151677952, 1146880: 2151682112, 1212416: 0, 1277952: 4198400, 1343488: 4194368, 1409024: 2147483648, 1474560: 2147487808, 1540096: 64, 1605632: 2147483712, 1671168: 4096, 1736704: 2147487744, 1802240: 2151678016, 1867776: 4160, 1933312: 2151682048, 1998848: 4194304, 2064384: 4198464 }, { 0: 128, 4096: 17039360, 8192: 262144, 12288: 536870912, 16384: 537133184, 20480: 16777344, 24576: 553648256, 28672: 262272, 32768: 16777216, 36864: 537133056, 40960: 536871040, 45056: 553910400, 49152: 553910272, 53248: 0, 57344: 17039488, 61440: 553648128, 2048: 17039488, 6144: 553648256, 10240: 128, 14336: 17039360, 18432: 262144, 22528: 537133184, 26624: 553910272, 30720: 536870912, 34816: 537133056, 38912: 0, 43008: 553910400, 47104: 16777344, 51200: 536871040, 55296: 553648128, 59392: 16777216, 63488: 262272, 65536: 262144, 69632: 128, 73728: 536870912, 77824: 553648256, 81920: 16777344, 86016: 553910272, 90112: 537133184, 94208: 16777216, 98304: 553910400, 102400: 553648128, 106496: 17039360, 110592: 537133056, 114688: 262272, 118784: 536871040, 122880: 0, 126976: 17039488, 67584: 553648256, 71680: 16777216, 75776: 17039360, 79872: 537133184, 83968: 536870912, 88064: 17039488, 92160: 128, 96256: 553910272, 100352: 262272, 104448: 553910400, 108544: 0, 112640: 553648128, 116736: 16777344, 120832: 262144, 124928: 537133056, 129024: 536871040 }, { 0: 268435464, 256: 8192, 512: 270532608, 768: 270540808, 1024: 268443648, 1280: 2097152, 1536: 2097160, 1792: 268435456, 2048: 0, 2304: 268443656, 2560: 2105344, 2816: 8, 3072: 270532616, 3328: 2105352, 3584: 8200, 3840: 270540800, 128: 270532608, 384: 270540808, 640: 8, 896: 2097152, 1152: 2105352, 1408: 268435464, 1664: 268443648, 1920: 8200, 2176: 2097160, 2432: 8192, 2688: 268443656, 2944: 270532616, 3200: 0, 3456: 270540800, 3712: 2105344, 3968: 268435456, 4096: 268443648, 4352: 270532616, 4608: 270540808, 4864: 8200, 5120: 2097152, 5376: 268435456, 5632: 268435464, 5888: 2105344, 6144: 2105352, 6400: 0, 6656: 8, 6912: 270532608, 7168: 8192, 7424: 268443656, 7680: 270540800, 7936: 2097160, 4224: 8, 4480: 2105344, 4736: 2097152, 4992: 268435464, 5248: 268443648, 5504: 8200, 5760: 270540808, 6016: 270532608, 6272: 270540800, 6528: 270532616, 6784: 8192, 7040: 2105352, 7296: 2097160, 7552: 0, 7808: 268435456, 8064: 268443656 }, { 0: 1048576, 16: 33555457, 32: 1024, 48: 1049601, 64: 34604033, 80: 0, 96: 1, 112: 34603009, 128: 33555456, 144: 1048577, 160: 33554433, 176: 34604032, 192: 34603008, 208: 1025, 224: 1049600, 240: 33554432, 8: 34603009, 24: 0, 40: 33555457, 56: 34604032, 72: 1048576, 88: 33554433, 104: 33554432, 120: 1025, 136: 1049601, 152: 33555456, 168: 34603008, 184: 1048577, 200: 1024, 216: 34604033, 232: 1, 248: 1049600, 256: 33554432, 272: 1048576, 288: 33555457, 304: 34603009, 320: 1048577, 336: 33555456, 352: 34604032, 368: 1049601, 384: 1025, 400: 34604033, 416: 1049600, 432: 1, 448: 0, 464: 34603008, 480: 33554433, 496: 1024, 264: 1049600, 280: 33555457, 296: 34603009, 312: 1, 328: 33554432, 344: 1048576, 360: 1025, 376: 34604032, 392: 33554433, 408: 34603008, 424: 0, 440: 34604033, 456: 1049601, 472: 1024, 488: 33555456, 504: 1048577 }, { 0: 134219808, 1: 131072, 2: 134217728, 3: 32, 4: 131104, 5: 134350880, 6: 134350848, 7: 2048, 8: 134348800, 9: 134219776, 10: 133120, 11: 134348832, 12: 2080, 13: 0, 14: 134217760, 15: 133152, 2147483648: 2048, 2147483649: 134350880, 2147483650: 134219808, 2147483651: 134217728, 2147483652: 134348800, 2147483653: 133120, 2147483654: 133152, 2147483655: 32, 2147483656: 134217760, 2147483657: 2080, 2147483658: 131104, 2147483659: 134350848, 2147483660: 0, 2147483661: 134348832, 2147483662: 134219776, 2147483663: 131072, 16: 133152, 17: 134350848, 18: 32, 19: 2048, 20: 134219776, 21: 134217760, 22: 134348832, 23: 131072, 24: 0, 25: 131104, 26: 134348800, 27: 134219808, 28: 134350880, 29: 133120, 30: 2080, 31: 134217728, 2147483664: 131072, 2147483665: 2048, 2147483666: 134348832, 2147483667: 133152, 2147483668: 32, 2147483669: 134348800, 2147483670: 134217728, 2147483671: 134219808, 2147483672: 134350880, 2147483673: 134217760, 2147483674: 134219776, 2147483675: 0, 2147483676: 133120, 2147483677: 2080, 2147483678: 131104, 2147483679: 134350848 }], l = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679], b = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.N = 2, r3.I = [], r3.U = [], r3.L = 0, r3.F = 0, r3.O = t4, r3.A(), r3;
            }
            return c(t3, n3), t3.prototype.A = function() {
              for (var n4 = this.H.words, t4 = [], r3 = 0; r3 < 56; r3++) {
                var i3 = a[r3] - 1;
                t4[r3] = n4[i3 >>> 5] >>> 31 - i3 % 32 & 1;
              }
              for (var e2 = this.I = [], o2 = 0; o2 < 16; o2++) {
                var u2 = e2[o2] = [], f2 = v[o2];
                for (r3 = 0; r3 < 24; r3++) u2[r3 / 6 | 0] |= t4[(h[r3] - 1 + f2) % 28] << 31 - r3 % 6, u2[4 + (r3 / 6 | 0)] |= t4[28 + (h[r3 + 24] - 1 + f2) % 28] << 31 - r3 % 6;
                u2[0] = u2[0] << 1 | u2[0] >>> 31;
                for (r3 = 1; r3 < 7; r3++) u2[r3] = u2[r3] >>> 4 * (r3 - 1) + 3;
                u2[7] = u2[7] << 5 | u2[7] >>> 27;
              }
              this.U = [];
              for (r3 = 0; r3 < 16; r3++) this.U[r3] = e2[15 - r3];
            }, t3.prototype.encryptBlock = function(n4, t4) {
              this.R(n4, t4, this.I);
            }, t3.prototype.decryptBlock = function(n4, t4) {
              this.R(n4, t4, this.U);
            }, t3.prototype.R = function(n4, t4, r3) {
              this.L = n4[t4], this.F = n4[t4 + 1], this.X(4, 252645135), this.X(16, 65535), this.Z(2, 858993459), this.Z(8, 16711935), this.X(1, 1431655765);
              for (var i3 = 0; i3 < 16; i3++) {
                for (var e2 = r3[i3], o2 = this.L, u2 = this.F, f2 = 0, c2 = 0; c2 < 8; c2++) {
                  var s2 = (u2 ^ e2[c2]) & l[c2];
                  f2 |= w[c2][s2 >>> 0];
                }
                this.L = u2, this.F = o2 ^ f2;
              }
              var a2 = this.L;
              this.L = this.F, this.F = a2, this.X(1, 1431655765), this.Z(8, 16711935), this.Z(2, 858993459), this.X(16, 65535), this.X(4, 252645135), n4[t4] = this.L, n4[t4 + 1] = this.F;
            }, t3.prototype.X = function(n4, t4) {
              var r3 = (this.L >>> n4 ^ this.F) & t4;
              this.F ^= r3, this.L ^= r3 << n4;
            }, t3.prototype.Z = function(n4, t4) {
              var r3 = (this.F >>> n4 ^ this.L) & t4;
              this.L ^= r3, this.F ^= r3 << n4;
            }, t3.createEncryptor = function(n4, r3) {
              return new t3(s(s({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: o.t.ENC_TRANSFORM_MODE }));
            }, t3.createDecryptor = function(n4, r3) {
              return new t3(s(s({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: o.t.DEC_TRANSFORM_MODE }));
            }, t3.encrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? u.E.encrypt(t3, n4, r3, i3) : f.D.encrypt(t3, n4, r3, i3);
            }, t3.decrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? u.E.decrypt(t3, n4, r3, i3) : f.D.decrypt(t3, n4, r3, i3);
            }, t3.keySize = 2, t3.ivSize = 2, t3;
          }(e.G);
        }, 6739: function(n2, t2, r2) {
          r2.d(t2, { DES3: function() {
            return v;
          } });
          var i2, e = r2(9109), o = r2(787), u = r2(9456), f = r2(9910), c = r2(3354), s = r2(5693), a = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), h = function() {
            return (h = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, v = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              r3.N = 2, r3.O = t4;
              var i3 = r3.J();
              return r3.Y = i3[0], r3.$ = i3[1], r3.nn = i3[2], r3;
            }
            return a(t3, n3), t3.prototype.J = function() {
              var n4 = this.H.words;
              if (2 !== n4.length && 4 !== n4.length && n4.length < 6) throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
              var t4 = n4.slice(0, 2), r3 = n4.length < 4 ? n4.slice(0, 2) : n4.slice(2, 4), i3 = n4.length < 6 ? n4.slice(0, 2) : n4.slice(4, 6);
              return [f.DES.createEncryptor(new c.e(t4)), f.DES.createEncryptor(new c.e(r3)), f.DES.createEncryptor(new c.e(i3))];
            }, t3.prototype.A = function() {
              var n4 = this.J();
              this.Y = n4[0], this.$ = n4[1], this.nn = n4[2];
            }, t3.prototype.encryptBlock = function(n4, t4) {
              this.Y.encryptBlock(n4, t4), this.$.decryptBlock(n4, t4), this.nn.encryptBlock(n4, t4);
            }, t3.prototype.decryptBlock = function(n4, t4) {
              this.nn.decryptBlock(n4, t4), this.$.encryptBlock(n4, t4), this.Y.decryptBlock(n4, t4);
            }, t3.createEncryptor = function(n4, r3) {
              return new t3(h(h({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: u.t.ENC_TRANSFORM_MODE }));
            }, t3.createDecryptor = function(n4, r3) {
              return new t3(h(h({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: u.t.DEC_TRANSFORM_MODE }));
            }, t3.encrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? s.E.encrypt(t3, n4, r3, i3) : e.D.encrypt(t3, n4, r3, i3);
            }, t3.decrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? s.E.decrypt(t3, n4, r3, i3) : e.D.decrypt(t3, n4, r3, i3);
            }, t3.keySize = 6, t3.ivSize = 2, t3;
          }(o.G);
        }, 7753: function(n2, t2, r2) {
          r2.d(t2, { GMAC: function() {
            return f;
          } });
          var i2 = r2(4768), e = r2(3354), o = r2(9691), u = r2(5607);
          function f(n3, t3, r3, f2, c) {
            var s = "string" == typeof n3 ? i2.d.parse(n3) : n3, a = r3 || new e.e([0, 0, 0, 0]), h = c && c.Cipher ? c.Cipher : o.AES, v = "string" == typeof t3 ? i2.d.parse(t3) : t3, w = f2 || 16;
            return u.V.mac(h, v, a, s, void 0, w);
          }
        }, 6367: function(n2, t2, r2) {
          r2.d(t2, { Hmac: function() {
            return e;
          } });
          var i2 = r2(4768), e = function() {
            function n3(n4, t3) {
              this.tn = n4, "string" == typeof t3 && (t3 = i2.d.parse(t3));
              var r3 = n4.blockSize, e2 = 4 * r3;
              t3.nSigBytes > e2 && (t3 = n4.finalize(t3)), t3.clamp();
              for (var o = this.rn = t3.clone(), u = this.en = t3.clone(), f = o.words, c = u.words, s = 0; s < r3; s++) f[s] ^= 1549556828, c[s] ^= 909522486;
              u.nSigBytes = e2, o.nSigBytes = e2, this.reset();
            }
            return n3.prototype.reset = function() {
              this.tn.reset(), this.tn.update(this.en);
            }, n3.prototype.update = function(n4) {
              return this.tn.update(n4), this;
            }, n3.prototype.finalize = function(n4) {
              var t3 = this.tn.finalize(n4);
              return this.tn.reset(), this.tn.finalize(this.rn.clone().concat(t3));
            }, n3;
          }();
        }, 3027: function(n2, t2, r2) {
          r2.d(t2, { HmacMD5: function() {
            return o;
          } });
          var i2 = r2(6367), e = r2(670);
          function o(n3, t3) {
            return new i2.Hmac(new e.MD5(), t3).finalize(n3);
          }
        }, 149: function(n2, t2, r2) {
          r2.d(t2, { HmacSHA1: function() {
            return o;
          } });
          var i2 = r2(6367), e = r2(3173);
          function o(n3, t3) {
            return new i2.Hmac(new e.SHA1(), t3).finalize(n3);
          }
        }, 4105: function(n2, t2, r2) {
          r2.d(t2, { HmacSHA224: function() {
            return o;
          } });
          var i2 = r2(6367), e = r2(766);
          function o(n3, t3) {
            return new i2.Hmac(new e.SHA224(), t3).finalize(n3);
          }
        }, 980: function(n2, t2, r2) {
          r2.d(t2, { HmacSHA256: function() {
            return o;
          } });
          var i2 = r2(6367), e = r2(5561);
          function o(n3, t3) {
            return new i2.Hmac(new e.SHA256(), t3).finalize(n3);
          }
        }, 5838: function(n2, t2, r2) {
          r2.d(t2, { HmacSHA384: function() {
            return o;
          } });
          var i2 = r2(6367), e = r2(6324);
          function o(n3, t3) {
            return new i2.Hmac(new e.SHA384(), t3).finalize(n3);
          }
        }, 9902: function(n2, t2, r2) {
          r2.d(t2, { HmacSHA512: function() {
            return o;
          } });
          var i2 = r2(6367), e = r2(7491);
          function o(n3, t3) {
            return new i2.Hmac(new e.SHA512(), t3).finalize(n3);
          }
        }, 670: function(n2, t2, r2) {
          r2.d(t2, { MD5: function() {
            return v;
          } });
          var i2, e = r2(3354), o = r2(1868), u = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), f = [];
          function c(n3, t3, r3, i3, e2, o2, u2) {
            var f2 = n3 + (t3 & r3 | ~t3 & i3) + e2 + u2;
            return (f2 << o2 | f2 >>> 32 - o2) + t3;
          }
          function s(n3, t3, r3, i3, e2, o2, u2) {
            var f2 = n3 + (t3 & i3 | r3 & ~i3) + e2 + u2;
            return (f2 << o2 | f2 >>> 32 - o2) + t3;
          }
          function a(n3, t3, r3, i3, e2, o2, u2) {
            var f2 = n3 + (t3 ^ r3 ^ i3) + e2 + u2;
            return (f2 << o2 | f2 >>> 32 - o2) + t3;
          }
          function h(n3, t3, r3, i3, e2, o2, u2) {
            var f2 = n3 + (r3 ^ (t3 | ~i3)) + e2 + u2;
            return (f2 << o2 | f2 >>> 32 - o2) + t3;
          }
          !function() {
            for (var n3 = 0; n3 < 64; n3++) f[n3] = 4294967296 * Math.abs(Math.sin(n3 + 1)) | 0;
          }();
          var v = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.on = new e.e([1732584193, 4023233417, 2562383102, 271733878]), t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
            }
            return u(t3, n3), t3.prototype.A = function() {
              this.on = new e.e([1732584193, 4023233417, 2562383102, 271733878]);
            }, t3.prototype.un = function(n4, t4) {
              for (var r3 = 0; r3 < 16; r3++) {
                var i3 = t4 + r3, e2 = n4[i3];
                n4[i3] = 16711935 & (e2 << 8 | e2 >>> 24) | 4278255360 & (e2 << 24 | e2 >>> 8);
              }
              var o2 = this.on.words, u2 = n4[t4], v2 = n4[t4 + 1], w = n4[t4 + 2], l = n4[t4 + 3], b = n4[t4 + 4], d = n4[t4 + 5], y = n4[t4 + 6], p = n4[t4 + 7], O = n4[t4 + 8], j = n4[t4 + 9], _ = n4[t4 + 10], m = n4[t4 + 11], A = n4[t4 + 12], g = n4[t4 + 13], E = n4[t4 + 14], S = n4[t4 + 15], M = o2[0], k = o2[1], H = o2[2], C = o2[3];
              M = c(M, k, H, C, u2, 7, f[0]), C = c(C, M, k, H, v2, 12, f[1]), H = c(H, C, M, k, w, 17, f[2]), k = c(k, H, C, M, l, 22, f[3]), M = c(M, k, H, C, b, 7, f[4]), C = c(C, M, k, H, d, 12, f[5]), H = c(H, C, M, k, y, 17, f[6]), k = c(k, H, C, M, p, 22, f[7]), M = c(M, k, H, C, O, 7, f[8]), C = c(C, M, k, H, j, 12, f[9]), H = c(H, C, M, k, _, 17, f[10]), k = c(k, H, C, M, m, 22, f[11]), M = c(M, k, H, C, A, 7, f[12]), C = c(C, M, k, H, g, 12, f[13]), H = c(H, C, M, k, E, 17, f[14]), M = s(M, k = c(k, H, C, M, S, 22, f[15]), H, C, v2, 5, f[16]), C = s(C, M, k, H, y, 9, f[17]), H = s(H, C, M, k, m, 14, f[18]), k = s(k, H, C, M, u2, 20, f[19]), M = s(M, k, H, C, d, 5, f[20]), C = s(C, M, k, H, _, 9, f[21]), H = s(H, C, M, k, S, 14, f[22]), k = s(k, H, C, M, b, 20, f[23]), M = s(M, k, H, C, j, 5, f[24]), C = s(C, M, k, H, E, 9, f[25]), H = s(H, C, M, k, l, 14, f[26]), k = s(k, H, C, M, O, 20, f[27]), M = s(M, k, H, C, g, 5, f[28]), C = s(C, M, k, H, w, 9, f[29]), H = s(H, C, M, k, p, 14, f[30]), M = a(M, k = s(k, H, C, M, A, 20, f[31]), H, C, d, 4, f[32]), C = a(C, M, k, H, O, 11, f[33]), H = a(H, C, M, k, m, 16, f[34]), k = a(k, H, C, M, E, 23, f[35]), M = a(M, k, H, C, v2, 4, f[36]), C = a(C, M, k, H, b, 11, f[37]), H = a(H, C, M, k, p, 16, f[38]), k = a(k, H, C, M, _, 23, f[39]), M = a(M, k, H, C, g, 4, f[40]), C = a(C, M, k, H, u2, 11, f[41]), H = a(H, C, M, k, l, 16, f[42]), k = a(k, H, C, M, y, 23, f[43]), M = a(M, k, H, C, j, 4, f[44]), C = a(C, M, k, H, A, 11, f[45]), H = a(H, C, M, k, S, 16, f[46]), M = h(M, k = a(k, H, C, M, w, 23, f[47]), H, C, u2, 6, f[48]), C = h(C, M, k, H, p, 10, f[49]), H = h(H, C, M, k, E, 15, f[50]), k = h(k, H, C, M, d, 21, f[51]), M = h(M, k, H, C, A, 6, f[52]), C = h(C, M, k, H, l, 10, f[53]), H = h(H, C, M, k, _, 15, f[54]), k = h(k, H, C, M, v2, 21, f[55]), M = h(M, k, H, C, O, 6, f[56]), C = h(C, M, k, H, S, 10, f[57]), H = h(H, C, M, k, y, 15, f[58]), k = h(k, H, C, M, g, 21, f[59]), M = h(M, k, H, C, b, 6, f[60]), C = h(C, M, k, H, m, 10, f[61]), H = h(H, C, M, k, w, 15, f[62]), k = h(k, H, C, M, j, 21, f[63]), o2[0] = o2[0] + M | 0, o2[1] = o2[1] + k | 0, o2[2] = o2[2] + H | 0, o2[3] = o2[3] + C | 0;
            }, t3.prototype.fn = function() {
              var n4 = this.cn, t4 = n4.words, r3 = 8 * this.sn, i3 = 8 * n4.nSigBytes;
              t4[i3 >>> 5] |= 128 << 24 - i3 % 32;
              var e2 = Math.floor(r3 / 4294967296), o2 = r3;
              t4[15 + (i3 + 64 >>> 9 << 4)] = 16711935 & (e2 << 8 | e2 >>> 24) | 4278255360 & (e2 << 24 | e2 >>> 8), t4[14 + (i3 + 64 >>> 9 << 4)] = 16711935 & (o2 << 8 | o2 >>> 24) | 4278255360 & (o2 << 24 | o2 >>> 8), n4.nSigBytes = 4 * (t4.length + 1), this.an();
              for (var u2 = this.on, f2 = u2.words, c2 = 0; c2 < 4; c2++) {
                var s2 = f2[c2];
                f2[c2] = 16711935 & (s2 << 8 | s2 >>> 24) | 4278255360 & (s2 << 24 | s2 >>> 8);
              }
              return u2;
            }, t3.prototype.clone = function() {
              return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
            }, t3.hash = function(n4) {
              return new t3().finalize(n4);
            }, t3;
          }(o.P);
        }, 4615: function(n2, t2, r2) {
          r2.d(t2, { RC4: function() {
            return s;
          } });
          var i2, e = r2(30), o = r2(5693), u = r2(9109), f = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), c = function() {
            return (c = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, s = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.S = [], r3.i = 0, r3.j = 0, r3.O = t4, r3.A(), r3;
            }
            return f(t3, n3), t3.prototype.A = function() {
              var n4 = this.H, t4 = n4.words, r3 = n4.nSigBytes;
              this.S = [];
              for (var i3 = 0; i3 < 256; i3++) this.S[i3] = i3;
              i3 = 0;
              for (var e2 = 0; i3 < 256; i3++) {
                var o2 = i3 % r3, u2 = t4[o2 >>> 2] >>> 24 - o2 % 4 * 8 & 255;
                e2 = (e2 + this.S[i3] + u2) % 256;
                var f2 = this.S[i3];
                this.S[i3] = this.S[e2], this.S[e2] = f2;
              }
              this.i = this.j = 0;
            }, t3.prototype.un = function(n4, t4) {
              n4[t4] ^= this.generateKeyStreamWord();
            }, t3.prototype.generateKeyStreamWord = function() {
              for (var n4 = this.S, t4 = this.i, r3 = this.j, i3 = 0, e2 = 0; e2 < 4; e2++) {
                r3 = (r3 + n4[t4 = (t4 + 1) % 256]) % 256;
                var o2 = n4[t4];
                n4[t4] = n4[r3], n4[r3] = o2, i3 |= n4[(n4[t4] + n4[r3]) % 256] << 24 - 8 * e2;
              }
              return this.i = t4, this.j = r3, i3;
            }, t3.createEncryptor = function(n4, r3) {
              return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
            }, t3.createDecryptor = function(n4, r3) {
              return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
            }, t3.encrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? o.E.encrypt(t3, n4, r3, i3) : u.D.encrypt(t3, n4, r3, i3);
            }, t3.decrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? o.E.decrypt(t3, n4, r3, i3) : u.D.decrypt(t3, n4, r3, i3);
            }, t3.ivSize = 0, t3.keySize = 8, t3;
          }(e.q);
        }, 9639: function(n2, t2, r2) {
          r2.d(t2, { RC4Drop: function() {
            return s;
          } });
          var i2, e = r2(5693), o = r2(9109), u = r2(4615), f = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), c = function() {
            return (c = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, s = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.drop = 192, r3.O = t4, t4 && "number" == typeof t4.drop && (r3.drop = t4.drop), r3.A(), r3;
            }
            return f(t3, n3), t3.prototype.A = function() {
              n3.prototype.A.call(this);
              for (var t4 = this.drop; t4 > 0; t4--) this.generateKeyStreamWord();
            }, t3.createEncryptor = function(n4, r3) {
              return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
            }, t3.createDecryptor = function(n4, r3) {
              return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
            }, t3.encrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? e.E.encrypt(t3, n4, r3, i3) : o.D.encrypt(t3, n4, r3, i3);
            }, t3.decrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? e.E.decrypt(t3, n4, r3, i3) : o.D.decrypt(t3, n4, r3, i3);
            }, t3;
          }(u.RC4);
        }, 7104: function(n2, t2, r2) {
          r2.d(t2, { RIPEMD160: function() {
            return O;
          } });
          var i2, e = r2(1868), o = r2(3354), u = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), f = new o.e([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]), c = new o.e([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]), s = new o.e([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]), a = new o.e([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]), h = new o.e([0, 1518500249, 1859775393, 2400959708, 2840853838]), v = new o.e([1352829926, 1548603684, 1836072691, 2053994217, 0]);
          function w(n3, t3, r3) {
            return n3 ^ t3 ^ r3;
          }
          function l(n3, t3, r3) {
            return n3 & t3 | ~n3 & r3;
          }
          function b(n3, t3, r3) {
            return (n3 | ~t3) ^ r3;
          }
          function d(n3, t3, r3) {
            return n3 & r3 | t3 & ~r3;
          }
          function y(n3, t3, r3) {
            return n3 ^ (t3 | ~r3);
          }
          function p(n3, t3) {
            return n3 << t3 | n3 >>> 32 - t3;
          }
          var O = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.on = new o.e([1732584193, 4023233417, 2562383102, 271733878, 3285377520]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
            }
            return u(t3, n3), t3.prototype.A = function() {
              this.on = new o.e([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
            }, t3.prototype.un = function(n4, t4) {
              for (var r3 = 0; r3 < 16; r3++) {
                var i3 = t4 + r3, e2 = n4[i3];
                n4[i3] = 16711935 & (e2 << 8 | e2 >>> 24) | 4278255360 & (e2 << 24 | e2 >>> 8);
              }
              var o2, u2, O2, j, _, m, A, g, E, S, M, k = this.on.words, H = h.words, C = v.words, B = f.words, N = c.words, I = s.words, z = a.words;
              m = o2 = k[0], A = u2 = k[1], g = O2 = k[2], E = j = k[3], S = _ = k[4];
              for (r3 = 0; r3 < 80; r3 += 1) M = o2 + n4[t4 + B[r3]] | 0, M += r3 < 16 ? w(u2, O2, j) + H[0] : r3 < 32 ? l(u2, O2, j) + H[1] : r3 < 48 ? b(u2, O2, j) + H[2] : r3 < 64 ? d(u2, O2, j) + H[3] : y(u2, O2, j) + H[4], M = (M = p(M |= 0, I[r3])) + _ | 0, o2 = _, _ = j, j = p(O2, 10), O2 = u2, u2 = M, M = m + n4[t4 + N[r3]] | 0, M += r3 < 16 ? y(A, g, E) + C[0] : r3 < 32 ? d(A, g, E) + C[1] : r3 < 48 ? b(A, g, E) + C[2] : r3 < 64 ? l(A, g, E) + C[3] : w(A, g, E) + C[4], M = (M = p(M |= 0, z[r3])) + S | 0, m = S, S = E, E = p(g, 10), g = A, A = M;
              M = k[1] + O2 + E | 0, k[1] = k[2] + j + S | 0, k[2] = k[3] + _ + m | 0, k[3] = k[4] + o2 + A | 0, k[4] = k[0] + u2 + g | 0, k[0] = M;
            }, t3.prototype.fn = function() {
              var n4 = this.cn, t4 = n4.words, r3 = 8 * this.sn, i3 = 8 * n4.nSigBytes;
              t4[i3 >>> 5] |= 128 << 24 - i3 % 32, t4[14 + (i3 + 64 >>> 9 << 4)] = 16711935 & (r3 << 8 | r3 >>> 24) | 4278255360 & (r3 << 24 | r3 >>> 8), n4.nSigBytes = 4 * (t4.length + 1), this.an();
              for (var e2 = this.on, o2 = e2.words, u2 = 0; u2 < 5; u2++) {
                var f2 = o2[u2];
                o2[u2] = 16711935 & (f2 << 8 | f2 >>> 24) | 4278255360 & (f2 << 24 | f2 >>> 8);
              }
              return e2;
            }, t3.prototype.clone = function() {
              return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
            }, t3.hash = function(n4, r3) {
              return new t3(r3).finalize(n4);
            }, t3;
          }(e.P);
        }, 5187: function(n2, t2, r2) {
          r2.d(t2, { Rabbit: function() {
            return s;
          } });
          var i2, e = r2(30), o = r2(5693), u = r2(9109), f = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), c = function() {
            return (c = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, s = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.N = 4, r3.S = [], r3.C = [], r3.G = [], r3.hn = [], r3.vn = [], r3.wn = 0, r3.O = t4, r3.A(), r3;
            }
            return f(t3, n3), t3.prototype.A = function() {
              for (var n4 = this.H.words, t4 = this.ln, r3 = 0; r3 < 4; r3++) n4[r3] = 16711935 & (n4[r3] << 8 | n4[r3] >>> 24) | 4278255360 & (n4[r3] << 24 | n4[r3] >>> 8);
              var i3 = this.hn = [n4[0], n4[3] << 16 | n4[2] >>> 16, n4[1], n4[0] << 16 | n4[3] >>> 16, n4[2], n4[1] << 16 | n4[0] >>> 16, n4[3], n4[2] << 16 | n4[1] >>> 16], e2 = this.vn = [n4[2] << 16 | n4[2] >>> 16, 4294901760 & n4[0] | 65535 & n4[1], n4[3] << 16 | n4[3] >>> 16, 4294901760 & n4[1] | 65535 & n4[2], n4[0] << 16 | n4[0] >>> 16, 4294901760 & n4[2] | 65535 & n4[3], n4[1] << 16 | n4[1] >>> 16, 4294901760 & n4[3] | 65535 & n4[0]];
              this.wn = 0;
              for (r3 = 0; r3 < 4; r3++) this.nextState();
              for (r3 = 0; r3 < 8; r3++) e2[r3] ^= i3[r3 + 4 & 7];
              if (t4) {
                var o2 = t4.words, u2 = o2[0], f2 = o2[1], c2 = 16711935 & (u2 << 8 | u2 >>> 24) | 4278255360 & (u2 << 24 | u2 >>> 8), s2 = 16711935 & (f2 << 8 | f2 >>> 24) | 4278255360 & (f2 << 24 | f2 >>> 8), a = c2 >>> 16 | 4294901760 & s2, h = s2 << 16 | 65535 & c2;
                e2[0] ^= c2, e2[1] ^= a, e2[2] ^= s2, e2[3] ^= h, e2[4] ^= c2, e2[5] ^= a, e2[6] ^= s2, e2[7] ^= h;
                for (r3 = 0; r3 < 4; r3++) this.nextState();
              }
            }, t3.prototype.un = function(n4, t4) {
              var r3 = this.hn;
              this.nextState(), this.S[0] = r3[0] ^ r3[5] >>> 16 ^ r3[3] << 16, this.S[1] = r3[2] ^ r3[7] >>> 16 ^ r3[5] << 16, this.S[2] = r3[4] ^ r3[1] >>> 16 ^ r3[7] << 16, this.S[3] = r3[6] ^ r3[3] >>> 16 ^ r3[1] << 16;
              for (var i3 = 0; i3 < 4; i3++) this.S[i3] = 16711935 & (this.S[i3] << 8 | this.S[i3] >>> 24) | 4278255360 & (this.S[i3] << 24 | this.S[i3] >>> 8), n4[t4 + i3] ^= this.S[i3];
            }, t3.prototype.nextState = function() {
              for (var n4 = this.hn, t4 = this.vn, r3 = 0; r3 < 8; r3++) this.C[r3] = t4[r3];
              t4[0] = t4[0] + 1295307597 + this.wn | 0, t4[1] = t4[1] + 3545052371 + (t4[0] >>> 0 < this.C[0] >>> 0 ? 1 : 0) | 0, t4[2] = t4[2] + 886263092 + (t4[1] >>> 0 < this.C[1] >>> 0 ? 1 : 0) | 0, t4[3] = t4[3] + 1295307597 + (t4[2] >>> 0 < this.C[2] >>> 0 ? 1 : 0) | 0, t4[4] = t4[4] + 3545052371 + (t4[3] >>> 0 < this.C[3] >>> 0 ? 1 : 0) | 0, t4[5] = t4[5] + 886263092 + (t4[4] >>> 0 < this.C[4] >>> 0 ? 1 : 0) | 0, t4[6] = t4[6] + 1295307597 + (t4[5] >>> 0 < this.C[5] >>> 0 ? 1 : 0) | 0, t4[7] = t4[7] + 3545052371 + (t4[6] >>> 0 < this.C[6] >>> 0 ? 1 : 0) | 0, this.wn = t4[7] >>> 0 < this.C[7] >>> 0 ? 1 : 0;
              for (r3 = 0; r3 < 8; r3++) {
                var i3 = n4[r3] + t4[r3], e2 = 65535 & i3, o2 = i3 >>> 16, u2 = ((e2 * e2 >>> 17) + e2 * o2 >>> 15) + o2 * o2, f2 = ((4294901760 & i3) * i3 | 0) + ((65535 & i3) * i3 | 0);
                this.G[r3] = u2 ^ f2;
              }
              var c2 = this.G;
              n4[0] = c2[0] + (c2[7] << 16 | c2[7] >>> 16) + (c2[6] << 16 | c2[6] >>> 16) | 0, n4[1] = c2[1] + (c2[0] << 8 | c2[0] >>> 24) + c2[7] | 0, n4[2] = c2[2] + (c2[1] << 16 | c2[1] >>> 16) + (c2[0] << 16 | c2[0] >>> 16) | 0, n4[3] = c2[3] + (c2[2] << 8 | c2[2] >>> 24) + c2[1] | 0, n4[4] = c2[4] + (c2[3] << 16 | c2[3] >>> 16) + (c2[2] << 16 | c2[2] >>> 16) | 0, n4[5] = c2[5] + (c2[4] << 8 | c2[4] >>> 24) + c2[3] | 0, n4[6] = c2[6] + (c2[5] << 16 | c2[5] >>> 16) + (c2[4] << 16 | c2[4] >>> 16) | 0, n4[7] = c2[7] + (c2[6] << 8 | c2[6] >>> 24) + c2[5] | 0;
            }, t3.createEncryptor = function(n4, r3) {
              return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
            }, t3.createDecryptor = function(n4, r3) {
              return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4 }));
            }, t3.encrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? o.E.encrypt(t3, n4, r3, i3) : u.D.encrypt(t3, n4, r3, i3);
            }, t3.decrypt = function(n4, r3, i3) {
              return "string" == typeof r3 ? o.E.decrypt(t3, n4, r3, i3) : u.D.decrypt(t3, n4, r3, i3);
            }, t3.ivSize = 4, t3;
          }(e.q);
        }, 3173: function(n2, t2, r2) {
          r2.d(t2, { SHA1: function() {
            return c;
          } });
          var i2, e = r2(1868), o = r2(3354), u = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), f = [], c = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.on = new o.e([1732584193, 4023233417, 2562383102, 271733878, 3285377520]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
            }
            return u(t3, n3), t3.prototype.A = function() {
              this.on = new o.e([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
            }, t3.prototype.un = function(n4, t4) {
              for (var r3 = this.on.words, i3 = r3[0], e2 = r3[1], o2 = r3[2], u2 = r3[3], c2 = r3[4], s = 0; s < 80; s++) {
                if (s < 16) f[s] = 0 | n4[t4 + s];
                else {
                  var a = f[s - 3] ^ f[s - 8] ^ f[s - 14] ^ f[s - 16];
                  f[s] = a << 1 | a >>> 31;
                }
                var h = (i3 << 5 | i3 >>> 27) + c2 + f[s];
                h += s < 20 ? 1518500249 + (e2 & o2 | ~e2 & u2) : s < 40 ? 1859775393 + (e2 ^ o2 ^ u2) : s < 60 ? (e2 & o2 | e2 & u2 | o2 & u2) - 1894007588 : (e2 ^ o2 ^ u2) - 899497514, c2 = u2, u2 = o2, o2 = e2 << 30 | e2 >>> 2, e2 = i3, i3 = h;
              }
              r3[0] = r3[0] + i3 | 0, r3[1] = r3[1] + e2 | 0, r3[2] = r3[2] + o2 | 0, r3[3] = r3[3] + u2 | 0, r3[4] = r3[4] + c2 | 0;
            }, t3.prototype.fn = function() {
              var n4 = this.cn.words, t4 = 8 * this.sn, r3 = 8 * this.cn.nSigBytes;
              return n4[r3 >>> 5] |= 128 << 24 - r3 % 32, n4[14 + (r3 + 64 >>> 9 << 4)] = Math.floor(t4 / 4294967296), n4[15 + (r3 + 64 >>> 9 << 4)] = t4, this.cn.nSigBytes = 4 * n4.length, this.an(), this.on;
            }, t3.prototype.clone = function() {
              return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
            }, t3.hash = function(n4, r3) {
              return new t3(r3).finalize(n4);
            }, t3;
          }(e.P);
        }, 766: function(n2, t2, r2) {
          r2.d(t2, { SHA224: function() {
            return f;
          } });
          var i2, e = r2(3354), o = r2(5561), u = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), f = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.on = new e.e([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
            }
            return u(t3, n3), t3.prototype.A = function() {
              this.on = new e.e([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]);
            }, t3.prototype.fn = function() {
              var t4 = n3.prototype.fn.call(this);
              return t4.nSigBytes -= 4, t4;
            }, t3.prototype.clone = function() {
              return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
            }, t3.hash = function(n4, r3) {
              return new t3(r3).finalize(n4);
            }, t3;
          }(o.SHA256);
        }, 5561: function(n2, t2, r2) {
          r2.d(t2, { SHA256: function() {
            return v;
          } });
          var i2, e = r2(1868), o = r2(3354), u = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), f = [], c = [];
          function s(n3) {
            for (var t3 = Math.sqrt(n3), r3 = 2; r3 <= t3; r3++) if (!(n3 % r3)) return false;
            return true;
          }
          function a(n3) {
            return 4294967296 * (n3 - (0 | n3)) | 0;
          }
          !function() {
            for (var n3 = 2, t3 = 0; t3 < 64; ) s(n3) && (t3 < 8 && (f[t3] = a(Math.pow(n3, 0.5))), c[t3] = a(Math.pow(n3, 1 / 3)), t3++), n3++;
          }();
          var h = [], v = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.on = new o.e(f.slice(0)), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
            }
            return u(t3, n3), t3.prototype.A = function() {
              this.on = new o.e(f.slice(0));
            }, t3.prototype.un = function(n4, t4) {
              for (var r3 = this.on.words, i3 = r3[0], e2 = r3[1], o2 = r3[2], u2 = r3[3], f2 = r3[4], s2 = r3[5], a2 = r3[6], v2 = r3[7], w = 0; w < 64; w++) {
                if (w < 16) h[w] = 0 | n4[t4 + w];
                else {
                  var l = h[w - 15], b = (l << 25 | l >>> 7) ^ (l << 14 | l >>> 18) ^ l >>> 3, d = h[w - 2], y = (d << 15 | d >>> 17) ^ (d << 13 | d >>> 19) ^ d >>> 10;
                  h[w] = b + h[w - 7] + y + h[w - 16];
                }
                var p = i3 & e2 ^ i3 & o2 ^ e2 & o2, O = (i3 << 30 | i3 >>> 2) ^ (i3 << 19 | i3 >>> 13) ^ (i3 << 10 | i3 >>> 22), j = v2 + ((f2 << 26 | f2 >>> 6) ^ (f2 << 21 | f2 >>> 11) ^ (f2 << 7 | f2 >>> 25)) + (f2 & s2 ^ ~f2 & a2) + c[w] + h[w];
                v2 = a2, a2 = s2, s2 = f2, f2 = u2 + j | 0, u2 = o2, o2 = e2, e2 = i3, i3 = j + (O + p) | 0;
              }
              r3[0] = r3[0] + i3 | 0, r3[1] = r3[1] + e2 | 0, r3[2] = r3[2] + o2 | 0, r3[3] = r3[3] + u2 | 0, r3[4] = r3[4] + f2 | 0, r3[5] = r3[5] + s2 | 0, r3[6] = r3[6] + a2 | 0, r3[7] = r3[7] + v2 | 0;
            }, t3.prototype.fn = function() {
              var n4 = this.cn.words, t4 = 8 * this.sn, r3 = 8 * this.cn.nSigBytes;
              return n4[r3 >>> 5] |= 128 << 24 - r3 % 32, n4[14 + (r3 + 64 >>> 9 << 4)] = Math.floor(t4 / 4294967296), n4[15 + (r3 + 64 >>> 9 << 4)] = t4, this.cn.nSigBytes = 4 * n4.length, this.an(), this.on;
            }, t3.prototype.clone = function() {
              return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
            }, t3.hash = function(n4, r3) {
              return new t3(r3).finalize(n4);
            }, t3;
          }(e.P);
        }, 3408: function(n2, t2, r2) {
          r2.d(t2, { SHA3: function() {
            return v;
          } });
          var i2, e = r2(6957), o = r2(1868), u = r2(3354), f = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), c = [], s = [], a = [];
          !function() {
            for (var n3 = 1, t3 = 0, r3 = 0; r3 < 24; r3++) {
              c[n3 + 5 * t3] = (r3 + 1) * (r3 + 2) / 2 % 64;
              var i3 = (2 * n3 + 3 * t3) % 5;
              n3 = t3 % 5, t3 = i3;
            }
            for (var o2 = 0; o2 < 5; o2++) for (var u2 = 0; u2 < 5; u2++) s[o2 + 5 * u2] = u2 + (2 * o2 + 3 * u2) % 5 * 5;
            for (var f2 = 1, h2 = 0; h2 < 24; h2++) {
              for (var v2 = 0, w = 0, l = 0; l < 7; l++) {
                if (1 & f2) {
                  var b = (1 << l) - 1;
                  b < 32 ? w ^= 1 << b : v2 ^= 1 << b - 32;
                }
                128 & f2 ? f2 = f2 << 1 ^ 113 : f2 <<= 1;
              }
              a[h2] = new e.r(v2, w);
            }
          }();
          var h = [];
          !function() {
            for (var n3 = 0; n3 < 25; n3++) h[n3] = new e.r(0, 0);
          }();
          var v = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              if (r3.N = 32, r3.bn = [], r3.dn = 512, r3.O = t4, t4) {
                if (void 0 !== t4.outputLength) {
                  if (![224, 256, 384, 512].includes(t4.outputLength)) throw new Error("Unsupported output length.");
                  r3.dn = t4.outputLength;
                }
                void 0 !== t4.state && (r3.bn = t4.state.map(function(n4) {
                  return n4.clone();
                }));
              }
              if (0 === r3.bn.length) for (var i3 = 0; i3 < 25; i3++) r3.bn[i3] = new e.r(0, 0);
              return r3.N = (1600 - 2 * r3.dn) / 32, r3;
            }
            return f(t3, n3), t3.prototype.A = function() {
              this.bn = [];
              for (var n4 = 0; n4 < 25; n4++) this.bn[n4] = new e.r(0, 0);
              this.N = (1600 - 2 * this.dn) / 32;
            }, t3.prototype.un = function(n4, t4) {
              for (var r3 = this.bn, i3 = this.N / 2, e2 = 0; e2 < i3; e2++) {
                var o2 = n4[t4 + 2 * e2], u2 = n4[t4 + 2 * e2 + 1];
                o2 = 16711935 & (o2 << 8 | o2 >>> 24) | 4278255360 & (o2 << 24 | o2 >>> 8), u2 = 16711935 & (u2 << 8 | u2 >>> 24) | 4278255360 & (u2 << 24 | u2 >>> 8), r3[e2].high ^= u2, r3[e2].low ^= o2;
              }
              for (var f2 = 0; f2 < 24; f2++) {
                for (var v2 = 0; v2 < 5; v2++) {
                  for (var w = 0, l = 0, b = 0; b < 5; b++) {
                    w ^= (k = r3[v2 + 5 * b]).high, l ^= k.low;
                  }
                  var d = h[v2];
                  d.high = w, d.low = l;
                }
                for (v2 = 0; v2 < 5; v2++) {
                  var y = h[(v2 + 4) % 5], p = h[(v2 + 1) % 5], O = p.high, j = p.low;
                  for (w = y.high ^ (O << 1 | j >>> 31), l = y.low ^ (j << 1 | O >>> 31), b = 0; b < 5; b++) {
                    (k = r3[v2 + 5 * b]).high ^= w, k.low ^= l;
                  }
                }
                for (var _ = 1; _ < 25; _++) {
                  w = void 0, l = void 0;
                  var m = r3[_].high, A = r3[_].low, g = c[_];
                  g < 32 ? (w = m << g | A >>> 32 - g, l = A << g | m >>> 32 - g) : (w = A << g - 32 | m >>> 64 - g, l = m << g - 32 | A >>> 64 - g);
                  var E = h[s[_]];
                  E.high = w, E.low = l;
                }
                var S = h[0], M = r3[0];
                S.high = M.high, S.low = M.low;
                for (v2 = 0; v2 < 5; v2++) for (b = 0; b < 5; b++) {
                  var k = r3[_ = v2 + 5 * b], H = h[_], C = h[(v2 + 1) % 5 + 5 * b], B = h[(v2 + 2) % 5 + 5 * b];
                  k.high = H.high ^ ~C.high & B.high, k.low = H.low ^ ~C.low & B.low;
                }
                var N = r3[0], I = a[f2];
                N.high ^= I.high, N.low ^= I.low;
              }
            }, t3.prototype.fn = function() {
              var n4 = this.cn, t4 = n4.words, r3 = 8 * n4.nSigBytes, i3 = 32 * this.blockSize;
              t4[r3 >>> 5] |= 1 << 24 - r3 % 32, t4[(Math.ceil((r3 + 1) / i3) * i3 >>> 5) - 1] |= 128, n4.nSigBytes = 4 * t4.length, this.an();
              for (var e2 = this.bn, o2 = this.dn / 8, f2 = o2 / 8, c2 = [], s2 = 0; s2 < f2; s2++) {
                var a2 = e2[s2], h2 = a2.high, v2 = a2.low;
                h2 = 16711935 & (h2 << 8 | h2 >>> 24) | 4278255360 & (h2 << 24 | h2 >>> 8), v2 = 16711935 & (v2 << 8 | v2 >>> 24) | 4278255360 & (v2 << 24 | v2 >>> 8), c2.push(v2), c2.push(h2);
              }
              return new u.e(c2, o2);
            }, t3.prototype.clone = function() {
              return new t3({ outputLength: this.dn, state: this.bn, blockSize: this.N, data: this.cn, nBytes: this.sn });
            }, t3.hash = function(n4, r3) {
              return new t3(r3).finalize(n4);
            }, t3;
          }(o.P);
        }, 6324: function(n2, t2, r2) {
          r2.d(t2, { SHA384: function() {
            return f;
          } });
          var i2, e = r2(6957), o = r2(7491), u = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), f = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.on = new e.m([new e.r(3418070365, 3238371032), new e.r(1654270250, 914150663), new e.r(2438529370, 812702999), new e.r(355462360, 4144912697), new e.r(1731405415, 4290775857), new e.r(2394180231, 1750603025), new e.r(3675008525, 1694076839), new e.r(1203062813, 3204075428)]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
            }
            return u(t3, n3), t3.prototype.A = function() {
              this.on = new e.m([new e.r(3418070365, 3238371032), new e.r(1654270250, 914150663), new e.r(2438529370, 812702999), new e.r(355462360, 4144912697), new e.r(1731405415, 4290775857), new e.r(2394180231, 1750603025), new e.r(3675008525, 1694076839), new e.r(1203062813, 3204075428)]);
            }, t3.prototype.fn = function() {
              var t4 = n3.prototype.fn.call(this);
              return t4.nSigBytes -= 16, t4;
            }, t3.prototype.clone = function() {
              return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
            }, t3.hash = function(n4, r3) {
              return new t3(r3).finalize(n4);
            }, t3;
          }(o.SHA512);
        }, 7491: function(n2, t2, r2) {
          r2.d(t2, { SHA512: function() {
            return s;
          } });
          var i2, e = r2(1868), o = r2(6957), u = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), f = [new o.r(1116352408, 3609767458), new o.r(1899447441, 602891725), new o.r(3049323471, 3964484399), new o.r(3921009573, 2173295548), new o.r(961987163, 4081628472), new o.r(1508970993, 3053834265), new o.r(2453635748, 2937671579), new o.r(2870763221, 3664609560), new o.r(3624381080, 2734883394), new o.r(310598401, 1164996542), new o.r(607225278, 1323610764), new o.r(1426881987, 3590304994), new o.r(1925078388, 4068182383), new o.r(2162078206, 991336113), new o.r(2614888103, 633803317), new o.r(3248222580, 3479774868), new o.r(3835390401, 2666613458), new o.r(4022224774, 944711139), new o.r(264347078, 2341262773), new o.r(604807628, 2007800933), new o.r(770255983, 1495990901), new o.r(1249150122, 1856431235), new o.r(1555081692, 3175218132), new o.r(1996064986, 2198950837), new o.r(2554220882, 3999719339), new o.r(2821834349, 766784016), new o.r(2952996808, 2566594879), new o.r(3210313671, 3203337956), new o.r(3336571891, 1034457026), new o.r(3584528711, 2466948901), new o.r(113926993, 3758326383), new o.r(338241895, 168717936), new o.r(666307205, 1188179964), new o.r(773529912, 1546045734), new o.r(1294757372, 1522805485), new o.r(1396182291, 2643833823), new o.r(1695183700, 2343527390), new o.r(1986661051, 1014477480), new o.r(2177026350, 1206759142), new o.r(2456956037, 344077627), new o.r(2730485921, 1290863460), new o.r(2820302411, 3158454273), new o.r(3259730800, 3505952657), new o.r(3345764771, 106217008), new o.r(3516065817, 3606008344), new o.r(3600352804, 1432725776), new o.r(4094571909, 1467031594), new o.r(275423344, 851169720), new o.r(430227734, 3100823752), new o.r(506948616, 1363258195), new o.r(659060556, 3750685593), new o.r(883997877, 3785050280), new o.r(958139571, 3318307427), new o.r(1322822218, 3812723403), new o.r(1537002063, 2003034995), new o.r(1747873779, 3602036899), new o.r(1955562222, 1575990012), new o.r(2024104815, 1125592928), new o.r(2227730452, 2716904306), new o.r(2361852424, 442776044), new o.r(2428436474, 593698344), new o.r(2756734187, 3733110249), new o.r(3204031479, 2999351573), new o.r(3329325298, 3815920427), new o.r(3391569614, 3928383900), new o.r(3515267271, 566280711), new o.r(3940187606, 3454069534), new o.r(4118630271, 4000239992), new o.r(116418474, 1914138554), new o.r(174292421, 2731055270), new o.r(289380356, 3203993006), new o.r(460393269, 320620315), new o.r(685471733, 587496836), new o.r(852142971, 1086792851), new o.r(1017036298, 365543100), new o.r(1126000580, 2618297676), new o.r(1288033470, 3409855158), new o.r(1501505948, 4234509866), new o.r(1607167915, 987167468), new o.r(1816402316, 1246189591)], c = [];
          !function() {
            for (var n3 = 0; n3 < 80; n3++) c[n3] = new o.r(0, 0);
          }();
          var s = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.N = 32, r3.on = new o.m([new o.r(1779033703, 4089235720), new o.r(3144134277, 2227873595), new o.r(1013904242, 4271175723), new o.r(2773480762, 1595750129), new o.r(1359893119, 2917565137), new o.r(2600822924, 725511199), new o.r(528734635, 4215389547), new o.r(1541459225, 327033209)]), r3.O = t4, t4 && void 0 !== t4.hash && (r3.on = t4.hash.clone()), r3;
            }
            return u(t3, n3), t3.prototype.A = function() {
              this.on = new o.m([new o.r(1779033703, 4089235720), new o.r(3144134277, 2227873595), new o.r(1013904242, 4271175723), new o.r(2773480762, 1595750129), new o.r(1359893119, 2917565137), new o.r(2600822924, 725511199), new o.r(528734635, 4215389547), new o.r(1541459225, 327033209)]);
            }, t3.prototype.un = function(n4, t4) {
              for (var r3 = this.on.words, i3 = r3[0], e2 = r3[1], o2 = r3[2], u2 = r3[3], s2 = r3[4], a = r3[5], h = r3[6], v = r3[7], w = i3.high, l = i3.low, b = e2.high, d = e2.low, y = o2.high, p = o2.low, O = u2.high, j = u2.low, _ = s2.high, m = s2.low, A = a.high, g = a.low, E = h.high, S = h.low, M = v.high, k = v.low, H = w, C = l, B = b, N = d, I = y, z = p, D = O, U = j, L = _, F = m, x = A, P = g, R = E, T = S, K = M, W = k, G = 0; G < 80; G++) {
                var q = void 0, Q = void 0, X = c[G];
                if (G < 16) Q = X.high = 0 | n4[t4 + 2 * G], q = X.low = 0 | n4[t4 + 2 * G + 1];
                else {
                  var V = c[G - 15], Z = V.high, J = V.low, Y = (Z >>> 1 | J << 31) ^ (Z >>> 8 | J << 24) ^ Z >>> 7, $ = (J >>> 1 | Z << 31) ^ (J >>> 8 | Z << 24) ^ (J >>> 7 | Z << 25), nn = c[G - 2], tn = nn.high, rn = nn.low, en = (tn >>> 19 | rn << 13) ^ (tn << 3 | rn >>> 29) ^ tn >>> 6, on = (rn >>> 19 | tn << 13) ^ (rn << 3 | tn >>> 29) ^ (rn >>> 6 | tn << 26), un = c[G - 7], fn = un.high, cn = un.low, sn = c[G - 16], an = sn.high, hn = sn.low;
                  Q = (Q = (Q = Y + fn + ((q = $ + cn) >>> 0 < $ >>> 0 ? 1 : 0)) + en + ((q += on) >>> 0 < on >>> 0 ? 1 : 0)) + an + ((q += hn) >>> 0 < hn >>> 0 ? 1 : 0), X.high = Q, X.low = q;
                }
                var vn = L & x ^ ~L & R, wn = F & P ^ ~F & T, ln = H & B ^ H & I ^ B & I, bn = C & N ^ C & z ^ N & z, dn = (H >>> 28 | C << 4) ^ (H << 30 | C >>> 2) ^ (H << 25 | C >>> 7), yn = (C >>> 28 | H << 4) ^ (C << 30 | H >>> 2) ^ (C << 25 | H >>> 7), pn = (L >>> 14 | F << 18) ^ (L >>> 18 | F << 14) ^ (L << 23 | F >>> 9), On = (F >>> 14 | L << 18) ^ (F >>> 18 | L << 14) ^ (F << 23 | L >>> 9), jn = f[G], _n = jn.high, mn = jn.low, An = W + On, gn = K + pn + (An >>> 0 < W >>> 0 ? 1 : 0), En = yn + bn;
                K = R, W = T, R = x, T = P, x = L, P = F, L = D + (gn = (gn = (gn = gn + vn + ((An += wn) >>> 0 < wn >>> 0 ? 1 : 0)) + _n + ((An += mn) >>> 0 < mn >>> 0 ? 1 : 0)) + Q + ((An += q) >>> 0 < q >>> 0 ? 1 : 0)) + ((F = U + An | 0) >>> 0 < U >>> 0 ? 1 : 0) | 0, D = I, U = z, I = B, z = N, B = H, N = C, H = gn + (dn + ln + (En >>> 0 < yn >>> 0 ? 1 : 0)) + ((C = An + En | 0) >>> 0 < An >>> 0 ? 1 : 0) | 0;
              }
              l = i3.low = l + C, i3.high = w + H + (l >>> 0 < C >>> 0 ? 1 : 0), d = e2.low = d + N, e2.high = b + B + (d >>> 0 < N >>> 0 ? 1 : 0), p = o2.low = p + z, o2.high = y + I + (p >>> 0 < z >>> 0 ? 1 : 0), j = u2.low = j + U, u2.high = O + D + (j >>> 0 < U >>> 0 ? 1 : 0), m = s2.low = m + F, s2.high = _ + L + (m >>> 0 < F >>> 0 ? 1 : 0), g = a.low = g + P, a.high = A + x + (g >>> 0 < P >>> 0 ? 1 : 0), S = h.low = S + T, h.high = E + R + (S >>> 0 < T >>> 0 ? 1 : 0), k = v.low = k + W, v.high = M + K + (k >>> 0 < W >>> 0 ? 1 : 0);
            }, t3.prototype.fn = function() {
              var n4 = this.cn, t4 = n4.words, r3 = 8 * this.sn, i3 = 8 * n4.nSigBytes;
              return t4[i3 >>> 5] |= 128 << 24 - i3 % 32, t4[30 + (i3 + 128 >>> 10 << 5)] = Math.floor(r3 / 4294967296), t4[31 + (i3 + 128 >>> 10 << 5)] = r3, n4.nSigBytes = 4 * t4.length, this.an(), this.on.to32();
            }, t3.prototype.clone = function() {
              return new t3({ hash: this.on, blockSize: this.N, data: this.cn, nBytes: this.sn });
            }, t3.hash = function(n4, r3) {
              return new t3(r3).finalize(n4);
            }, t3;
          }(e.P);
        }, 3354: function(n2, t2, r2) {
          r2.d(t2, { e: function() {
            return o;
          } });
          var i2 = r2(5720), e = r2(9054), o = function() {
            function n3(t3, r3) {
              if (Array.isArray(t3) || !t3) return this.yn = Array.isArray(t3) ? t3 : [], void (this.pn = "number" == typeof r3 ? r3 : 4 * this.yn.length);
              if (t3 instanceof n3) return this.yn = t3.words.slice(), void (this.pn = t3.nSigBytes);
              var i3;
              try {
                t3 instanceof ArrayBuffer ? i3 = new Uint8Array(t3) : (t3 instanceof Uint8Array || t3 instanceof Int8Array || t3 instanceof Uint8ClampedArray || t3 instanceof Int16Array || t3 instanceof Uint16Array || t3 instanceof Int32Array || t3 instanceof Uint32Array || t3 instanceof Float32Array || t3 instanceof Float64Array) && (i3 = new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength));
              } catch (n4) {
                throw new Error("Invalid argument");
              }
              if (!i3) throw new Error("Invalid argument");
              for (var e2 = i3.byteLength, o2 = [], u = 0; u < e2; u++) o2[u >>> 2] |= i3[u] << 24 - u % 4 * 8;
              this.yn = o2, this.pn = e2;
            }
            return Object.defineProperty(n3.prototype, "nSigBytes", { get: function() {
              return this.pn;
            }, set: function(n4) {
              this.pn = n4;
            }, enumerable: false, configurable: true }), Object.defineProperty(n3.prototype, "words", { get: function() {
              return this.yn;
            }, enumerable: false, configurable: true }), n3.prototype.toString = function(n4) {
              return n4 ? n4.stringify(this) : i2.p.stringify(this);
            }, n3.prototype.toUint8Array = function() {
              for (var n4 = this.yn, t3 = this.pn, r3 = new Uint8Array(t3), i3 = 0; i3 < t3; i3++) r3[i3] = n4[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
              return r3;
            }, n3.prototype.concat = function(n4) {
              var t3 = n4.words.slice(), r3 = n4.nSigBytes;
              if (this.clamp(), this.pn % 4) for (var i3 = 0; i3 < r3; i3++) {
                var e2 = t3[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
                this.yn[this.pn + i3 >>> 2] |= e2 << 24 - (this.pn + i3) % 4 * 8;
              }
              else for (i3 = 0; i3 < r3; i3 += 4) this.yn[this.pn + i3 >>> 2] = t3[i3 >>> 2];
              return this.pn += r3, this;
            }, n3.prototype.clamp = function() {
              var n4 = this.pn;
              this.yn[n4 >>> 2] &= 4294967295 << 32 - n4 % 4 * 8, this.yn.length = Math.ceil(n4 / 4);
            }, n3.prototype.clone = function() {
              return new n3(this.yn.slice(), this.pn);
            }, n3.random = function(t3) {
              for (var r3 = [], i3 = 0; i3 < t3; i3 += 4) r3.push((0, e.M)());
              return new n3(r3, t3);
            }, n3;
          }();
        }, 6957: function(n2, t2, r2) {
          r2.d(t2, { r: function() {
            return o;
          }, m: function() {
            return u;
          } });
          var i2 = r2(5720), e = r2(3354), o = function() {
            function n3(n4, t3) {
              this.high = n4, this.low = t3;
            }
            return n3.prototype.clone = function() {
              return new n3(this.high, this.low);
            }, n3;
          }(), u = function() {
            function n3(n4, t3) {
              this.yn = n4 || [], this.pn = "number" == typeof t3 ? t3 : 8 * this.yn.length;
            }
            return Object.defineProperty(n3.prototype, "nSigBytes", { get: function() {
              return this.pn;
            }, set: function(n4) {
              this.pn = n4;
            }, enumerable: false, configurable: true }), Object.defineProperty(n3.prototype, "words", { get: function() {
              return this.yn;
            }, enumerable: false, configurable: true }), n3.prototype.to32 = function() {
              for (var n4 = [], t3 = 0; t3 < this.yn.length; t3++) {
                var r3 = this.yn[t3];
                n4.push(r3.high), n4.push(r3.low);
              }
              return new e.e(n4, this.pn);
            }, n3.prototype.toString = function(n4) {
              return n4 ? n4.stringify(this.to32()) : i2.p.stringify(this.to32());
            }, n3.prototype.clone = function() {
              for (var t3 = this.yn.slice(), r3 = 0; r3 < t3.length; r3++) t3[r3] = t3[r3].clone();
              return new n3(t3, this.pn);
            }, n3;
          }();
        }, 7211: function(n2, t2, r2) {
          r2.d(t2, { C: function() {
            return o;
          } });
          var i2 = r2(3354), e = r2(4768), o = function() {
            function n3(n4) {
              this.On = 0, this.N = 0, this.O = n4, this.cn = n4 && void 0 !== n4.data ? n4.data.clone() : new i2.e(), this.sn = n4 && "number" == typeof n4.nBytes ? n4.nBytes : 0;
            }
            return Object.defineProperty(n3.prototype, "blockSize", { get: function() {
              return this.N;
            }, enumerable: false, configurable: true }), n3.prototype.reset = function(n4, t3) {
              this.cn = void 0 !== n4 ? n4.clone() : new i2.e(), this.sn = "number" == typeof t3 ? t3 : 0;
            }, n3.prototype.jn = function(n4) {
              var t3 = "string" == typeof n4 ? e.d.parse(n4) : n4;
              this.cn.concat(t3), this.sn += t3.nSigBytes;
            }, n3.prototype.an = function(n4) {
              var t3, r3 = this.cn.words, e2 = this.cn.nSigBytes, o2 = this.N, u = e2 / (4 * this.N), f = (u = n4 ? Math.ceil(u) : Math.max((0 | u) - this.On, 0)) * o2, c = Math.min(4 * f, e2);
              if (f) {
                for (var s = 0; s < f; s += o2) this.un(r3, s);
                t3 = r3.splice(0, f), this.cn.nSigBytes -= c;
              }
              return new i2.e(t3, c);
            }, n3.prototype.un = function(n4, t3) {
              throw new Error("Not implemented");
            }, n3;
          }();
        }, 1868: function(n2, t2, r2) {
          r2.d(t2, { P: function() {
            return u;
          } });
          var i2, e = r2(7211), o = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), u = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.N = 16, r3.O = t4, t4 && "number" == typeof t4.blockSize && (r3.N = t4.blockSize), r3.reset(t4 ? t4.data : void 0, t4 ? t4.nBytes : void 0), r3;
            }
            return o(t3, n3), Object.defineProperty(t3.prototype, "blockSize", { get: function() {
              return this.N;
            }, enumerable: false, configurable: true }), t3.prototype.reset = function(t4, r3) {
              n3.prototype.reset.call(this, t4, r3), this.A();
            }, t3.prototype.update = function(n4) {
              return this.jn(n4), this.an(), this;
            }, t3.prototype.finalize = function(n4) {
              return n4 && this.jn(n4), this.fn();
            }, t3.prototype.A = function() {
              throw new Error("Not implemented");
            }, t3.prototype.fn = function() {
              throw new Error("Not implemented");
            }, t3;
          }(e.C);
        }, 787: function(n2, t2, r2) {
          r2.d(t2, { G: function() {
            return s;
          } });
          var i2, e = r2(9456), o = r2(4344), u = r2(7919), f = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), c = function() {
            return (c = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, s = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.N = 4, r3._n = o.n, r3.mn = u.l, r3.O = t4, r3._n = void 0 !== t4.mode ? t4.mode : r3._n, r3.mn = void 0 !== t4.padding ? t4.padding : r3.mn, r3.reset(null == t4 ? void 0 : t4.data, null == t4 ? void 0 : t4.nBytes), r3;
            }
            return f(t3, n3), Object.defineProperty(t3.prototype, "mode", { get: function() {
              return this.An;
            }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "padding", { get: function() {
              return this.mn;
            }, enumerable: false, configurable: true }), t3.prototype.reset = function(t4, r3) {
              var i3;
              n3.prototype.reset.call(this, t4, r3), this.gn === e.t.ENC_TRANSFORM_MODE ? i3 = this._n.createEncryptor : (i3 = this._n.createDecryptor, this.On = 1), this._n && this.En === i3 ? this.An = new this._n({ cipher: this, iv: this.ln }) : (this.An = i3.call(this._n, { cipher: this, iv: this.ln }), this.En = i3);
            }, t3.prototype.un = function(n4, t4) {
              var r3;
              null === (r3 = this.An) || void 0 === r3 || r3.processBlock(n4, t4);
            }, t3.prototype.fn = function() {
              var n4, t4 = this.mn;
              return this.gn === e.t.ENC_TRANSFORM_MODE ? (t4.pad(this.cn, this.blockSize), n4 = this.an(true)) : (n4 = this.an(true), t4.unpad(n4)), n4;
            }, t3.prototype.encryptBlock = function(n4, t4) {
              throw new Error("Not implemented");
            }, t3.prototype.decryptBlock = function(n4, t4) {
              throw new Error("Not implemented");
            }, t3.createEncryptor = function(n4, r3) {
              return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: e.t.ENC_TRANSFORM_MODE }));
            }, t3.createDecryptor = function(n4, r3) {
              return new t3(c(c({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: e.t.DEC_TRANSFORM_MODE }));
            }, t3;
          }(e.t);
        }, 9456: function(n2, t2, r2) {
          r2.d(t2, { t: function() {
            return f;
          } });
          var i2, e = r2(7211), o = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), u = function() {
            return (u = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, f = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.gn = 1, r3.O = t4, r3.H = t4.key, r3.ln = void 0 !== t4.iv ? t4.iv : r3.ln, r3.gn = void 0 !== t4.transformMode ? t4.transformMode : r3.gn, r3;
            }
            return o(t3, n3), Object.defineProperty(t3.prototype, "iv", { get: function() {
              return this.ln;
            }, enumerable: false, configurable: true }), t3.prototype.reset = function(t4, r3) {
              n3.prototype.reset.call(this, t4, r3), this.A();
            }, t3.prototype.process = function(n4) {
              return this.jn(n4), this.an();
            }, t3.prototype.finalize = function(n4) {
              return n4 && this.jn(n4), this.fn();
            }, t3.prototype.A = function() {
              throw new Error("Not implemented");
            }, t3.prototype.un = function(n4, t4) {
              throw new Error("Not implemented");
            }, t3.prototype.fn = function() {
              throw new Error("Not implemented");
            }, t3.createEncryptor = function(n4, r3) {
              return new t3(u(u({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: t3.ENC_TRANSFORM_MODE }));
            }, t3.createDecryptor = function(n4, r3) {
              return new t3(u(u({}, r3 = void 0 === r3 ? {} : r3), { key: n4, transformMode: t3.DEC_TRANSFORM_MODE }));
            }, t3.ENC_TRANSFORM_MODE = 1, t3.DEC_TRANSFORM_MODE = 2, t3.keySize = 4, t3.ivSize = 4, t3;
          }(e.C);
        }, 2505: function(n2, t2, r2) {
          r2.d(t2, { Q: function() {
            return e;
          } });
          var i2 = r2(1232), e = function() {
            function n3(n4) {
              this.formatter = i2.w, n4 && (this.cipherText = n4.cipherText, this.key = n4.key, this.iv = n4.iv, this.salt = n4.salt, this.Algorithm = n4.Algorithm, this.mode = n4.mode, this.padding = n4.padding, this.blockSize = n4.blockSize, this.formatter = n4.formatter || i2.w);
            }
            return n3.prototype.toString = function(n4) {
              return (n4 || this.formatter).stringify(this);
            }, n3;
          }();
        }, 5693: function(n2, t2, r2) {
          r2.d(t2, { E: function() {
            return c;
          } });
          var i2 = r2(9109), e = r2(2214), o = r2(2505), u = r2(1232), f = function() {
            return (f = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, c = { encrypt: function(n3, t3, r3, u2) {
            var c2 = u2 ? f({}, u2) : {}, s = u2 && u2.KDF ? u2.KDF : e.s, a = {};
            u2 && u2.kdfHasher && (a.kdfHasher = u2.kdfHasher), u2 && u2.kdfIterations && (a.kdfIterations = u2.kdfIterations), u2 && u2.kdfModule && (a.kdfModule = u2.kdfModule);
            var h = s.execute(r3, n3.keySize, n3.ivSize, c2.kdfSalt, a);
            c2.iv = h.iv;
            var v = i2.D.encrypt(n3, t3, h.key, c2);
            return new o.Q(f(f({}, v), { key: h.key, iv: h.iv, salt: h.salt }));
          }, decrypt: function(n3, t3, r3, o2) {
            var c2 = o2 ? f({}, o2) : {}, s = c2.KDF ? c2.KDF : e.s, a = c2.formatter ? c2.formatter : u.w, h = (0, i2.W)(t3, a), v = {};
            o2 && o2.kdfHasher && (v.kdfHasher = o2.kdfHasher), o2 && o2.kdfIterations && (v.kdfIterations = o2.kdfIterations), o2 && o2.kdfModule && (v.kdfModule = o2.kdfModule);
            var w = s.execute(r3, n3.keySize, n3.ivSize, h.salt, v);
            return c2.iv = w.iv, i2.D.decrypt(n3, h, w.key, c2);
          } };
        }, 9109: function(n2, t2, r2) {
          r2.d(t2, { W: function() {
            return o;
          }, D: function() {
            return u;
          } });
          var i2 = r2(1232), e = r2(2505);
          function o(n3, t3) {
            return "string" == typeof n3 ? t3.parse(n3) : n3;
          }
          var u = { encrypt: function(n3, t3, r3, o2) {
            var u2 = n3.createEncryptor(r3, o2), f = u2.finalize(t3);
            return new e.Q({ cipherText: f, key: r3, iv: u2.iv, Algorithm: n3, mode: u2.mode, padding: u2.padding, blockSize: u2.blockSize, formatter: (null == o2 ? void 0 : o2.formatter) || i2.w });
          }, decrypt: function(n3, t3, r3, e2) {
            var u2 = n3.createDecryptor(r3, e2), f = o(t3, (null == e2 ? void 0 : e2.formatter) || i2.w);
            return u2.finalize(f.cipherText || "");
          } };
        }, 30: function(n2, t2, r2) {
          r2.d(t2, { q: function() {
            return u;
          } });
          var i2, e = r2(9456), o = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), u = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.N = 1, r3;
            }
            return o(t3, n3), t3.prototype.fn = function() {
              return this.an(true);
            }, t3;
          }(e.t);
        }, 1232: function(n2, t2, r2) {
          r2.d(t2, { w: function() {
            return u;
          } });
          var i2 = r2(2505), e = r2(3354), o = r2(1773), u = { stringify: function(n3) {
            var t3 = n3.cipherText, r3 = n3.salt;
            return t3 ? r3 ? new e.e([1398893684, 1701076831]).concat(r3).concat(t3).toString(o.D) : t3.toString(o.D) : "";
          }, parse: function(n3) {
            var t3, r3 = o.D.parse(n3), u2 = r3.words;
            return 1398893684 === u2[0] && 1701076831 === u2[1] && (t3 = new e.e(u2.slice(2, 4)), u2.splice(0, 4), r3.nSigBytes -= 16), new i2.Q({ cipherText: r3, salt: t3 });
          } };
        }, 2214: function(n2, t2, r2) {
          r2.d(t2, { s: function() {
            return f;
          } });
          var i2 = r2(3354), e = r2(2505), o = r2(7008), u = function() {
            return (u = Object.assign || function(n3) {
              for (var t3, r3 = 1, i3 = arguments.length; r3 < i3; r3++) for (var e2 in t3 = arguments[r3]) Object.prototype.hasOwnProperty.call(t3, e2) && (n3[e2] = t3[e2]);
              return n3;
            }).apply(this, arguments);
          }, f = { execute: function(n3, t3, r3, f2, c) {
            f2 || (f2 = i2.e.random(8));
            var s = c && c.kdfModule || o.E, a = c ? { Hasher: c.kdfHasher, iterations: c.kdfIterations } : {}, h = s.getKey(n3, f2, u(u({}, a), { keySize: t3 + r3 })), v = new i2.e(h.words.slice(t3), 4 * r3);
            return h.nSigBytes = 4 * t3, new e.Q({ key: h, iv: v, salt: f2 });
          } };
        }, 7008: function(n2, t2, r2) {
          r2.d(t2, { E: function() {
            return s;
          } });
          var i2, e = r2(5561), o = r2(6367), u = r2(3354), f = r2(9541), c = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), s = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.Sn = 4, r3.Mn = e.SHA256, r3.kn = 1e4, t4 && (r3.Sn = void 0 !== t4.keySize ? t4.keySize : r3.Sn, r3.Mn = void 0 !== t4.Hasher ? t4.Hasher : r3.Mn, r3.kn = void 0 !== t4.iterations ? t4.iterations : r3.kn), r3;
            }
            return c(t3, n3), t3.prototype.compute = function(n4, t4) {
              for (var r3 = new o.Hmac(new this.Mn(), n4), i3 = new u.e(), e2 = new u.e([1]), f2 = i3.words, c2 = e2.words, s2 = this.Sn, a = this.kn; f2.length < s2; ) {
                var h = r3.update(t4).finalize(e2);
                r3.reset();
                for (var v = h.words, w = v.length, l = h, b = 1; b < a; b++) {
                  l = r3.finalize(l), r3.reset();
                  for (var d = l.words, y = 0; y < w; y++) v[y] ^= d[y];
                }
                i3.concat(h), c2[0]++;
              }
              return i3.nSigBytes = 4 * s2, i3;
            }, t3.getKey = function(n4, r3, i3) {
              return new t3(i3).compute(n4, r3);
            }, t3;
          }(f._);
        }, 9541: function(n2, t2, r2) {
          r2.d(t2, { _: function() {
            return i2;
          } });
          var i2 = function() {
            function n3(n4) {
              this.O = n4;
            }
            return n3.prototype.compute = function(n4, t3) {
              throw new Error("Not implemented");
            }, n3.getKey = function(n4, t3, r3) {
              throw new Error("Not implemented");
            }, n3;
          }();
        }, 1863: function(n2, t2, r2) {
          r2.d(t2, { T: function() {
            return i2;
          } });
          var i2 = function() {
            function n3(n4) {
              this.O = n4, this.Hn = n4.cipher, this.ln = n4.iv;
            }
            return n3.prototype.processBlock = function(n4, t3) {
            }, n3.createEncryptor = function(n4) {
              throw new Error("Not implemented yet");
            }, n3.createDecryptor = function(n4) {
              throw new Error("Not implemented yet");
            }, n3;
          }();
        }, 4344: function(n2, t2, r2) {
          r2.d(t2, { n: function() {
            return u;
          } });
          var i2, e = r2(1863), o = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), u = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.Cn = [], r3;
            }
            return o(t3, n3), t3.prototype.xorBlock = function(n4, t4, r3) {
              var i3, e2 = this.ln;
              e2 ? (i3 = e2.words, this.ln = void 0) : i3 = this.Cn;
              for (var o2 = 0; o2 < r3; o2++) n4[t4 + o2] ^= i3[o2];
            }, t3.createEncryptor = function(n4) {
              return new t3.Encryptor(n4);
            }, t3.createDecryptor = function(n4) {
              return new t3.Decryptor(n4);
            }, t3.Encryptor = function(n4) {
              function t4() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return o(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                var r3 = this.Hn, i3 = r3.blockSize;
                this.xorBlock(n5, t5, i3), r3.encryptBlock(n5, t5), this.Cn = n5.slice(t5, t5 + i3);
              }, t4;
            }(t3), t3.Decryptor = function(n4) {
              function t4() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return o(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                var r3 = this.Hn, i3 = r3.blockSize, e2 = n5.slice(t5, t5 + i3);
                r3.decryptBlock(n5, t5), this.xorBlock(n5, t5, i3), this.Cn = e2;
              }, t4;
            }(t3), t3;
          }(e.T);
        }, 4055: function(n2, t2, r2) {
          r2.d(t2, { I4: function() {
            return e;
          }, z6: function() {
            return o;
          }, ur: function() {
            return u;
          } });
          var i2 = r2(3354);
          function e(n3) {
            var t3 = n3.nSigBytes % 16;
            if (0 !== t3) {
              for (var r3 = 16 - t3, e2 = [], o2 = Math.floor(r3 / 4), u2 = 0; u2 < o2; u2++) e2.push(0);
              r3 % 4 > 0 && e2.push(0), n3.concat(new i2.e(e2, r3));
            }
          }
          function o(n3, t3) {
            return new i2.e(n3.words.slice(), t3);
          }
          function u(n3, t3) {
            for (var r3 = n3.nSigBytes - t3, e2 = [], o2 = 0; o2 < t3; o2++) {
              var u2 = o2 >>> 2, f = r3 + o2, c = f >>> 2, s = n3.words[c] >>> 24 - f % 4 * 8 & 255;
              e2[u2] = 0 | e2[u2] | s << 24 - o2 % 4 * 8;
            }
            var a = new i2.e(e2, t3);
            return a.clamp(), a;
          }
        }, 7919: function(n2, t2, r2) {
          r2.d(t2, { l: function() {
            return e;
          } });
          var i2 = r2(3354);
          var e = { pad: function(n3, t3) {
            for (var r3 = 4 * t3, e2 = r3 - n3.nSigBytes % r3, o = e2 << 24 | e2 << 16 | e2 << 8 | e2, u = [], f = 0; f < e2; f += 4) u.push(o);
            var c = new i2.e(u, e2);
            n3.concat(c);
          }, unpad: function(n3) {
            var t3 = 255 & n3.words[n3.nSigBytes - 1 >>> 2];
            n3.nSigBytes -= t3;
          } };
        }, 1756: function(n2, t2, r2) {
          r2.d(t2, { w: function() {
            return u;
          } });
          var i2, e = "undefined" != typeof navigator && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", o = (i2 = parseInt((/msie (\d+)/.exec(e) || [])[1], 10), isNaN(i2) ? (i2 = parseInt((/trident\/.*; rv:(\d+)/.exec(e) || [])[1], 10), !isNaN(i2) && i2) : i2);
          function u(n3, t3) {
            return false !== o && (!t3 || ("<" === n3 ? o < t3 : "<=" === n3 ? o <= t3 : ">" === n3 ? o > t3 : ">=" === n3 ? o >= t3 : o === t3));
          }
        }, 1773: function(n2, t2, r2) {
          r2.d(t2, { D: function() {
            return f;
          } });
          for (var i2 = r2(3354), e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", o = [], u = 0; u < e.length; u++) o[e.charCodeAt(u)] = u;
          var f = { stringify: function(n3) {
            var t3 = n3.words, r3 = n3.nSigBytes;
            n3.clamp();
            for (var i3 = [], o2 = 0; o2 < r3; o2 += 3) for (var u2 = (t3[o2 >>> 2] >>> 24 - o2 % 4 * 8 & 255) << 16 | (t3[o2 + 1 >>> 2] >>> 24 - (o2 + 1) % 4 * 8 & 255) << 8 | t3[o2 + 2 >>> 2] >>> 24 - (o2 + 2) % 4 * 8 & 255, f2 = 0; f2 < 4 && o2 + 0.75 * f2 < r3; f2++) i3.push(e.charAt(u2 >>> 6 * (3 - f2) & 63));
            var c = e.charAt(64);
            if (c) for (; i3.length % 4; ) i3.push(c);
            return i3.join("");
          }, parse: function(n3) {
            var t3 = n3.length, r3 = e.charAt(64);
            if (r3) {
              var u2 = n3.indexOf(r3);
              -1 !== u2 && (t3 = u2);
            }
            for (var f2 = [], c = 0, s = 0; s < t3; s++) if (s % 4) {
              var a = o[n3.charCodeAt(s - 1)] << s % 4 * 2 | o[n3.charCodeAt(s)] >>> 6 - s % 4 * 2;
              f2[c >>> 2] |= a << 24 - c % 4 * 8, c++;
            }
            return new i2.e(f2, c);
          } };
        }, 5720: function(n2, t2, r2) {
          r2.d(t2, { p: function() {
            return e;
          } });
          var i2 = r2(3354), e = { stringify: function(n3) {
            for (var t3 = n3.nSigBytes, r3 = n3.words, i3 = [], e2 = 0; e2 < t3; e2++) {
              var o = r3[e2 >>> 2] >>> 24 - e2 % 4 * 8 & 255;
              i3.push((o >>> 4).toString(16)), i3.push((15 & o).toString(16));
            }
            return i3.join("");
          }, parse: function(n3) {
            var t3 = n3.length;
            if (t3 % 2 != 0) throw new Error("Hex string count must be even");
            if (!/^[a-fA-F0-9]+$/.test(n3)) throw new Error("Invalid Hex string: " + n3);
            for (var r3 = [], e2 = 0; e2 < t3; e2 += 2) r3[e2 >>> 3] |= parseInt(n3.substr(e2, 2), 16) << 24 - e2 % 8 * 4;
            return new i2.e(r3, t3 / 2);
          } };
        }, 8702: function(n2, t2, r2) {
          r2.d(t2, { m: function() {
            return e;
          } });
          var i2 = r2(3354), e = { stringify: function(n3) {
            for (var t3 = n3.nSigBytes, r3 = n3.words, i3 = [], e2 = 0; e2 < t3; e2++) {
              var o = r3[e2 >>> 2] >>> 24 - e2 % 4 * 8 & 255;
              i3.push(String.fromCharCode(o));
            }
            return i3.join("");
          }, parse: function(n3) {
            for (var t3 = n3.length, r3 = [], e2 = 0; e2 < t3; e2++) r3[e2 >>> 2] |= (255 & n3.charCodeAt(e2)) << 24 - e2 % 4 * 8;
            return new i2.e(r3, t3);
          } };
        }, 4768: function(n2, t2, r2) {
          r2.d(t2, { d: function() {
            return e;
          } });
          var i2 = r2(8702), e = { stringify: function(n3) {
            try {
              return decodeURIComponent(escape(i2.m.stringify(n3)));
            } catch (n4) {
              throw new Error("Malformed UTF-8 data");
            }
          }, parse: function(n3) {
            return i2.m.parse(unescape(encodeURIComponent(n3)));
          } };
        }, 2688: function(n2, t2, r2) {
          r2.d(t2, { Base64: function() {
            return o.D;
          }, EvpKDF: function() {
            return O;
          }, Hex: function() {
            return c.p;
          }, Latin1: function() {
            return f.m;
          }, OpenSSLKDF: function() {
            return l.s;
          }, PBKDF2: function() {
            return b.E;
          }, Utf16: function() {
            return w;
          }, Utf16BE: function() {
            return s;
          }, Utf16LE: function() {
            return v;
          }, Utf8: function() {
            return u.d;
          }, Word32Array: function() {
            return i2.e;
          }, Word64: function() {
            return e.r;
          }, Word64Array: function() {
            return e.m;
          } });
          r2(9054);
          var i2 = r2(3354), e = r2(6957), o = (r2(1756), r2(1773)), u = r2(4768), f = r2(8702), c = r2(5720), s = { stringify: function(n3) {
            for (var t3 = n3.words, r3 = n3.nSigBytes, i3 = [], e2 = 0; e2 < r3; e2 += 2) {
              var o2 = t3[e2 >>> 2] >>> 16 - e2 % 4 * 8 & 65535;
              i3.push(String.fromCharCode(o2));
            }
            return i3.join("");
          }, parse: function(n3) {
            for (var t3 = n3.length, r3 = [], e2 = 0; e2 < t3; e2++) r3[e2 >>> 1] |= n3.charCodeAt(e2) << 16 - e2 % 2 * 16;
            return new i2.e(r3, 2 * t3);
          } };
          function a(n3) {
            return n3 << 8 & 4278255360 | n3 >>> 8 & 16711935;
          }
          var h, v = { stringify: function(n3) {
            for (var t3 = n3.words, r3 = n3.nSigBytes, i3 = [], e2 = 0; e2 < r3; e2 += 2) {
              var o2 = a(t3[e2 >>> 2] >>> 16 - e2 % 4 * 8 & 65535);
              i3.push(String.fromCharCode(o2));
            }
            return i3.join("");
          }, parse: function(n3) {
            for (var t3 = n3.length, r3 = [], e2 = 0; e2 < t3; e2++) r3[e2 >>> 1] |= a(n3.charCodeAt(e2) << 16 - e2 % 2 * 16);
            return new i2.e(r3, 2 * t3);
          } }, w = s, l = r2(2214), b = r2(7008), d = r2(670), y = r2(9541), p = (h = function(n3, t3) {
            return (h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            h(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), O = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              return r3.Sn = 4, r3.Mn = d.MD5, r3.kn = 1, t4 && (r3.Sn = void 0 !== t4.keySize ? t4.keySize : r3.Sn, r3.Mn = void 0 !== t4.Hasher ? t4.Hasher : r3.Mn, r3.kn = void 0 !== t4.iterations ? t4.iterations : r3.kn), r3;
            }
            return p(t3, n3), t3.prototype.compute = function(n4, t4) {
              for (var r3, e2 = new this.Mn(), o2 = new i2.e(), u2 = o2.words, f2 = this.Sn, c2 = this.kn; u2.length < f2; ) {
                r3 && e2.update(r3), r3 = e2.update(n4).finalize(t4), e2.reset();
                for (var s2 = 1; s2 < c2; s2++) r3 = e2.finalize(r3), e2.reset();
                o2.concat(r3);
              }
              return o2.nSigBytes = 4 * f2, o2;
            }, t3.getKey = function(n4, r3, i3) {
              return new t3(i3).compute(n4, r3);
            }, t3;
          }(y._);
        }, 9054: function(n2, t2, r2) {
          r2.d(t2, { M: function() {
            return e;
          } });
          var i2 = r2(1756);
          var e = function() {
            if ("undefined" != typeof window) {
              var n3 = window.crypto || window.msCrypto;
              if (!n3) {
                if ((0, i2.w)("<", 11)) return console.warn("IE <= 10 uses insecure random generator. Please consider to use IE11 or another modern browser"), function() {
                  return Math.floor(512 * Math.random()) % 256;
                };
                throw new Error("Crypto module not found");
              }
              return function() {
                return n3.getRandomValues(new Uint32Array(1))[0];
              };
            }
            return void 0 !== r2.g && r2.g.crypto ? function() {
              return r2.g.crypto.randomBytes(4).readInt32LE();
            } : function() {
              return require("crypto").randomBytes(4).readInt32LE();
            };
          }();
        }, 3664: function(n2, t2, r2) {
          r2.d(t2, { K: function() {
            return c;
          } });
          var i2, e = r2(1863), o = r2(3354), u = r2(4055), f = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), c = function(n3) {
            function t3(t4) {
              var r3 = n3.call(this, t4) || this;
              r3.Bn = 1;
              var i3 = t4.cipher, e2 = t4.iv;
              if (4 !== i3.blockSize) throw new Error("In CCM, cipher block size must be 128bit");
              if (e2 && (e2.nSigBytes > 13 || e2.nSigBytes < 7)) throw new Error("Byte size of iv must be between 7 and 13");
              return r3.Nn = e2 || new o.e([0, 0], 8), r3.In = 15 - r3.Nn.nSigBytes, r3;
            }
            return f(t3, n3), t3.getB0 = function(n4, t4, r3, i3) {
              if (r3.nSigBytes + i3.nSigBytes !== 15) throw new Error("LEN(Q)+LEN(N) must be 15");
              var e2 = 255 & (0 | (n4 ? 1 : 0) << 6 | (t4 - 2) / 2 << 3 | r3.nSigBytes - 1), u2 = i3.clone().concat(r3);
              return new o.e([e2 << 24], 1).concat(u2);
            }, t3.formatAssociatedDataAndPayload = function(n4, t4) {
              var r3, i3 = n4.nSigBytes;
              if (0 === i3) r3 = new o.e([0], 0);
              else if (i3 < Math.pow(2, 16) - Math.pow(2, 8)) r3 = new o.e([i3 << 16], 2);
              else {
                if (!(i3 < Math.pow(2, 32))) throw new Error("LEN(A) larger than 2**32-1 is not supported");
                r3 = new o.e([4294836224], 2).concat(new o.e([i3], 4));
              }
              for (var e2 = Math.floor(n4.nSigBytes / 4), u2 = 0; u2 < e2; u2++) r3.concat(new o.e([n4.words[u2]], 4));
              n4.nSigBytes % 4 && (r3.concat(new o.e([n4.words[e2]], n4.nSigBytes % 4)), r3.concat(new o.e([0], 4 - n4.nSigBytes % 4))), r3.nSigBytes % 16 && r3.concat(new o.e([0], 16 - r3.nSigBytes % 16));
              var f2 = Math.floor(t4.nSigBytes / 4);
              for (u2 = 0; u2 < f2; u2++) r3.concat(new o.e([t4.words[u2]], 4));
              return t4.nSigBytes % 4 && (r3.concat(new o.e([t4.words[f2]], t4.nSigBytes % 4)), r3.concat(new o.e([0], 4 - t4.nSigBytes % 4))), r3.nSigBytes % 16 && r3.concat(new o.e([0], 16 - r3.nSigBytes % 16)), r3;
            }, t3.genCtr = function(n4, t4, r3) {
              if (t4.nSigBytes + n4 !== 15) throw new Error("LEN(Q)+LEN(N) must be 15");
              for (var i3 = new o.e([(n4 - 1 & 7) << 24], 1), e2 = new o.e([], 0), u2 = Math.floor(n4 / 4), f2 = 0; f2 < u2 - 1; f2++) e2.concat(new o.e([0], 4));
              return n4 % 4 ? n4 > 4 ? (e2.concat(new o.e([0], n4 % 4)), e2.concat(new o.e([r3], 4))) : e2.concat(new o.e([r3 << 32 - 8 * n4], n4)) : e2.concat(new o.e([r3], 4)), i3.concat(t4).concat(e2);
            }, t3.mac = function(n4, r3, i3, e2, f2, c2) {
              var s = new n4({ key: r3, iv: i3 });
              if (4 !== s.blockSize) throw new Error("In CCM, cipher block size must be 128bit");
              if (i3 && (i3.nSigBytes > 13 || i3.nSigBytes < 7)) throw new Error("Byte size of iv must be between 7 and 13");
              var a = i3 || new o.e([0, 0], 8), h = (null == e2 ? void 0 : e2.clone()) || new o.e(), v = h.nSigBytes, w = (null == f2 ? void 0 : f2.clone()) || new o.e(), l = w.nSigBytes;
              if (l >>> 0 > 4294967295) throw new Error("Byte length of Payload(plainText) larger than 2^32-1 (4,294,967,295byte) is not supported at this time.");
              var b = 15 - a.nSigBytes, d = (0, u.ur)(new o.e([0, l], 8), b), y = c2 || 16, p = t3.getB0(Boolean(v), y, d, a), O = t3.formatAssociatedDataAndPayload(h, w), j = p.words.slice();
              s.encryptBlock(j, 0);
              for (var _ = O.nSigBytes / 16, m = O.words, A = j, g = 0; g < _; g++) {
                var E = [m[4 * g] ^ A[0], m[4 * g + 1] ^ A[1], m[4 * g + 2] ^ A[2], m[4 * g + 3] ^ A[3]];
                s.encryptBlock(E, 0), A = E;
              }
              var S = new o.e(A, y), M = t3.genCtr(b, a, 0);
              s.encryptBlock(M.words, 0);
              for (g = 0; g < 4; g++) S.words[g] ^= M.words[g];
              return S.clamp(), S;
            }, t3.combineCipherTextAndAuthTag = function(n4, t4) {
              return n4.clone().concat(t4);
            }, t3.splitCipherTextAndAuthTag = function(n4, t4) {
              var r3 = t4 || 16;
              return { cipherText: (0, u.z6)(n4, n4.nSigBytes - r3), authTag: (0, u.ur)(n4, r3) };
            }, t3.createEncryptor = function(n4) {
              return new t3.Encryptor(n4);
            }, t3.createDecryptor = function(n4) {
              return new t3.Decryptor(n4);
            }, t3.Encryptor = function(n4) {
              function r3() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return f(r3, n4), r3.prototype.processBlock = function(n5, r4) {
                var i3 = this.Hn, e2 = i3.blockSize, o2 = t3.genCtr(this.In, this.Nn, this.Bn);
                i3.encryptBlock(o2.words, 0);
                for (var u2 = 0; u2 < e2; u2++) n5[r4 + u2] ^= o2.words[u2];
                this.Bn++;
              }, r3;
            }(t3), t3.Decryptor = function(n4) {
              function r3() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return f(r3, n4), r3.prototype.processBlock = function(n5, r4) {
                var i3 = this.Hn, e2 = i3.blockSize, o2 = t3.genCtr(this.In, this.Nn, this.Bn);
                i3.encryptBlock(o2.words, 0);
                for (var u2 = 0; u2 < e2; u2++) n5[r4 + u2] ^= o2.words[u2];
                this.Bn++;
              }, r3;
            }(t3), t3;
          }(e.T);
        }, 5607: function(n2, t2, r2) {
          r2.d(t2, { V: function() {
            return c;
          } });
          var i2, e = r2(1863), o = r2(3354), u = r2(4055), f = (i2 = function(n3, t3) {
            return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
              n4.__proto__ = t4;
            } || function(n4, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
            })(n3, t3);
          }, function(n3, t3) {
            function r3() {
              this.constructor = n3;
            }
            i2(n3, t3), n3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
          }), c = function(n3) {
            function t3(r3) {
              var i3 = n3.call(this, r3) || this;
              if (i3.zn = [], i3.Dn = [], i3.Un = [], 4 !== r3.cipher.blockSize) throw new Error("In GCM block cipher mode, cipher block size must be 128bit");
              var e2 = r3.cipher, o2 = r3.iv, u2 = [0, 0, 0, 0];
              return e2.encryptBlock(u2, 0), i3.zn = u2, i3.Dn = t3.getJ0(u2, null == o2 ? void 0 : o2.words), i3.Un = i3.Dn.slice(), i3;
            }
            return f(t3, n3), t3.getJ0 = function(n4, r3) {
              var i3;
              if (r3 && 0 !== r3.length) if (3 === r3.length) i3 = [r3[0], r3[1], r3[2], 1];
              else {
                for (var e2 = r3.length % 4 > 0 ? 4 - r3.length % 4 : 0, o2 = r3.slice(), u2 = 0; u2 < e2 + 2; u2++) o2.push(0);
                o2.push(0), o2.push(32 * r3.length), i3 = t3.GHASH(n4, o2);
              }
              else i3 = [0, 0, 0, 1];
              return i3;
            }, t3.inc32 = function(n4) {
              var t4 = n4.slice(), r3 = t4[3] >>> 0, i3 = r3 + 1 >>> 0 < r3;
              if (t4[3] = t4[3] + 1 | 0, i3) {
                var e2 = t4[2] >>> 0, o2 = e2 + 1 >>> 0 < e2;
                t4[2] = t4[2] + 1 | 0, o2 && (t4[1] = t4[1] + 1 | 0);
              }
              return t4;
            }, t3.mul = function(n4, t4) {
              for (var r3 = [3774873600, 0, 0, 0], i3 = [0, 0, 0, 0], e2 = t4.slice(), o2 = 0; o2 < 128; o2++) {
                (n4[o2 >>> 5] >>> 31 - o2 % 32 & 1) > 0 && (i3[0] = i3[0] ^ e2[0], i3[1] = i3[1] ^ e2[1], i3[2] = i3[2] ^ e2[2], i3[3] = i3[3] ^ e2[3]);
                var u2 = (1 & e2[3]) >>> 0, f2 = (1 & e2[0]) >>> 0, c2 = (1 & e2[1]) >>> 0, s = (1 & e2[2]) >>> 0;
                e2[0] = e2[0] >>> 1, e2[1] = e2[1] >>> 1 | (f2 ? 2147483648 : 0), e2[2] = e2[2] >>> 1 | (c2 ? 2147483648 : 0), e2[3] = e2[3] >>> 1 | (s ? 2147483648 : 0), u2 > 0 && (e2[0] ^= r3[0], e2[1] ^= r3[1], e2[2] ^= r3[2], e2[3] ^= r3[3]);
              }
              return i3;
            }, t3.GHASH = function(n4, r3) {
              if (n4.length % 4 != 0) throw new Error("Length of 32bit word array 'H' must be multiple of 4(128bit)");
              if (r3.length % 4 != 0) throw new Error("Length of 32bit word array 'X' must be multiple of 4(128bit)");
              for (var i3 = r3.length, e2 = [0, 0, 0, 0], o2 = 0; o2 < i3; o2 += 4) e2[0] = e2[0] ^ r3[o2], e2[1] = e2[1] ^ r3[o2 + 1], e2[2] = e2[2] ^ r3[o2 + 2], e2[3] = e2[3] ^ r3[o2 + 3], e2 = t3.mul(e2, n4);
              return e2;
            }, t3.GCTR = function(n4, r3, i3) {
              if (0 === i3.nSigBytes) return i3.clone();
              if (4 !== r3.length) throw new Error("Initial Counter Block size must be 128bit");
              for (var e2 = i3.words, u2 = Math.ceil(i3.nSigBytes / 16), f2 = [r3.slice()], c2 = 1; c2 < u2; c2++) {
                var s = t3.inc32(f2[c2 - 1]);
                f2.push(s);
              }
              var a = new o.e();
              for (c2 = 0; c2 < u2; c2++) {
                n4.encryptBlock(f2[c2], 0);
                var h = i3.nSigBytes % 16;
                if (c2 < u2 - 1 || 0 === h) {
                  var v = e2[4 * c2] ^ f2[c2][0], w = e2[4 * c2 + 1] ^ f2[c2][1], l = e2[4 * c2 + 2] ^ f2[c2][2], b = e2[4 * c2 + 3] ^ f2[c2][3], d = new o.e([v, w, l, b]);
                  a.concat(d);
                } else {
                  for (var y = [], p = 0, O = Math.floor(h / 4), j = 0; j < O; j++) {
                    var _ = e2[4 * c2 + j] ^ f2[c2][j];
                    y.push(_), p += 4;
                  }
                  var m = h % 4;
                  if (m > 0) {
                    var A = e2[4 * c2 + O] << 32 - 8 * m ^ f2[c2][O];
                    y.push(A), p += m;
                  }
                  var g = new o.e(y, p);
                  a.concat(g);
                }
              }
              return a.nSigBytes = i3.nSigBytes, a.clamp(), a;
            }, t3.mac = function(n4, r3, i3, e2, f2, c2) {
              var s = new n4({ key: r3, iv: i3 }), a = [0, 0, 0, 0];
              s.encryptBlock(a, 0);
              var h = t3.getJ0(a, i3.words), v = (null == e2 ? void 0 : e2.clone()) || new o.e(), w = [0, 8 * v.nSigBytes], l = (null == f2 ? void 0 : f2.clone()) || new o.e(), b = [0, 8 * l.nSigBytes], d = c2 || 16;
              (0, u.I4)(v), (0, u.I4)(l);
              var y = v.words.concat(l.words).concat(w).concat(b), p = t3.GHASH(a, y), O = t3.GCTR(s, h, new o.e(p));
              return (0, u.z6)(O, d);
            }, t3.createEncryptor = function(n4) {
              return new t3.Encryptor(n4);
            }, t3.createDecryptor = function(n4) {
              return new t3.Decryptor(n4);
            }, t3.Encryptor = function(n4) {
              function r3() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return f(r3, n4), r3.prototype.processBlock = function(n5, r4) {
                var i3 = this.Hn.blockSize;
                this.Un = t3.inc32(this.Un);
                for (var e2 = new o.e(n5.slice(r4, r4 + i3)), u2 = t3.GCTR(this.Hn, this.Un, e2), f2 = 0; f2 < i3; f2++) n5[r4 + f2] = u2.words[f2];
              }, r3;
            }(t3), t3.Decryptor = function(n4) {
              function r3() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return f(r3, n4), r3.prototype.processBlock = function(n5, r4) {
                var i3 = this.Hn.blockSize;
                this.Un = t3.inc32(this.Un);
                for (var e2 = new o.e(n5.slice(r4, r4 + i3)), u2 = t3.GCTR(this.Hn, this.Un, e2), f2 = 0; f2 < i3; f2++) n5[r4 + f2] = u2.words[f2];
              }, r3;
            }(t3), t3;
          }(e.T);
        } }, t = {};
        function r(i2) {
          var e = t[i2];
          if (void 0 !== e) return e.exports;
          var o = t[i2] = { exports: {} };
          return n[i2](o, o.exports, r), o.exports;
        }
        r.d = function(n2, t2) {
          for (var i2 in t2) r.o(t2, i2) && !r.o(n2, i2) && Object.defineProperty(n2, i2, { enumerable: true, get: t2[i2] });
        }, r.g = function() {
          if ("object" == typeof globalThis) return globalThis;
          try {
            return this || new Function("return this")();
          } catch (n2) {
            if ("object" == typeof window) return window;
          }
        }(), r.o = function(n2, t2) {
          return Object.prototype.hasOwnProperty.call(n2, t2);
        }, r.r = function(n2) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n2, "Ln", { value: true });
        };
        var i = {};
        return function() {
          r.r(i), r.d(i, { AES: function() {
            return A.AES;
          }, Base64: function() {
            return t2.Base64;
          }, CBCMAC: function() {
            return b.CBCMAC;
          }, CipherParams: function() {
            return u.Q;
          }, DES: function() {
            return g.DES;
          }, DES3: function() {
            return E.DES3;
          }, EvpKDF: function() {
            return t2.EvpKDF;
          }, GMAC: function() {
            return l.GMAC;
          }, Hex: function() {
            return t2.Hex;
          }, Hmac: function() {
            return f.Hmac;
          }, HmacMD5: function() {
            return c.HmacMD5;
          }, HmacSHA1: function() {
            return s.HmacSHA1;
          }, HmacSHA224: function() {
            return a.HmacSHA224;
          }, HmacSHA256: function() {
            return h.HmacSHA256;
          }, HmacSHA384: function() {
            return v.HmacSHA384;
          }, HmacSHA512: function() {
            return w.HmacSHA512;
          }, Latin1: function() {
            return t2.Latin1;
          }, MD5: function() {
            return d.MD5;
          }, OpenSSLKDF: function() {
            return t2.OpenSSLKDF;
          }, PBKDF2: function() {
            return t2.PBKDF2;
          }, PasswordBasedCipher: function() {
            return o.E;
          }, RC4: function() {
            return k.RC4;
          }, RC4Drop: function() {
            return H.RC4Drop;
          }, RIPEMD160: function() {
            return S.RIPEMD160;
          }, Rabbit: function() {
            return M.Rabbit;
          }, SHA1: function() {
            return y.SHA1;
          }, SHA224: function() {
            return p.SHA224;
          }, SHA256: function() {
            return O.SHA256;
          }, SHA3: function() {
            return m.SHA3;
          }, SHA384: function() {
            return j.SHA384;
          }, SHA512: function() {
            return _.SHA512;
          }, SerializableCipher: function() {
            return e.D;
          }, Utf16: function() {
            return t2.Utf16;
          }, Utf16BE: function() {
            return t2.Utf16BE;
          }, Utf16LE: function() {
            return t2.Utf16LE;
          }, Utf8: function() {
            return t2.Utf8;
          }, Word32Array: function() {
            return t2.Word32Array;
          }, Word64: function() {
            return t2.Word64;
          }, Word64Array: function() {
            return t2.Word64Array;
          }, formatter: function() {
            return Y;
          }, mode: function() {
            return Z;
          }, pad: function() {
            return J;
          } });
          var n2, t2 = r(2688), e = r(9109), o = r(5693), u = r(2505), f = r(6367), c = r(3027), s = r(149), a = r(4105), h = r(980), v = r(5838), w = r(9902), l = r(7753), b = r(3967), d = r(670), y = r(3173), p = r(766), O = r(5561), j = r(6324), _ = r(7491), m = r(3408), A = r(9691), g = r(9910), E = r(6739), S = r(7104), M = r(5187), k = r(4615), H = r(9639), C = r(4344), B = r(1863), N = (n2 = function(t3, r2) {
            return (n2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n3, t4) {
              n3.__proto__ = t4;
            } || function(n3, t4) {
              for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n3[r3] = t4[r3]);
            })(t3, r2);
          }, function(t3, r2) {
            function i2() {
              this.constructor = t3;
            }
            n2(t3, r2), t3.prototype = null === r2 ? Object.create(r2) : (i2.prototype = r2.prototype, new i2());
          }), I = function(n3) {
            function t3(t4) {
              var r2 = n3.call(this, t4) || this;
              return r2.Cn = [], r2;
            }
            return N(t3, n3), t3.prototype.generateKeyStreamAndEncrypt = function(n4, t4, r2, i2) {
              var e2, o2 = this.ln;
              o2 ? (e2 = o2.words.slice(0), this.ln = void 0) : e2 = this.Cn, i2.encryptBlock(e2, 0);
              for (var u2 = 0; u2 < r2; u2++) n4[t4 + u2] ^= e2[u2];
            }, t3.createEncryptor = function(n4) {
              return new t3.Encryptor(n4);
            }, t3.createDecryptor = function(n4) {
              return new t3.Decryptor(n4);
            }, t3.Encryptor = function(n4) {
              function t4() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return N(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                this.generateKeyStreamAndEncrypt(n5, t5, this.Hn.blockSize, this.Hn), this.Cn = n5.slice(t5, t5 + this.Hn.blockSize);
              }, t4;
            }(t3), t3.Decryptor = function(n4) {
              function t4() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return N(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                var r2 = n5.slice(t5, t5 + this.Hn.blockSize);
                this.generateKeyStreamAndEncrypt(n5, t5, this.Hn.blockSize, this.Hn), this.Cn = r2;
              }, t4;
            }(t3), t3;
          }(B.T), z = /* @__PURE__ */ function() {
            var n3 = function(t3, r2) {
              return (n3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(t3, r2);
            };
            return function(t3, r2) {
              function i2() {
                this.constructor = t3;
              }
              n3(t3, r2), t3.prototype = null === r2 ? Object.create(r2) : (i2.prototype = r2.prototype, new i2());
            };
          }(), D = function(n3) {
            function t3(t4) {
              var r2 = n3.call(this, t4) || this;
              return r2.Fn = [], r2;
            }
            return z(t3, n3), t3.createEncryptor = function(n4) {
              return new t3.Encryptor(n4);
            }, t3.createDecryptor = function(n4) {
              return new t3.Decryptor(n4);
            }, t3.Encryptor = function(n4) {
              function t4() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return z(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                var r2 = this.Hn, i2 = r2.blockSize, e2 = this.ln, o2 = this.Fn;
                e2 && (o2 = this.Fn = e2.words.slice(0), this.ln = void 0);
                var u2 = o2.slice(0);
                r2.encryptBlock(u2, 0), o2[i2 - 1] = o2[i2 - 1] + 1 | 0;
                for (var f2 = 0; f2 < i2; f2++) n5[t5 + f2] ^= u2[f2];
              }, t4;
            }(t3), t3.Decryptor = t3.Encryptor, t3;
          }(B.T), U = /* @__PURE__ */ function() {
            var n3 = function(t3, r2) {
              return (n3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(t3, r2);
            };
            return function(t3, r2) {
              function i2() {
                this.constructor = t3;
              }
              n3(t3, r2), t3.prototype = null === r2 ? Object.create(r2) : (i2.prototype = r2.prototype, new i2());
            };
          }(), L = function(n3) {
            function t3(t4) {
              return n3.call(this, t4) || this;
            }
            return U(t3, n3), t3.createEncryptor = function(n4) {
              return new t3.Encryptor(n4);
            }, t3.createDecryptor = function(n4) {
              return new t3.Decryptor(n4);
            }, t3.Encryptor = function(n4) {
              function t4() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return U(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                this.Hn.encryptBlock(n5, t5);
              }, t4;
            }(t3), t3.Decryptor = function(n4) {
              function t4() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return U(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                this.Hn.decryptBlock(n5, t5);
              }, t4;
            }(t3), t3;
          }(B.T), F = /* @__PURE__ */ function() {
            var n3 = function(t3, r2) {
              return (n3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n4, t4) {
                n4.__proto__ = t4;
              } || function(n4, t4) {
                for (var r3 in t4) Object.prototype.hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
              })(t3, r2);
            };
            return function(t3, r2) {
              function i2() {
                this.constructor = t3;
              }
              n3(t3, r2), t3.prototype = null === r2 ? Object.create(r2) : (i2.prototype = r2.prototype, new i2());
            };
          }(), x = function(n3) {
            function t3(t4) {
              var r2 = n3.call(this, t4) || this;
              return r2.xn = [], r2;
            }
            return F(t3, n3), t3.createEncryptor = function(n4) {
              return new t3.Encryptor(n4);
            }, t3.createDecryptor = function(n4) {
              return new t3.Decryptor(n4);
            }, t3.Encryptor = function(n4) {
              function t4() {
                return null !== n4 && n4.apply(this, arguments) || this;
              }
              return F(t4, n4), t4.prototype.processBlock = function(n5, t5) {
                var r2 = this.Hn, i2 = r2.blockSize, e2 = this.ln, o2 = this.xn;
                e2 && (o2 = this.xn = e2.words.slice(0), this.ln = void 0), r2.encryptBlock(o2, 0);
                for (var u2 = 0; u2 < i2; u2++) n5[t5 + u2] ^= o2[u2];
              }, t4;
            }(t3), t3.Decryptor = t3.Encryptor, t3;
          }(B.T), P = r(5607), R = r(3664);
          var T = { pad: function(n3, t3) {
            var r2 = n3.nSigBytes, i2 = 4 * t3, e2 = i2 - r2 % i2, o2 = r2 + e2 - 1;
            n3.clamp(), n3.words[o2 >>> 2] |= e2 << 24 - o2 % 4 * 8, n3.nSigBytes += e2;
          }, unpad: function(n3) {
            var t3 = 255 & n3.words[n3.nSigBytes - 1 >>> 2];
            n3.nSigBytes -= t3;
          } }, K = r(3354);
          var W = { pad: function(n3, t3) {
            var r2 = 4 * t3, i2 = r2 - n3.nSigBytes % r2;
            n3.concat(K.e.random(i2 - 1)).concat(new K.e([i2 << 24], 1));
          }, unpad: function(n3) {
            var t3 = 255 & n3.words[n3.nSigBytes - 1 >>> 2];
            n3.nSigBytes -= t3;
          } };
          var G = { pad: function(n3, t3) {
            var r2 = 4 * t3;
            n3.clamp(), n3.nSigBytes += r2 - (n3.nSigBytes % r2 || r2);
          }, unpad: function(n3) {
            for (var t3 = n3.words, r2 = n3.nSigBytes - 1; r2 >= 0; r2--) if (t3[r2 >>> 2] >>> 24 - r2 % 4 * 8 & 255) {
              n3.nSigBytes = r2 + 1;
              break;
            }
          } };
          var q = { pad: function(n3, t3) {
            n3.concat(new K.e([2147483648], 1)), G.pad(n3, t3);
          }, unpad: function(n3) {
            G.unpad(n3), n3.nSigBytes -= 1;
          } }, Q = r(7919);
          var X = { pad: function(n3, t3) {
          }, unpad: function(n3) {
          } }, V = r(1232), Z = { CBC: C.n, CFB: I, CTR: D, ECB: L, OFB: x, GCM: P.V, CCM: R.K }, J = { AnsiX923: T, ISO10126: W, ISO97971: q, Pkcs7: Q.l, NoPadding: X, Zero: G }, Y = { OpenSSLFormatter: V.w };
        }(), i;
      }();
    });
  }
});

// ../auth/dist/tokenToHash.js
var require_tokenToHash = __commonJS({
  "../auth/dist/tokenToHash.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k)) __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenToHash = void 0;
    var JsCrypto = __importStar(require_jscrypto());
    var tokenToHash = ({ secretToken }) => JsCrypto.SHA256.hash(secretToken).toString(JsCrypto.Base64);
    exports2.tokenToHash = tokenToHash;
  }
});

// ../../node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/url-alphabet/index.cjs
var require_url_alphabet = __commonJS({
  "../../node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/url-alphabet/index.cjs"(exports2, module2) {
    var urlAlphabet2 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    module2.exports = { urlAlphabet: urlAlphabet2 };
  }
});

// ../../node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/index.cjs
var require_nanoid = __commonJS({
  "../../node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/index.cjs"(exports2, module2) {
    var crypto9 = require("crypto");
    var { urlAlphabet: urlAlphabet2 } = require_url_alphabet();
    var POOL_SIZE_MULTIPLIER2 = 128;
    var pool2;
    var poolOffset2;
    var fillPool2 = (bytes2) => {
      if (!pool2 || pool2.length < bytes2) {
        pool2 = Buffer.allocUnsafe(bytes2 * POOL_SIZE_MULTIPLIER2);
        crypto9.randomFillSync(pool2);
        poolOffset2 = 0;
      } else if (poolOffset2 + bytes2 > pool2.length) {
        crypto9.randomFillSync(pool2);
        poolOffset2 = 0;
      }
      poolOffset2 += bytes2;
    };
    var random = (bytes2) => {
      fillPool2(bytes2 -= 0);
      return pool2.subarray(poolOffset2 - bytes2, poolOffset2);
    };
    var customRandom = (alphabet3, defaultSize, getRandom) => {
      let mask2 = (2 << 31 - Math.clz32(alphabet3.length - 1 | 1)) - 1;
      let step2 = Math.ceil(1.6 * mask2 * defaultSize / alphabet3.length);
      return (size5 = defaultSize) => {
        let id = "";
        while (true) {
          let bytes2 = getRandom(step2);
          let i = step2;
          while (i--) {
            id += alphabet3[bytes2[i] & mask2] || "";
            if (id.length === size5) return id;
          }
        }
      };
    };
    var customAlphabet = (alphabet3, size5 = 21) => customRandom(alphabet3, size5, random);
    var nanoid2 = (size5 = 21) => {
      fillPool2(size5 -= 0);
      let id = "";
      for (let i = poolOffset2 - size5; i < poolOffset2; i++) {
        id += urlAlphabet2[pool2[i] & 63];
      }
      return id;
    };
    module2.exports = { nanoid: nanoid2, customAlphabet, customRandom, urlAlphabet: urlAlphabet2, random };
  }
});

// ../auth/dist/createApplicationClientId.js
var require_createApplicationClientId = __commonJS({
  "../auth/dist/createApplicationClientId.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createApplicationClientId = void 0;
    var nanoid_1 = require_nanoid();
    var createApplicationClientId = () => `client_${(0, nanoid_1.nanoid)(20)}`;
    exports2.createApplicationClientId = createApplicationClientId;
  }
});

// ../auth/dist/createPersonalAccessToken.js
var require_createPersonalAccessToken = __commonJS({
  "../auth/dist/createPersonalAccessToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPersonalAccessToken = void 0;
    var nanoid_1 = require_nanoid();
    var createPersonalAccessToken = () => `pat_${(0, nanoid_1.nanoid)(20)}`;
    exports2.createPersonalAccessToken = createPersonalAccessToken;
  }
});

// ../auth/dist/createChallengeToken.js
var require_createChallengeToken = __commonJS({
  "../auth/dist/createChallengeToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createChallengeToken = void 0;
    var nanoid_1 = require_nanoid();
    var createToken_1 = require_createToken();
    var createChallengeToken = async ({ secret }) => (0, createToken_1.createToken)({ payload: { challenge: (0, nanoid_1.nanoid)(20) }, secret, expiration: "10m" });
    exports2.createChallengeToken = createChallengeToken;
  }
});

// ../auth/dist/verifyChallengeToken.js
var require_verifyChallengeToken = __commonJS({
  "../auth/dist/verifyChallengeToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyChallengeToken = void 0;
    var verifyToken_1 = require_verifyToken();
    var verifyChallengeToken = (args) => (0, verifyToken_1.verifyToken)(args);
    exports2.verifyChallengeToken = verifyChallengeToken;
  }
});

// ../auth/dist/decodeToken.js
var require_decodeToken = __commonJS({
  "../auth/dist/decodeToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeToken = void 0;
    var errors_1 = require_dist();
    var jose_1 = require_cjs();
    var decodeToken = ({ token }) => {
      try {
        return (0, jose_1.decodeJwt)(token);
      } catch {
        throw new errors_1.AuthorizationError();
      }
    };
    exports2.decodeToken = decodeToken;
  }
});

// ../auth/dist/decodeAccessToken.js
var require_decodeAccessToken = __commonJS({
  "../auth/dist/decodeAccessToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeAccessToken = void 0;
    var decodeToken_1 = require_decodeToken();
    var decodeAccessToken2 = (args) => (0, decodeToken_1.decodeToken)(args);
    exports2.decodeAccessToken = decodeAccessToken2;
  }
});

// ../auth/dist/constants.js
var require_constants = __commonJS({
  "../auth/dist/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.constants = void 0;
    exports2.constants = {
      AUTHORIZATION_HEADER_NAME: "Authorization",
      AUTHORIZATION_BEARER: "Bearer",
      CLIENT_ID_QUERY_STRING_FIELD_NAME: "clientId",
      SDK_CLIENT_TYPE_NAME: "sdk",
      UI_CLIENT_TYPE_NAME: "ui",
      CUSTOM_HEADERS: {
        clientType: "X-Client-Type",
        twoFactorAuthToken: "X-2FA-Token",
        twoFactorRecoveryCode: "X-2FA-Recovery-Code"
      }
    };
  }
});

// ../auth/dist/getTokenFromRequest.js
var require_getTokenFromRequest = __commonJS({
  "../auth/dist/getTokenFromRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTokenFromRequest = void 0;
    var errors_1 = require_dist();
    var constants_1 = require_constants();
    var getTokenFromRequest = (request) => {
      const header = request.headers[constants_1.constants.AUTHORIZATION_HEADER_NAME];
      if (!header) {
        throw new errors_1.AuthorizationError();
      }
      return header.replace("Bearer ", "");
    };
    exports2.getTokenFromRequest = getTokenFromRequest;
  }
});

// ../auth/dist/denyAccessFromAuthorizer.js
var require_denyAccessFromAuthorizer = __commonJS({
  "../auth/dist/denyAccessFromAuthorizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.denyAccessFromAuthorizer = void 0;
    var denyAccessFromAuthorizer = ({ methodArn }) => ({
      principalId: "unknown",
      policyDocument: {
        Version: "2012-10-17",
        Statement: [
          {
            Action: "execute-api:Invoke",
            Effect: "Deny",
            Resource: methodArn
          }
        ]
      },
      context: {}
    });
    exports2.denyAccessFromAuthorizer = denyAccessFromAuthorizer;
  }
});

// ../auth/dist/allowAccessFromAuthorizer.js
var require_allowAccessFromAuthorizer = __commonJS({
  "../auth/dist/allowAccessFromAuthorizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.allowAccessFromAuthorizer = void 0;
    var allowAccessFromAuthorizer = ({ principalId, context: context2 }) => ({
      principalId,
      policyDocument: {
        Version: "2012-10-17",
        Statement: [
          {
            Action: "execute-api:Invoke",
            Effect: "Allow",
            Resource: "*"
          }
        ]
      },
      context: context2
    });
    exports2.allowAccessFromAuthorizer = allowAccessFromAuthorizer;
  }
});

// ../auth/dist/generateGithubAppInstallationHash.js
var require_generateGithubAppInstallationHash = __commonJS({
  "../auth/dist/generateGithubAppInstallationHash.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateGithubAppInstallationHash = void 0;
    var nanoid_1 = require_nanoid();
    var generateGithubAppInstallationHash = () => (0, nanoid_1.nanoid)(32);
    exports2.generateGithubAppInstallationHash = generateGithubAppInstallationHash;
  }
});

// ../auth/dist/generateGithubAppInstallationUrl.js
var require_generateGithubAppInstallationUrl = __commonJS({
  "../auth/dist/generateGithubAppInstallationUrl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateGithubAppInstallationUrl = void 0;
    var generateGithubAppInstallationUrl = ({ appName, hash, callbackUrl, userId, gitProviderId }) => {
      const stateJson = {
        userId,
        gitProviderId,
        hash
      };
      const stateJsonString = JSON.stringify(stateJson);
      const encodedStateJson = encodeURIComponent(stateJsonString);
      return `https://github.com/apps/${appName}/installations/new?state=${encodedStateJson}&redirect_uri=${encodeURI(callbackUrl)}`;
    };
    exports2.generateGithubAppInstallationUrl = generateGithubAppInstallationUrl;
  }
});

// ../auth/dist/generateGithubAppAuthorizationUrl.js
var require_generateGithubAppAuthorizationUrl = __commonJS({
  "../auth/dist/generateGithubAppAuthorizationUrl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateGithubAppAuthorizationUrl = void 0;
    var generateGithubAppAuthorizationUrl = ({ clientId, userId, gitProviderId, callbackUrl }) => {
      const stateJson = {
        userId,
        gitProviderId
      };
      const stateJsonString = JSON.stringify(stateJson);
      const encodedStateJson = encodeURIComponent(stateJsonString);
      return `https://github.com/login/oauth/authorize?client_id=${clientId}&state=${encodedStateJson}&redirect_uri=${encodeURI(callbackUrl)}`;
    };
    exports2.generateGithubAppAuthorizationUrl = generateGithubAppAuthorizationUrl;
  }
});

// ../auth/dist/verifyAssetsAccessToken.js
var require_verifyAssetsAccessToken = __commonJS({
  "../auth/dist/verifyAssetsAccessToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyAssetsAccessToken = void 0;
    var verifyToken_1 = require_verifyToken();
    var verifyAssetsAccessToken = (args) => (0, verifyToken_1.verifyToken)(args);
    exports2.verifyAssetsAccessToken = verifyAssetsAccessToken;
  }
});

// ../auth/dist/permissions.js
var require_permissions = __commonJS({
  "../auth/dist/permissions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Permissions = void 0;
    var errors_1 = require_dist();
    var permissionScopes = [
      // Project permissions
      "PROJECT_EDIT_NAME",
      "PROJECT_EDIT_AVATAR",
      "PROJECT_EDIT_ACCESS_FROM_OFAC_COUNTRIES",
      "PROJECT_DELETE",
      // Storage permissions
      "STORAGE_EDIT_SETTINGS",
      "STORAGE_UPLOAD",
      "STORAGE_EDIT_NAME",
      "STORAGE_DELETE",
      "STORAGE_VIEW_INFORMATION",
      "STORAGE_VIEW_LIST",
      // Private gateway permissions
      "PRIVATE_GATEWAY_CREATE",
      "PRIVATE_GATEWAY_UPDATE_NAME",
      "PRIVATE_GATEWAY_DELETE",
      "PRIVATE_GATEWAY_ADD_AND_VERIFY_DOMAIN",
      "PRIVATE_GATEWAY_CHANGE_PRIMARY_DOMAIN",
      "PRIVATE_GATEWAY_DELETE_DOMAIN",
      "PRIVATE_GATEWAY_VIEW",
      // Site permissions
      "SITE_CREATE",
      "SITE_DEPLOY",
      "SITE_VIEW_OVERVIEW",
      "SITE_VIEW_BUILD_SETTINGS",
      "SITE_EDIT_BUILD_SETTINGS",
      "SITE_VIEW_ENV_VARIABLES",
      "SITE_EDIT_ENV_VARIABLES",
      "SITE_VIEW_DEPLOYMENTS",
      "SITE_VIEW_ANALYTICS",
      "SITE_EDIT_NAME",
      "SITE_EDIT_SLUG",
      "SITE_EDIT_AVATAR",
      "SITE_PURGE_CACHE",
      "SITE_DELETE",
      "SITE_ADD_AND_VERIFY_DOMAIN",
      "SITE_CHANGE_PRIMARY_DOMAIN",
      "SITE_DELETE_DOMAIN",
      "SITE_ADD_AND_VERIFY_ENS",
      "SITE_DELETE_ENS",
      "SITE_ADD_GIT_INTEGRATION",
      "SITE_REMOVE_GIT_INTEGRATION",
      // Function permissions
      "FUNCTION_CREATE",
      "FUNCTION_DEPLOY",
      "FUNCTION_EDIT_SETTINGS",
      "FUNCTION_DELETE",
      "FUNCTION_VIEW",
      "FUNCTION_VIEW_DEPLOYMENT",
      // IPNS permissions
      "IPNS_CREATE_RECORD",
      "IPNS_PUBLISH_RECORD",
      "IPNS_DELETE_RECORD",
      "IPNS_VIEW",
      // Billing permissions
      "BILLING_VIEW",
      "BILLING_MANAGE",
      // Application permissions
      "APPLICATION_VIEW",
      "APPLICATION_CREATE",
      "APPLICATION_EDIT",
      // Member permissions
      "MEMBER_TEAM_VIEW",
      "MEMBER_INVITE",
      "MEMBER_CHANGE_PERMISSIONS",
      "MEMBER_ASSIGN_OWNER",
      "MEMBER_DELETE_OTHERS",
      // Template permissions
      "TEMPLATE_CREATE"
    ];
    var Permissions = class _Permissions {
      static parse(permissions) {
        const scopes = permissions ? permissions.split(",") : [];
        for (const scope of scopes) {
          if (!permissionScopes.includes(scope)) {
            throw new errors_1.PermissionScopeError({ scope });
          }
        }
        return new _Permissions(scopes);
      }
      constructor(scopes) {
        this.scopes = new Set(scopes);
      }
      add(scope) {
        this.scopes.add(scope);
      }
      has(scope) {
        return this.scopes.has(scope);
      }
      delete(scope) {
        this.scopes.delete(scope);
      }
      toString() {
        return [...this.scopes].join(",");
      }
      toArray() {
        return [...this.scopes];
      }
    };
    exports2.Permissions = Permissions;
  }
});

// ../auth/dist/predefinedPermissionGroups/admin.js
var require_admin = __commonJS({
  "../auth/dist/predefinedPermissionGroups/admin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.admin = void 0;
    var permissions_1 = require_permissions();
    exports2.admin = new permissions_1.Permissions([
      "PROJECT_EDIT_NAME",
      "PROJECT_EDIT_AVATAR",
      "PROJECT_EDIT_ACCESS_FROM_OFAC_COUNTRIES",
      "STORAGE_EDIT_SETTINGS",
      "STORAGE_UPLOAD",
      "STORAGE_EDIT_NAME",
      "STORAGE_DELETE",
      "STORAGE_VIEW_INFORMATION",
      "STORAGE_VIEW_LIST",
      "PRIVATE_GATEWAY_CREATE",
      "PRIVATE_GATEWAY_UPDATE_NAME",
      "PRIVATE_GATEWAY_DELETE",
      "PRIVATE_GATEWAY_ADD_AND_VERIFY_DOMAIN",
      "PRIVATE_GATEWAY_CHANGE_PRIMARY_DOMAIN",
      "PRIVATE_GATEWAY_DELETE_DOMAIN",
      "PRIVATE_GATEWAY_VIEW",
      "SITE_CREATE",
      "SITE_DEPLOY",
      "SITE_VIEW_OVERVIEW",
      "SITE_VIEW_BUILD_SETTINGS",
      "SITE_EDIT_BUILD_SETTINGS",
      "SITE_VIEW_ENV_VARIABLES",
      "SITE_EDIT_ENV_VARIABLES",
      "SITE_VIEW_DEPLOYMENTS",
      "SITE_VIEW_ANALYTICS",
      "SITE_EDIT_NAME",
      "SITE_EDIT_SLUG",
      "SITE_EDIT_AVATAR",
      "SITE_PURGE_CACHE",
      "SITE_DELETE",
      "SITE_ADD_AND_VERIFY_DOMAIN",
      "SITE_CHANGE_PRIMARY_DOMAIN",
      "SITE_DELETE_DOMAIN",
      "SITE_ADD_AND_VERIFY_ENS",
      "SITE_DELETE_ENS",
      "SITE_ADD_GIT_INTEGRATION",
      "SITE_REMOVE_GIT_INTEGRATION",
      "FUNCTION_CREATE",
      "FUNCTION_DEPLOY",
      "FUNCTION_EDIT_SETTINGS",
      "FUNCTION_DELETE",
      "FUNCTION_VIEW",
      "FUNCTION_VIEW_DEPLOYMENT",
      "IPNS_CREATE_RECORD",
      "IPNS_PUBLISH_RECORD",
      "IPNS_DELETE_RECORD",
      "IPNS_VIEW",
      "BILLING_VIEW",
      "APPLICATION_VIEW",
      "APPLICATION_CREATE",
      "APPLICATION_EDIT",
      "MEMBER_TEAM_VIEW",
      "MEMBER_INVITE",
      "MEMBER_CHANGE_PERMISSIONS",
      "MEMBER_DELETE_OTHERS",
      "TEMPLATE_CREATE"
    ]);
  }
});

// ../auth/dist/predefinedPermissionGroups/member.js
var require_member = __commonJS({
  "../auth/dist/predefinedPermissionGroups/member.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.member = void 0;
    var permissions_1 = require_permissions();
    exports2.member = new permissions_1.Permissions([
      "PROJECT_EDIT_NAME",
      "PROJECT_EDIT_AVATAR",
      "STORAGE_UPLOAD",
      "STORAGE_EDIT_NAME",
      "STORAGE_DELETE",
      "STORAGE_VIEW_INFORMATION",
      "STORAGE_VIEW_LIST",
      "PRIVATE_GATEWAY_CREATE",
      "PRIVATE_GATEWAY_UPDATE_NAME",
      "PRIVATE_GATEWAY_ADD_AND_VERIFY_DOMAIN",
      "PRIVATE_GATEWAY_CHANGE_PRIMARY_DOMAIN",
      "PRIVATE_GATEWAY_DELETE_DOMAIN",
      "PRIVATE_GATEWAY_DELETE",
      "PRIVATE_GATEWAY_VIEW",
      "SITE_CREATE",
      "SITE_DEPLOY",
      "SITE_VIEW_OVERVIEW",
      "SITE_EDIT_NAME",
      "SITE_EDIT_SLUG",
      "SITE_EDIT_AVATAR",
      "SITE_VIEW_BUILD_SETTINGS",
      "SITE_EDIT_BUILD_SETTINGS",
      "SITE_VIEW_ENV_VARIABLES",
      "SITE_EDIT_ENV_VARIABLES",
      "SITE_VIEW_DEPLOYMENTS",
      "SITE_VIEW_ANALYTICS",
      "SITE_PURGE_CACHE",
      "SITE_ADD_AND_VERIFY_DOMAIN",
      "SITE_CHANGE_PRIMARY_DOMAIN",
      "SITE_DELETE_DOMAIN",
      "SITE_ADD_AND_VERIFY_ENS",
      "SITE_ADD_GIT_INTEGRATION",
      "SITE_DELETE_ENS",
      "FUNCTION_CREATE",
      "FUNCTION_DEPLOY",
      "FUNCTION_EDIT_SETTINGS",
      "FUNCTION_VIEW",
      "FUNCTION_VIEW_DEPLOYMENT",
      "FUNCTION_DELETE",
      "IPNS_CREATE_RECORD",
      "IPNS_PUBLISH_RECORD",
      "IPNS_DELETE_RECORD",
      "IPNS_VIEW",
      "APPLICATION_VIEW",
      "APPLICATION_CREATE",
      "APPLICATION_EDIT",
      "MEMBER_TEAM_VIEW",
      "TEMPLATE_CREATE"
    ]);
  }
});

// ../auth/dist/predefinedPermissionGroups/owner.js
var require_owner = __commonJS({
  "../auth/dist/predefinedPermissionGroups/owner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.owner = void 0;
    var permissions_1 = require_permissions();
    exports2.owner = new permissions_1.Permissions([
      "PROJECT_EDIT_NAME",
      "PROJECT_EDIT_AVATAR",
      "PROJECT_DELETE",
      "PROJECT_EDIT_ACCESS_FROM_OFAC_COUNTRIES",
      "STORAGE_EDIT_SETTINGS",
      "STORAGE_UPLOAD",
      "STORAGE_EDIT_NAME",
      "STORAGE_DELETE",
      "STORAGE_VIEW_INFORMATION",
      "STORAGE_VIEW_LIST",
      "PRIVATE_GATEWAY_CREATE",
      "PRIVATE_GATEWAY_UPDATE_NAME",
      "PRIVATE_GATEWAY_DELETE",
      "PRIVATE_GATEWAY_ADD_AND_VERIFY_DOMAIN",
      "PRIVATE_GATEWAY_CHANGE_PRIMARY_DOMAIN",
      "PRIVATE_GATEWAY_DELETE_DOMAIN",
      "PRIVATE_GATEWAY_VIEW",
      "SITE_CREATE",
      "SITE_DEPLOY",
      "SITE_VIEW_OVERVIEW",
      "SITE_VIEW_BUILD_SETTINGS",
      "SITE_EDIT_BUILD_SETTINGS",
      "SITE_VIEW_ENV_VARIABLES",
      "SITE_EDIT_ENV_VARIABLES",
      "SITE_VIEW_DEPLOYMENTS",
      "SITE_VIEW_ANALYTICS",
      "SITE_EDIT_NAME",
      "SITE_EDIT_SLUG",
      "SITE_EDIT_AVATAR",
      "SITE_PURGE_CACHE",
      "SITE_DELETE",
      "SITE_ADD_AND_VERIFY_DOMAIN",
      "SITE_CHANGE_PRIMARY_DOMAIN",
      "SITE_DELETE_DOMAIN",
      "SITE_ADD_AND_VERIFY_ENS",
      "SITE_DELETE_ENS",
      "SITE_ADD_GIT_INTEGRATION",
      "SITE_REMOVE_GIT_INTEGRATION",
      "FUNCTION_CREATE",
      "FUNCTION_DEPLOY",
      "FUNCTION_EDIT_SETTINGS",
      "FUNCTION_DELETE",
      "FUNCTION_VIEW",
      "FUNCTION_VIEW_DEPLOYMENT",
      "IPNS_CREATE_RECORD",
      "IPNS_PUBLISH_RECORD",
      "IPNS_DELETE_RECORD",
      "IPNS_VIEW",
      "IPNS_CREATE_RECORD",
      "IPNS_PUBLISH_RECORD",
      "IPNS_DELETE_RECORD",
      "IPNS_VIEW",
      "BILLING_VIEW",
      "BILLING_MANAGE",
      "APPLICATION_VIEW",
      "APPLICATION_CREATE",
      "APPLICATION_EDIT",
      "MEMBER_TEAM_VIEW",
      "MEMBER_INVITE",
      "MEMBER_CHANGE_PERMISSIONS",
      "MEMBER_ASSIGN_OWNER",
      "MEMBER_DELETE_OTHERS",
      "TEMPLATE_CREATE"
    ]);
  }
});

// ../auth/dist/predefinedPermissionGroups/readOnly.js
var require_readOnly = __commonJS({
  "../auth/dist/predefinedPermissionGroups/readOnly.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readOnly = void 0;
    var permissions_1 = require_permissions();
    exports2.readOnly = new permissions_1.Permissions([
      "STORAGE_VIEW_INFORMATION",
      "STORAGE_VIEW_LIST",
      "SITE_VIEW_OVERVIEW",
      "SITE_VIEW_DEPLOYMENTS",
      "SITE_VIEW_BUILD_SETTINGS",
      "SITE_VIEW_ENV_VARIABLES",
      "SITE_VIEW_ANALYTICS",
      "FUNCTION_VIEW",
      "FUNCTION_VIEW_DEPLOYMENT",
      "IPNS_VIEW",
      "PRIVATE_GATEWAY_VIEW",
      "APPLICATION_VIEW"
    ]);
  }
});

// ../auth/dist/index.js
var require_dist2 = __commonJS({
  "../auth/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.predefinedPermissionGroups = void 0;
    __exportStar(require_createAccessToken(), exports2);
    __exportStar(require_createAssetsAccessToken(), exports2);
    __exportStar(require_createMigrationToken(), exports2);
    __exportStar(require_verifyAccessToken(), exports2);
    __exportStar(require_verifyMigrationToken(), exports2);
    __exportStar(require_tokenToHash(), exports2);
    __exportStar(require_createApplicationClientId(), exports2);
    __exportStar(require_createPersonalAccessToken(), exports2);
    __exportStar(require_createChallengeToken(), exports2);
    __exportStar(require_verifyChallengeToken(), exports2);
    __exportStar(require_decodeAccessToken(), exports2);
    __exportStar(require_getTokenFromRequest(), exports2);
    __exportStar(require_denyAccessFromAuthorizer(), exports2);
    __exportStar(require_allowAccessFromAuthorizer(), exports2);
    __exportStar(require_generateGithubAppInstallationHash(), exports2);
    __exportStar(require_generateGithubAppInstallationUrl(), exports2);
    __exportStar(require_generateGithubAppAuthorizationUrl(), exports2);
    __exportStar(require_constants(), exports2);
    __exportStar(require_verifyAssetsAccessToken(), exports2);
    __exportStar(require_permissions(), exports2);
    var admin_1 = require_admin();
    var member_1 = require_member();
    var owner_1 = require_owner();
    var readOnly_1 = require_readOnly();
    exports2.predefinedPermissionGroups = { owner: owner_1.owner, admin: admin_1.admin, member: member_1.member, readOnly: readOnly_1.readOnly };
  }
});

// ../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/multibases.js
var LOAD_BASE, Multibases;
var init_multibases = __esm({
  "../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/multibases.js"() {
    LOAD_BASE = (name20) => Promise.reject(new Error(`No base found for "${name20}"`));
    Multibases = class {
      constructor(options) {
        this._basesByName = {};
        this._basesByPrefix = {};
        this._loadBase = options.loadBase || LOAD_BASE;
        for (const base6 of options.bases) {
          this.addBase(base6);
        }
      }
      addBase(base6) {
        if (this._basesByName[base6.name] || this._basesByPrefix[base6.prefix]) {
          throw new Error(`Codec already exists for codec "${base6.name}"`);
        }
        this._basesByName[base6.name] = base6;
        this._basesByPrefix[base6.prefix] = base6;
      }
      removeBase(base6) {
        delete this._basesByName[base6.name];
        delete this._basesByPrefix[base6.prefix];
      }
      async getBase(nameOrPrefix) {
        if (this._basesByName[nameOrPrefix]) {
          return this._basesByName[nameOrPrefix];
        }
        if (this._basesByPrefix[nameOrPrefix]) {
          return this._basesByPrefix[nameOrPrefix];
        }
        const base6 = await this._loadBase(nameOrPrefix);
        if (this._basesByName[base6.name] == null && this._basesByPrefix[base6.prefix] == null) {
          this.addBase(base6);
        }
        return base6;
      }
      listBases() {
        return Object.values(this._basesByName);
      }
    };
  }
});

// ../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/multicodecs.js
var LOAD_CODEC, Multicodecs;
var init_multicodecs = __esm({
  "../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/multicodecs.js"() {
    LOAD_CODEC = (codeOrName) => Promise.reject(new Error(`No codec found for "${codeOrName}"`));
    Multicodecs = class {
      constructor(options) {
        this._codecsByName = {};
        this._codecsByCode = {};
        this._loadCodec = options.loadCodec || LOAD_CODEC;
        for (const codec of options.codecs) {
          this.addCodec(codec);
        }
      }
      addCodec(codec) {
        if (this._codecsByName[codec.name] || this._codecsByCode[codec.code]) {
          throw new Error(`Resolver already exists for codec "${codec.name}"`);
        }
        this._codecsByName[codec.name] = codec;
        this._codecsByCode[codec.code] = codec;
      }
      removeCodec(codec) {
        delete this._codecsByName[codec.name];
        delete this._codecsByCode[codec.code];
      }
      async getCodec(code25) {
        const table = typeof code25 === "string" ? this._codecsByName : this._codecsByCode;
        if (table[code25]) {
          return table[code25];
        }
        const codec = await this._loadCodec(code25);
        if (table[code25] == null) {
          this.addCodec(codec);
        }
        return codec;
      }
      listCodecs() {
        return Object.values(this._codecsByName);
      }
    };
  }
});

// ../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/multihashes.js
var LOAD_HASHER, Multihashes;
var init_multihashes = __esm({
  "../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/multihashes.js"() {
    LOAD_HASHER = (codeOrName) => Promise.reject(new Error(`No hasher found for "${codeOrName}"`));
    Multihashes = class {
      constructor(options) {
        this._hashersByName = {};
        this._hashersByCode = {};
        this._loadHasher = options.loadHasher || LOAD_HASHER;
        for (const hasher of options.hashers) {
          this.addHasher(hasher);
        }
      }
      addHasher(hasher) {
        if (this._hashersByName[hasher.name] || this._hashersByCode[hasher.code]) {
          throw new Error(`Resolver already exists for codec "${hasher.name}"`);
        }
        this._hashersByName[hasher.name] = hasher;
        this._hashersByCode[hasher.code] = hasher;
      }
      removeHasher(hasher) {
        delete this._hashersByName[hasher.name];
        delete this._hashersByCode[hasher.code];
      }
      async getHasher(code25) {
        const table = typeof code25 === "string" ? this._hashersByName : this._hashersByCode;
        if (table[code25]) {
          return table[code25];
        }
        const hasher = await this._loadHasher(code25);
        if (table[code25] == null) {
          this.addHasher(hasher);
        }
        return hasher;
      }
      listHashers() {
        return Object.values(this._hashersByName);
      }
    };
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/varint.js
function encode(num, out, offset2) {
  out = out || [];
  offset2 = offset2 || 0;
  var oldOffset = offset2;
  while (num >= INT) {
    out[offset2++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset2++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset2] = num | 0;
  encode.bytes = offset2 - oldOffset + 1;
  return out;
}
function read(buf3, offset2) {
  var res = 0, offset2 = offset2 || 0, shift = 0, counter = offset2, b, l = buf3.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset2;
  return res;
}
var encode_1, MSB, REST, MSBALL, INT, decode, MSB$1, REST$1, N1, N2, N3, N4, N5, N6, N7, N8, N9, length, varint, _brrp_varint, varint_default;
var init_varint = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/varint.js"() {
    encode_1 = encode;
    MSB = 128;
    REST = 127;
    MSBALL = ~REST;
    INT = Math.pow(2, 31);
    decode = read;
    MSB$1 = 128;
    REST$1 = 127;
    N1 = Math.pow(2, 7);
    N2 = Math.pow(2, 14);
    N3 = Math.pow(2, 21);
    N4 = Math.pow(2, 28);
    N5 = Math.pow(2, 35);
    N6 = Math.pow(2, 42);
    N7 = Math.pow(2, 49);
    N8 = Math.pow(2, 56);
    N9 = Math.pow(2, 63);
    length = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
    varint = {
      encode: encode_1,
      decode,
      encodingLength: length
    };
    _brrp_varint = varint;
    varint_default = _brrp_varint;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/varint.js
var decode2, encodeTo, encodingLength;
var init_varint2 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/varint.js"() {
    init_varint();
    decode2 = (data, offset2 = 0) => {
      const code25 = varint_default.decode(data, offset2);
      return [
        code25,
        varint_default.decode.bytes
      ];
    };
    encodeTo = (int, target, offset2 = 0) => {
      varint_default.encode(int, target, offset2);
      return target;
    };
    encodingLength = (int) => {
      return varint_default.encodingLength(int);
    };
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bytes.js
var empty, equals, coerce, fromString, toString;
var init_bytes = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bytes.js"() {
    empty = new Uint8Array(0);
    equals = (aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    coerce = (o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
        return o;
      if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    fromString = (str) => new TextEncoder().encode(str);
    toString = (b) => new TextDecoder().decode(b);
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/digest.js
var create, decode3, equals2, Digest;
var init_digest = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/digest.js"() {
    init_bytes();
    init_varint2();
    create = (code25, digest6) => {
      const size5 = digest6.byteLength;
      const sizeOffset = encodingLength(code25);
      const digestOffset = sizeOffset + encodingLength(size5);
      const bytes2 = new Uint8Array(digestOffset + size5);
      encodeTo(code25, bytes2, 0);
      encodeTo(size5, bytes2, sizeOffset);
      bytes2.set(digest6, digestOffset);
      return new Digest(code25, size5, digest6, bytes2);
    };
    decode3 = (multihash) => {
      const bytes2 = coerce(multihash);
      const [code25, sizeOffset] = decode2(bytes2);
      const [size5, digestOffset] = decode2(bytes2.subarray(sizeOffset));
      const digest6 = bytes2.subarray(sizeOffset + digestOffset);
      if (digest6.byteLength !== size5) {
        throw new Error("Incorrect length");
      }
      return new Digest(code25, size5, digest6, bytes2);
    };
    equals2 = (a, b) => {
      if (a === b) {
        return true;
      } else {
        return a.code === b.code && a.size === b.size && equals(a.bytes, b.bytes);
      }
    };
    Digest = class {
      constructor(code25, size5, digest6, bytes2) {
        this.code = code25;
        this.size = size5;
        this.digest = digest6;
        this.bytes = bytes2;
      }
    };
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/base-x.js
function base(ALPHABET, name20) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode45(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length5 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size5 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size5);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size5 - 1; (carry !== 0 || i2 < length5) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i2;
      pbegin++;
    }
    var it2 = size5 - length5;
    while (it2 !== size5 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size5; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length5 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size5 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size5);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size5 - 1; (carry !== 0 || i2 < length5) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size5 - length5;
    while (it4 !== size5 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size5 - it4));
    var j2 = zeroes;
    while (it4 !== size5) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode53(string4) {
    var buffer3 = decodeUnsafe(string4);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name20} character`);
  }
  return {
    encode: encode45,
    decodeUnsafe,
    decode: decode53
  };
}
var src, _brrp__multiformats_scope_baseX, base_x_default;
var init_base_x = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/base-x.js"() {
    src = base;
    _brrp__multiformats_scope_baseX = src;
    base_x_default = _brrp__multiformats_scope_baseX;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base.js
var Encoder, Decoder, ComposedDecoder, or, Codec, from, baseX, decode4, encode2, rfc4648;
var init_base = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base.js"() {
    init_base_x();
    init_bytes();
    Encoder = class {
      constructor(name20, prefix2, baseEncode) {
        this.name = name20;
        this.prefix = prefix2;
        this.baseEncode = baseEncode;
      }
      encode(bytes2) {
        if (bytes2 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes2)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder = class {
      constructor(name20, prefix2, baseDecode) {
        this.name = name20;
        this.prefix = prefix2;
        if (prefix2.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix2.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text2) {
        if (typeof text2 === "string") {
          if (text2.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text2.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder3) {
        return or(this, decoder3);
      }
    };
    ComposedDecoder = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder3) {
        return or(this, decoder3);
      }
      decode(input10) {
        const prefix2 = input10[0];
        const decoder3 = this.decoders[prefix2];
        if (decoder3) {
          return decoder3.decode(input10);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input10)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    or = (left, right) => new ComposedDecoder({
      ...left.decoders || { [left.prefix]: left },
      ...right.decoders || { [right.prefix]: right }
    });
    Codec = class {
      constructor(name20, prefix2, baseEncode, baseDecode) {
        this.name = name20;
        this.prefix = prefix2;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name20, prefix2, baseEncode);
        this.decoder = new Decoder(name20, prefix2, baseDecode);
      }
      encode(input10) {
        return this.encoder.encode(input10);
      }
      decode(input10) {
        return this.decoder.decode(input10);
      }
    };
    from = ({ name: name20, prefix: prefix2, encode: encode45, decode: decode53 }) => new Codec(name20, prefix2, encode45, decode53);
    baseX = ({ prefix: prefix2, name: name20, alphabet: alphabet3 }) => {
      const { encode: encode45, decode: decode53 } = base_x_default(alphabet3, name20);
      return from({
        prefix: prefix2,
        name: name20,
        encode: encode45,
        decode: (text2) => coerce(decode53(text2))
      });
    };
    decode4 = (string4, alphabet3, bitsPerChar, name20) => {
      const codes = {};
      for (let i = 0; i < alphabet3.length; ++i) {
        codes[alphabet3[i]] = i;
      }
      let end = string4.length;
      while (string4[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer3 = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string4[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name20} character`);
        }
        buffer3 = buffer3 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer3 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer3 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    encode2 = (data, alphabet3, bitsPerChar) => {
      const pad2 = alphabet3[alphabet3.length - 1] === "=";
      const mask2 = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer3 = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer3 = buffer3 << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet3[mask2 & buffer3 >> bits];
        }
      }
      if (bits) {
        out += alphabet3[mask2 & buffer3 << bitsPerChar - bits];
      }
      if (pad2) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    rfc4648 = ({ name: name20, prefix: prefix2, bitsPerChar, alphabet: alphabet3 }) => {
      return from({
        prefix: prefix2,
        name: name20,
        encode(input10) {
          return encode2(input10, alphabet3, bitsPerChar);
        },
        decode(input10) {
          return decode4(input10, alphabet3, bitsPerChar, name20);
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});
var base58btc, base58flickr;
var init_base58 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base58.js"() {
    init_base();
    base58btc = baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr = baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32, base32upper, base32pad, base32padupper, base32hex, base32hexupper, base32hexpad, base32hexpadupper, base32z;
var init_base32 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base32.js"() {
    init_base();
    base32 = rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper = rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad = rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper = rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex = rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper = rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad = rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper = rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z = rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/cid.js
var CID, parseCIDtoBytes, toStringV0, toStringV1, DAG_PB_CODE, SHA_256_CODE, encodeCID, cidSymbol, readonly, hidden, version, deprecate, IS_CID_DEPRECATION;
var init_cid = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/cid.js"() {
    init_varint2();
    init_digest();
    init_base58();
    init_base32();
    init_bytes();
    CID = class _CID {
      constructor(version3, code25, multihash, bytes2) {
        this.code = code25;
        this.version = version3;
        this.multihash = multihash;
        this.bytes = bytes2;
        this.byteOffset = bytes2.byteOffset;
        this.byteLength = bytes2.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden,
          byteLength: hidden,
          code: readonly,
          version: readonly,
          multihash: readonly,
          bytes: readonly,
          _baseCache: hidden,
          asCID: hidden
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code25, multihash } = this;
            if (code25 !== DAG_PB_CODE) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return _CID.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code25, digest: digest6 } = this.multihash;
            const multihash = create(code25, digest6);
            return _CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
      }
      toString(base6) {
        const { bytes: bytes2, version: version3, _baseCache } = this;
        switch (version3) {
          case 0:
            return toStringV0(bytes2, _baseCache, base6 || base58btc.encoder);
          default:
            return toStringV1(bytes2, _baseCache, base6 || base32.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate(/^0\.0/, IS_CID_DEPRECATION);
        return !!(value && (value[cidSymbol] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof _CID) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version3, code: code25, multihash, bytes: bytes2 } = value;
          return new _CID(version3, code25, multihash, bytes2 || encodeCID(version3, code25, multihash.bytes));
        } else if (value != null && value[cidSymbol] === true) {
          const { version: version3, multihash, code: code25 } = value;
          const digest6 = decode3(multihash);
          return _CID.create(version3, code25, digest6);
        } else {
          return null;
        }
      }
      static create(version3, code25, digest6) {
        if (typeof code25 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version3) {
          case 0: {
            if (code25 !== DAG_PB_CODE) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
            } else {
              return new _CID(version3, code25, digest6, digest6.bytes);
            }
          }
          case 1: {
            const bytes2 = encodeCID(version3, code25, digest6.bytes);
            return new _CID(version3, code25, digest6, bytes2);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest6) {
        return _CID.create(0, DAG_PB_CODE, digest6);
      }
      static createV1(code25, digest6) {
        return _CID.create(1, code25, digest6);
      }
      static decode(bytes2) {
        const [cid, remainder] = _CID.decodeFirst(bytes2);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes2) {
        const specs = _CID.inspectBytes(bytes2);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest6 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? _CID.createV0(digest6) : _CID.createV1(specs.codec, digest6);
        return [
          cid,
          bytes2.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset2 = 0;
        const next = () => {
          const [i, length5] = decode2(initialBytes.subarray(offset2));
          offset2 += length5;
          return i;
        };
        let version3 = next();
        let codec = DAG_PB_CODE;
        if (version3 === 18) {
          version3 = 0;
          offset2 = 0;
        } else if (version3 === 1) {
          codec = next();
        }
        if (version3 !== 0 && version3 !== 1) {
          throw new RangeError(`Invalid CID version ${version3}`);
        }
        const prefixSize = offset2;
        const multihashCode = next();
        const digestSize = next();
        const size5 = offset2 + digestSize;
        const multihashSize = size5 - prefixSize;
        return {
          version: version3,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size: size5
        };
      }
      static parse(source, base6) {
        const [prefix2, bytes2] = parseCIDtoBytes(source, base6);
        const cid = _CID.decode(bytes2);
        cid._baseCache.set(prefix2, source);
        return cid;
      }
    };
    parseCIDtoBytes = (source, base6) => {
      switch (source[0]) {
        case "Q": {
          const decoder3 = base6 || base58btc;
          return [
            base58btc.prefix,
            decoder3.decode(`${base58btc.prefix}${source}`)
          ];
        }
        case base58btc.prefix: {
          const decoder3 = base6 || base58btc;
          return [
            base58btc.prefix,
            decoder3.decode(source)
          ];
        }
        case base32.prefix: {
          const decoder3 = base6 || base32;
          return [
            base32.prefix,
            decoder3.decode(source)
          ];
        }
        default: {
          if (base6 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base6.decode(source)
          ];
        }
      }
    };
    toStringV0 = (bytes2, cache5, base6) => {
      const { prefix: prefix2 } = base6;
      if (prefix2 !== base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base6.name} encoding`);
      }
      const cid = cache5.get(prefix2);
      if (cid == null) {
        const cid2 = base6.encode(bytes2).slice(1);
        cache5.set(prefix2, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    toStringV1 = (bytes2, cache5, base6) => {
      const { prefix: prefix2 } = base6;
      const cid = cache5.get(prefix2);
      if (cid == null) {
        const cid2 = base6.encode(bytes2);
        cache5.set(prefix2, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    DAG_PB_CODE = 112;
    SHA_256_CODE = 18;
    encodeCID = (version3, code25, multihash) => {
      const codeOffset = encodingLength(version3);
      const hashOffset = codeOffset + encodingLength(code25);
      const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo(version3, bytes2, 0);
      encodeTo(code25, bytes2, codeOffset);
      bytes2.set(multihash, hashOffset);
      return bytes2;
    };
    cidSymbol = Symbol.for("@ipld/js-cid/CID");
    readonly = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    hidden = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    version = "0.0.0-dev";
    deprecate = (range, message) => {
      if (range.test(version)) {
        console.warn(message);
      } else {
        throw new Error(message);
      }
    };
    IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
  }
});

// ../../node_modules/.pnpm/@ipld+dag-pb@2.1.18/node_modules/@ipld/dag-pb/esm/src/pb-decode.js
function decodeVarint(bytes2, offset2) {
  let v = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset2 >= bytes2.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b = bytes2[offset2++];
    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
    if (b < 128) {
      break;
    }
  }
  return [
    v,
    offset2
  ];
}
function decodeBytes(bytes2, offset2) {
  let byteLen;
  [byteLen, offset2] = decodeVarint(bytes2, offset2);
  const postOffset = offset2 + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes2.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [
    bytes2.subarray(offset2, postOffset),
    postOffset
  ];
}
function decodeKey(bytes2, index2) {
  let wire;
  [wire, index2] = decodeVarint(bytes2, index2);
  return [
    wire & 7,
    wire >> 3,
    index2
  ];
}
function decodeLink(bytes2) {
  const link5 = {};
  const l = bytes2.length;
  let index2 = 0;
  while (index2 < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index2] = decodeKey(bytes2, index2);
    if (fieldNum === 1) {
      if (link5.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link5.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link5.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      ;
      [link5.Hash, index2] = decodeBytes(bytes2, index2);
    } else if (fieldNum === 2) {
      if (link5.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link5.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index2] = decodeBytes(bytes2, index2);
      link5.Name = textDecoder.decode(byts);
    } else if (fieldNum === 3) {
      if (link5.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      ;
      [link5.Tsize, index2] = decodeVarint(bytes2, index2);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index2 > l) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link5;
}
function decodeNode(bytes2) {
  const l = bytes2.length;
  let index2 = 0;
  let links3;
  let linksBeforeData = false;
  let data;
  while (index2 < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index2] = decodeKey(bytes2, index2);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      ;
      [data, index2] = decodeBytes(bytes2, index2);
      if (links3) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links3) {
        links3 = [];
      }
      let byts;
      [byts, index2] = decodeBytes(bytes2, index2);
      links3.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index2 > l) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links3 || [];
  return node;
}
var textDecoder;
var init_pb_decode = __esm({
  "../../node_modules/.pnpm/@ipld+dag-pb@2.1.18/node_modules/@ipld/dag-pb/esm/src/pb-decode.js"() {
    textDecoder = new TextDecoder();
  }
});

// ../../node_modules/.pnpm/@ipld+dag-pb@2.1.18/node_modules/@ipld/dag-pb/esm/src/pb-encode.js
function encodeLink(link5, bytes2) {
  let i = bytes2.length;
  if (typeof link5.Tsize === "number") {
    if (link5.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link5.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i = encodeVarint(bytes2, i, link5.Tsize) - 1;
    bytes2[i] = 24;
  }
  if (typeof link5.Name === "string") {
    const nameBytes = textEncoder.encode(link5.Name);
    i -= nameBytes.length;
    bytes2.set(nameBytes, i);
    i = encodeVarint(bytes2, i, nameBytes.length) - 1;
    bytes2[i] = 18;
  }
  if (link5.Hash) {
    i -= link5.Hash.length;
    bytes2.set(link5.Hash, i);
    i = encodeVarint(bytes2, i, link5.Hash.length) - 1;
    bytes2[i] = 10;
  }
  return bytes2.length - i;
}
function encodeNode(node) {
  const size5 = sizeNode(node);
  const bytes2 = new Uint8Array(size5);
  let i = size5;
  if (node.Data) {
    i -= node.Data.length;
    bytes2.set(node.Data, i);
    i = encodeVarint(bytes2, i, node.Data.length) - 1;
    bytes2[i] = 10;
  }
  if (node.Links) {
    for (let index2 = node.Links.length - 1; index2 >= 0; index2--) {
      const size6 = encodeLink(node.Links[index2], bytes2.subarray(0, i));
      i -= size6;
      i = encodeVarint(bytes2, i, size6) - 1;
      bytes2[i] = 18;
    }
  }
  return bytes2;
}
function sizeLink(link5) {
  let n = 0;
  if (link5.Hash) {
    const l = link5.Hash.length;
    n += 1 + l + sov(l);
  }
  if (typeof link5.Name === "string") {
    const l = textEncoder.encode(link5.Name).length;
    n += 1 + l + sov(l);
  }
  if (typeof link5.Tsize === "number") {
    n += 1 + sov(link5.Tsize);
  }
  return n;
}
function sizeNode(node) {
  let n = 0;
  if (node.Data) {
    const l = node.Data.length;
    n += 1 + l + sov(l);
  }
  if (node.Links) {
    for (const link5 of node.Links) {
      const l = sizeLink(link5);
      n += 1 + l + sov(l);
    }
  }
  return n;
}
function encodeVarint(bytes2, offset2, v) {
  offset2 -= sov(v);
  const base6 = offset2;
  while (v >= maxUInt32) {
    bytes2[offset2++] = v & 127 | 128;
    v /= 128;
  }
  while (v >= 128) {
    bytes2[offset2++] = v & 127 | 128;
    v >>>= 7;
  }
  bytes2[offset2] = v;
  return base6;
}
function sov(x) {
  if (x % 2 === 0) {
    x++;
  }
  return Math.floor((len64(x) + 6) / 7);
}
function len64(x) {
  let n = 0;
  if (x >= maxInt32) {
    x = Math.floor(x / maxInt32);
    n = 32;
  }
  if (x >= 1 << 16) {
    x >>>= 16;
    n += 16;
  }
  if (x >= 1 << 8) {
    x >>>= 8;
    n += 8;
  }
  return n + len8tab[x];
}
var textEncoder, maxInt32, maxUInt32, len8tab;
var init_pb_encode = __esm({
  "../../node_modules/.pnpm/@ipld+dag-pb@2.1.18/node_modules/@ipld/dag-pb/esm/src/pb-encode.js"() {
    textEncoder = new TextEncoder();
    maxInt32 = 2 ** 32;
    maxUInt32 = 2 ** 31;
    len8tab = [
      0,
      1,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ];
  }
});

// ../../node_modules/.pnpm/@ipld+dag-pb@2.1.18/node_modules/@ipld/dag-pb/esm/src/util.js
function linkComparator(a, b) {
  if (a === b) {
    return 0;
  }
  const abuf = a.Name ? textEncoder2.encode(a.Name) : [];
  const bbuf = b.Name ? textEncoder2.encode(b.Name) : [];
  let x = abuf.length;
  let y = bbuf.length;
  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (abuf[i] !== bbuf[i]) {
      x = abuf[i];
      y = bbuf[i];
      break;
    }
  }
  return x < y ? -1 : y < x ? 1 : 0;
}
function hasOnlyProperties(node, properties) {
  return !Object.keys(node).some((p) => !properties.includes(p));
}
function asLink(link5) {
  if (typeof link5.asCID === "object") {
    const Hash = CID.asCID(link5);
    if (!Hash) {
      throw new TypeError("Invalid DAG-PB form");
    }
    return { Hash };
  }
  if (typeof link5 !== "object" || Array.isArray(link5)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbl = {};
  if (link5.Hash) {
    let cid = CID.asCID(link5.Hash);
    try {
      if (!cid) {
        if (typeof link5.Hash === "string") {
          cid = CID.parse(link5.Hash);
        } else if (link5.Hash instanceof Uint8Array) {
          cid = CID.decode(link5.Hash);
        }
      }
    } catch (e) {
      throw new TypeError(`Invalid DAG-PB form: ${e.message}`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (typeof link5.Name === "string") {
    pbl.Name = link5.Name;
  }
  if (typeof link5.Tsize === "number") {
    pbl.Tsize = link5.Tsize;
  }
  return pbl;
}
function prepare(node) {
  if (node instanceof Uint8Array || typeof node === "string") {
    node = { Data: node };
  }
  if (typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbn = {};
  if (node.Data !== void 0) {
    if (typeof node.Data === "string") {
      pbn.Data = textEncoder2.encode(node.Data);
    } else if (node.Data instanceof Uint8Array) {
      pbn.Data = node.Data;
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  }
  if (node.Links !== void 0) {
    if (Array.isArray(node.Links)) {
      pbn.Links = node.Links.map(asLink);
      pbn.Links.sort(linkComparator);
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate(node) {
  if (!node || typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties(node, pbNodeProperties)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");
  }
  if (!Array.isArray(node.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be an array)");
  }
  for (let i = 0; i < node.Links.length; i++) {
    const link5 = node.Links[i];
    if (!link5 || typeof link5 !== "object" || Array.isArray(link5)) {
      throw new TypeError("Invalid DAG-PB form (bad link object)");
    }
    if (!hasOnlyProperties(link5, pbLinkProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");
    }
    if (!link5.Hash) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link5.Hash.asCID !== link5.Hash) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link5.Name !== void 0 && typeof link5.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link5.Tsize !== void 0 && (typeof link5.Tsize !== "number" || link5.Tsize % 1 !== 0)) {
      throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
    }
    if (i > 0 && linkComparator(link5, node.Links[i - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
function createNode(data, links3 = []) {
  return prepare({
    Data: data,
    Links: links3
  });
}
function createLink(name20, size5, cid) {
  return asLink({
    Hash: cid,
    Name: name20,
    Tsize: size5
  });
}
var pbNodeProperties, pbLinkProperties, textEncoder2;
var init_util = __esm({
  "../../node_modules/.pnpm/@ipld+dag-pb@2.1.18/node_modules/@ipld/dag-pb/esm/src/util.js"() {
    init_cid();
    pbNodeProperties = [
      "Data",
      "Links"
    ];
    pbLinkProperties = [
      "Hash",
      "Name",
      "Tsize"
    ];
    textEncoder2 = new TextEncoder();
  }
});

// ../../node_modules/.pnpm/@ipld+dag-pb@2.1.18/node_modules/@ipld/dag-pb/esm/src/index.js
var src_exports = {};
__export(src_exports, {
  code: () => code,
  createLink: () => createLink,
  createNode: () => createNode,
  decode: () => decode5,
  encode: () => encode3,
  name: () => name,
  prepare: () => prepare,
  validate: () => validate
});
function encode3(node) {
  validate(node);
  const pbn = {};
  if (node.Links) {
    pbn.Links = node.Links.map((l) => {
      const link5 = {};
      if (l.Hash) {
        link5.Hash = l.Hash.bytes;
      }
      if (l.Name !== void 0) {
        link5.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link5.Tsize = l.Tsize;
      }
      return link5;
    });
  }
  if (node.Data) {
    pbn.Data = node.Data;
  }
  return encodeNode(pbn);
}
function decode5(bytes2) {
  const pbn = decodeNode(bytes2);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l) => {
      const link5 = {};
      try {
        link5.Hash = CID.decode(l.Hash);
      } catch (e) {
      }
      if (!link5.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l.Name !== void 0) {
        link5.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link5.Tsize = l.Tsize;
      }
      return link5;
    });
  }
  return node;
}
var name, code;
var init_src = __esm({
  "../../node_modules/.pnpm/@ipld+dag-pb@2.1.18/node_modules/@ipld/dag-pb/esm/src/index.js"() {
    init_cid();
    init_pb_decode();
    init_pb_encode();
    init_util();
    name = "dag-pb";
    code = 112;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/is.js
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf2 = typeof value;
  if (typeofs.includes(typeOf2)) {
    return typeOf2;
  }
  if (typeOf2 === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer(value)) {
    return "Buffer";
  }
  const objectType = getObjectType(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
var typeofs, objectTypeNames;
var init_is = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/is.js"() {
    typeofs = [
      "string",
      "number",
      "bigint",
      "symbol"
    ];
    objectTypeNames = [
      "Function",
      "Generator",
      "AsyncGenerator",
      "GeneratorFunction",
      "AsyncGeneratorFunction",
      "AsyncFunction",
      "Observable",
      "Array",
      "Buffer",
      "Object",
      "RegExp",
      "Date",
      "Error",
      "Map",
      "Set",
      "WeakMap",
      "WeakSet",
      "ArrayBuffer",
      "SharedArrayBuffer",
      "DataView",
      "Promise",
      "URL",
      "HTMLElement",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Uint16Array",
      "Int32Array",
      "Uint32Array",
      "Float32Array",
      "Float64Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/token.js
var Type, Token;
var init_token = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/token.js"() {
    Type = class {
      constructor(major, name20, terminal) {
        this.major = major;
        this.majorEncoded = major << 5;
        this.name = name20;
        this.terminal = terminal;
      }
      toString() {
        return `Type[${this.major}].${this.name}`;
      }
      compare(typ) {
        return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
      }
    };
    Type.uint = new Type(0, "uint", true);
    Type.negint = new Type(1, "negint", true);
    Type.bytes = new Type(2, "bytes", true);
    Type.string = new Type(3, "string", true);
    Type.array = new Type(4, "array", false);
    Type.map = new Type(5, "map", false);
    Type.tag = new Type(6, "tag", false);
    Type.float = new Type(7, "float", true);
    Type.false = new Type(7, "false", true);
    Type.true = new Type(7, "true", true);
    Type.null = new Type(7, "null", true);
    Type.undefined = new Type(7, "undefined", true);
    Type.break = new Type(7, "break", true);
    Token = class {
      constructor(type2, value, encodedLength) {
        this.type = type2;
        this.value = value;
        this.encodedLength = encodedLength;
        this.encodedBytes = void 0;
        this.byteValue = void 0;
      }
      toString() {
        return `Token[${this.type}].${this.value}`;
      }
    };
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/byte-utils.js
function isBuffer2(buf3) {
  return useBuffer && globalThis.Buffer.isBuffer(buf3);
}
function asU8A(buf3) {
  if (!(buf3 instanceof Uint8Array)) {
    return Uint8Array.from(buf3);
  }
  return isBuffer2(buf3) ? new Uint8Array(buf3.buffer, buf3.byteOffset, buf3.byteLength) : buf3;
}
function compare(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes(string4, units = Infinity) {
  let codePoint;
  const length5 = string4.length;
  let leadSurrogate = null;
  const bytes2 = [];
  for (let i = 0; i < length5; ++i) {
    codePoint = string4.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        } else if (i + 1 === length5) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes2.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes2.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes2.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes2.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes2.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes2;
}
function utf8Slice(buf3, offset2, end) {
  const res = [];
  while (offset2 < end) {
    const firstByte = buf3[offset2];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset2 + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf3[offset2 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf3[offset2 + 1];
          thirdByte = buf3[offset2 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf3[offset2 + 1];
          thirdByte = buf3[offset2 + 2];
          fourthByte = buf3[offset2 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset2 += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
var useBuffer, textDecoder2, textEncoder3, toString2, fromString2, fromArray, slice, concat, alloc, MAX_ARGUMENTS_LENGTH;
var init_byte_utils = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/byte-utils.js"() {
    useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
    textDecoder2 = new TextDecoder();
    textEncoder3 = new TextEncoder();
    toString2 = useBuffer ? (bytes2, start, end) => {
      return end - start > 64 ? globalThis.Buffer.from(bytes2.subarray(start, end)).toString("utf8") : utf8Slice(bytes2, start, end);
    } : (bytes2, start, end) => {
      return end - start > 64 ? textDecoder2.decode(bytes2.subarray(start, end)) : utf8Slice(bytes2, start, end);
    };
    fromString2 = useBuffer ? (string4) => {
      return string4.length > 64 ? globalThis.Buffer.from(string4) : utf8ToBytes(string4);
    } : (string4) => {
      return string4.length > 64 ? textEncoder3.encode(string4) : utf8ToBytes(string4);
    };
    fromArray = (arr) => {
      return Uint8Array.from(arr);
    };
    slice = useBuffer ? (bytes2, start, end) => {
      if (isBuffer2(bytes2)) {
        return new Uint8Array(bytes2.subarray(start, end));
      }
      return bytes2.slice(start, end);
    } : (bytes2, start, end) => {
      return bytes2.slice(start, end);
    };
    concat = useBuffer ? (chunks, length5) => {
      chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
      return asU8A(globalThis.Buffer.concat(chunks, length5));
    } : (chunks, length5) => {
      const out = new Uint8Array(length5);
      let off = 0;
      for (let b of chunks) {
        if (off + b.length > out.length) {
          b = b.subarray(0, out.length - off);
        }
        out.set(b, off);
        off += b.length;
      }
      return out;
    };
    alloc = useBuffer ? (size5) => {
      return globalThis.Buffer.allocUnsafe(size5);
    } : (size5) => {
      return new Uint8Array(size5);
    };
    MAX_ARGUMENTS_LENGTH = 4096;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/bl.js
var defaultChunkSize, Bl;
var init_bl = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/bl.js"() {
    init_byte_utils();
    defaultChunkSize = 256;
    Bl = class {
      constructor(chunkSize = defaultChunkSize) {
        this.chunkSize = chunkSize;
        this.cursor = 0;
        this.maxCursor = -1;
        this.chunks = [];
        this._initReuseChunk = null;
      }
      reset() {
        this.cursor = 0;
        this.maxCursor = -1;
        if (this.chunks.length) {
          this.chunks = [];
        }
        if (this._initReuseChunk !== null) {
          this.chunks.push(this._initReuseChunk);
          this.maxCursor = this._initReuseChunk.length - 1;
        }
      }
      push(bytes2) {
        let topChunk = this.chunks[this.chunks.length - 1];
        const newMax = this.cursor + bytes2.length;
        if (newMax <= this.maxCursor + 1) {
          const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
          topChunk.set(bytes2, chunkPos);
        } else {
          if (topChunk) {
            const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
            if (chunkPos < topChunk.length) {
              this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
              this.maxCursor = this.cursor - 1;
            }
          }
          if (bytes2.length < 64 && bytes2.length < this.chunkSize) {
            topChunk = alloc(this.chunkSize);
            this.chunks.push(topChunk);
            this.maxCursor += topChunk.length;
            if (this._initReuseChunk === null) {
              this._initReuseChunk = topChunk;
            }
            topChunk.set(bytes2, 0);
          } else {
            this.chunks.push(bytes2);
            this.maxCursor += bytes2.length;
          }
        }
        this.cursor += bytes2.length;
      }
      toBytes(reset = false) {
        let byts;
        if (this.chunks.length === 1) {
          const chunk = this.chunks[0];
          if (reset && this.cursor > chunk.length / 2) {
            byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
            this._initReuseChunk = null;
            this.chunks = [];
          } else {
            byts = slice(chunk, 0, this.cursor);
          }
        } else {
          byts = concat(this.chunks, this.cursor);
        }
        if (reset) {
          this.reset();
        }
        return byts;
      }
    };
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/common.js
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}
var decodeErrPrefix, encodeErrPrefix, uintMinorPrefixBytes;
var init_common = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/common.js"() {
    decodeErrPrefix = "CBOR decode error:";
    encodeErrPrefix = "CBOR encode error:";
    uintMinorPrefixBytes = [];
    uintMinorPrefixBytes[23] = 1;
    uintMinorPrefixBytes[24] = 2;
    uintMinorPrefixBytes[25] = 3;
    uintMinorPrefixBytes[26] = 5;
    uintMinorPrefixBytes[27] = 9;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/0uint.js
function readUint8(data, offset2, options) {
  assertEnoughData(data, offset2, 1);
  const value = data[offset2];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data, offset2, options) {
  assertEnoughData(data, offset2, 2);
  const value = data[offset2] << 8 | data[offset2 + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data, offset2, options) {
  assertEnoughData(data, offset2, 4);
  const value = data[offset2] * 16777216 + (data[offset2 + 1] << 16) + (data[offset2 + 2] << 8) + data[offset2 + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data, offset2, options) {
  assertEnoughData(data, offset2, 8);
  const hi = data[offset2] * 16777216 + (data[offset2 + 1] << 16) + (data[offset2 + 2] << 8) + data[offset2 + 3];
  const lo = data[offset2 + 4] * 16777216 + (data[offset2 + 5] << 16) + (data[offset2 + 6] << 8) + data[offset2 + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf3, token) {
  return encodeUintValue(buf3, 0, token.value);
}
function encodeUintValue(buf3, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf3.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf3.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf3.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf3.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set5 = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set5[8] = lo & 255;
      lo = lo >> 8;
      set5[7] = lo & 255;
      lo = lo >> 8;
      set5[6] = lo & 255;
      lo = lo >> 8;
      set5[5] = lo & 255;
      set5[4] = hi & 255;
      hi = hi >> 8;
      set5[3] = hi & 255;
      hi = hi >> 8;
      set5[2] = hi & 255;
      hi = hi >> 8;
      set5[1] = hi & 255;
      buf3.push(set5);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
var uintBoundaries;
var init_uint = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/0uint.js"() {
    init_token();
    init_common();
    uintBoundaries = [
      24,
      256,
      65536,
      4294967296,
      BigInt("18446744073709551616")
    ];
    encodeUint.encodedSize = function encodedSize(token) {
      return encodeUintValue.encodedSize(token.value);
    };
    encodeUintValue.encodedSize = function encodedSize2(uint) {
      if (uint < uintBoundaries[0]) {
        return 1;
      }
      if (uint < uintBoundaries[1]) {
        return 2;
      }
      if (uint < uintBoundaries[2]) {
        return 3;
      }
      if (uint < uintBoundaries[3]) {
        return 5;
      }
      return 9;
    };
    encodeUint.compareTokens = function compareTokens(tok1, tok2) {
      return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
    };
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/1negint.js
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
function decodeNegint64(data, pos, _minor, options) {
  const int = readUint64(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf3, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf3, token.type.majorEncoded, unsigned);
}
var neg1b, pos1b;
var init_negint = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/1negint.js"() {
    init_token();
    init_uint();
    init_common();
    neg1b = BigInt(-1);
    pos1b = BigInt(1);
    encodeNegint.encodedSize = function encodedSize3(token) {
      const negint = token.value;
      const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
      if (unsigned < uintBoundaries[0]) {
        return 1;
      }
      if (unsigned < uintBoundaries[1]) {
        return 2;
      }
      if (unsigned < uintBoundaries[2]) {
        return 3;
      }
      if (unsigned < uintBoundaries[3]) {
        return 5;
      }
      return 9;
    };
    encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
      return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
    };
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/2bytes.js
function toToken(data, pos, prefix2, length5) {
  assertEnoughData(data, pos, prefix2 + length5);
  const buf3 = slice(data, pos + prefix2, pos + prefix2 + length5);
  return new Token(Type.bytes, buf3, prefix2 + length5);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString2(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf3, token) {
  const bytes2 = tokenBytes(token);
  encodeUintValue(buf3, token.type.majorEncoded, bytes2.length);
  buf3.push(bytes2);
}
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
}
var init_bytes2 = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/2bytes.js"() {
    init_token();
    init_common();
    init_uint();
    init_byte_utils();
    encodeBytes.encodedSize = function encodedSize4(token) {
      const bytes2 = tokenBytes(token);
      return encodeUintValue.encodedSize(bytes2.length) + bytes2.length;
    };
    encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
      return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
    };
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/3string.js
function toToken2(data, pos, prefix2, length5, options) {
  const totLength = prefix2 + length5;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString2(data, pos + prefix2, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix2, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options) {
  return toToken2(data, pos, 1, minor, options);
}
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
function decodeString64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l, options);
}
var encodeString;
var init_string = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/3string.js"() {
    init_token();
    init_common();
    init_uint();
    init_bytes2();
    init_byte_utils();
    encodeString = encodeBytes;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/4array.js
function toToken3(_data, _pos, prefix2, length5) {
  return new Token(Type.array, length5, prefix2);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
function encodeArray(buf3, token) {
  encodeUintValue(buf3, Type.array.majorEncoded, token.value);
}
var init_array = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/4array.js"() {
    init_token();
    init_uint();
    init_common();
    encodeArray.compareTokens = encodeUint.compareTokens;
    encodeArray.encodedSize = function encodedSize5(token) {
      return encodeUintValue.encodedSize(token.value);
    };
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/5map.js
function toToken4(_data, _pos, prefix2, length5) {
  return new Token(Type.map, length5, prefix2);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
function encodeMap(buf3, token) {
  encodeUintValue(buf3, Type.map.majorEncoded, token.value);
}
var init_map = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/5map.js"() {
    init_token();
    init_uint();
    init_common();
    encodeMap.compareTokens = encodeUint.compareTokens;
    encodeMap.encodedSize = function encodedSize6(token) {
      return encodeUintValue.encodedSize(token.value);
    };
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/6tag.js
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf3, token) {
  encodeUintValue(buf3, Type.tag.majorEncoded, token.value);
}
var init_tag = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/6tag.js"() {
    init_token();
    init_uint();
    encodeTag.compareTokens = encodeUint.compareTokens;
    encodeTag.encodedSize = function encodedSize7(token) {
      return encodeUintValue.encodedSize(token.value);
    };
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/7float.js
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value, bytes2, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value, bytes2);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf3, token, options) {
  const float2 = token.value;
  if (float2 === false) {
    buf3.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float2 === true) {
    buf3.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float2 === null) {
    buf3.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float2 === void 0) {
    buf3.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float2);
      decoded = readFloat16(ui8a, 1);
      if (float2 === decoded || Number.isNaN(float2)) {
        ui8a[0] = 249;
        buf3.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float2);
        decoded = readFloat32(ui8a, 1);
        if (float2 === decoded) {
          ui8a[0] = 250;
          buf3.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float2);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf3.push(ui8a.slice(0, 9));
    }
  }
}
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a3, pos) {
  if (ui8a3.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a3[pos] << 8) + ui8a3[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a3, pos) {
  if (ui8a3.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset2 = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset2, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a3, pos) {
  if (ui8a3.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset2 = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset2, 8).getFloat64(0, false);
}
var MINOR_FALSE, MINOR_TRUE, MINOR_NULL, MINOR_UNDEFINED, buffer, dataView, ui8a;
var init_float = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/7float.js"() {
    init_token();
    init_common();
    init_uint();
    MINOR_FALSE = 20;
    MINOR_TRUE = 21;
    MINOR_NULL = 22;
    MINOR_UNDEFINED = 23;
    encodeFloat.encodedSize = function encodedSize8(token, options) {
      const float2 = token.value;
      if (float2 === false || float2 === true || float2 === null || float2 === void 0) {
        return 1;
      }
      if (!options || options.float64 !== true) {
        encodeFloat16(float2);
        let decoded = readFloat16(ui8a, 1);
        if (float2 === decoded || Number.isNaN(float2)) {
          return 3;
        }
        encodeFloat32(float2);
        decoded = readFloat32(ui8a, 1);
        if (float2 === decoded) {
          return 5;
        }
      }
      return 9;
    };
    buffer = new ArrayBuffer(9);
    dataView = new DataView(buffer, 1);
    ui8a = new Uint8Array(buffer, 0);
    encodeFloat.compareTokens = encodeUint.compareTokens;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/jump.js
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}
var jump, quick;
var init_jump = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/jump.js"() {
    init_token();
    init_uint();
    init_negint();
    init_bytes2();
    init_string();
    init_array();
    init_map();
    init_tag();
    init_float();
    init_common();
    init_byte_utils();
    jump = [];
    for (let i = 0; i <= 23; i++) {
      jump[i] = invalidMinor;
    }
    jump[24] = decodeUint8;
    jump[25] = decodeUint16;
    jump[26] = decodeUint32;
    jump[27] = decodeUint64;
    jump[28] = invalidMinor;
    jump[29] = invalidMinor;
    jump[30] = invalidMinor;
    jump[31] = invalidMinor;
    for (let i = 32; i <= 55; i++) {
      jump[i] = invalidMinor;
    }
    jump[56] = decodeNegint8;
    jump[57] = decodeNegint16;
    jump[58] = decodeNegint32;
    jump[59] = decodeNegint64;
    jump[60] = invalidMinor;
    jump[61] = invalidMinor;
    jump[62] = invalidMinor;
    jump[63] = invalidMinor;
    for (let i = 64; i <= 87; i++) {
      jump[i] = decodeBytesCompact;
    }
    jump[88] = decodeBytes8;
    jump[89] = decodeBytes16;
    jump[90] = decodeBytes32;
    jump[91] = decodeBytes64;
    jump[92] = invalidMinor;
    jump[93] = invalidMinor;
    jump[94] = invalidMinor;
    jump[95] = errorer("indefinite length bytes/strings are not supported");
    for (let i = 96; i <= 119; i++) {
      jump[i] = decodeStringCompact;
    }
    jump[120] = decodeString8;
    jump[121] = decodeString16;
    jump[122] = decodeString32;
    jump[123] = decodeString64;
    jump[124] = invalidMinor;
    jump[125] = invalidMinor;
    jump[126] = invalidMinor;
    jump[127] = errorer("indefinite length bytes/strings are not supported");
    for (let i = 128; i <= 151; i++) {
      jump[i] = decodeArrayCompact;
    }
    jump[152] = decodeArray8;
    jump[153] = decodeArray16;
    jump[154] = decodeArray32;
    jump[155] = decodeArray64;
    jump[156] = invalidMinor;
    jump[157] = invalidMinor;
    jump[158] = invalidMinor;
    jump[159] = decodeArrayIndefinite;
    for (let i = 160; i <= 183; i++) {
      jump[i] = decodeMapCompact;
    }
    jump[184] = decodeMap8;
    jump[185] = decodeMap16;
    jump[186] = decodeMap32;
    jump[187] = decodeMap64;
    jump[188] = invalidMinor;
    jump[189] = invalidMinor;
    jump[190] = invalidMinor;
    jump[191] = decodeMapIndefinite;
    for (let i = 192; i <= 215; i++) {
      jump[i] = decodeTagCompact;
    }
    jump[216] = decodeTag8;
    jump[217] = decodeTag16;
    jump[218] = decodeTag32;
    jump[219] = decodeTag64;
    jump[220] = invalidMinor;
    jump[221] = invalidMinor;
    jump[222] = invalidMinor;
    jump[223] = invalidMinor;
    for (let i = 224; i <= 243; i++) {
      jump[i] = errorer("simple values are not supported");
    }
    jump[244] = invalidMinor;
    jump[245] = invalidMinor;
    jump[246] = invalidMinor;
    jump[247] = decodeUndefined;
    jump[248] = errorer("simple values are not supported");
    jump[249] = decodeFloat16;
    jump[250] = decodeFloat32;
    jump[251] = decodeFloat64;
    jump[252] = invalidMinor;
    jump[253] = invalidMinor;
    jump[254] = invalidMinor;
    jump[255] = decodeBreak;
    quick = [];
    for (let i = 0; i < 24; i++) {
      quick[i] = new Token(Type.uint, i, 1);
    }
    for (let i = -1; i >= -24; i--) {
      quick[31 - i] = new Token(Type.negint, i, 1);
    }
    quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
    quick[96] = new Token(Type.string, "", 1);
    quick[128] = new Token(Type.array, 0, 1);
    quick[160] = new Token(Type.map, 0, 1);
    quick[244] = new Token(Type.false, false, 1);
    quick[245] = new Token(Type.true, true, 1);
    quick[246] = new Token(Type.null, null, 1);
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/encode.js
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries3, options) {
  if (options.mapSorter) {
    entries3.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf3, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf3, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf3, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder3 = encoders[tokens.type.major];
    if (encoder3.encodedSize) {
      const size5 = encoder3.encodedSize(tokens, options);
      const buf3 = new Bl(size5);
      encoder3(buf3, tokens, options);
      if (buf3.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf3.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode4(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}
var defaultEncodeOptions, cborEncoders, buf, Ref, simpleTokens, typeEncoders;
var init_encode = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/encode.js"() {
    init_is();
    init_token();
    init_bl();
    init_common();
    init_jump();
    init_byte_utils();
    init_uint();
    init_negint();
    init_bytes2();
    init_string();
    init_array();
    init_map();
    init_tag();
    init_float();
    defaultEncodeOptions = {
      float64: false,
      mapSorter,
      quickEncodeToken
    };
    cborEncoders = makeCborEncoders();
    buf = new Bl();
    Ref = class _Ref {
      constructor(obj, parent) {
        this.obj = obj;
        this.parent = parent;
      }
      includes(obj) {
        let p = this;
        do {
          if (p.obj === obj) {
            return true;
          }
        } while (p = p.parent);
        return false;
      }
      static createCheck(stack, obj) {
        if (stack && stack.includes(obj)) {
          throw new Error(`${encodeErrPrefix} object contains circular references`);
        }
        return new _Ref(obj, stack);
      }
    };
    simpleTokens = {
      null: new Token(Type.null, null),
      undefined: new Token(Type.undefined, void 0),
      true: new Token(Type.true, true),
      false: new Token(Type.false, false),
      emptyArray: new Token(Type.array, 0),
      emptyMap: new Token(Type.map, 0)
    };
    typeEncoders = {
      number(obj, _typ, _options, _refStack) {
        if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
          return new Token(Type.float, obj);
        } else if (obj >= 0) {
          return new Token(Type.uint, obj);
        } else {
          return new Token(Type.negint, obj);
        }
      },
      bigint(obj, _typ, _options, _refStack) {
        if (obj >= BigInt(0)) {
          return new Token(Type.uint, obj);
        } else {
          return new Token(Type.negint, obj);
        }
      },
      Uint8Array(obj, _typ, _options, _refStack) {
        return new Token(Type.bytes, obj);
      },
      string(obj, _typ, _options, _refStack) {
        return new Token(Type.string, obj);
      },
      boolean(obj, _typ, _options, _refStack) {
        return obj ? simpleTokens.true : simpleTokens.false;
      },
      null(_obj, _typ, _options, _refStack) {
        return simpleTokens.null;
      },
      undefined(_obj, _typ, _options, _refStack) {
        return simpleTokens.undefined;
      },
      ArrayBuffer(obj, _typ, _options, _refStack) {
        return new Token(Type.bytes, new Uint8Array(obj));
      },
      DataView(obj, _typ, _options, _refStack) {
        return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
      },
      Array(obj, _typ, options, refStack) {
        if (!obj.length) {
          if (options.addBreakTokens === true) {
            return [
              simpleTokens.emptyArray,
              new Token(Type.break)
            ];
          }
          return simpleTokens.emptyArray;
        }
        refStack = Ref.createCheck(refStack, obj);
        const entries3 = [];
        let i = 0;
        for (const e of obj) {
          entries3[i++] = objectToTokens(e, options, refStack);
        }
        if (options.addBreakTokens) {
          return [
            new Token(Type.array, obj.length),
            entries3,
            new Token(Type.break)
          ];
        }
        return [
          new Token(Type.array, obj.length),
          entries3
        ];
      },
      Object(obj, typ, options, refStack) {
        const isMap = typ !== "Object";
        const keys2 = isMap ? obj.keys() : Object.keys(obj);
        const length5 = isMap ? obj.size : keys2.length;
        if (!length5) {
          if (options.addBreakTokens === true) {
            return [
              simpleTokens.emptyMap,
              new Token(Type.break)
            ];
          }
          return simpleTokens.emptyMap;
        }
        refStack = Ref.createCheck(refStack, obj);
        const entries3 = [];
        let i = 0;
        for (const key of keys2) {
          entries3[i++] = [
            objectToTokens(key, options, refStack),
            objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
          ];
        }
        sortMapEntries(entries3, options);
        if (options.addBreakTokens) {
          return [
            new Token(Type.map, length5),
            entries3,
            new Token(Type.break)
          ];
        }
        return [
          new Token(Type.map, length5),
          entries3
        ];
      }
    };
    typeEncoders.Map = typeEncoders.Object;
    typeEncoders.Buffer = typeEncoders.Uint8Array;
    for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
      typeEncoders[`${typ}Array`] = typeEncoders.DataView;
    }
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/decode.js
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
      }
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decode6(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}
var defaultDecodeOptions, Tokeniser, DONE, BREAK;
var init_decode = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/decode.js"() {
    init_common();
    init_token();
    init_jump();
    defaultDecodeOptions = {
      strict: false,
      allowIndefinite: true,
      allowUndefined: true,
      allowBigInt: true
    };
    Tokeniser = class {
      constructor(data, options = {}) {
        this.pos = 0;
        this.data = data;
        this.options = options;
      }
      done() {
        return this.pos >= this.data.length;
      }
      next() {
        const byt = this.data[this.pos];
        let token = quick[byt];
        if (token === void 0) {
          const decoder3 = jump[byt];
          if (!decoder3) {
            throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
          }
          const minor = byt & 31;
          token = decoder3(this.data, this.pos, minor, this.options);
        }
        this.pos += token.encodedLength;
        return token;
      }
    };
    DONE = Symbol.for("DONE");
    BREAK = Symbol.for("BREAK");
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/cborg.js
var init_cborg = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/cborg.js"() {
    init_encode();
    init_decode();
    init_token();
  }
});

// ../../node_modules/.pnpm/@ipld+dag-cbor@7.0.3/node_modules/@ipld/dag-cbor/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  code: () => code2,
  decode: () => decode7,
  encode: () => encode5,
  name: () => name2
});
function cidEncoder(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes2)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
function cidDecoder(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes2.subarray(1));
}
var CID_CBOR_TAG, encodeOptions, decodeOptions, name2, code2, encode5, decode7;
var init_esm = __esm({
  "../../node_modules/.pnpm/@ipld+dag-cbor@7.0.3/node_modules/@ipld/dag-cbor/esm/index.js"() {
    init_cborg();
    init_cid();
    CID_CBOR_TAG = 42;
    encodeOptions = {
      float64: true,
      typeEncoders: {
        Object: cidEncoder,
        undefined: undefinedEncoder,
        number: numberEncoder
      }
    };
    decodeOptions = {
      allowIndefinite: false,
      coerceUndefinedToNull: true,
      allowNaN: false,
      allowInfinity: false,
      allowBigInt: true,
      strict: true,
      useMaps: false,
      tags: []
    };
    decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
    name2 = "dag-cbor";
    code2 = 113;
    encode5 = (node) => encode4(node, encodeOptions);
    decode7 = (data) => decode6(data, decodeOptions);
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/hasher.js
var from2, Hasher;
var init_hasher = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/hasher.js"() {
    init_digest();
    from2 = ({ name: name20, code: code25, encode: encode45 }) => new Hasher(name20, code25, encode45);
    Hasher = class {
      constructor(name20, code25, encode45) {
        this.name = name20;
        this.code = code25;
        this.encode = encode45;
      }
      digest(input10) {
        if (input10 instanceof Uint8Array) {
          const result = this.encode(input10);
          return result instanceof Uint8Array ? create(this.code, result) : result.then((digest6) => create(this.code, digest6));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/index.js
var init_src2 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/index.js"() {
    init_cid();
    init_varint2();
    init_bytes();
    init_hasher();
    init_digest();
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64, base64pad, base64url, base64urlpad;
var init_base64 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base64.js"() {
    init_base();
    base64 = rfc4648({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    base64pad = rfc4648({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    base64url = rfc4648({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    base64urlpad = rfc4648({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/json/encode.js
function mapSorter2(e1, e2) {
  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {
    throw new Error(`${encodeErrPrefix} complex map keys are not supported`);
  }
  const keyToken1 = e1[0];
  const keyToken2 = e2[0];
  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {
    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`);
  }
  if (keyToken1 < keyToken2) {
    return -1;
  }
  if (keyToken1 > keyToken2) {
    return 1;
  }
  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`);
}
function encode6(data, options) {
  options = Object.assign({}, defaultEncodeOptions2, options);
  return encodeCustom(data, new JSONEncoder(), options);
}
var JSONEncoder, defaultEncodeOptions2;
var init_encode2 = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/json/encode.js"() {
    init_token();
    init_encode();
    init_common();
    init_byte_utils();
    JSONEncoder = class extends Array {
      constructor() {
        super();
        this.inRecursive = [];
      }
      prefix(buf3) {
        const recurs = this.inRecursive[this.inRecursive.length - 1];
        if (recurs) {
          if (recurs.type === Type.array) {
            recurs.elements++;
            if (recurs.elements !== 1) {
              buf3.push([44]);
            }
          }
          if (recurs.type === Type.map) {
            recurs.elements++;
            if (recurs.elements !== 1) {
              if (recurs.elements % 2 === 1) {
                buf3.push([44]);
              } else {
                buf3.push([58]);
              }
            }
          }
        }
      }
      [Type.uint.major](buf3, token) {
        this.prefix(buf3);
        const is3 = String(token.value);
        const isa = [];
        for (let i = 0; i < is3.length; i++) {
          isa[i] = is3.charCodeAt(i);
        }
        buf3.push(isa);
      }
      [Type.negint.major](buf3, token) {
        this[Type.uint.major](buf3, token);
      }
      [Type.bytes.major](_buf, _token) {
        throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`);
      }
      [Type.string.major](buf3, token) {
        this.prefix(buf3);
        const byts = fromString2(JSON.stringify(token.value));
        buf3.push(byts.length > 32 ? asU8A(byts) : byts);
      }
      [Type.array.major](buf3, _token) {
        this.prefix(buf3);
        this.inRecursive.push({
          type: Type.array,
          elements: 0
        });
        buf3.push([91]);
      }
      [Type.map.major](buf3, _token) {
        this.prefix(buf3);
        this.inRecursive.push({
          type: Type.map,
          elements: 0
        });
        buf3.push([123]);
      }
      [Type.tag.major](_buf, _token) {
      }
      [Type.float.major](buf3, token) {
        if (token.type.name === "break") {
          const recurs = this.inRecursive.pop();
          if (recurs) {
            if (recurs.type === Type.array) {
              buf3.push([93]);
            } else if (recurs.type === Type.map) {
              buf3.push([125]);
            } else {
              throw new Error("Unexpected recursive type; this should not happen!");
            }
            return;
          }
          throw new Error("Unexpected break; this should not happen!");
        }
        if (token.value === void 0) {
          throw new Error(`${encodeErrPrefix} unsupported type: undefined`);
        }
        this.prefix(buf3);
        if (token.type.name === "true") {
          buf3.push([
            116,
            114,
            117,
            101
          ]);
          return;
        } else if (token.type.name === "false") {
          buf3.push([
            102,
            97,
            108,
            115,
            101
          ]);
          return;
        } else if (token.type.name === "null") {
          buf3.push([
            110,
            117,
            108,
            108
          ]);
          return;
        }
        const is3 = String(token.value);
        const isa = [];
        let dp = false;
        for (let i = 0; i < is3.length; i++) {
          isa[i] = is3.charCodeAt(i);
          if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {
            dp = true;
          }
        }
        if (!dp) {
          isa.push(46);
          isa.push(48);
        }
        buf3.push(isa);
      }
    };
    defaultEncodeOptions2 = {
      addBreakTokens: true,
      mapSorter: mapSorter2
    };
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/json/decode.js
function decode8(data, options) {
  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options);
  return decode6(data, options);
}
var Tokenizer;
var init_decode2 = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/json/decode.js"() {
    init_decode();
    init_token();
    init_byte_utils();
    init_common();
    Tokenizer = class {
      constructor(data, options = {}) {
        this.pos = 0;
        this.data = data;
        this.options = options;
        this.modeStack = ["value"];
        this.lastToken = "";
      }
      done() {
        return this.pos >= this.data.length;
      }
      ch() {
        return this.data[this.pos];
      }
      currentMode() {
        return this.modeStack[this.modeStack.length - 1];
      }
      skipWhitespace() {
        let c = this.ch();
        while (c === 32 || c === 9 || c === 13 || c === 10) {
          c = this.data[++this.pos];
        }
      }
      expect(str) {
        if (this.data.length - this.pos < str.length) {
          throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this.pos}`);
        }
        for (let i = 0; i < str.length; i++) {
          if (this.data[this.pos++] !== str[i]) {
            throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}, expected to find '${String.fromCharCode(...str)}'`);
          }
        }
      }
      parseNumber() {
        const startPos = this.pos;
        let negative = false;
        let float2 = false;
        const swallow = (chars) => {
          while (!this.done()) {
            const ch = this.ch();
            if (chars.includes(ch)) {
              this.pos++;
            } else {
              break;
            }
          }
        };
        if (this.ch() === 45) {
          negative = true;
          this.pos++;
        }
        if (this.ch() === 48) {
          this.pos++;
          if (this.ch() === 46) {
            this.pos++;
            float2 = true;
          } else {
            return new Token(Type.uint, 0, this.pos - startPos);
          }
        }
        swallow([
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57
        ]);
        if (negative && this.pos === startPos + 1) {
          throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);
        }
        if (!this.done() && this.ch() === 46) {
          if (float2) {
            throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);
          }
          float2 = true;
          this.pos++;
          swallow([
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57
          ]);
        }
        if (!this.done() && (this.ch() === 101 || this.ch() === 69)) {
          float2 = true;
          this.pos++;
          if (!this.done() && (this.ch() === 43 || this.ch() === 45)) {
            this.pos++;
          }
          swallow([
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57
          ]);
        }
        const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this.pos));
        const num = parseFloat(numStr);
        if (float2) {
          return new Token(Type.float, num, this.pos - startPos);
        }
        if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {
          return new Token(num >= 0 ? Type.uint : Type.negint, num, this.pos - startPos);
        }
        return new Token(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this.pos - startPos);
      }
      parseString() {
        if (this.ch() !== 34) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}; this shouldn't happen`);
        }
        this.pos++;
        for (let i = this.pos, l = 0; i < this.data.length && l < 65536; i++, l++) {
          const ch = this.data[i];
          if (ch === 92 || ch < 32 || ch >= 128) {
            break;
          }
          if (ch === 34) {
            const str = String.fromCharCode.apply(null, this.data.subarray(this.pos, i));
            this.pos = i + 1;
            return new Token(Type.string, str, l);
          }
        }
        const startPos = this.pos;
        const chars = [];
        const readu4 = () => {
          if (this.pos + 4 >= this.data.length) {
            throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this.pos}`);
          }
          let u4 = 0;
          for (let i = 0; i < 4; i++) {
            let ch = this.ch();
            if (ch >= 48 && ch <= 57) {
              ch -= 48;
            } else if (ch >= 97 && ch <= 102) {
              ch = ch - 97 + 10;
            } else if (ch >= 65 && ch <= 70) {
              ch = ch - 65 + 10;
            } else {
              throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this.pos}`);
            }
            u4 = u4 * 16 + ch;
            this.pos++;
          }
          return u4;
        };
        const readUtf8Char = () => {
          const firstByte = this.ch();
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (this.pos + bytesPerSequence > this.data.length) {
            throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this.pos}`);
          }
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = this.data[this.pos + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = this.data[this.pos + 1];
              thirdByte = this.data[this.pos + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = this.data[this.pos + 1];
              thirdByte = this.data[this.pos + 2];
              fourthByte = this.data[this.pos + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            chars.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          chars.push(codePoint);
          this.pos += bytesPerSequence;
        };
        while (!this.done()) {
          const ch = this.ch();
          let ch1;
          switch (ch) {
            case 92:
              this.pos++;
              if (this.done()) {
                throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this.pos}`);
              }
              ch1 = this.ch();
              this.pos++;
              switch (ch1) {
                case 34:
                case 39:
                case 92:
                case 47:
                  chars.push(ch1);
                  break;
                case 98:
                  chars.push(8);
                  break;
                case 116:
                  chars.push(9);
                  break;
                case 110:
                  chars.push(10);
                  break;
                case 102:
                  chars.push(12);
                  break;
                case 114:
                  chars.push(13);
                  break;
                case 117:
                  chars.push(readu4());
                  break;
                default:
                  throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this.pos}`);
              }
              break;
            case 34:
              this.pos++;
              return new Token(Type.string, decodeCodePointsArray(chars), this.pos - startPos);
            default:
              if (ch < 32) {
                throw new Error(`${decodeErrPrefix} invalid control character at position ${this.pos}`);
              } else if (ch < 128) {
                chars.push(ch);
                this.pos++;
              } else {
                readUtf8Char();
              }
          }
        }
        throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this.pos}`);
      }
      parseValue() {
        switch (this.ch()) {
          case 123:
            this.modeStack.push("obj-start");
            this.pos++;
            return new Token(Type.map, Infinity, 1);
          case 91:
            this.modeStack.push("array-start");
            this.pos++;
            return new Token(Type.array, Infinity, 1);
          case 34: {
            return this.parseString();
          }
          case 110:
            this.expect([
              110,
              117,
              108,
              108
            ]);
            return new Token(Type.null, null, 4);
          case 102:
            this.expect([
              102,
              97,
              108,
              115,
              101
            ]);
            return new Token(Type.false, false, 5);
          case 116:
            this.expect([
              116,
              114,
              117,
              101
            ]);
            return new Token(Type.true, true, 4);
          case 45:
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.parseNumber();
          default:
            throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}`);
        }
      }
      next() {
        this.skipWhitespace();
        switch (this.currentMode()) {
          case "value":
            this.modeStack.pop();
            return this.parseValue();
          case "array-value": {
            this.modeStack.pop();
            if (this.ch() === 93) {
              this.pos++;
              this.skipWhitespace();
              return new Token(Type.break, void 0, 1);
            }
            if (this.ch() !== 44) {
              throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
            }
            this.pos++;
            this.modeStack.push("array-value");
            this.skipWhitespace();
            return this.parseValue();
          }
          case "array-start": {
            this.modeStack.pop();
            if (this.ch() === 93) {
              this.pos++;
              this.skipWhitespace();
              return new Token(Type.break, void 0, 1);
            }
            this.modeStack.push("array-value");
            this.skipWhitespace();
            return this.parseValue();
          }
          case "obj-key":
            if (this.ch() === 125) {
              this.modeStack.pop();
              this.pos++;
              this.skipWhitespace();
              return new Token(Type.break, void 0, 1);
            }
            if (this.ch() !== 44) {
              throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
            }
            this.pos++;
            this.skipWhitespace();
          case "obj-start": {
            this.modeStack.pop();
            if (this.ch() === 125) {
              this.pos++;
              this.skipWhitespace();
              return new Token(Type.break, void 0, 1);
            }
            const token = this.parseString();
            this.skipWhitespace();
            if (this.ch() !== 58) {
              throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
            }
            this.pos++;
            this.modeStack.push("obj-value");
            return token;
          }
          case "obj-value": {
            this.modeStack.pop();
            this.modeStack.push("obj-key");
            this.skipWhitespace();
            return this.parseValue();
          }
          default:
            throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this.pos}; this shouldn't happen`);
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/json/json.js
var init_json = __esm({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/json/json.js"() {
    init_encode2();
    init_decode2();
  }
});

// ../../node_modules/.pnpm/@ipld+dag-json@8.0.11/node_modules/@ipld/dag-json/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  code: () => code3,
  decode: () => decode9,
  encode: () => encode7,
  name: () => name3
});
function cidEncoder2(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const cidString = cid.toString();
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    new Token(Type.string, cidString, cidString.length),
    new Token(Type.break, void 0, 1)
  ];
}
function bytesEncoder(bytes2) {
  const bytesString = base64.encode(bytes2).slice(1);
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "bytes", 5),
    new Token(Type.string, bytesString, bytesString.length),
    new Token(Type.break, void 0, 1),
    new Token(Type.break, void 0, 1)
  ];
}
function undefinedEncoder2() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder2(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions2, DagJsonTokenizer, decodeOptions2, name3, code3, encode7, decode9;
var init_esm2 = __esm({
  "../../node_modules/.pnpm/@ipld+dag-json@8.0.11/node_modules/@ipld/dag-json/esm/index.js"() {
    init_src2();
    init_base64();
    init_cborg();
    init_json();
    encodeOptions2 = {
      typeEncoders: {
        Object: cidEncoder2,
        Uint8Array: bytesEncoder,
        Buffer: bytesEncoder,
        undefined: undefinedEncoder2,
        number: numberEncoder2
      }
    };
    DagJsonTokenizer = class extends Tokenizer {
      constructor(data, options) {
        super(data, options);
        this.tokenBuffer = [];
      }
      done() {
        return this.tokenBuffer.length === 0 && super.done();
      }
      _next() {
        if (this.tokenBuffer.length > 0) {
          return this.tokenBuffer.pop();
        }
        return super.next();
      }
      next() {
        const token = this._next();
        if (token.type === Type.map) {
          const keyToken = this._next();
          if (keyToken.type === Type.string && keyToken.value === "/") {
            const valueToken = this._next();
            if (valueToken.type === Type.string) {
              const breakToken = this._next();
              if (breakToken.type !== Type.break) {
                throw new Error("Invalid encoded CID form");
              }
              this.tokenBuffer.push(valueToken);
              return new Token(Type.tag, 42, 0);
            }
            if (valueToken.type === Type.map) {
              const innerKeyToken = this._next();
              if (innerKeyToken.type === Type.string && innerKeyToken.value === "bytes") {
                const innerValueToken = this._next();
                if (innerValueToken.type === Type.string) {
                  for (let i = 0; i < 2; i++) {
                    const breakToken = this._next();
                    if (breakToken.type !== Type.break) {
                      throw new Error("Invalid encoded Bytes form");
                    }
                  }
                  const bytes2 = base64.decode(`m${innerValueToken.value}`);
                  return new Token(Type.bytes, bytes2, innerValueToken.value.length);
                }
                this.tokenBuffer.push(innerValueToken);
              }
              this.tokenBuffer.push(innerKeyToken);
            }
            this.tokenBuffer.push(valueToken);
          }
          this.tokenBuffer.push(keyToken);
        }
        return token;
      }
    };
    decodeOptions2 = {
      allowIndefinite: false,
      allowUndefined: false,
      allowNaN: false,
      allowInfinity: false,
      allowBigInt: true,
      strict: true,
      useMaps: false,
      tags: []
    };
    decodeOptions2.tags[42] = CID.parse;
    name3 = "dag-json";
    code3 = 297;
    encode7 = (node) => encode6(node, encodeOptions2);
    decode9 = (data) => {
      const options = Object.assign(decodeOptions2, { tokenizer: new DagJsonTokenizer(data, decodeOptions2) });
      return decode8(data, options);
    };
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/vendor/base-x.js
var require_base_x = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/vendor/base-x.js"(exports2, module2) {
    "use strict";
    function base6(ALPHABET, name20) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode45(source) {
        if (source instanceof Uint8Array) ;
        else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length5 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size5 = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size5);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size5 - 1; (carry !== 0 || i2 < length5) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length5 = i2;
          pbegin++;
        }
        var it2 = size5 - length5;
        while (it2 !== size5 && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size5; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length5 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size5 = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size5);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size5 - 1; (carry !== 0 || i2 < length5) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length5 = i2;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size5 - length5;
        while (it4 !== size5 && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size5 - it4));
        var j2 = zeroes;
        while (it4 !== size5) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode53(string4) {
        var buffer3 = decodeUnsafe(string4);
        if (buffer3) {
          return buffer3;
        }
        throw new Error(`Non-${name20} character`);
      }
      return {
        encode: encode45,
        decodeUnsafe,
        decode: decode53
      };
    }
    var src5 = base6;
    var _brrp__multiformats_scope_baseX5 = src5;
    module2.exports = _brrp__multiformats_scope_baseX5;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bytes.js
var require_bytes = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bytes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var empty10 = new Uint8Array(0);
    var toHex2 = (d) => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
    var fromHex2 = (hex) => {
      const hexes2 = hex.match(/../g);
      return hexes2 ? new Uint8Array(hexes2.map((b) => parseInt(b, 16))) : empty10;
    };
    var equals10 = (aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    var coerce5 = (o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
        return o;
      if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    var isBinary2 = (o) => o instanceof ArrayBuffer || ArrayBuffer.isView(o);
    var fromString7 = (str) => new TextEncoder().encode(str);
    var toString8 = (b) => new TextDecoder().decode(b);
    exports2.coerce = coerce5;
    exports2.empty = empty10;
    exports2.equals = equals10;
    exports2.fromHex = fromHex2;
    exports2.fromString = fromString7;
    exports2.isBinary = isBinary2;
    exports2.toHex = toHex2;
    exports2.toString = toString8;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base.js
var require_base = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var baseX$1 = require_base_x();
    var bytes2 = require_bytes();
    var Encoder5 = class {
      constructor(name20, prefix2, baseEncode) {
        this.name = name20;
        this.prefix = prefix2;
        this.baseEncode = baseEncode;
      }
      encode(bytes3) {
        if (bytes3 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes3)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    var Decoder5 = class {
      constructor(name20, prefix2, baseDecode) {
        this.name = name20;
        this.prefix = prefix2;
        if (prefix2.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix2.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text2) {
        if (typeof text2 === "string") {
          if (text2.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text2.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder3) {
        return or14(this, decoder3);
      }
    };
    var ComposedDecoder5 = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder3) {
        return or14(this, decoder3);
      }
      decode(input10) {
        const prefix2 = input10[0];
        const decoder3 = this.decoders[prefix2];
        if (decoder3) {
          return decoder3.decode(input10);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input10)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    var or14 = (left, right) => new ComposedDecoder5({
      ...left.decoders || { [left.prefix]: left },
      ...right.decoders || { [right.prefix]: right }
    });
    var Codec5 = class {
      constructor(name20, prefix2, baseEncode, baseDecode) {
        this.name = name20;
        this.prefix = prefix2;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder5(name20, prefix2, baseEncode);
        this.decoder = new Decoder5(name20, prefix2, baseDecode);
      }
      encode(input10) {
        return this.encoder.encode(input10);
      }
      decode(input10) {
        return this.decoder.decode(input10);
      }
    };
    var from21 = ({ name: name20, prefix: prefix2, encode: encode46, decode: decode54 }) => new Codec5(name20, prefix2, encode46, decode54);
    var baseX5 = ({ prefix: prefix2, name: name20, alphabet: alphabet3 }) => {
      const { encode: encode46, decode: decode54 } = baseX$1(alphabet3, name20);
      return from21({
        prefix: prefix2,
        name: name20,
        encode: encode46,
        decode: (text2) => bytes2.coerce(decode54(text2))
      });
    };
    var decode53 = (string4, alphabet3, bitsPerChar, name20) => {
      const codes = {};
      for (let i = 0; i < alphabet3.length; ++i) {
        codes[alphabet3[i]] = i;
      }
      let end = string4.length;
      while (string4[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer3 = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string4[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name20} character`);
        }
        buffer3 = buffer3 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer3 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer3 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    var encode45 = (data, alphabet3, bitsPerChar) => {
      const pad2 = alphabet3[alphabet3.length - 1] === "=";
      const mask2 = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer3 = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer3 = buffer3 << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet3[mask2 & buffer3 >> bits];
        }
      }
      if (bits) {
        out += alphabet3[mask2 & buffer3 << bitsPerChar - bits];
      }
      if (pad2) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    var rfc46485 = ({ name: name20, prefix: prefix2, bitsPerChar, alphabet: alphabet3 }) => {
      return from21({
        prefix: prefix2,
        name: name20,
        encode(input10) {
          return encode45(input10, alphabet3, bitsPerChar);
        },
        decode(input10) {
          return decode53(input10, alphabet3, bitsPerChar, name20);
        }
      });
    };
    exports2.Codec = Codec5;
    exports2.baseX = baseX5;
    exports2.from = from21;
    exports2.or = or14;
    exports2.rfc4648 = rfc46485;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base64.js
var require_base64 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var base644 = base6.rfc4648({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    var base64pad4 = base6.rfc4648({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    var base64url4 = base6.rfc4648({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    var base64urlpad4 = base6.rfc4648({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
    exports2.base64 = base644;
    exports2.base64pad = base64pad4;
    exports2.base64url = base64url4;
    exports2.base64urlpad = base64urlpad4;
  }
});

// ../../node_modules/.pnpm/dag-jose@1.0.0/node_modules/dag-jose/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/dag-jose@1.0.0/node_modules/dag-jose/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromBase64url = exports2.toBase64url = void 0;
    var base64_1 = require_base64();
    function toBase64url(b) {
      return base64_1.base64url.encode(b).slice(1);
    }
    exports2.toBase64url = toBase64url;
    function fromBase64url(s) {
      return base64_1.base64url.decode(`u${s}`);
    }
    exports2.fromBase64url = fromBase64url;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/vendor/varint.js
var require_varint = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/vendor/varint.js"(exports2, module2) {
    "use strict";
    var encode_15 = encode45;
    var MSB6 = 128;
    var REST6 = 127;
    var MSBALL6 = ~REST6;
    var INT6 = Math.pow(2, 31);
    function encode45(num, out, offset2) {
      out = out || [];
      offset2 = offset2 || 0;
      var oldOffset = offset2;
      while (num >= INT6) {
        out[offset2++] = num & 255 | MSB6;
        num /= 128;
      }
      while (num & MSBALL6) {
        out[offset2++] = num & 255 | MSB6;
        num >>>= 7;
      }
      out[offset2] = num | 0;
      encode45.bytes = offset2 - oldOffset + 1;
      return out;
    }
    var decode53 = read10;
    var MSB$15 = 128;
    var REST$15 = 127;
    function read10(buf3, offset2) {
      var res = 0, offset2 = offset2 || 0, shift = 0, counter = offset2, b, l = buf3.length;
      do {
        if (counter >= l) {
          read10.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf3[counter++];
        res += shift < 28 ? (b & REST$15) << shift : (b & REST$15) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB$15);
      read10.bytes = counter - offset2;
      return res;
    }
    var N15 = Math.pow(2, 7);
    var N25 = Math.pow(2, 14);
    var N35 = Math.pow(2, 21);
    var N45 = Math.pow(2, 28);
    var N55 = Math.pow(2, 35);
    var N65 = Math.pow(2, 42);
    var N75 = Math.pow(2, 49);
    var N85 = Math.pow(2, 56);
    var N95 = Math.pow(2, 63);
    var length5 = function(value) {
      return value < N15 ? 1 : value < N25 ? 2 : value < N35 ? 3 : value < N45 ? 4 : value < N55 ? 5 : value < N65 ? 6 : value < N75 ? 7 : value < N85 ? 8 : value < N95 ? 9 : 10;
    };
    var varint9 = {
      encode: encode_15,
      decode: decode53,
      encodingLength: length5
    };
    var _brrp_varint5 = varint9;
    var varint$1 = _brrp_varint5;
    module2.exports = varint$1;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/varint.js
var require_varint2 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/varint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var varint$1 = require_varint();
    var decode53 = (data, offset2 = 0) => {
      const code25 = varint$1.decode(data, offset2);
      return [
        code25,
        varint$1.decode.bytes
      ];
    };
    var encodeTo6 = (int, target, offset2 = 0) => {
      varint$1.encode(int, target, offset2);
      return target;
    };
    var encodingLength6 = (int) => {
      return varint$1.encodingLength(int);
    };
    exports2.decode = decode53;
    exports2.encodeTo = encodeTo6;
    exports2.encodingLength = encodingLength6;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/digest.js
var require_digest2 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/digest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bytes2 = require_bytes();
    var varint9 = require_varint2();
    var create21 = (code25, digest6) => {
      const size5 = digest6.byteLength;
      const sizeOffset = varint9.encodingLength(code25);
      const digestOffset = sizeOffset + varint9.encodingLength(size5);
      const bytes3 = new Uint8Array(digestOffset + size5);
      varint9.encodeTo(code25, bytes3, 0);
      varint9.encodeTo(size5, bytes3, sizeOffset);
      bytes3.set(digest6, digestOffset);
      return new Digest7(code25, size5, digest6, bytes3);
    };
    var decode53 = (multihash) => {
      const bytes$1 = bytes2.coerce(multihash);
      const [code25, sizeOffset] = varint9.decode(bytes$1);
      const [size5, digestOffset] = varint9.decode(bytes$1.subarray(sizeOffset));
      const digest6 = bytes$1.subarray(sizeOffset + digestOffset);
      if (digest6.byteLength !== size5) {
        throw new Error("Incorrect length");
      }
      return new Digest7(code25, size5, digest6, bytes$1);
    };
    var equals10 = (a, b) => {
      if (a === b) {
        return true;
      } else {
        return a.code === b.code && a.size === b.size && bytes2.equals(a.bytes, b.bytes);
      }
    };
    var Digest7 = class {
      constructor(code25, size5, digest6, bytes3) {
        this.code = code25;
        this.size = size5;
        this.digest = digest6;
        this.bytes = bytes3;
      }
    };
    exports2.Digest = Digest7;
    exports2.create = create21;
    exports2.decode = decode53;
    exports2.equals = equals10;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base58.js
var require_base58 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base58.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var base58btc5 = base6.baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    var base58flickr5 = base6.baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
    exports2.base58btc = base58btc5;
    exports2.base58flickr = base58flickr5;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base32.js
var require_base32 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base32.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var base325 = base6.rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    var base32upper5 = base6.rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    var base32pad5 = base6.rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    var base32padupper5 = base6.rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    var base32hex5 = base6.rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    var base32hexupper5 = base6.rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    var base32hexpad5 = base6.rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    var base32hexpadupper5 = base6.rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    var base32z5 = base6.rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
    exports2.base32 = base325;
    exports2.base32hex = base32hex5;
    exports2.base32hexpad = base32hexpad5;
    exports2.base32hexpadupper = base32hexpadupper5;
    exports2.base32hexupper = base32hexupper5;
    exports2.base32pad = base32pad5;
    exports2.base32padupper = base32padupper5;
    exports2.base32upper = base32upper5;
    exports2.base32z = base32z5;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/cid.js
var require_cid = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/cid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var varint9 = require_varint2();
    var digest6 = require_digest2();
    var base58 = require_base58();
    var base325 = require_base32();
    var bytes2 = require_bytes();
    var CID5 = class _CID {
      constructor(version4, code25, multihash, bytes3) {
        this.code = code25;
        this.version = version4;
        this.multihash = multihash;
        this.bytes = bytes3;
        this.byteOffset = bytes3.byteOffset;
        this.byteLength = bytes3.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden2,
          byteLength: hidden2,
          code: readonly3,
          version: readonly3,
          multihash: readonly3,
          bytes: readonly3,
          _baseCache: hidden2,
          asCID: hidden2
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code25, multihash } = this;
            if (code25 !== DAG_PB_CODE7) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE5) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return _CID.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code25, digest: digest$1 } = this.multihash;
            const multihash = digest6.create(code25, digest$1);
            return _CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && digest6.equals(this.multihash, other.multihash);
      }
      toString(base6) {
        const { bytes: bytes3, version: version4, _baseCache } = this;
        switch (version4) {
          case 0:
            return toStringV05(bytes3, _baseCache, base6 || base58.base58btc.encoder);
          default:
            return toStringV15(bytes3, _baseCache, base6 || base325.base32.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate2(/^0\.0/, IS_CID_DEPRECATION2);
        return !!(value && (value[cidSymbol5] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof _CID) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version4, code: code25, multihash, bytes: bytes3 } = value;
          return new _CID(version4, code25, multihash, bytes3 || encodeCID6(version4, code25, multihash.bytes));
        } else if (value != null && value[cidSymbol5] === true) {
          const { version: version4, multihash, code: code25 } = value;
          const digest$1 = digest6.decode(multihash);
          return _CID.create(version4, code25, digest$1);
        } else {
          return null;
        }
      }
      static create(version4, code25, digest7) {
        if (typeof code25 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version4) {
          case 0: {
            if (code25 !== DAG_PB_CODE7) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE7}) block encoding`);
            } else {
              return new _CID(version4, code25, digest7, digest7.bytes);
            }
          }
          case 1: {
            const bytes3 = encodeCID6(version4, code25, digest7.bytes);
            return new _CID(version4, code25, digest7, bytes3);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest7) {
        return _CID.create(0, DAG_PB_CODE7, digest7);
      }
      static createV1(code25, digest7) {
        return _CID.create(1, code25, digest7);
      }
      static decode(bytes3) {
        const [cid, remainder] = _CID.decodeFirst(bytes3);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes$1) {
        const specs = _CID.inspectBytes(bytes$1);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = bytes2.coerce(bytes$1.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest$1 = new digest6.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? _CID.createV0(digest$1) : _CID.createV1(specs.codec, digest$1);
        return [
          cid,
          bytes$1.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset2 = 0;
        const next = () => {
          const [i, length5] = varint9.decode(initialBytes.subarray(offset2));
          offset2 += length5;
          return i;
        };
        let version4 = next();
        let codec = DAG_PB_CODE7;
        if (version4 === 18) {
          version4 = 0;
          offset2 = 0;
        } else if (version4 === 1) {
          codec = next();
        }
        if (version4 !== 0 && version4 !== 1) {
          throw new RangeError(`Invalid CID version ${version4}`);
        }
        const prefixSize = offset2;
        const multihashCode = next();
        const digestSize = next();
        const size5 = offset2 + digestSize;
        const multihashSize = size5 - prefixSize;
        return {
          version: version4,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size: size5
        };
      }
      static parse(source, base6) {
        const [prefix2, bytes3] = parseCIDtoBytes5(source, base6);
        const cid = _CID.decode(bytes3);
        cid._baseCache.set(prefix2, source);
        return cid;
      }
    };
    var parseCIDtoBytes5 = (source, base6) => {
      switch (source[0]) {
        case "Q": {
          const decoder3 = base6 || base58.base58btc;
          return [
            base58.base58btc.prefix,
            decoder3.decode(`${base58.base58btc.prefix}${source}`)
          ];
        }
        case base58.base58btc.prefix: {
          const decoder3 = base6 || base58.base58btc;
          return [
            base58.base58btc.prefix,
            decoder3.decode(source)
          ];
        }
        case base325.base32.prefix: {
          const decoder3 = base6 || base325.base32;
          return [
            base325.base32.prefix,
            decoder3.decode(source)
          ];
        }
        default: {
          if (base6 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base6.decode(source)
          ];
        }
      }
    };
    var toStringV05 = (bytes3, cache5, base6) => {
      const { prefix: prefix2 } = base6;
      if (prefix2 !== base58.base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base6.name} encoding`);
      }
      const cid = cache5.get(prefix2);
      if (cid == null) {
        const cid2 = base6.encode(bytes3).slice(1);
        cache5.set(prefix2, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    var toStringV15 = (bytes3, cache5, base6) => {
      const { prefix: prefix2 } = base6;
      const cid = cache5.get(prefix2);
      if (cid == null) {
        const cid2 = base6.encode(bytes3);
        cache5.set(prefix2, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    var DAG_PB_CODE7 = 112;
    var SHA_256_CODE5 = 18;
    var encodeCID6 = (version4, code25, multihash) => {
      const codeOffset = varint9.encodingLength(version4);
      const hashOffset = codeOffset + varint9.encodingLength(code25);
      const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
      varint9.encodeTo(version4, bytes3, 0);
      varint9.encodeTo(code25, bytes3, codeOffset);
      bytes3.set(multihash, hashOffset);
      return bytes3;
    };
    var cidSymbol5 = Symbol.for("@ipld/js-cid/CID");
    var readonly3 = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    var hidden2 = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    var version3 = "0.0.0-dev";
    var deprecate2 = (range, message) => {
      if (range.test(version3)) {
        console.warn(message);
      } else {
        throw new Error(message);
      }
    };
    var IS_CID_DEPRECATION2 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
    exports2.CID = CID5;
  }
});

// ../../node_modules/.pnpm/dag-jose@1.0.0/node_modules/dag-jose/lib/signing.js
var require_signing = __commonJS({
  "../../node_modules/.pnpm/dag-jose@1.0.0/node_modules/dag-jose/lib/signing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_utils();
    var cid_1 = require_cid();
    function fromSplit(split3) {
      const [protectedHeader, payload, signature] = split3;
      return {
        payload,
        signatures: [{ protected: protectedHeader, signature }],
        link: cid_1.CID.decode(utils_1.fromBase64url(payload))
      };
    }
    function encodeSignature2(signature) {
      const encoded = {
        signature: utils_1.fromBase64url(signature.signature)
      };
      if (signature.header)
        encoded.header = signature.header;
      if (signature.protected)
        encoded.protected = utils_1.fromBase64url(signature.protected);
      return encoded;
    }
    function encode45(jws) {
      const payload = utils_1.fromBase64url(jws.payload);
      try {
        cid_1.CID.decode(payload);
      } catch (e) {
        throw new Error("Not a valid DagJWS");
      }
      const encodedJws = {
        payload,
        signatures: jws.signatures.map(encodeSignature2)
      };
      return encodedJws;
    }
    function decodeSignature(encoded) {
      const sign2 = {
        signature: utils_1.toBase64url(encoded.signature)
      };
      if (encoded.header)
        sign2.header = encoded.header;
      if (encoded.protected)
        sign2.protected = utils_1.toBase64url(encoded.protected);
      return sign2;
    }
    function decode53(encoded) {
      const decoded = {
        payload: utils_1.toBase64url(encoded.payload),
        signatures: encoded.signatures.map(decodeSignature)
      };
      decoded.link = cid_1.CID.decode(new Uint8Array(encoded.payload));
      return decoded;
    }
    exports2.default = {
      fromSplit,
      encode: encode45,
      decode: decode53
    };
  }
});

// ../../node_modules/.pnpm/dag-jose@1.0.0/node_modules/dag-jose/lib/encryption.js
var require_encryption = __commonJS({
  "../../node_modules/.pnpm/dag-jose@1.0.0/node_modules/dag-jose/lib/encryption.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_utils();
    function fromSplit(split3) {
      const [protectedHeader, encrypted_key, iv, ciphertext, tag2] = split3;
      const jwe = {
        ciphertext,
        iv,
        protected: protectedHeader,
        tag: tag2
      };
      if (encrypted_key)
        jwe.recipients = [{ encrypted_key }];
      return jwe;
    }
    function encodeRecipient(recipient) {
      const encRec = {};
      if (recipient.encrypted_key)
        encRec.encrypted_key = utils_1.fromBase64url(recipient.encrypted_key);
      if (recipient.header)
        encRec.header = recipient.header;
      return encRec;
    }
    function encode45(jwe) {
      const encJwe = {
        ciphertext: utils_1.fromBase64url(jwe.ciphertext),
        protected: utils_1.fromBase64url(jwe.protected),
        iv: utils_1.fromBase64url(jwe.iv),
        tag: utils_1.fromBase64url(jwe.tag)
      };
      if (jwe.aad)
        encJwe.aad = utils_1.fromBase64url(jwe.aad);
      if (jwe.recipients)
        encJwe.recipients = jwe.recipients.map(encodeRecipient);
      if (jwe.unprotected)
        encJwe.unprotected = jwe.unprotected;
      return encJwe;
    }
    function decodeRecipient(encoded) {
      const recipient = {};
      if (encoded.encrypted_key)
        recipient.encrypted_key = utils_1.toBase64url(encoded.encrypted_key);
      if (encoded.header)
        recipient.header = encoded.header;
      return recipient;
    }
    function decode53(encoded) {
      const jwe = {
        ciphertext: utils_1.toBase64url(encoded.ciphertext),
        protected: utils_1.toBase64url(encoded.protected),
        iv: utils_1.toBase64url(encoded.iv),
        tag: utils_1.toBase64url(encoded.tag)
      };
      if (encoded.aad)
        jwe.aad = utils_1.toBase64url(encoded.aad);
      if (encoded.recipients)
        jwe.recipients = encoded.recipients.map(decodeRecipient);
      if (encoded.unprotected)
        jwe.unprotected = encoded.unprotected;
      return jwe;
    }
    exports2.default = {
      fromSplit,
      decode: decode53,
      encode: encode45
    };
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/is.js
var require_is = __commonJS({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typeofs3 = [
      "string",
      "number",
      "bigint",
      "symbol"
    ];
    var objectTypeNames3 = [
      "Function",
      "Generator",
      "AsyncGenerator",
      "GeneratorFunction",
      "AsyncGeneratorFunction",
      "AsyncFunction",
      "Observable",
      "Array",
      "Buffer",
      "Object",
      "RegExp",
      "Date",
      "Error",
      "Map",
      "Set",
      "WeakMap",
      "WeakSet",
      "ArrayBuffer",
      "SharedArrayBuffer",
      "DataView",
      "Promise",
      "URL",
      "HTMLElement",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Uint16Array",
      "Int32Array",
      "Uint32Array",
      "Float32Array",
      "Float64Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
    function is3(value) {
      if (value === null) {
        return "null";
      }
      if (value === void 0) {
        return "undefined";
      }
      if (value === true || value === false) {
        return "boolean";
      }
      const typeOf2 = typeof value;
      if (typeofs3.includes(typeOf2)) {
        return typeOf2;
      }
      if (typeOf2 === "function") {
        return "Function";
      }
      if (Array.isArray(value)) {
        return "Array";
      }
      if (isBuffer5(value)) {
        return "Buffer";
      }
      const objectType = getObjectType3(value);
      if (objectType) {
        return objectType;
      }
      return "Object";
    }
    function isBuffer5(value) {
      return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
    }
    function getObjectType3(value) {
      const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
      if (objectTypeNames3.includes(objectTypeName)) {
        return objectTypeName;
      }
      return void 0;
    }
    exports2.is = is3;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/token.js
var require_token = __commonJS({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/token.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Type3 = class {
      constructor(major, name20, terminal) {
        this.major = major;
        this.majorEncoded = major << 5;
        this.name = name20;
        this.terminal = terminal;
      }
      toString() {
        return `Type[${this.major}].${this.name}`;
      }
      compare(typ) {
        return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
      }
    };
    Type3.uint = new Type3(0, "uint", true);
    Type3.negint = new Type3(1, "negint", true);
    Type3.bytes = new Type3(2, "bytes", true);
    Type3.string = new Type3(3, "string", true);
    Type3.array = new Type3(4, "array", false);
    Type3.map = new Type3(5, "map", false);
    Type3.tag = new Type3(6, "tag", false);
    Type3.float = new Type3(7, "float", true);
    Type3.false = new Type3(7, "false", true);
    Type3.true = new Type3(7, "true", true);
    Type3.null = new Type3(7, "null", true);
    Type3.undefined = new Type3(7, "undefined", true);
    Type3.break = new Type3(7, "break", true);
    var Token3 = class {
      constructor(type2, value, encodedLength) {
        this.type = type2;
        this.value = value;
        this.encodedLength = encodedLength;
        this.encodedBytes = void 0;
        this.byteValue = void 0;
      }
      toString() {
        return `Token[${this.type}].${this.value}`;
      }
    };
    exports2.Token = Token3;
    exports2.Type = Type3;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/byte-utils.js
var require_byte_utils = __commonJS({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/byte-utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var useBuffer3 = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
    var textDecoder7 = new TextDecoder();
    var textEncoder9 = new TextEncoder();
    function isBuffer5(buf3) {
      return useBuffer3 && globalThis.Buffer.isBuffer(buf3);
    }
    function asU8A3(buf3) {
      if (!(buf3 instanceof Uint8Array)) {
        return Uint8Array.from(buf3);
      }
      return isBuffer5(buf3) ? new Uint8Array(buf3.buffer, buf3.byteOffset, buf3.byteLength) : buf3;
    }
    var toString8 = useBuffer3 ? (bytes2, start, end) => {
      return end - start > 64 ? globalThis.Buffer.from(bytes2.subarray(start, end)).toString("utf8") : utf8Slice3(bytes2, start, end);
    } : (bytes2, start, end) => {
      return end - start > 64 ? textDecoder7.decode(bytes2.subarray(start, end)) : utf8Slice3(bytes2, start, end);
    };
    var fromString7 = useBuffer3 ? (string4) => {
      return string4.length > 64 ? globalThis.Buffer.from(string4) : utf8ToBytes3(string4);
    } : (string4) => {
      return string4.length > 64 ? textEncoder9.encode(string4) : utf8ToBytes3(string4);
    };
    var fromArray3 = (arr) => {
      return Uint8Array.from(arr);
    };
    var slice4 = useBuffer3 ? (bytes2, start, end) => {
      if (isBuffer5(bytes2)) {
        return new Uint8Array(bytes2.subarray(start, end));
      }
      return bytes2.slice(start, end);
    } : (bytes2, start, end) => {
      return bytes2.slice(start, end);
    };
    var concat4 = useBuffer3 ? (chunks, length5) => {
      chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
      return asU8A3(globalThis.Buffer.concat(chunks, length5));
    } : (chunks, length5) => {
      const out = new Uint8Array(length5);
      let off = 0;
      for (let b of chunks) {
        if (off + b.length > out.length) {
          b = b.subarray(0, out.length - off);
        }
        out.set(b, off);
        off += b.length;
      }
      return out;
    };
    var alloc4 = useBuffer3 ? (size5) => {
      return globalThis.Buffer.allocUnsafe(size5);
    } : (size5) => {
      return new Uint8Array(size5);
    };
    var toHex2 = useBuffer3 ? (d) => {
      if (typeof d === "string") {
        return d;
      }
      return globalThis.Buffer.from(toBytes5(d)).toString("hex");
    } : (d) => {
      if (typeof d === "string") {
        return d;
      }
      return Array.prototype.reduce.call(toBytes5(d), (p, c) => `${p}${c.toString(16).padStart(2, "0")}`, "");
    };
    var fromHex2 = useBuffer3 ? (hex) => {
      if (hex instanceof Uint8Array) {
        return hex;
      }
      return globalThis.Buffer.from(hex, "hex");
    } : (hex) => {
      if (hex instanceof Uint8Array) {
        return hex;
      }
      if (!hex.length) {
        return new Uint8Array(0);
      }
      return new Uint8Array(hex.split("").map((c, i, d) => i % 2 === 0 ? `0x${c}${d[i + 1]}` : "").filter(Boolean).map((e) => parseInt(e, 16)));
    };
    function toBytes5(obj) {
      if (obj instanceof Uint8Array && obj.constructor.name === "Uint8Array") {
        return obj;
      }
      if (obj instanceof ArrayBuffer) {
        return new Uint8Array(obj);
      }
      if (ArrayBuffer.isView(obj)) {
        return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    }
    function compare4(b1, b2) {
      if (isBuffer5(b1) && isBuffer5(b2)) {
        return b1.compare(b2);
      }
      for (let i = 0; i < b1.length; i++) {
        if (b1[i] === b2[i]) {
          continue;
        }
        return b1[i] < b2[i] ? -1 : 1;
      }
      return 0;
    }
    function utf8ToBytes3(string4, units = Infinity) {
      let codePoint;
      const length5 = string4.length;
      let leadSurrogate = null;
      const bytes2 = [];
      for (let i = 0; i < length5; ++i) {
        codePoint = string4.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes2.push(239, 191, 189);
              continue;
            } else if (i + 1 === length5) {
              if ((units -= 3) > -1)
                bytes2.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes2.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes2.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes2.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes2.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes2;
    }
    function utf8Slice3(buf3, offset2, end) {
      const res = [];
      while (offset2 < end) {
        const firstByte = buf3[offset2];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (offset2 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf3[offset2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf3[offset2 + 1];
              thirdByte = buf3[offset2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf3[offset2 + 1];
              thirdByte = buf3[offset2 + 2];
              fourthByte = buf3[offset2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        offset2 += bytesPerSequence;
      }
      return decodeCodePointsArray3(res);
    }
    var MAX_ARGUMENTS_LENGTH3 = 4096;
    function decodeCodePointsArray3(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH3) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH3));
      }
      return res;
    }
    exports2.alloc = alloc4;
    exports2.asU8A = asU8A3;
    exports2.compare = compare4;
    exports2.concat = concat4;
    exports2.decodeCodePointsArray = decodeCodePointsArray3;
    exports2.fromArray = fromArray3;
    exports2.fromHex = fromHex2;
    exports2.fromString = fromString7;
    exports2.slice = slice4;
    exports2.toHex = toHex2;
    exports2.toString = toString8;
    exports2.useBuffer = useBuffer3;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/bl.js
var require_bl = __commonJS({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/bl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var byteUtils = require_byte_utils();
    var defaultChunkSize3 = 256;
    var Bl3 = class {
      constructor(chunkSize = defaultChunkSize3) {
        this.chunkSize = chunkSize;
        this.cursor = 0;
        this.maxCursor = -1;
        this.chunks = [];
        this._initReuseChunk = null;
      }
      reset() {
        this.cursor = 0;
        this.maxCursor = -1;
        if (this.chunks.length) {
          this.chunks = [];
        }
        if (this._initReuseChunk !== null) {
          this.chunks.push(this._initReuseChunk);
          this.maxCursor = this._initReuseChunk.length - 1;
        }
      }
      push(bytes2) {
        let topChunk = this.chunks[this.chunks.length - 1];
        const newMax = this.cursor + bytes2.length;
        if (newMax <= this.maxCursor + 1) {
          const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
          topChunk.set(bytes2, chunkPos);
        } else {
          if (topChunk) {
            const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
            if (chunkPos < topChunk.length) {
              this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
              this.maxCursor = this.cursor - 1;
            }
          }
          if (bytes2.length < 64 && bytes2.length < this.chunkSize) {
            topChunk = byteUtils.alloc(this.chunkSize);
            this.chunks.push(topChunk);
            this.maxCursor += topChunk.length;
            if (this._initReuseChunk === null) {
              this._initReuseChunk = topChunk;
            }
            topChunk.set(bytes2, 0);
          } else {
            this.chunks.push(bytes2);
            this.maxCursor += bytes2.length;
          }
        }
        this.cursor += bytes2.length;
      }
      toBytes(reset = false) {
        let byts;
        if (this.chunks.length === 1) {
          const chunk = this.chunks[0];
          if (reset && this.cursor > chunk.length / 2) {
            byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
            this._initReuseChunk = null;
            this.chunks = [];
          } else {
            byts = byteUtils.slice(chunk, 0, this.cursor);
          }
        } else {
          byts = byteUtils.concat(this.chunks, this.cursor);
        }
        if (reset) {
          this.reset();
        }
        return byts;
      }
    };
    exports2.Bl = Bl3;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/common.js
var require_common = __commonJS({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var decodeErrPrefix3 = "CBOR decode error:";
    var encodeErrPrefix3 = "CBOR encode error:";
    var uintMinorPrefixBytes3 = [];
    uintMinorPrefixBytes3[23] = 1;
    uintMinorPrefixBytes3[24] = 2;
    uintMinorPrefixBytes3[25] = 3;
    uintMinorPrefixBytes3[26] = 5;
    uintMinorPrefixBytes3[27] = 9;
    function assertEnoughData3(data, pos, need) {
      if (data.length - pos < need) {
        throw new Error(`${decodeErrPrefix3} not enough data for type`);
      }
    }
    exports2.assertEnoughData = assertEnoughData3;
    exports2.decodeErrPrefix = decodeErrPrefix3;
    exports2.encodeErrPrefix = encodeErrPrefix3;
    exports2.uintMinorPrefixBytes = uintMinorPrefixBytes3;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/0uint.js
var require_uint = __commonJS({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/0uint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var token = require_token();
    var common = require_common();
    var uintBoundaries3 = [
      24,
      256,
      65536,
      4294967296,
      BigInt("18446744073709551616")
    ];
    function readUint83(data, offset2, options) {
      common.assertEnoughData(data, offset2, 1);
      const value = data[offset2];
      if (options.strict === true && value < uintBoundaries3[0]) {
        throw new Error(`${common.decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
      }
      return value;
    }
    function readUint163(data, offset2, options) {
      common.assertEnoughData(data, offset2, 2);
      const value = data[offset2] << 8 | data[offset2 + 1];
      if (options.strict === true && value < uintBoundaries3[1]) {
        throw new Error(`${common.decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
      }
      return value;
    }
    function readUint323(data, offset2, options) {
      common.assertEnoughData(data, offset2, 4);
      const value = data[offset2] * 16777216 + (data[offset2 + 1] << 16) + (data[offset2 + 2] << 8) + data[offset2 + 3];
      if (options.strict === true && value < uintBoundaries3[2]) {
        throw new Error(`${common.decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
      }
      return value;
    }
    function readUint643(data, offset2, options) {
      common.assertEnoughData(data, offset2, 8);
      const hi = data[offset2] * 16777216 + (data[offset2 + 1] << 16) + (data[offset2 + 2] << 8) + data[offset2 + 3];
      const lo = data[offset2 + 4] * 16777216 + (data[offset2 + 5] << 16) + (data[offset2 + 6] << 8) + data[offset2 + 7];
      const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
      if (options.strict === true && value < uintBoundaries3[3]) {
        throw new Error(`${common.decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
      }
      if (value <= Number.MAX_SAFE_INTEGER) {
        return Number(value);
      }
      if (options.allowBigInt === true) {
        return value;
      }
      throw new Error(`${common.decodeErrPrefix} integers outside of the safe integer range are not supported`);
    }
    function decodeUint83(data, pos, _minor, options) {
      return new token.Token(token.Type.uint, readUint83(data, pos + 1, options), 2);
    }
    function decodeUint163(data, pos, _minor, options) {
      return new token.Token(token.Type.uint, readUint163(data, pos + 1, options), 3);
    }
    function decodeUint323(data, pos, _minor, options) {
      return new token.Token(token.Type.uint, readUint323(data, pos + 1, options), 5);
    }
    function decodeUint643(data, pos, _minor, options) {
      return new token.Token(token.Type.uint, readUint643(data, pos + 1, options), 9);
    }
    function encodeUint3(buf3, token2) {
      return encodeUintValue3(buf3, 0, token2.value);
    }
    function encodeUintValue3(buf3, major, uint) {
      if (uint < uintBoundaries3[0]) {
        const nuint = Number(uint);
        buf3.push([major | nuint]);
      } else if (uint < uintBoundaries3[1]) {
        const nuint = Number(uint);
        buf3.push([
          major | 24,
          nuint
        ]);
      } else if (uint < uintBoundaries3[2]) {
        const nuint = Number(uint);
        buf3.push([
          major | 25,
          nuint >>> 8,
          nuint & 255
        ]);
      } else if (uint < uintBoundaries3[3]) {
        const nuint = Number(uint);
        buf3.push([
          major | 26,
          nuint >>> 24 & 255,
          nuint >>> 16 & 255,
          nuint >>> 8 & 255,
          nuint & 255
        ]);
      } else {
        const buint = BigInt(uint);
        if (buint < uintBoundaries3[4]) {
          const set5 = [
            major | 27,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ];
          let lo = Number(buint & BigInt(4294967295));
          let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
          set5[8] = lo & 255;
          lo = lo >> 8;
          set5[7] = lo & 255;
          lo = lo >> 8;
          set5[6] = lo & 255;
          lo = lo >> 8;
          set5[5] = lo & 255;
          set5[4] = hi & 255;
          hi = hi >> 8;
          set5[3] = hi & 255;
          hi = hi >> 8;
          set5[2] = hi & 255;
          hi = hi >> 8;
          set5[1] = hi & 255;
          buf3.push(set5);
        } else {
          throw new Error(`${common.decodeErrPrefix} encountered BigInt larger than allowable range`);
        }
      }
    }
    encodeUint3.encodedSize = function encodedSize17(token2) {
      return encodeUintValue3.encodedSize(token2.value);
    };
    encodeUintValue3.encodedSize = function encodedSize17(uint) {
      if (uint < uintBoundaries3[0]) {
        return 1;
      }
      if (uint < uintBoundaries3[1]) {
        return 2;
      }
      if (uint < uintBoundaries3[2]) {
        return 3;
      }
      if (uint < uintBoundaries3[3]) {
        return 5;
      }
      return 9;
    };
    encodeUint3.compareTokens = function compareTokens7(tok1, tok2) {
      return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
    };
    exports2.decodeUint16 = decodeUint163;
    exports2.decodeUint32 = decodeUint323;
    exports2.decodeUint64 = decodeUint643;
    exports2.decodeUint8 = decodeUint83;
    exports2.encodeUint = encodeUint3;
    exports2.encodeUintValue = encodeUintValue3;
    exports2.readUint16 = readUint163;
    exports2.readUint32 = readUint323;
    exports2.readUint64 = readUint643;
    exports2.readUint8 = readUint83;
    exports2.uintBoundaries = uintBoundaries3;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/1negint.js
var require_negint = __commonJS({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/1negint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var token = require_token();
    var _0uint = require_uint();
    var common = require_common();
    function decodeNegint83(data, pos, _minor, options) {
      return new token.Token(token.Type.negint, -1 - _0uint.readUint8(data, pos + 1, options), 2);
    }
    function decodeNegint163(data, pos, _minor, options) {
      return new token.Token(token.Type.negint, -1 - _0uint.readUint16(data, pos + 1, options), 3);
    }
    function decodeNegint323(data, pos, _minor, options) {
      return new token.Token(token.Type.negint, -1 - _0uint.readUint32(data, pos + 1, options), 5);
    }
    var neg1b3 = BigInt(-1);
    var pos1b3 = BigInt(1);
    function decodeNegint643(data, pos, _minor, options) {
      const int = _0uint.readUint64(data, pos + 1, options);
      if (typeof int !== "bigint") {
        const value = -1 - int;
        if (value >= Number.MIN_SAFE_INTEGER) {
          return new token.Token(token.Type.negint, value, 9);
        }
      }
      if (options.allowBigInt !== true) {
        throw new Error(`${common.decodeErrPrefix} integers outside of the safe integer range are not supported`);
      }
      return new token.Token(token.Type.negint, neg1b3 - BigInt(int), 9);
    }
    function encodeNegint3(buf3, token2) {
      const negint = token2.value;
      const unsigned = typeof negint === "bigint" ? negint * neg1b3 - pos1b3 : negint * -1 - 1;
      _0uint.encodeUintValue(buf3, token2.type.majorEncoded, unsigned);
    }
    encodeNegint3.encodedSize = function encodedSize17(token2) {
      const negint = token2.value;
      const unsigned = typeof negint === "bigint" ? negint * neg1b3 - pos1b3 : negint * -1 - 1;
      if (unsigned < _0uint.uintBoundaries[0]) {
        return 1;
      }
      if (unsigned < _0uint.uintBoundaries[1]) {
        return 2;
      }
      if (unsigned < _0uint.uintBoundaries[2]) {
        return 3;
      }
      if (unsigned < _0uint.uintBoundaries[3]) {
        return 5;
      }
      return 9;
    };
    encodeNegint3.compareTokens = function compareTokens7(tok1, tok2) {
      return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
    };
    exports2.decodeNegint16 = decodeNegint163;
    exports2.decodeNegint32 = decodeNegint323;
    exports2.decodeNegint64 = decodeNegint643;
    exports2.decodeNegint8 = decodeNegint83;
    exports2.encodeNegint = encodeNegint3;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/2bytes.js
var require_bytes2 = __commonJS({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/2bytes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var token = require_token();
    var common = require_common();
    var _0uint = require_uint();
    var byteUtils = require_byte_utils();
    function toToken9(data, pos, prefix2, length5) {
      common.assertEnoughData(data, pos, prefix2 + length5);
      const buf3 = byteUtils.slice(data, pos + prefix2, pos + prefix2 + length5);
      return new token.Token(token.Type.bytes, buf3, prefix2 + length5);
    }
    function decodeBytesCompact3(data, pos, minor, _options) {
      return toToken9(data, pos, 1, minor);
    }
    function decodeBytes83(data, pos, _minor, options) {
      return toToken9(data, pos, 2, _0uint.readUint8(data, pos + 1, options));
    }
    function decodeBytes163(data, pos, _minor, options) {
      return toToken9(data, pos, 3, _0uint.readUint16(data, pos + 1, options));
    }
    function decodeBytes323(data, pos, _minor, options) {
      return toToken9(data, pos, 5, _0uint.readUint32(data, pos + 1, options));
    }
    function decodeBytes643(data, pos, _minor, options) {
      const l = _0uint.readUint64(data, pos + 1, options);
      if (typeof l === "bigint") {
        throw new Error(`${common.decodeErrPrefix} 64-bit integer bytes lengths not supported`);
      }
      return toToken9(data, pos, 9, l);
    }
    function tokenBytes3(token$1) {
      if (token$1.encodedBytes === void 0) {
        token$1.encodedBytes = token$1.type === token.Type.string ? byteUtils.fromString(token$1.value) : token$1.value;
      }
      return token$1.encodedBytes;
    }
    function encodeBytes3(buf3, token2) {
      const bytes2 = tokenBytes3(token2);
      _0uint.encodeUintValue(buf3, token2.type.majorEncoded, bytes2.length);
      buf3.push(bytes2);
    }
    encodeBytes3.encodedSize = function encodedSize17(token2) {
      const bytes2 = tokenBytes3(token2);
      return _0uint.encodeUintValue.encodedSize(bytes2.length) + bytes2.length;
    };
    encodeBytes3.compareTokens = function compareTokens7(tok1, tok2) {
      return compareBytes3(tokenBytes3(tok1), tokenBytes3(tok2));
    };
    function compareBytes3(b1, b2) {
      return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : byteUtils.compare(b1, b2);
    }
    exports2.compareBytes = compareBytes3;
    exports2.decodeBytes16 = decodeBytes163;
    exports2.decodeBytes32 = decodeBytes323;
    exports2.decodeBytes64 = decodeBytes643;
    exports2.decodeBytes8 = decodeBytes83;
    exports2.decodeBytesCompact = decodeBytesCompact3;
    exports2.encodeBytes = encodeBytes3;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/3string.js
var require_string = __commonJS({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/3string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var token = require_token();
    var common = require_common();
    var _0uint = require_uint();
    var _2bytes = require_bytes2();
    var byteUtils = require_byte_utils();
    function toToken9(data, pos, prefix2, length5, options) {
      const totLength = prefix2 + length5;
      common.assertEnoughData(data, pos, totLength);
      const tok = new token.Token(token.Type.string, byteUtils.toString(data, pos + prefix2, pos + totLength), totLength);
      if (options.retainStringBytes === true) {
        tok.byteValue = byteUtils.slice(data, pos + prefix2, pos + totLength);
      }
      return tok;
    }
    function decodeStringCompact3(data, pos, minor, options) {
      return toToken9(data, pos, 1, minor, options);
    }
    function decodeString83(data, pos, _minor, options) {
      return toToken9(data, pos, 2, _0uint.readUint8(data, pos + 1, options), options);
    }
    function decodeString163(data, pos, _minor, options) {
      return toToken9(data, pos, 3, _0uint.readUint16(data, pos + 1, options), options);
    }
    function decodeString323(data, pos, _minor, options) {
      return toToken9(data, pos, 5, _0uint.readUint32(data, pos + 1, options), options);
    }
    function decodeString643(data, pos, _minor, options) {
      const l = _0uint.readUint64(data, pos + 1, options);
      if (typeof l === "bigint") {
        throw new Error(`${common.decodeErrPrefix} 64-bit integer string lengths not supported`);
      }
      return toToken9(data, pos, 9, l, options);
    }
    var encodeString3 = _2bytes.encodeBytes;
    exports2.decodeString16 = decodeString163;
    exports2.decodeString32 = decodeString323;
    exports2.decodeString64 = decodeString643;
    exports2.decodeString8 = decodeString83;
    exports2.decodeStringCompact = decodeStringCompact3;
    exports2.encodeString = encodeString3;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/4array.js
var require_array = __commonJS({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/4array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var token = require_token();
    var _0uint = require_uint();
    var common = require_common();
    function toToken9(_data, _pos, prefix2, length5) {
      return new token.Token(token.Type.array, length5, prefix2);
    }
    function decodeArrayCompact3(data, pos, minor, _options) {
      return toToken9(data, pos, 1, minor);
    }
    function decodeArray83(data, pos, _minor, options) {
      return toToken9(data, pos, 2, _0uint.readUint8(data, pos + 1, options));
    }
    function decodeArray163(data, pos, _minor, options) {
      return toToken9(data, pos, 3, _0uint.readUint16(data, pos + 1, options));
    }
    function decodeArray323(data, pos, _minor, options) {
      return toToken9(data, pos, 5, _0uint.readUint32(data, pos + 1, options));
    }
    function decodeArray643(data, pos, _minor, options) {
      const l = _0uint.readUint64(data, pos + 1, options);
      if (typeof l === "bigint") {
        throw new Error(`${common.decodeErrPrefix} 64-bit integer array lengths not supported`);
      }
      return toToken9(data, pos, 9, l);
    }
    function decodeArrayIndefinite3(data, pos, _minor, options) {
      if (options.allowIndefinite === false) {
        throw new Error(`${common.decodeErrPrefix} indefinite length items not allowed`);
      }
      return toToken9(data, pos, 1, Infinity);
    }
    function encodeArray3(buf3, token$1) {
      _0uint.encodeUintValue(buf3, token.Type.array.majorEncoded, token$1.value);
    }
    encodeArray3.compareTokens = _0uint.encodeUint.compareTokens;
    encodeArray3.encodedSize = function encodedSize17(token2) {
      return _0uint.encodeUintValue.encodedSize(token2.value);
    };
    exports2.decodeArray16 = decodeArray163;
    exports2.decodeArray32 = decodeArray323;
    exports2.decodeArray64 = decodeArray643;
    exports2.decodeArray8 = decodeArray83;
    exports2.decodeArrayCompact = decodeArrayCompact3;
    exports2.decodeArrayIndefinite = decodeArrayIndefinite3;
    exports2.encodeArray = encodeArray3;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/5map.js
var require_map = __commonJS({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/5map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var token = require_token();
    var _0uint = require_uint();
    var common = require_common();
    function toToken9(_data, _pos, prefix2, length5) {
      return new token.Token(token.Type.map, length5, prefix2);
    }
    function decodeMapCompact3(data, pos, minor, _options) {
      return toToken9(data, pos, 1, minor);
    }
    function decodeMap83(data, pos, _minor, options) {
      return toToken9(data, pos, 2, _0uint.readUint8(data, pos + 1, options));
    }
    function decodeMap163(data, pos, _minor, options) {
      return toToken9(data, pos, 3, _0uint.readUint16(data, pos + 1, options));
    }
    function decodeMap323(data, pos, _minor, options) {
      return toToken9(data, pos, 5, _0uint.readUint32(data, pos + 1, options));
    }
    function decodeMap643(data, pos, _minor, options) {
      const l = _0uint.readUint64(data, pos + 1, options);
      if (typeof l === "bigint") {
        throw new Error(`${common.decodeErrPrefix} 64-bit integer map lengths not supported`);
      }
      return toToken9(data, pos, 9, l);
    }
    function decodeMapIndefinite3(data, pos, _minor, options) {
      if (options.allowIndefinite === false) {
        throw new Error(`${common.decodeErrPrefix} indefinite length items not allowed`);
      }
      return toToken9(data, pos, 1, Infinity);
    }
    function encodeMap3(buf3, token$1) {
      _0uint.encodeUintValue(buf3, token.Type.map.majorEncoded, token$1.value);
    }
    encodeMap3.compareTokens = _0uint.encodeUint.compareTokens;
    encodeMap3.encodedSize = function encodedSize17(token2) {
      return _0uint.encodeUintValue.encodedSize(token2.value);
    };
    exports2.decodeMap16 = decodeMap163;
    exports2.decodeMap32 = decodeMap323;
    exports2.decodeMap64 = decodeMap643;
    exports2.decodeMap8 = decodeMap83;
    exports2.decodeMapCompact = decodeMapCompact3;
    exports2.decodeMapIndefinite = decodeMapIndefinite3;
    exports2.encodeMap = encodeMap3;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/6tag.js
var require_tag = __commonJS({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/6tag.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var token = require_token();
    var _0uint = require_uint();
    function decodeTagCompact3(_data, _pos, minor, _options) {
      return new token.Token(token.Type.tag, minor, 1);
    }
    function decodeTag83(data, pos, _minor, options) {
      return new token.Token(token.Type.tag, _0uint.readUint8(data, pos + 1, options), 2);
    }
    function decodeTag163(data, pos, _minor, options) {
      return new token.Token(token.Type.tag, _0uint.readUint16(data, pos + 1, options), 3);
    }
    function decodeTag323(data, pos, _minor, options) {
      return new token.Token(token.Type.tag, _0uint.readUint32(data, pos + 1, options), 5);
    }
    function decodeTag643(data, pos, _minor, options) {
      return new token.Token(token.Type.tag, _0uint.readUint64(data, pos + 1, options), 9);
    }
    function encodeTag3(buf3, token$1) {
      _0uint.encodeUintValue(buf3, token.Type.tag.majorEncoded, token$1.value);
    }
    encodeTag3.compareTokens = _0uint.encodeUint.compareTokens;
    encodeTag3.encodedSize = function encodedSize17(token2) {
      return _0uint.encodeUintValue.encodedSize(token2.value);
    };
    exports2.decodeTag16 = decodeTag163;
    exports2.decodeTag32 = decodeTag323;
    exports2.decodeTag64 = decodeTag643;
    exports2.decodeTag8 = decodeTag83;
    exports2.decodeTagCompact = decodeTagCompact3;
    exports2.encodeTag = encodeTag3;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/7float.js
var require_float = __commonJS({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/7float.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var token = require_token();
    var common = require_common();
    var _0uint = require_uint();
    var MINOR_FALSE3 = 20;
    var MINOR_TRUE3 = 21;
    var MINOR_NULL3 = 22;
    var MINOR_UNDEFINED3 = 23;
    function decodeUndefined3(_data, _pos, _minor, options) {
      if (options.allowUndefined === false) {
        throw new Error(`${common.decodeErrPrefix} undefined values are not supported`);
      } else if (options.coerceUndefinedToNull === true) {
        return new token.Token(token.Type.null, null, 1);
      }
      return new token.Token(token.Type.undefined, void 0, 1);
    }
    function decodeBreak3(_data, _pos, _minor, options) {
      if (options.allowIndefinite === false) {
        throw new Error(`${common.decodeErrPrefix} indefinite length items not allowed`);
      }
      return new token.Token(token.Type.break, void 0, 1);
    }
    function createToken3(value, bytes2, options) {
      if (options) {
        if (options.allowNaN === false && Number.isNaN(value)) {
          throw new Error(`${common.decodeErrPrefix} NaN values are not supported`);
        }
        if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
          throw new Error(`${common.decodeErrPrefix} Infinity values are not supported`);
        }
      }
      return new token.Token(token.Type.float, value, bytes2);
    }
    function decodeFloat163(data, pos, _minor, options) {
      return createToken3(readFloat163(data, pos + 1), 3, options);
    }
    function decodeFloat323(data, pos, _minor, options) {
      return createToken3(readFloat323(data, pos + 1), 5, options);
    }
    function decodeFloat643(data, pos, _minor, options) {
      return createToken3(readFloat643(data, pos + 1), 9, options);
    }
    function encodeFloat3(buf3, token$1, options) {
      const float2 = token$1.value;
      if (float2 === false) {
        buf3.push([token.Type.float.majorEncoded | MINOR_FALSE3]);
      } else if (float2 === true) {
        buf3.push([token.Type.float.majorEncoded | MINOR_TRUE3]);
      } else if (float2 === null) {
        buf3.push([token.Type.float.majorEncoded | MINOR_NULL3]);
      } else if (float2 === void 0) {
        buf3.push([token.Type.float.majorEncoded | MINOR_UNDEFINED3]);
      } else {
        let decoded;
        let success = false;
        if (!options || options.float64 !== true) {
          encodeFloat163(float2);
          decoded = readFloat163(ui8a3, 1);
          if (float2 === decoded || Number.isNaN(float2)) {
            ui8a3[0] = 249;
            buf3.push(ui8a3.slice(0, 3));
            success = true;
          } else {
            encodeFloat323(float2);
            decoded = readFloat323(ui8a3, 1);
            if (float2 === decoded) {
              ui8a3[0] = 250;
              buf3.push(ui8a3.slice(0, 5));
              success = true;
            }
          }
        }
        if (!success) {
          encodeFloat643(float2);
          decoded = readFloat643(ui8a3, 1);
          ui8a3[0] = 251;
          buf3.push(ui8a3.slice(0, 9));
        }
      }
    }
    encodeFloat3.encodedSize = function encodedSize17(token2, options) {
      const float2 = token2.value;
      if (float2 === false || float2 === true || float2 === null || float2 === void 0) {
        return 1;
      }
      if (!options || options.float64 !== true) {
        encodeFloat163(float2);
        let decoded = readFloat163(ui8a3, 1);
        if (float2 === decoded || Number.isNaN(float2)) {
          return 3;
        }
        encodeFloat323(float2);
        decoded = readFloat323(ui8a3, 1);
        if (float2 === decoded) {
          return 5;
        }
      }
      return 9;
    };
    var buffer3 = new ArrayBuffer(9);
    var dataView3 = new DataView(buffer3, 1);
    var ui8a3 = new Uint8Array(buffer3, 0);
    function encodeFloat163(inp) {
      if (inp === Infinity) {
        dataView3.setUint16(0, 31744, false);
      } else if (inp === -Infinity) {
        dataView3.setUint16(0, 64512, false);
      } else if (Number.isNaN(inp)) {
        dataView3.setUint16(0, 32256, false);
      } else {
        dataView3.setFloat32(0, inp);
        const valu32 = dataView3.getUint32(0);
        const exponent = (valu32 & 2139095040) >> 23;
        const mantissa = valu32 & 8388607;
        if (exponent === 255) {
          dataView3.setUint16(0, 31744, false);
        } else if (exponent === 0) {
          dataView3.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
        } else {
          const logicalExponent = exponent - 127;
          if (logicalExponent < -24) {
            dataView3.setUint16(0, 0);
          } else if (logicalExponent < -14) {
            dataView3.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
          } else {
            dataView3.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
          }
        }
      }
    }
    function readFloat163(ui8a4, pos) {
      if (ui8a4.length - pos < 2) {
        throw new Error(`${common.decodeErrPrefix} not enough data for float16`);
      }
      const half = (ui8a4[pos] << 8) + ui8a4[pos + 1];
      if (half === 31744) {
        return Infinity;
      }
      if (half === 64512) {
        return -Infinity;
      }
      if (half === 32256) {
        return NaN;
      }
      const exp = half >> 10 & 31;
      const mant = half & 1023;
      let val;
      if (exp === 0) {
        val = mant * 2 ** -24;
      } else if (exp !== 31) {
        val = (mant + 1024) * 2 ** (exp - 25);
      } else {
        val = mant === 0 ? Infinity : NaN;
      }
      return half & 32768 ? -val : val;
    }
    function encodeFloat323(inp) {
      dataView3.setFloat32(0, inp, false);
    }
    function readFloat323(ui8a4, pos) {
      if (ui8a4.length - pos < 4) {
        throw new Error(`${common.decodeErrPrefix} not enough data for float32`);
      }
      const offset2 = (ui8a4.byteOffset || 0) + pos;
      return new DataView(ui8a4.buffer, offset2, 4).getFloat32(0, false);
    }
    function encodeFloat643(inp) {
      dataView3.setFloat64(0, inp, false);
    }
    function readFloat643(ui8a4, pos) {
      if (ui8a4.length - pos < 8) {
        throw new Error(`${common.decodeErrPrefix} not enough data for float64`);
      }
      const offset2 = (ui8a4.byteOffset || 0) + pos;
      return new DataView(ui8a4.buffer, offset2, 8).getFloat64(0, false);
    }
    encodeFloat3.compareTokens = _0uint.encodeUint.compareTokens;
    exports2.decodeBreak = decodeBreak3;
    exports2.decodeFloat16 = decodeFloat163;
    exports2.decodeFloat32 = decodeFloat323;
    exports2.decodeFloat64 = decodeFloat643;
    exports2.decodeUndefined = decodeUndefined3;
    exports2.encodeFloat = encodeFloat3;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/jump.js
var require_jump = __commonJS({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/jump.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var token = require_token();
    var _0uint = require_uint();
    var _1negint = require_negint();
    var _2bytes = require_bytes2();
    var _3string = require_string();
    var _4array = require_array();
    var _5map = require_map();
    var _6tag = require_tag();
    var _7float = require_float();
    var common = require_common();
    var byteUtils = require_byte_utils();
    function invalidMinor3(data, pos, minor) {
      throw new Error(`${common.decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
    }
    function errorer3(msg) {
      return () => {
        throw new Error(`${common.decodeErrPrefix} ${msg}`);
      };
    }
    var jump3 = [];
    for (let i = 0; i <= 23; i++) {
      jump3[i] = invalidMinor3;
    }
    jump3[24] = _0uint.decodeUint8;
    jump3[25] = _0uint.decodeUint16;
    jump3[26] = _0uint.decodeUint32;
    jump3[27] = _0uint.decodeUint64;
    jump3[28] = invalidMinor3;
    jump3[29] = invalidMinor3;
    jump3[30] = invalidMinor3;
    jump3[31] = invalidMinor3;
    for (let i = 32; i <= 55; i++) {
      jump3[i] = invalidMinor3;
    }
    jump3[56] = _1negint.decodeNegint8;
    jump3[57] = _1negint.decodeNegint16;
    jump3[58] = _1negint.decodeNegint32;
    jump3[59] = _1negint.decodeNegint64;
    jump3[60] = invalidMinor3;
    jump3[61] = invalidMinor3;
    jump3[62] = invalidMinor3;
    jump3[63] = invalidMinor3;
    for (let i = 64; i <= 87; i++) {
      jump3[i] = _2bytes.decodeBytesCompact;
    }
    jump3[88] = _2bytes.decodeBytes8;
    jump3[89] = _2bytes.decodeBytes16;
    jump3[90] = _2bytes.decodeBytes32;
    jump3[91] = _2bytes.decodeBytes64;
    jump3[92] = invalidMinor3;
    jump3[93] = invalidMinor3;
    jump3[94] = invalidMinor3;
    jump3[95] = errorer3("indefinite length bytes/strings are not supported");
    for (let i = 96; i <= 119; i++) {
      jump3[i] = _3string.decodeStringCompact;
    }
    jump3[120] = _3string.decodeString8;
    jump3[121] = _3string.decodeString16;
    jump3[122] = _3string.decodeString32;
    jump3[123] = _3string.decodeString64;
    jump3[124] = invalidMinor3;
    jump3[125] = invalidMinor3;
    jump3[126] = invalidMinor3;
    jump3[127] = errorer3("indefinite length bytes/strings are not supported");
    for (let i = 128; i <= 151; i++) {
      jump3[i] = _4array.decodeArrayCompact;
    }
    jump3[152] = _4array.decodeArray8;
    jump3[153] = _4array.decodeArray16;
    jump3[154] = _4array.decodeArray32;
    jump3[155] = _4array.decodeArray64;
    jump3[156] = invalidMinor3;
    jump3[157] = invalidMinor3;
    jump3[158] = invalidMinor3;
    jump3[159] = _4array.decodeArrayIndefinite;
    for (let i = 160; i <= 183; i++) {
      jump3[i] = _5map.decodeMapCompact;
    }
    jump3[184] = _5map.decodeMap8;
    jump3[185] = _5map.decodeMap16;
    jump3[186] = _5map.decodeMap32;
    jump3[187] = _5map.decodeMap64;
    jump3[188] = invalidMinor3;
    jump3[189] = invalidMinor3;
    jump3[190] = invalidMinor3;
    jump3[191] = _5map.decodeMapIndefinite;
    for (let i = 192; i <= 215; i++) {
      jump3[i] = _6tag.decodeTagCompact;
    }
    jump3[216] = _6tag.decodeTag8;
    jump3[217] = _6tag.decodeTag16;
    jump3[218] = _6tag.decodeTag32;
    jump3[219] = _6tag.decodeTag64;
    jump3[220] = invalidMinor3;
    jump3[221] = invalidMinor3;
    jump3[222] = invalidMinor3;
    jump3[223] = invalidMinor3;
    for (let i = 224; i <= 243; i++) {
      jump3[i] = errorer3("simple values are not supported");
    }
    jump3[244] = invalidMinor3;
    jump3[245] = invalidMinor3;
    jump3[246] = invalidMinor3;
    jump3[247] = _7float.decodeUndefined;
    jump3[248] = errorer3("simple values are not supported");
    jump3[249] = _7float.decodeFloat16;
    jump3[250] = _7float.decodeFloat32;
    jump3[251] = _7float.decodeFloat64;
    jump3[252] = invalidMinor3;
    jump3[253] = invalidMinor3;
    jump3[254] = invalidMinor3;
    jump3[255] = _7float.decodeBreak;
    var quick3 = [];
    for (let i = 0; i < 24; i++) {
      quick3[i] = new token.Token(token.Type.uint, i, 1);
    }
    for (let i = -1; i >= -24; i--) {
      quick3[31 - i] = new token.Token(token.Type.negint, i, 1);
    }
    quick3[64] = new token.Token(token.Type.bytes, new Uint8Array(0), 1);
    quick3[96] = new token.Token(token.Type.string, "", 1);
    quick3[128] = new token.Token(token.Type.array, 0, 1);
    quick3[160] = new token.Token(token.Type.map, 0, 1);
    quick3[244] = new token.Token(token.Type.false, false, 1);
    quick3[245] = new token.Token(token.Type.true, true, 1);
    quick3[246] = new token.Token(token.Type.null, null, 1);
    function quickEncodeToken3(token$1) {
      switch (token$1.type) {
        case token.Type.false:
          return byteUtils.fromArray([244]);
        case token.Type.true:
          return byteUtils.fromArray([245]);
        case token.Type.null:
          return byteUtils.fromArray([246]);
        case token.Type.bytes:
          if (!token$1.value.length) {
            return byteUtils.fromArray([64]);
          }
          return;
        case token.Type.string:
          if (token$1.value === "") {
            return byteUtils.fromArray([96]);
          }
          return;
        case token.Type.array:
          if (token$1.value === 0) {
            return byteUtils.fromArray([128]);
          }
          return;
        case token.Type.map:
          if (token$1.value === 0) {
            return byteUtils.fromArray([160]);
          }
          return;
        case token.Type.uint:
          if (token$1.value < 24) {
            return byteUtils.fromArray([Number(token$1.value)]);
          }
          return;
        case token.Type.negint:
          if (token$1.value >= -24) {
            return byteUtils.fromArray([31 - Number(token$1.value)]);
          }
      }
    }
    exports2.jump = jump3;
    exports2.quick = quick3;
    exports2.quickEncodeToken = quickEncodeToken3;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/encode.js
var require_encode = __commonJS({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/encode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var is3 = require_is();
    var token = require_token();
    var bl = require_bl();
    var common = require_common();
    var jump3 = require_jump();
    var byteUtils = require_byte_utils();
    var _0uint = require_uint();
    var _1negint = require_negint();
    var _2bytes = require_bytes2();
    var _3string = require_string();
    var _4array = require_array();
    var _5map = require_map();
    var _6tag = require_tag();
    var _7float = require_float();
    var defaultEncodeOptions6 = {
      float64: false,
      mapSorter: mapSorter5,
      quickEncodeToken: jump3.quickEncodeToken
    };
    function makeCborEncoders3() {
      const encoders = [];
      encoders[token.Type.uint.major] = _0uint.encodeUint;
      encoders[token.Type.negint.major] = _1negint.encodeNegint;
      encoders[token.Type.bytes.major] = _2bytes.encodeBytes;
      encoders[token.Type.string.major] = _3string.encodeString;
      encoders[token.Type.array.major] = _4array.encodeArray;
      encoders[token.Type.map.major] = _5map.encodeMap;
      encoders[token.Type.tag.major] = _6tag.encodeTag;
      encoders[token.Type.float.major] = _7float.encodeFloat;
      return encoders;
    }
    var cborEncoders4 = makeCborEncoders3();
    var buf3 = new bl.Bl();
    var Ref3 = class _Ref {
      constructor(obj, parent) {
        this.obj = obj;
        this.parent = parent;
      }
      includes(obj) {
        let p = this;
        do {
          if (p.obj === obj) {
            return true;
          }
        } while (p = p.parent);
        return false;
      }
      static createCheck(stack, obj) {
        if (stack && stack.includes(obj)) {
          throw new Error(`${common.encodeErrPrefix} object contains circular references`);
        }
        return new _Ref(obj, stack);
      }
    };
    var simpleTokens3 = {
      null: new token.Token(token.Type.null, null),
      undefined: new token.Token(token.Type.undefined, void 0),
      true: new token.Token(token.Type.true, true),
      false: new token.Token(token.Type.false, false),
      emptyArray: new token.Token(token.Type.array, 0),
      emptyMap: new token.Token(token.Type.map, 0)
    };
    var typeEncoders3 = {
      number(obj, _typ, _options, _refStack) {
        if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
          return new token.Token(token.Type.float, obj);
        } else if (obj >= 0) {
          return new token.Token(token.Type.uint, obj);
        } else {
          return new token.Token(token.Type.negint, obj);
        }
      },
      bigint(obj, _typ, _options, _refStack) {
        if (obj >= BigInt(0)) {
          return new token.Token(token.Type.uint, obj);
        } else {
          return new token.Token(token.Type.negint, obj);
        }
      },
      Uint8Array(obj, _typ, _options, _refStack) {
        return new token.Token(token.Type.bytes, obj);
      },
      string(obj, _typ, _options, _refStack) {
        return new token.Token(token.Type.string, obj);
      },
      boolean(obj, _typ, _options, _refStack) {
        return obj ? simpleTokens3.true : simpleTokens3.false;
      },
      null(_obj, _typ, _options, _refStack) {
        return simpleTokens3.null;
      },
      undefined(_obj, _typ, _options, _refStack) {
        return simpleTokens3.undefined;
      },
      ArrayBuffer(obj, _typ, _options, _refStack) {
        return new token.Token(token.Type.bytes, new Uint8Array(obj));
      },
      DataView(obj, _typ, _options, _refStack) {
        return new token.Token(token.Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
      },
      Array(obj, _typ, options, refStack) {
        if (!obj.length) {
          if (options.addBreakTokens === true) {
            return [
              simpleTokens3.emptyArray,
              new token.Token(token.Type.break)
            ];
          }
          return simpleTokens3.emptyArray;
        }
        refStack = Ref3.createCheck(refStack, obj);
        const entries3 = [];
        let i = 0;
        for (const e of obj) {
          entries3[i++] = objectToTokens3(e, options, refStack);
        }
        if (options.addBreakTokens) {
          return [
            new token.Token(token.Type.array, obj.length),
            entries3,
            new token.Token(token.Type.break)
          ];
        }
        return [
          new token.Token(token.Type.array, obj.length),
          entries3
        ];
      },
      Object(obj, typ, options, refStack) {
        const isMap = typ !== "Object";
        const keys2 = isMap ? obj.keys() : Object.keys(obj);
        const length5 = isMap ? obj.size : keys2.length;
        if (!length5) {
          if (options.addBreakTokens === true) {
            return [
              simpleTokens3.emptyMap,
              new token.Token(token.Type.break)
            ];
          }
          return simpleTokens3.emptyMap;
        }
        refStack = Ref3.createCheck(refStack, obj);
        const entries3 = [];
        let i = 0;
        for (const key of keys2) {
          entries3[i++] = [
            objectToTokens3(key, options, refStack),
            objectToTokens3(isMap ? obj.get(key) : obj[key], options, refStack)
          ];
        }
        sortMapEntries3(entries3, options);
        if (options.addBreakTokens) {
          return [
            new token.Token(token.Type.map, length5),
            entries3,
            new token.Token(token.Type.break)
          ];
        }
        return [
          new token.Token(token.Type.map, length5),
          entries3
        ];
      }
    };
    typeEncoders3.Map = typeEncoders3.Object;
    typeEncoders3.Buffer = typeEncoders3.Uint8Array;
    for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
      typeEncoders3[`${typ}Array`] = typeEncoders3.DataView;
    }
    function objectToTokens3(obj, options = {}, refStack) {
      const typ = is3.is(obj);
      const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders3[typ];
      if (typeof customTypeEncoder === "function") {
        const tokens = customTypeEncoder(obj, typ, options, refStack);
        if (tokens != null) {
          return tokens;
        }
      }
      const typeEncoder = typeEncoders3[typ];
      if (!typeEncoder) {
        throw new Error(`${common.encodeErrPrefix} unsupported type: ${typ}`);
      }
      return typeEncoder(obj, typ, options, refStack);
    }
    function sortMapEntries3(entries3, options) {
      if (options.mapSorter) {
        entries3.sort(options.mapSorter);
      }
    }
    function mapSorter5(e1, e2) {
      const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
      const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
      if (keyToken1.type !== keyToken2.type) {
        return keyToken1.type.compare(keyToken2.type);
      }
      const major = keyToken1.type.major;
      const tcmp = cborEncoders4[major].compareTokens(keyToken1, keyToken2);
      if (tcmp === 0) {
        console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
      }
      return tcmp;
    }
    function tokensToEncoded3(buf4, tokens, encoders, options) {
      if (Array.isArray(tokens)) {
        for (const token2 of tokens) {
          tokensToEncoded3(buf4, token2, encoders, options);
        }
      } else {
        encoders[tokens.type.major](buf4, tokens, options);
      }
    }
    function encodeCustom3(data, encoders, options) {
      const tokens = objectToTokens3(data, options);
      if (!Array.isArray(tokens) && options.quickEncodeToken) {
        const quickBytes = options.quickEncodeToken(tokens);
        if (quickBytes) {
          return quickBytes;
        }
        const encoder3 = encoders[tokens.type.major];
        if (encoder3.encodedSize) {
          const size5 = encoder3.encodedSize(tokens, options);
          const buf4 = new bl.Bl(size5);
          encoder3(buf4, tokens, options);
          if (buf4.chunks.length !== 1) {
            throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
          }
          return byteUtils.asU8A(buf4.chunks[0]);
        }
      }
      buf3.reset();
      tokensToEncoded3(buf3, tokens, encoders, options);
      return buf3.toBytes(true);
    }
    function encode45(data, options) {
      options = Object.assign({}, defaultEncodeOptions6, options);
      return encodeCustom3(data, cborEncoders4, options);
    }
    exports2.Ref = Ref3;
    exports2.encode = encode45;
    exports2.encodeCustom = encodeCustom3;
    exports2.makeCborEncoders = makeCborEncoders3;
    exports2.objectToTokens = objectToTokens3;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/decode.js
var require_decode = __commonJS({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/lib/decode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var common = require_common();
    var token = require_token();
    var jump3 = require_jump();
    var defaultDecodeOptions3 = {
      strict: false,
      allowIndefinite: true,
      allowUndefined: true,
      allowBigInt: true
    };
    var Tokeniser3 = class {
      constructor(data, options = {}) {
        this.pos = 0;
        this.data = data;
        this.options = options;
      }
      done() {
        return this.pos >= this.data.length;
      }
      next() {
        const byt = this.data[this.pos];
        let token2 = jump3.quick[byt];
        if (token2 === void 0) {
          const decoder3 = jump3.jump[byt];
          if (!decoder3) {
            throw new Error(`${common.decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
          }
          const minor = byt & 31;
          token2 = decoder3(this.data, this.pos, minor, this.options);
        }
        this.pos += token2.encodedLength;
        return token2;
      }
    };
    var DONE3 = Symbol.for("DONE");
    var BREAK3 = Symbol.for("BREAK");
    function tokenToArray3(token2, tokeniser, options) {
      const arr = [];
      for (let i = 0; i < token2.value; i++) {
        const value = tokensToObject3(tokeniser, options);
        if (value === BREAK3) {
          if (token2.value === Infinity) {
            break;
          }
          throw new Error(`${common.decodeErrPrefix} got unexpected break to lengthed array`);
        }
        if (value === DONE3) {
          throw new Error(`${common.decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token2.value})`);
        }
        arr[i] = value;
      }
      return arr;
    }
    function tokenToMap3(token2, tokeniser, options) {
      const useMaps = options.useMaps === true;
      const obj = useMaps ? void 0 : {};
      const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
      for (let i = 0; i < token2.value; i++) {
        const key = tokensToObject3(tokeniser, options);
        if (key === BREAK3) {
          if (token2.value === Infinity) {
            break;
          }
          throw new Error(`${common.decodeErrPrefix} got unexpected break to lengthed map`);
        }
        if (key === DONE3) {
          throw new Error(`${common.decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token2.value})`);
        }
        if (useMaps !== true && typeof key !== "string") {
          throw new Error(`${common.decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
        }
        if (options.rejectDuplicateMapKeys === true) {
          if (useMaps && m.has(key) || !useMaps && key in obj) {
            throw new Error(`${common.decodeErrPrefix} found repeat map key "${key}"`);
          }
        }
        const value = tokensToObject3(tokeniser, options);
        if (value === DONE3) {
          throw new Error(`${common.decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token2.value})`);
        }
        if (useMaps) {
          m.set(key, value);
        } else {
          obj[key] = value;
        }
      }
      return useMaps ? m : obj;
    }
    function tokensToObject3(tokeniser, options) {
      if (tokeniser.done()) {
        return DONE3;
      }
      const token$1 = tokeniser.next();
      if (token$1.type === token.Type.break) {
        return BREAK3;
      }
      if (token$1.type.terminal) {
        return token$1.value;
      }
      if (token$1.type === token.Type.array) {
        return tokenToArray3(token$1, tokeniser, options);
      }
      if (token$1.type === token.Type.map) {
        return tokenToMap3(token$1, tokeniser, options);
      }
      if (token$1.type === token.Type.tag) {
        if (options.tags && typeof options.tags[token$1.value] === "function") {
          const tagged = tokensToObject3(tokeniser, options);
          return options.tags[token$1.value](tagged);
        }
        throw new Error(`${common.decodeErrPrefix} tag not supported (${token$1.value})`);
      }
      throw new Error("unsupported");
    }
    function decode53(data, options) {
      if (!(data instanceof Uint8Array)) {
        throw new Error(`${common.decodeErrPrefix} data to decode must be a Uint8Array`);
      }
      options = Object.assign({}, defaultDecodeOptions3, options);
      const tokeniser = options.tokenizer || new Tokeniser3(data, options);
      const decoded = tokensToObject3(tokeniser, options);
      if (decoded === DONE3) {
        throw new Error(`${common.decodeErrPrefix} did not find any content to decode`);
      }
      if (decoded === BREAK3) {
        throw new Error(`${common.decodeErrPrefix} got unexpected break`);
      }
      if (!tokeniser.done()) {
        throw new Error(`${common.decodeErrPrefix} too many terminals, data makes no sense`);
      }
      return decoded;
    }
    exports2.Tokeniser = Tokeniser3;
    exports2.decode = decode53;
    exports2.tokensToObject = tokensToObject3;
  }
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/cborg.js
var require_cborg = __commonJS({
  "../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/cjs/cborg.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var encode45 = require_encode();
    var decode53 = require_decode();
    var token = require_token();
    exports2.encode = encode45.encode;
    exports2.decode = decode53.decode;
    exports2.Token = token.Token;
    exports2.Type = token.Type;
  }
});

// ../../node_modules/.pnpm/@ipld+dag-cbor@6.0.15/node_modules/@ipld/dag-cbor/cjs/index.js
var require_cjs2 = __commonJS({
  "../../node_modules/.pnpm/@ipld+dag-cbor@6.0.15/node_modules/@ipld/dag-cbor/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var cborg = require_cborg();
    var cid = require_cid();
    function _interopNamespace(e) {
      if (e && e.__esModule) return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var cborg__namespace = /* @__PURE__ */ _interopNamespace(cborg);
    var CID_CBOR_TAG3 = 42;
    function cidEncoder5(obj) {
      if (obj.asCID !== obj) {
        return null;
      }
      const cid$1 = cid.CID.asCID(obj);
      if (!cid$1) {
        return null;
      }
      const bytes2 = new Uint8Array(cid$1.bytes.byteLength + 1);
      bytes2.set(cid$1.bytes, 1);
      return [
        new cborg__namespace.Token(cborg__namespace.Type.tag, CID_CBOR_TAG3),
        new cborg__namespace.Token(cborg__namespace.Type.bytes, bytes2)
      ];
    }
    function undefinedEncoder5() {
      throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
    }
    function numberEncoder5(num) {
      if (Number.isNaN(num)) {
        throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
      }
      if (num === Infinity || num === -Infinity) {
        throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
      }
      return null;
    }
    var encodeOptions5 = {
      float64: true,
      typeEncoders: {
        Object: cidEncoder5,
        undefined: undefinedEncoder5,
        number: numberEncoder5
      }
    };
    function cidDecoder3(bytes2) {
      if (bytes2[0] !== 0) {
        throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
      }
      return cid.CID.decode(bytes2.subarray(1));
    }
    var decodeOptions5 = {
      allowIndefinite: false,
      allowUndefined: false,
      allowNaN: false,
      allowInfinity: false,
      allowBigInt: true,
      strict: true,
      useMaps: false,
      tags: []
    };
    decodeOptions5.tags[CID_CBOR_TAG3] = cidDecoder3;
    var name20 = "dag-cbor";
    var code25 = 113;
    var encode45 = (node) => cborg__namespace.encode(node, encodeOptions5);
    var decode53 = (data) => cborg__namespace.decode(data, decodeOptions5);
    exports2.code = code25;
    exports2.decode = decode53;
    exports2.encode = encode45;
    exports2.name = name20;
  }
});

// ../../node_modules/.pnpm/dag-jose@1.0.0/node_modules/dag-jose/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/dag-jose@1.0.0/node_modules/dag-jose/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k)) __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decode = exports2.encode = exports2.toGeneral = exports2.code = exports2.name = void 0;
    var signing_1 = __importDefault(require_signing());
    var encryption_1 = __importDefault(require_encryption());
    var cbor = __importStar(require_cjs2());
    exports2.name = "dag-jose";
    exports2.code = 133;
    function isDagJWS(jose) {
      return "payload" in jose && typeof jose.payload === "string" && "signatures" in jose && Array.isArray(jose.signatures);
    }
    function isEncodedJWS(jose) {
      return "payload" in jose && jose.payload instanceof Uint8Array && "signatures" in jose && Array.isArray(jose.signatures);
    }
    function isEncodedJWE(jose) {
      return "ciphertext" in jose && jose.ciphertext instanceof Uint8Array && "iv" in jose && jose.iv instanceof Uint8Array && "protected" in jose && jose.protected instanceof Uint8Array && "tag" in jose && jose.tag instanceof Uint8Array;
    }
    function isDagJWE(jose) {
      return "ciphertext" in jose && typeof jose.ciphertext === "string" && "iv" in jose && typeof jose.iv === "string" && "protected" in jose && typeof jose.protected === "string" && "tag" in jose && typeof jose.tag === "string";
    }
    function toGeneral(jose) {
      if (typeof jose === "string") {
        const split3 = jose.split(".");
        if (split3.length === 3) {
          return signing_1.default.fromSplit(split3);
        } else if (split3.length === 5) {
          return encryption_1.default.fromSplit(split3);
        }
        throw new Error("Not a valid JOSE string");
      }
      if (isDagJWS(jose) || isDagJWE(jose)) {
        return jose;
      }
      throw new Error("Not a valid unencoded JOSE object");
    }
    exports2.toGeneral = toGeneral;
    function encode45(obj) {
      if (typeof obj === "string") {
        obj = toGeneral(obj);
      }
      let encodedJose;
      if (isDagJWS(obj)) {
        encodedJose = signing_1.default.encode(obj);
      } else if (isDagJWE(obj)) {
        encodedJose = encryption_1.default.encode(obj);
      } else {
        throw new Error("Not a valid JOSE object");
      }
      return new Uint8Array(cbor.encode(encodedJose));
    }
    exports2.encode = encode45;
    function decode53(data) {
      let encoded;
      try {
        encoded = cbor.decode(data);
      } catch (e) {
        throw new Error("Not a valid DAG-JOSE object");
      }
      if (isEncodedJWS(encoded)) {
        return signing_1.default.decode(encoded);
      } else if (isEncodedJWE(encoded)) {
        return encryption_1.default.decode(encoded);
      } else {
        throw new Error("Not a valid DAG-JOSE object");
      }
    }
    exports2.decode = decode53;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var code4, name4, encode8, digest, identity;
var init_identity = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/identity.js"() {
    init_bytes();
    init_digest();
    code4 = 0;
    name4 = "identity";
    encode8 = coerce;
    digest = (input10) => create(code4, encode8(input10));
    identity = {
      code: code4,
      name: name4,
      encode: encode8,
      digest
    };
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var identity2;
var init_identity2 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/identity.js"() {
    init_base();
    init_bytes();
    identity2 = from({
      prefix: "\0",
      name: "identity",
      encode: (buf3) => toString(buf3),
      decode: (str) => fromString(str)
    });
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2;
var init_base2 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base2.js"() {
    init_base();
    base2 = rfc4648({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8;
var init_base8 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base8.js"() {
    init_base();
    base8 = rfc4648({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10;
var init_base10 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base10.js"() {
    init_base();
    base10 = baseX({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16, base16upper;
var init_base16 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base16.js"() {
    init_base();
    base16 = rfc4648({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    base16upper = rfc4648({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36, base36upper;
var init_base36 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base36.js"() {
    init_base();
    base36 = baseX({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    base36upper = baseX({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
function encode9(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
function decode10(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var alphabet, alphabetBytesToChars, alphabetCharsToBytes, base256emoji;
var init_base256emoji = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base256emoji.js"() {
    init_base();
    alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    alphabetBytesToChars = alphabet.reduce((p, c, i) => {
      p[i] = c;
      return p;
    }, []);
    alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
      p[c.codePointAt(0)] = i;
      return p;
    }, []);
    base256emoji = from({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: encode9,
      decode: decode10
    });
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/sha2.js
var sha2_exports = {};
__export(sha2_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});
var import_crypto, sha256, sha512;
var init_sha2 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/sha2.js"() {
    import_crypto = __toESM(require("crypto"), 1);
    init_hasher();
    init_bytes();
    sha256 = from2({
      name: "sha2-256",
      code: 18,
      encode: (input10) => coerce(import_crypto.default.createHash("sha256").update(input10).digest())
    });
    sha512 = from2({
      name: "sha2-512",
      code: 19,
      encode: (input10) => coerce(import_crypto.default.createHash("sha512").update(input10).digest())
    });
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/codecs/raw.js
var raw_exports = {};
__export(raw_exports, {
  code: () => code5,
  decode: () => decode11,
  encode: () => encode10,
  name: () => name5
});
var name5, code5, encode10, decode11;
var init_raw = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/codecs/raw.js"() {
    init_bytes();
    name5 = "raw";
    code5 = 85;
    encode10 = (node) => coerce(node);
    decode11 = (data) => coerce(data);
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/codecs/json.js
var json_exports2 = {};
__export(json_exports2, {
  code: () => code6,
  decode: () => decode12,
  encode: () => encode11,
  name: () => name6
});
var textEncoder4, textDecoder3, name6, code6, encode11, decode12;
var init_json2 = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/codecs/json.js"() {
    textEncoder4 = new TextEncoder();
    textDecoder3 = new TextDecoder();
    name6 = "json";
    code6 = 512;
    encode11 = (node) => textEncoder4.encode(JSON.stringify(node));
    decode12 = (data) => JSON.parse(textDecoder3.decode(data));
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/basics.js
var bases, hashes, codecs;
var init_basics = __esm({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/basics.js"() {
    init_identity2();
    init_base2();
    init_base8();
    init_base10();
    init_base16();
    init_base32();
    init_base36();
    init_base58();
    init_base64();
    init_base256emoji();
    init_sha2();
    init_identity();
    init_raw();
    init_json2();
    init_src2();
    bases = {
      ...identity_exports2,
      ...base2_exports,
      ...base8_exports,
      ...base10_exports,
      ...base16_exports,
      ...base32_exports,
      ...base36_exports,
      ...base58_exports,
      ...base64_exports,
      ...base256emoji_exports
    };
    hashes = {
      ...sha2_exports,
      ...identity_exports
    };
    codecs = {
      raw: raw_exports,
      json: json_exports2
    };
  }
});

// ../../node_modules/.pnpm/ip-regex@4.3.0/node_modules/ip-regex/index.js
var require_ip_regex = __commonJS({
  "../../node_modules/.pnpm/ip-regex@4.3.0/node_modules/ip-regex/index.js"(exports2, module2) {
    "use strict";
    var word = "[a-fA-F\\d:]";
    var b = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
    var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
    var v6seg = "[a-fA-F\\d]{1,4}";
    var v6 = `
(?:
(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
    var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
    var v4exact = new RegExp(`^${v4}$`);
    var v6exact = new RegExp(`^${v6}$`);
    var ip = (options) => options && options.exact ? v46Exact : new RegExp(`(?:${b(options)}${v4}${b(options)})|(?:${b(options)}${v6}${b(options)})`, "g");
    ip.v4 = (options) => options && options.exact ? v4exact : new RegExp(`${b(options)}${v4}${b(options)}`, "g");
    ip.v6 = (options) => options && options.exact ? v6exact : new RegExp(`${b(options)}${v6}${b(options)}`, "g");
    module2.exports = ip;
  }
});

// ../../node_modules/.pnpm/is-ip@3.1.0/node_modules/is-ip/index.js
var require_is_ip = __commonJS({
  "../../node_modules/.pnpm/is-ip@3.1.0/node_modules/is-ip/index.js"(exports2, module2) {
    "use strict";
    var ipRegex = require_ip_regex();
    var isIp = (string4) => ipRegex({ exact: true }).test(string4);
    isIp.v4 = (string4) => ipRegex.v4({ exact: true }).test(string4);
    isIp.v6 = (string4) => ipRegex.v6({ exact: true }).test(string4);
    isIp.version = (string4) => isIp(string4) ? isIp.v4(string4) ? 4 : 6 : void 0;
    module2.exports = isIp;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/identity.js
var require_identity = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/identity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var bytes2 = require_bytes();
    var identity6 = base6.from({
      prefix: "\0",
      name: "identity",
      encode: (buf3) => bytes2.toString(buf3),
      decode: (str) => bytes2.fromString(str)
    });
    exports2.identity = identity6;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base2.js
var require_base2 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var base23 = base6.rfc4648({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
    exports2.base2 = base23;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base8.js
var require_base8 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var base83 = base6.rfc4648({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
    exports2.base8 = base83;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base10.js
var require_base10 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base10.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var base103 = base6.baseX({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
    exports2.base10 = base103;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base16.js
var require_base16 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base16.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var base163 = base6.rfc4648({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    var base16upper3 = base6.rfc4648({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
    exports2.base16 = base163;
    exports2.base16upper = base16upper3;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base36.js
var require_base36 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base36.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var base363 = base6.baseX({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    var base36upper3 = base6.baseX({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
    exports2.base36 = base363;
    exports2.base36upper = base36upper3;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base256emoji.js
var require_base256emoji = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base256emoji.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base6 = require_base();
    var alphabet3 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    var alphabetBytesToChars3 = alphabet3.reduce((p, c, i) => {
      p[i] = c;
      return p;
    }, []);
    var alphabetCharsToBytes3 = alphabet3.reduce((p, c, i) => {
      p[c.codePointAt(0)] = i;
      return p;
    }, []);
    function encode45(data) {
      return data.reduce((p, c) => {
        p += alphabetBytesToChars3[c];
        return p;
      }, "");
    }
    function decode53(str) {
      const byts = [];
      for (const char of str) {
        const byt = alphabetCharsToBytes3[char.codePointAt(0)];
        if (byt === void 0) {
          throw new Error(`Non-base256emoji character: ${char}`);
        }
        byts.push(byt);
      }
      return new Uint8Array(byts);
    }
    var base256emoji3 = base6.from({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: encode45,
      decode: decode53
    });
    exports2.base256emoji = base256emoji3;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/hasher.js
var require_hasher = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/hasher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var digest6 = require_digest2();
    var from21 = ({ name: name20, code: code25, encode: encode45 }) => new Hasher6(name20, code25, encode45);
    var Hasher6 = class {
      constructor(name20, code25, encode45) {
        this.name = name20;
        this.code = code25;
        this.encode = encode45;
      }
      digest(input10) {
        if (input10 instanceof Uint8Array) {
          const result = this.encode(input10);
          return result instanceof Uint8Array ? digest6.create(this.code, result) : result.then((digest$1) => digest6.create(this.code, digest$1));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    exports2.Hasher = Hasher6;
    exports2.from = from21;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/sha2.js
var require_sha2 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/sha2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto9 = require("crypto");
    var hasher = require_hasher();
    var bytes2 = require_bytes();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto9);
    var sha2565 = hasher.from({
      name: "sha2-256",
      code: 18,
      encode: (input10) => bytes2.coerce(crypto__default["default"].createHash("sha256").update(input10).digest())
    });
    var sha5125 = hasher.from({
      name: "sha2-512",
      code: 19,
      encode: (input10) => bytes2.coerce(crypto__default["default"].createHash("sha512").update(input10).digest())
    });
    exports2.sha256 = sha2565;
    exports2.sha512 = sha5125;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/identity.js
var require_identity2 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/identity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bytes2 = require_bytes();
    var digest$1 = require_digest2();
    var code25 = 0;
    var name20 = "identity";
    var encode45 = bytes2.coerce;
    var digest6 = (input10) => digest$1.create(code25, encode45(input10));
    var identity6 = {
      code: code25,
      name: name20,
      encode: encode45,
      digest: digest6
    };
    exports2.identity = identity6;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/codecs/raw.js
var require_raw = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/codecs/raw.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bytes2 = require_bytes();
    var name20 = "raw";
    var code25 = 85;
    var encode45 = (node) => bytes2.coerce(node);
    var decode53 = (data) => bytes2.coerce(data);
    exports2.code = code25;
    exports2.decode = decode53;
    exports2.encode = encode45;
    exports2.name = name20;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/codecs/json.js
var require_json = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/codecs/json.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var textEncoder9 = new TextEncoder();
    var textDecoder7 = new TextDecoder();
    var name20 = "json";
    var code25 = 512;
    var encode45 = (node) => textEncoder9.encode(JSON.stringify(node));
    var decode53 = (data) => JSON.parse(textDecoder7.decode(data));
    exports2.code = code25;
    exports2.decode = decode53;
    exports2.encode = encode45;
    exports2.name = name20;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/index.js
var require_src = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var cid = require_cid();
    var varint9 = require_varint2();
    var bytes2 = require_bytes();
    var hasher = require_hasher();
    var digest6 = require_digest2();
    exports2.CID = cid.CID;
    exports2.varint = varint9;
    exports2.bytes = bytes2;
    exports2.hasher = hasher;
    exports2.digest = digest6;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/basics.js
var require_basics = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/basics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var identity6 = require_identity();
    var base23 = require_base2();
    var base83 = require_base8();
    var base103 = require_base10();
    var base163 = require_base16();
    var base325 = require_base32();
    var base363 = require_base36();
    var base58 = require_base58();
    var base644 = require_base64();
    var base256emoji3 = require_base256emoji();
    var sha2 = require_sha2();
    var identity$1 = require_identity2();
    var raw = require_raw();
    var json = require_json();
    require_src();
    var cid = require_cid();
    var hasher = require_hasher();
    var digest6 = require_digest2();
    var varint9 = require_varint2();
    var bytes2 = require_bytes();
    var bases3 = {
      ...identity6,
      ...base23,
      ...base83,
      ...base103,
      ...base163,
      ...base325,
      ...base363,
      ...base58,
      ...base644,
      ...base256emoji3
    };
    var hashes3 = {
      ...sha2,
      ...identity$1
    };
    var codecs2 = {
      raw,
      json
    };
    exports2.CID = cid.CID;
    exports2.hasher = hasher;
    exports2.digest = digest6;
    exports2.varint = varint9;
    exports2.bytes = bytes2;
    exports2.bases = bases3;
    exports2.codecs = codecs2;
    exports2.hashes = hashes3;
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/util/as-uint8array.js
var require_as_uint8array = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/util/as-uint8array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function asUint8Array4(buf3) {
      if (globalThis.Buffer != null) {
        return new Uint8Array(buf3.buffer, buf3.byteOffset, buf3.byteLength);
      }
      return buf3;
    }
    exports2.asUint8Array = asUint8Array4;
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/alloc.js
var require_alloc = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/alloc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var asUint8array = require_as_uint8array();
    function alloc4(size5 = 0) {
      if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.alloc(size5));
      }
      return new Uint8Array(size5);
    }
    function allocUnsafe3(size5 = 0) {
      if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.allocUnsafe(size5));
      }
      return new Uint8Array(size5);
    }
    exports2.alloc = alloc4;
    exports2.allocUnsafe = allocUnsafe3;
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/util/bases.js
var require_bases = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/util/bases.js"(exports2, module2) {
    "use strict";
    var basics = require_basics();
    var alloc4 = require_alloc();
    function createCodec3(name20, prefix2, encode45, decode53) {
      return {
        name: name20,
        prefix: prefix2,
        encoder: {
          name: name20,
          prefix: prefix2,
          encode: encode45
        },
        decoder: { decode: decode53 }
      };
    }
    var string4 = createCodec3("utf8", "u", (buf3) => {
      const decoder3 = new TextDecoder("utf8");
      return "u" + decoder3.decode(buf3);
    }, (str) => {
      const encoder3 = new TextEncoder();
      return encoder3.encode(str.substring(1));
    });
    var ascii3 = createCodec3("ascii", "a", (buf3) => {
      let string5 = "a";
      for (let i = 0; i < buf3.length; i++) {
        string5 += String.fromCharCode(buf3[i]);
      }
      return string5;
    }, (str) => {
      str = str.substring(1);
      const buf3 = alloc4.allocUnsafe(str.length);
      for (let i = 0; i < str.length; i++) {
        buf3[i] = str.charCodeAt(i);
      }
      return buf3;
    });
    var BASES3 = {
      utf8: string4,
      "utf-8": string4,
      hex: basics.bases.base16,
      latin1: ascii3,
      ascii: ascii3,
      binary: ascii3,
      ...basics.bases
    };
    module2.exports = BASES3;
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/to-string.js
var require_to_string = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/to-string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bases3 = require_bases();
    function toString8(array2, encoding = "utf8") {
      const base6 = bases3[encoding];
      if (!base6) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return globalThis.Buffer.from(array2.buffer, array2.byteOffset, array2.byteLength).toString("utf8");
      }
      return base6.encoder.encode(array2).substring(1);
    }
    exports2.toString = toString8;
  }
});

// ../../node_modules/.pnpm/multiaddr@10.0.1/node_modules/multiaddr/src/ip.js
var require_ip = __commonJS({
  "../../node_modules/.pnpm/multiaddr@10.0.1/node_modules/multiaddr/src/ip.js"(exports2, module2) {
    "use strict";
    var isIp = require_is_ip();
    var { toString: uint8ArrayToString } = require_to_string();
    var isIP = isIp;
    var isV4 = isIp.v4;
    var isV6 = isIp.v6;
    var toBytes5 = function(ip, buff, offset2) {
      offset2 = ~~offset2;
      let result;
      if (isV4(ip)) {
        result = buff || new Uint8Array(offset2 + 4);
        ip.split(/\./g).map(function(byte) {
          result[offset2++] = parseInt(byte, 10) & 255;
        });
      } else if (isV6(ip)) {
        const sections = ip.split(":", 8);
        let i;
        for (i = 0; i < sections.length; i++) {
          const isv4 = isV4(sections[i]);
          let v4Buffer;
          if (isv4) {
            v4Buffer = toBytes5(sections[i]);
            sections[i] = uint8ArrayToString(v4Buffer.slice(0, 2), "base16");
          }
          if (v4Buffer && ++i < 8) {
            sections.splice(i, 0, uint8ArrayToString(v4Buffer.slice(2, 4), "base16"));
          }
        }
        if (sections[0] === "") {
          while (sections.length < 8) sections.unshift("0");
        } else if (sections[sections.length - 1] === "") {
          while (sections.length < 8) sections.push("0");
        } else if (sections.length < 8) {
          for (i = 0; i < sections.length && sections[i] !== ""; i++) ;
          const argv = [i, "1"];
          for (i = 9 - sections.length; i > 0; i--) {
            argv.push("0");
          }
          sections.splice.apply(sections, argv);
        }
        result = buff || new Uint8Array(offset2 + 16);
        for (i = 0; i < sections.length; i++) {
          const word = parseInt(sections[i], 16);
          result[offset2++] = word >> 8 & 255;
          result[offset2++] = word & 255;
        }
      }
      if (!result) {
        throw Error("Invalid ip address: " + ip);
      }
      return result;
    };
    var toString8 = function(buff, offset2, length5) {
      offset2 = ~~offset2;
      length5 = length5 || buff.length - offset2;
      const result = [];
      let string4;
      const view6 = new DataView(buff.buffer);
      if (length5 === 4) {
        for (let i = 0; i < length5; i++) {
          result.push(buff[offset2 + i]);
        }
        string4 = result.join(".");
      } else if (length5 === 16) {
        for (let i = 0; i < length5; i += 2) {
          result.push(view6.getUint16(offset2 + i).toString(16));
        }
        string4 = result.join(":");
        string4 = string4.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3");
        string4 = string4.replace(/:{3,4}/, "::");
      }
      return string4;
    };
    module2.exports = {
      isIP,
      isV4,
      isV6,
      toBytes: toBytes5,
      toString: toString8
    };
  }
});

// ../../node_modules/.pnpm/multiaddr@10.0.1/node_modules/multiaddr/src/protocols-table.js
var require_protocols_table = __commonJS({
  "../../node_modules/.pnpm/multiaddr@10.0.1/node_modules/multiaddr/src/protocols-table.js"(exports2, module2) {
    "use strict";
    function Protocols(proto) {
      if (typeof proto === "number") {
        if (Protocols.codes[proto]) {
          return Protocols.codes[proto];
        }
        throw new Error("no protocol with code: " + proto);
      } else if (typeof proto === "string") {
        if (Protocols.names[proto]) {
          return Protocols.names[proto];
        }
        throw new Error("no protocol with name: " + proto);
      }
      throw new Error("invalid protocol id type: " + proto);
    }
    var V = -1;
    Protocols.lengthPrefixedVarSize = V;
    Protocols.V = V;
    Protocols.table = [
      [4, 32, "ip4"],
      [6, 16, "tcp"],
      [33, 16, "dccp"],
      [41, 128, "ip6"],
      [42, V, "ip6zone"],
      [53, V, "dns", "resolvable"],
      [54, V, "dns4", "resolvable"],
      [55, V, "dns6", "resolvable"],
      [56, V, "dnsaddr", "resolvable"],
      [132, 16, "sctp"],
      [273, 16, "udp"],
      [275, 0, "p2p-webrtc-star"],
      [276, 0, "p2p-webrtc-direct"],
      [277, 0, "p2p-stardust"],
      [290, 0, "p2p-circuit"],
      [301, 0, "udt"],
      [302, 0, "utp"],
      [400, V, "unix", false, "path"],
      // `ipfs` is added before `p2p` for legacy support.
      // All text representations will default to `p2p`, but `ipfs` will
      // still be supported
      [421, V, "ipfs"],
      // `p2p` is the preferred name for 421, and is now the default
      [421, V, "p2p"],
      [443, 0, "https"],
      [444, 96, "onion"],
      [445, 296, "onion3"],
      [446, V, "garlic64"],
      [460, 0, "quic"],
      [477, 0, "ws"],
      [478, 0, "wss"],
      [479, 0, "p2p-websocket-star"],
      [480, 0, "http"],
      [777, V, "memory"]
    ];
    Protocols.names = {};
    Protocols.codes = {};
    Protocols.table.map((row) => {
      const proto = p.apply(null, row);
      Protocols.codes[proto.code] = proto;
      Protocols.names[proto.name] = proto;
      return null;
    });
    Protocols.object = p;
    function p(code25, size5, name20, resolvable, path) {
      return {
        code: code25,
        size: size5,
        name: name20,
        resolvable: Boolean(resolvable),
        path: Boolean(path)
      };
    }
    module2.exports = Protocols;
  }
});

// ../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js
var require_encode2 = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js"(exports2, module2) {
    module2.exports = encode45;
    var MSB6 = 128;
    var REST6 = 127;
    var MSBALL6 = ~REST6;
    var INT6 = Math.pow(2, 31);
    function encode45(num, out, offset2) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode45.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset2 = offset2 || 0;
      var oldOffset = offset2;
      while (num >= INT6) {
        out[offset2++] = num & 255 | MSB6;
        num /= 128;
      }
      while (num & MSBALL6) {
        out[offset2++] = num & 255 | MSB6;
        num >>>= 7;
      }
      out[offset2] = num | 0;
      encode45.bytes = offset2 - oldOffset + 1;
      return out;
    }
  }
});

// ../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js
var require_decode2 = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js"(exports2, module2) {
    module2.exports = read10;
    var MSB6 = 128;
    var REST6 = 127;
    function read10(buf3, offset2) {
      var res = 0, offset2 = offset2 || 0, shift = 0, counter = offset2, b, l = buf3.length;
      do {
        if (counter >= l || shift > 49) {
          read10.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf3[counter++];
        res += shift < 28 ? (b & REST6) << shift : (b & REST6) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB6);
      read10.bytes = counter - offset2;
      return res;
    }
  }
});

// ../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js
var require_length = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js"(exports2, module2) {
    var N15 = Math.pow(2, 7);
    var N25 = Math.pow(2, 14);
    var N35 = Math.pow(2, 21);
    var N45 = Math.pow(2, 28);
    var N55 = Math.pow(2, 35);
    var N65 = Math.pow(2, 42);
    var N75 = Math.pow(2, 49);
    var N85 = Math.pow(2, 56);
    var N95 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N15 ? 1 : value < N25 ? 2 : value < N35 ? 3 : value < N45 ? 4 : value < N55 ? 5 : value < N65 ? 6 : value < N75 ? 7 : value < N85 ? 8 : value < N95 ? 9 : 10;
    };
  }
});

// ../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js
var require_varint3 = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js"(exports2, module2) {
    module2.exports = {
      encode: require_encode2(),
      decode: require_decode2(),
      encodingLength: require_length()
    };
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/from-string.js
var require_from_string = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/from-string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bases3 = require_bases();
    var asUint8array = require_as_uint8array();
    function fromString7(string4, encoding = "utf8") {
      const base6 = bases3[encoding];
      if (!base6) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.from(string4, "utf-8"));
      }
      return base6.decoder.decode(`${base6.prefix}${string4}`);
    }
    exports2.fromString = fromString7;
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/concat.js
var require_concat = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/concat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var alloc4 = require_alloc();
    var asUint8array = require_as_uint8array();
    function concat4(arrays, length5) {
      if (!length5) {
        length5 = arrays.reduce((acc, curr) => acc + curr.length, 0);
      }
      const output = alloc4.allocUnsafe(length5);
      let offset2 = 0;
      for (const arr of arrays) {
        output.set(arr, offset2);
        offset2 += arr.length;
      }
      return asUint8array.asUint8Array(output);
    }
    exports2.concat = concat4;
  }
});

// ../../node_modules/.pnpm/multiaddr@10.0.1/node_modules/multiaddr/src/convert.js
var require_convert = __commonJS({
  "../../node_modules/.pnpm/multiaddr@10.0.1/node_modules/multiaddr/src/convert.js"(exports2, module2) {
    "use strict";
    var ip = require_ip();
    var protocols = require_protocols_table();
    var { CID: CID5 } = require_cid();
    var { base32: base325 } = require_base32();
    var { base58btc: base58btc5 } = require_base58();
    var Digest7 = require_digest2();
    var varint9 = require_varint3();
    var { toString: uint8ArrayToString } = require_to_string();
    var { fromString: uint8ArrayFromString } = require_from_string();
    var { concat: uint8ArrayConcat } = require_concat();
    module2.exports = Convert;
    function Convert(proto, a) {
      if (a instanceof Uint8Array) {
        return Convert.toString(proto, a);
      } else {
        return Convert.toBytes(proto, a);
      }
    }
    Convert.toString = function convertToString(proto, buf3) {
      const protocol = protocols(proto);
      switch (protocol.code) {
        case 4:
        case 41:
          return bytes2ip(buf3);
        case 6:
        case 273:
        case 33:
        case 132:
          return bytes2port(buf3).toString();
        case 53:
        case 54:
        case 55:
        case 56:
        case 400:
        case 777:
          return bytes2str(buf3);
        case 421:
          return bytes2mh(buf3);
        case 444:
          return bytes2onion(buf3);
        case 445:
          return bytes2onion(buf3);
        default:
          return uint8ArrayToString(buf3, "base16");
      }
    };
    Convert.toBytes = function convertToBytes(proto, str) {
      const protocol = protocols(proto);
      switch (protocol.code) {
        case 4:
          return ip2bytes(str);
        case 41:
          return ip2bytes(str);
        case 6:
        case 273:
        case 33:
        case 132:
          return port2bytes(parseInt(str, 10));
        case 53:
        case 54:
        case 55:
        case 56:
        case 400:
        case 777:
          return str2bytes(str);
        case 421:
          return mh2bytes(str);
        case 444:
          return onion2bytes(str);
        case 445:
          return onion32bytes(str);
        default:
          return uint8ArrayFromString(str, "base16");
      }
    };
    function ip2bytes(ipString) {
      if (!ip.isIP(ipString)) {
        throw new Error("invalid ip address");
      }
      return ip.toBytes(ipString);
    }
    function bytes2ip(ipBuff) {
      const ipString = ip.toString(ipBuff);
      if (!ipString || !ip.isIP(ipString)) {
        throw new Error("invalid ip address");
      }
      return ipString;
    }
    function port2bytes(port) {
      const buf3 = new ArrayBuffer(2);
      const view6 = new DataView(buf3);
      view6.setUint16(0, port);
      return new Uint8Array(buf3);
    }
    function bytes2port(buf3) {
      const view6 = new DataView(buf3.buffer);
      return view6.getUint16(buf3.byteOffset);
    }
    function str2bytes(str) {
      const buf3 = uint8ArrayFromString(str);
      const size5 = Uint8Array.from(varint9.encode(buf3.length));
      return uint8ArrayConcat([size5, buf3], size5.length + buf3.length);
    }
    function bytes2str(buf3) {
      const size5 = varint9.decode(buf3);
      buf3 = buf3.slice(varint9.decode.bytes);
      if (buf3.length !== size5) {
        throw new Error("inconsistent lengths");
      }
      return uint8ArrayToString(buf3);
    }
    function mh2bytes(hash) {
      let mh;
      if (hash[0] === "Q" || hash[0] === "1") {
        mh = Digest7.decode(base58btc5.decode(`z${hash}`)).bytes;
      } else {
        mh = CID5.parse(hash).multihash.bytes;
      }
      const size5 = Uint8Array.from(varint9.encode(mh.length));
      return uint8ArrayConcat([size5, mh], size5.length + mh.length);
    }
    function bytes2mh(buf3) {
      const size5 = varint9.decode(buf3);
      const address = buf3.slice(varint9.decode.bytes);
      if (address.length !== size5) {
        throw new Error("inconsistent lengths");
      }
      return uint8ArrayToString(address, "base58btc");
    }
    function onion2bytes(str) {
      const addr = str.split(":");
      if (addr.length !== 2) {
        throw new Error("failed to parse onion addr: " + addr + " does not contain a port number");
      }
      if (addr[0].length !== 16) {
        throw new Error("failed to parse onion addr: " + addr[0] + " not a Tor onion address.");
      }
      const buf3 = base325.decode("b" + addr[0]);
      const port = parseInt(addr[1], 10);
      if (port < 1 || port > 65536) {
        throw new Error("Port number is not in range(1, 65536)");
      }
      const portBuf = port2bytes(port);
      return uint8ArrayConcat([buf3, portBuf], buf3.length + portBuf.length);
    }
    function onion32bytes(str) {
      const addr = str.split(":");
      if (addr.length !== 2) {
        throw new Error("failed to parse onion addr: " + addr + " does not contain a port number");
      }
      if (addr[0].length !== 56) {
        throw new Error("failed to parse onion addr: " + addr[0] + " not a Tor onion3 address.");
      }
      const buf3 = base325.decode("b" + addr[0]);
      const port = parseInt(addr[1], 10);
      if (port < 1 || port > 65536) {
        throw new Error("Port number is not in range(1, 65536)");
      }
      const portBuf = port2bytes(port);
      return uint8ArrayConcat([buf3, portBuf], buf3.length + portBuf.length);
    }
    function bytes2onion(buf3) {
      const addrBytes = buf3.slice(0, buf3.length - 2);
      const portBytes = buf3.slice(buf3.length - 2);
      const addr = uint8ArrayToString(addrBytes, "base32");
      const port = bytes2port(portBytes);
      return addr + ":" + port;
    }
  }
});

// ../../node_modules/.pnpm/multiaddr@10.0.1/node_modules/multiaddr/src/codec.js
var require_codec = __commonJS({
  "../../node_modules/.pnpm/multiaddr@10.0.1/node_modules/multiaddr/src/codec.js"(exports2, module2) {
    "use strict";
    var convert = require_convert();
    var protocols = require_protocols_table();
    var varint9 = require_varint3();
    var { concat: uint8ArrayConcat } = require_concat();
    var { toString: uint8ArrayToString } = require_to_string();
    module2.exports = {
      stringToStringTuples,
      stringTuplesToString,
      tuplesToStringTuples,
      stringTuplesToTuples,
      bytesToTuples,
      tuplesToBytes,
      bytesToString,
      stringToBytes,
      fromString: fromString7,
      fromBytes: fromBytes6,
      validateBytes,
      isValidBytes,
      cleanPath,
      ParseError: ParseError2,
      protoFromTuple,
      sizeForAddr
    };
    function stringToStringTuples(str) {
      const tuples = [];
      const parts = str.split("/").slice(1);
      if (parts.length === 1 && parts[0] === "") {
        return [];
      }
      for (let p = 0; p < parts.length; p++) {
        const part = parts[p];
        const proto = protocols(part);
        if (proto.size === 0) {
          tuples.push([part]);
          continue;
        }
        p++;
        if (p >= parts.length) {
          throw ParseError2("invalid address: " + str);
        }
        if (proto.path) {
          tuples.push([
            part,
            // TODO: should we need to check each path part to see if it's a proto?
            // This would allow for other protocols to be added after a unix path,
            // however it would have issues if the path had a protocol name in the path
            cleanPath(parts.slice(p).join("/"))
          ]);
          break;
        }
        tuples.push([part, parts[p]]);
      }
      return tuples;
    }
    function stringTuplesToString(tuples) {
      const parts = [];
      tuples.map((tup) => {
        const proto = protoFromTuple(tup);
        parts.push(proto.name);
        if (tup.length > 1) {
          parts.push(tup[1]);
        }
        return null;
      });
      return cleanPath(parts.join("/"));
    }
    function stringTuplesToTuples(tuples) {
      return tuples.map((tup) => {
        if (!Array.isArray(tup)) {
          tup = [tup];
        }
        const proto = protoFromTuple(tup);
        if (tup.length > 1) {
          return [proto.code, convert.toBytes(proto.code, tup[1])];
        }
        return [proto.code];
      });
    }
    function tuplesToStringTuples(tuples) {
      return tuples.map((tup) => {
        const proto = protoFromTuple(tup);
        if (tup[1]) {
          return [proto.code, convert.toString(proto.code, tup[1])];
        }
        return [proto.code];
      });
    }
    function tuplesToBytes(tuples) {
      return fromBytes6(uint8ArrayConcat(tuples.map((tup) => {
        const proto = protoFromTuple(tup);
        let buf3 = Uint8Array.from(varint9.encode(proto.code));
        if (tup.length > 1) {
          buf3 = uint8ArrayConcat([buf3, tup[1]]);
        }
        return buf3;
      })));
    }
    function sizeForAddr(p, addr) {
      if (p.size > 0) {
        return p.size / 8;
      } else if (p.size === 0) {
        return 0;
      } else {
        const size5 = varint9.decode(addr);
        return size5 + varint9.decode.bytes;
      }
    }
    function bytesToTuples(buf3) {
      const tuples = [];
      let i = 0;
      while (i < buf3.length) {
        const code25 = varint9.decode(buf3, i);
        const n = varint9.decode.bytes;
        const p = protocols(code25);
        const size5 = sizeForAddr(p, buf3.slice(i + n));
        if (size5 === 0) {
          tuples.push([code25]);
          i += n;
          continue;
        }
        const addr = buf3.slice(i + n, i + n + size5);
        i += size5 + n;
        if (i > buf3.length) {
          throw ParseError2("Invalid address Uint8Array: " + uint8ArrayToString(buf3, "base16"));
        }
        tuples.push([code25, addr]);
      }
      return tuples;
    }
    function bytesToString(buf3) {
      const a = bytesToTuples(buf3);
      const b = tuplesToStringTuples(a);
      return stringTuplesToString(b);
    }
    function stringToBytes(str) {
      str = cleanPath(str);
      const a = stringToStringTuples(str);
      const b = stringTuplesToTuples(a);
      return tuplesToBytes(b);
    }
    function fromString7(str) {
      return stringToBytes(str);
    }
    function fromBytes6(buf3) {
      const err = validateBytes(buf3);
      if (err) throw err;
      return Uint8Array.from(buf3);
    }
    function validateBytes(buf3) {
      try {
        bytesToTuples(buf3);
      } catch (err) {
        return err;
      }
    }
    function isValidBytes(buf3) {
      return validateBytes(buf3) === void 0;
    }
    function cleanPath(str) {
      return "/" + str.trim().split("/").filter((a) => a).join("/");
    }
    function ParseError2(str) {
      return new Error("Error parsing address: " + str);
    }
    function protoFromTuple(tup) {
      const proto = protocols(tup[0]);
      return proto;
    }
  }
});

// ../../node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js
var require_err_code = __commonJS({
  "../../node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js"(exports2, module2) {
    "use strict";
    function assign2(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err, code25, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code25 === "object") {
        props = code25;
        code25 = "";
      }
      if (code25) {
        props.code = code25;
      }
      try {
        return assign2(err, props);
      } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        const output = assign2(new ErrClass(), props);
        return output;
      }
    }
    module2.exports = createError;
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/equals.js
var require_equals = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/equals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function equals10(a, b) {
      if (a === b) {
        return true;
      }
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (let i = 0; i < a.byteLength; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    exports2.equals = equals10;
  }
});

// ../../node_modules/.pnpm/multiaddr@10.0.1/node_modules/multiaddr/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/.pnpm/multiaddr@10.0.1/node_modules/multiaddr/src/index.js"(exports2, module2) {
    "use strict";
    var codec = require_codec();
    var protocols = require_protocols_table();
    var varint9 = require_varint3();
    var { CID: CID5 } = require_cid();
    var { base58btc: base58btc5 } = require_base58();
    var errCode12 = require_err_code();
    var inspect = Symbol.for("nodejs.util.inspect.custom");
    var { toString: uint8ArrayToString } = require_to_string();
    var { equals: uint8ArrayEquals } = require_equals();
    var resolvers = /* @__PURE__ */ new Map();
    var symbol2 = Symbol.for("@multiformats/js-multiaddr/multiaddr");
    var Multiaddr14 = class _Multiaddr {
      /**
       * @example
       * ```js
       * new Multiaddr('/ip4/127.0.0.1/tcp/4001')
       * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
       * ```
       *
       * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)
       */
      constructor(addr) {
        if (addr == null) {
          addr = "";
        }
        Object.defineProperty(this, symbol2, { value: true });
        if (addr instanceof Uint8Array) {
          this.bytes = codec.fromBytes(addr);
        } else if (typeof addr === "string") {
          if (addr.length > 0 && addr.charAt(0) !== "/") {
            throw new Error(`multiaddr "${addr}" must start with a "/"`);
          }
          this.bytes = codec.fromString(addr);
        } else if (_Multiaddr.isMultiaddr(addr)) {
          this.bytes = codec.fromBytes(addr.bytes);
        } else {
          throw new Error("addr must be a string, Buffer, or another Multiaddr");
        }
      }
      /**
       * Returns Multiaddr as a String
       *
       * @example
       * ```js
       * new Multiaddr('/ip4/127.0.0.1/tcp/4001').toString()
       * // '/ip4/127.0.0.1/tcp/4001'
       * ```
       */
      toString() {
        return codec.bytesToString(this.bytes);
      }
      /**
       * Returns Multiaddr as a JSON encoded object
       *
       * @example
       * ```js
       * JSON.stringify(new Multiaddr('/ip4/127.0.0.1/tcp/4001'))
       * // '/ip4/127.0.0.1/tcp/4001'
       * ```
       */
      toJSON() {
        return this.toString();
      }
      /**
       * Returns Multiaddr as a convinient options object to be used with net.createConnection
       *
       * @example
       * ```js
       * new Multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()
       * // { family: 4, host: '127.0.0.1', transport: 'tcp', port: 4001 }
       * ```
       */
      toOptions() {
        const opts = {};
        const parsed = this.toString().split("/");
        opts.family = parsed[1] === "ip4" ? 4 : 6;
        opts.host = parsed[2];
        opts.transport = parsed[3];
        opts.port = parseInt(parsed[4]);
        return opts;
      }
      /**
       * Returns the protocols the Multiaddr is defined with, as an array of objects, in
       * left-to-right order. Each object contains the protocol code, protocol name,
       * and the size of its address space in bits.
       * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)
       *
       * @example
       * ```js
       * new Multiaddr('/ip4/127.0.0.1/tcp/4001').protos()
       * // [ { code: 4, size: 32, name: 'ip4' },
       * //   { code: 6, size: 16, name: 'tcp' } ]
       * ```
       *
       * @returns {Protocol[]} protocols - All the protocols the address is composed of
       */
      protos() {
        return this.protoCodes().map((code25) => Object.assign({}, protocols(code25)));
      }
      /**
       * Returns the codes of the protocols in left-to-right order.
       * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)
       *
       * @example
       * ```js
       * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()
       * // [ 4, 6 ]
       * ```
       *
       * @returns {number[]} protocol codes
       */
      protoCodes() {
        const codes = [];
        const buf3 = this.bytes;
        let i = 0;
        while (i < buf3.length) {
          const code25 = varint9.decode(buf3, i);
          const n = varint9.decode.bytes;
          const p = protocols(code25);
          const size5 = codec.sizeForAddr(p, buf3.slice(i + n));
          i += size5 + n;
          codes.push(code25);
        }
        return codes;
      }
      /**
       * Returns the names of the protocols in left-to-right order.
       * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)
       *
       * @example
       * ```js
       * new Multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()
       * // [ 'ip4', 'tcp' ]
       * ```
       *
       * @returns {string[]} protocol names
       */
      protoNames() {
        return this.protos().map((proto) => proto.name);
      }
      /**
       * Returns a tuple of parts
       *
       * @example
       * ```js
       * new Multiaddr("/ip4/127.0.0.1/tcp/4001").tuples()
       * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]
       * ```
       */
      tuples() {
        return codec.bytesToTuples(this.bytes);
      }
      /**
       * Returns a tuple of string/number parts
       * - tuples[][0] = code of protocol
       * - tuples[][1] = contents of address
       *
       * @example
       * ```js
       * new Multiaddr("/ip4/127.0.0.1/tcp/4001").stringTuples()
       * // [ [ 4, '127.0.0.1' ], [ 6, '4001' ] ]
       * ```
       */
      stringTuples() {
        const t = codec.bytesToTuples(this.bytes);
        return codec.tuplesToStringTuples(t);
      }
      /**
       * Encapsulates a Multiaddr in another Multiaddr
       *
       * @example
       * ```js
       * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080')
       * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>
       *
       * const mh2 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')
       * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
       *
       * const mh3 = mh1.encapsulate(mh2)
       * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>
       *
       * mh3.toString()
       * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'
       * ```
       *
       * @param {MultiaddrInput} addr - Multiaddr to add into this Multiaddr
       */
      encapsulate(addr) {
        addr = new _Multiaddr(addr);
        return new _Multiaddr(this.toString() + addr.toString());
      }
      /**
       * Decapsulates a Multiaddr from another Multiaddr
       *
       * @example
       * ```js
       * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080')
       * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>
       *
       * const mh2 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')
       * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
       *
       * const mh3 = mh1.encapsulate(mh2)
       * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>
       *
       * mh3.decapsulate(mh2).toString()
       * // '/ip4/8.8.8.8/tcp/1080'
       * ```
       *
       * @param {Multiaddr | string} addr - Multiaddr to remove from this Multiaddr
       * @returns {Multiaddr}
       */
      decapsulate(addr) {
        const addrString = addr.toString();
        const s = this.toString();
        const i = s.lastIndexOf(addrString);
        if (i < 0) {
          throw new Error("Address " + this + " does not contain subaddress: " + addr);
        }
        return new _Multiaddr(s.slice(0, i));
      }
      /**
       * A more reliable version of `decapsulate` if you are targeting a
       * specific code, such as 421 (the `p2p` protocol code). The last index of the code
       * will be removed from the `Multiaddr`, and a new instance will be returned.
       * If the code is not present, the original `Multiaddr` is returned.
       *
       * @example
       * ```js
       * const addr = new Multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')
       * // <Multiaddr 0400... - /ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC>
       *
       * addr.decapsulateCode(421).toString()
       * // '/ip4/0.0.0.0/tcp/8080'
       *
       * new Multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()
       * // '/ip4/127.0.0.1/tcp/8080'
       * ```
       *
       * @param {number} code - The code of the protocol to decapsulate from this Multiaddr
       * @returns {Multiaddr}
       */
      decapsulateCode(code25) {
        const tuples = this.tuples();
        for (let i = tuples.length - 1; i >= 0; i--) {
          if (tuples[i][0] === code25) {
            return new _Multiaddr(codec.tuplesToBytes(tuples.slice(0, i)));
          }
        }
        return this;
      }
      /**
       * Extract the peerId if the multiaddr contains one
       *
       * @example
       * ```js
       * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')
       * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string>
       *
       * // should return QmValidBase58string or null if the id is missing or invalid
       * const peerId = mh1.getPeerId()
       * ```
       *
       * @returns {string | null} peerId - The id of the peer or null if invalid or missing from the ma
       */
      getPeerId() {
        try {
          const tuples = this.stringTuples().filter((tuple3) => {
            if (tuple3[0] === protocols.names.ipfs.code) {
              return true;
            }
            return false;
          });
          const tuple2 = tuples.pop();
          if (tuple2 && tuple2[1]) {
            const peerIdStr = tuple2[1];
            if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
              return uint8ArrayToString(base58btc5.decode(`z${peerIdStr}`), "base58btc");
            }
            return uint8ArrayToString(CID5.parse(peerIdStr).multihash.bytes, "base58btc");
          }
          return null;
        } catch (e) {
          return null;
        }
      }
      /**
       * Extract the path if the multiaddr contains one
       *
       * @example
       * ```js
       * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')
       * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock>
       *
       * // should return utf8 string or null if the id is missing or invalid
       * const path = mh1.getPath()
       * ```js
       *
       * @returns {string | null} path - The path of the multiaddr, or null if no path protocol is present
       */
      getPath() {
        let path = null;
        try {
          path = this.stringTuples().filter((tuple2) => {
            const proto = protocols(tuple2[0]);
            if (proto.path) {
              return true;
            }
            return false;
          })[0][1];
          if (!path) {
            path = null;
          }
        } catch (e) {
          path = null;
        }
        return path;
      }
      /**
       * Checks if two Multiaddrs are the same
       *
       * @example
       * ```js
       * const mh1 = new Multiaddr('/ip4/8.8.8.8/tcp/1080')
       * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>
       *
       * const mh2 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')
       * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
       *
       * mh1.equals(mh1)
       * // true
       *
       * mh1.equals(mh2)
       * // false
       * ```
       *
       * @param {Multiaddr} addr
       * @returns {boolean}
       */
      equals(addr) {
        return uint8ArrayEquals(this.bytes, addr.bytes);
      }
      /**
       * Resolve multiaddr if containing resolvable hostname.
       *
       * @example
       * ```js
       * Multiaddr.resolvers.set('dnsaddr', resolverFunction)
       * const mh1 = new Multiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb')
       * const resolvedMultiaddrs = await mh1.resolve()
       * // [
       * //   <Multiaddr 04934b5353060fa1a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/tcp/4001/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>,
       * //   <Multiaddr 04934b53530601bbde03a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/tcp/443/wss/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>,
       * //   <Multiaddr 04934b535391020fa1cc03a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/udp/4001/quic/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>
       * // ]
       * ```
       *
       * @returns {Promise<Array<Multiaddr>>}
       */
      async resolve() {
        const resolvableProto = this.protos().find((p) => p.resolvable);
        if (!resolvableProto) {
          return [this];
        }
        const resolver = resolvers.get(resolvableProto.name);
        if (!resolver) {
          throw errCode12(new Error(`no available resolver for ${resolvableProto.name}`), "ERR_NO_AVAILABLE_RESOLVER");
        }
        const addresses = await resolver(this);
        return addresses.map((a) => new _Multiaddr(a));
      }
      /**
       * Gets a Multiaddrs node-friendly address object. Note that protocol information
       * is left out: in Node (and most network systems) the protocol is unknowable
       * given only the address.
       *
       * Has to be a ThinWaist Address, otherwise throws error
       *
       * @example
       * ```js
       * new Multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()
       * // {family: 4, address: '127.0.0.1', port: 4001}
       * ```
       *
       * @returns {{family: 4 | 6, address: string, port: number}}
       * @throws {Error} Throws error if Multiaddr is not a Thin Waist address
       */
      nodeAddress() {
        const codes = this.protoCodes();
        const names = this.protoNames();
        const parts = this.toString().split("/").slice(1);
        if (parts.length < 4) {
          throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".');
        } else if (codes[0] !== 4 && codes[0] !== 41 && codes[0] !== 54 && codes[0] !== 55) {
          throw new Error(`no protocol with name: "'${names[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`);
        } else if (parts[2] !== "tcp" && parts[2] !== "udp") {
          throw new Error(`no protocol with name: "'${names[1]}'". Must have a valid transport protocol: "{tcp, udp}".`);
        }
        return {
          family: codes[0] === 41 || codes[0] === 55 ? 6 : 4,
          address: parts[1],
          port: parseInt(parts[3])
          // tcp or udp port
        };
      }
      /**
       * Returns if a Multiaddr is a Thin Waist address or not.
       *
       * Thin Waist is if a Multiaddr adheres to the standard combination of:
       *
       * `{IPv4, IPv6}/{TCP, UDP}`
       *
       * @example
       * ```js
       * const mh1 = new Multiaddr('/ip4/127.0.0.1/tcp/4001')
       * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
       * const mh2 = new Multiaddr('/ip4/192.168.2.1/tcp/5001')
       * // <Multiaddr 04c0a80201061389 - /ip4/192.168.2.1/tcp/5001>
       * const mh3 = mh1.encapsulate(mh2)
       * // <Multiaddr 047f000001060fa104c0a80201061389 - /ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001>
       * const mh4 = new Multiaddr('/ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a')
       * // <Multiaddr 047f0000010607d0de039302a503221220d52ebb89d85b02a284948203a62ff28389c57c9f42beec4ec20db76a64835843 - /ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a>
       * mh1.isThinWaistAddress()
       * // true
       * mh2.isThinWaistAddress()
       * // true
       * mh3.isThinWaistAddress()
       * // false
       * mh4.isThinWaistAddress()
       * // false
       * ```
       *
       * @param {Multiaddr} [addr] - Defaults to using `this` instance
       */
      isThinWaistAddress(addr) {
        const protos = (addr || this).protos();
        if (protos.length !== 2) {
          return false;
        }
        if (protos[0].code !== 4 && protos[0].code !== 41) {
          return false;
        }
        if (protos[1].code !== 6 && protos[1].code !== 273) {
          return false;
        }
        return true;
      }
      /**
       * Creates a Multiaddr from a node-friendly address object
       *
       * @example
       * ```js
       * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')
       * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>
       * ```
       *
       * @param {{family: 4 | 6, address: string, port: number}} addr
       * @param {string} transport
       */
      static fromNodeAddress(addr, transport) {
        if (!addr) {
          throw new Error("requires node address object");
        }
        if (!transport) {
          throw new Error("requires transport protocol");
        }
        let ip;
        switch (addr.family) {
          case 4:
            ip = "ip4";
            break;
          case 6:
            ip = "ip6";
            break;
          default:
            throw Error(`Invalid addr family. Got '${addr.family}' instead of 4 or 6`);
        }
        return new _Multiaddr("/" + [ip, addr.address, transport, addr.port].join("/"));
      }
      /**
       * Returns if something is a Multiaddr that is a name
       *
       * @param {Multiaddr} addr
       * @returns {boolean} isName
       */
      static isName(addr) {
        if (!_Multiaddr.isMultiaddr(addr)) {
          return false;
        }
        return addr.protos().some((proto) => proto.resolvable);
      }
      /**
       * Check if object is a CID instance
       *
       * @param {any} value
       * @returns {value is Multiaddr}
       */
      static isMultiaddr(value) {
        return value instanceof _Multiaddr || Boolean(value && value[symbol2]);
      }
      /**
       * Returns Multiaddr as a human-readable string.
       * For post Node.js v10.0.0.
       * https://nodejs.org/api/deprecations.html#deprecations_dep0079_custom_inspection_function_on_objects_via_inspect
       *
       * @example
       * ```js
       * console.log(new Multiaddr('/ip4/127.0.0.1/tcp/4001'))
       * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'
       * ```
       *
       * @returns {string}
       */
      [inspect]() {
        return "<Multiaddr " + uint8ArrayToString(this.bytes, "base16") + " - " + codec.bytesToString(this.bytes) + ">";
      }
      /**
       * Returns Multiaddr as a human-readable string.
       * Fallback for pre Node.js v10.0.0.
       * https://nodejs.org/api/deprecations.html#deprecations_dep0079_custom_inspection_function_on_objects_via_inspect
       *
       * @example
       * ```js
       * new Multiaddr('/ip4/127.0.0.1/tcp/4001').inspect()
       * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'
       * ```
       *
       * @returns {string}
       */
      inspect() {
        return "<Multiaddr " + uint8ArrayToString(this.bytes, "base16") + " - " + codec.bytesToString(this.bytes) + ">";
      }
    };
    Multiaddr14.protocols = protocols;
    Multiaddr14.resolvers = resolvers;
    function multiaddr(addr) {
      return new Multiaddr14(addr);
    }
    module2.exports = { Multiaddr: Multiaddr14, multiaddr, protocols, resolvers };
  }
});

// ../../node_modules/.pnpm/is-electron@2.2.2/node_modules/is-electron/index.js
var require_is_electron = __commonJS({
  "../../node_modules/.pnpm/is-electron@2.2.2/node_modules/is-electron/index.js"(exports2, module2) {
    function isElectron() {
      if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
        return true;
      }
      if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
        return true;
      }
      if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
        return true;
      }
      return false;
    }
    module2.exports = isElectron;
  }
});

// ../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/env.js
var require_env2 = __commonJS({
  "../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/env.js"(exports2, module2) {
    "use strict";
    var isElectron = require_is_electron();
    var IS_ENV_WITH_DOM = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
    var IS_ELECTRON = isElectron();
    var IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON;
    var IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM;
    var IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM;
    var IS_NODE = typeof require === "function" && typeof process !== "undefined" && typeof process.release !== "undefined" && process.release.name === "node" && !IS_ELECTRON;
    var IS_WEBWORKER = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
    var IS_TEST = typeof process !== "undefined" && typeof process.env !== "undefined" && process.env.NODE_ENV === "test";
    var IS_REACT_NATIVE = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    module2.exports = {
      isTest: IS_TEST,
      isElectron: IS_ELECTRON,
      isElectronMain: IS_ELECTRON_MAIN,
      isElectronRenderer: IS_ELECTRON_RENDERER,
      isNode: IS_NODE,
      /**
       * Detects browser main thread  **NOT** web worker or service worker
       */
      isBrowser: IS_BROWSER,
      isWebWorker: IS_WEBWORKER,
      isEnvWithDom: IS_ENV_WITH_DOM,
      isReactNative: IS_REACT_NATIVE
    };
  }
});

// ../../node_modules/.pnpm/parse-duration@1.1.0/node_modules/parse-duration/index.mjs
function parse(str = "", format11 = "ms") {
  var result = null;
  str = (str + "").replace(/(\d)[,_](\d)/g, "$1$2");
  var isNegative = str[0] === "-";
  str.replace(durationRE, function(_, n, units) {
    units = unitRatio(units);
    if (units) result = (result || 0) + Math.abs(parseFloat(n, 10)) * units;
  });
  return result && result / (unitRatio(format11) || 1) * (isNegative ? -1 : 1);
}
function unitRatio(str) {
  return parse[str] || parse[str.toLowerCase().replace(/s$/, "")];
}
var durationRE, parse_duration_default;
var init_parse_duration = __esm({
  "../../node_modules/.pnpm/parse-duration@1.1.0/node_modules/parse-duration/index.mjs"() {
    durationRE = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/uig;
    parse.nanosecond = parse.ns = 1 / 1e6;
    parse["\xB5s"] = parse["\u03BCs"] = parse.us = parse.microsecond = 1 / 1e3;
    parse.millisecond = parse.ms = parse[""] = 1;
    parse.second = parse.sec = parse.s = parse.ms * 1e3;
    parse.minute = parse.min = parse.m = parse.s * 60;
    parse.hour = parse.hr = parse.h = parse.m * 60;
    parse.day = parse.d = parse.h * 24;
    parse.week = parse.wk = parse.w = parse.d * 7;
    parse.month = parse.b = parse.d * (365.25 / 12);
    parse.year = parse.yr = parse.y = parse.d * 365.25;
    parse_duration_default = parse;
  }
});

// ../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js
var require_ms = __commonJS({
  "../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type2 = typeof val;
      if (type2 === "string" && val.length > 0) {
        return parse8(val);
      } else if (type2 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse8(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match5 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match5) {
        return;
      }
      var n = parseFloat(match5[1]);
      var type2 = (match5[2] || "ms").toLowerCase();
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name20) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name20 + (isPlural ? "s" : "");
    }
  }
});

// ../../node_modules/.pnpm/debug@4.3.6/node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "../../node_modules/.pnpm/debug@4.3.6/node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce5;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug4(...args) {
          if (!debug4.enabled) {
            return;
          }
          const self2 = debug4;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match5, format11) => {
            if (match5 === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug.formatters[format11];
            if (typeof formatter === "function") {
              const val = args[index2];
              match5 = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match5;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug4.namespace = namespace;
        debug4.useColors = createDebug.useColors();
        debug4.color = createDebug.selectColor(namespace);
        debug4.extend = extend;
        debug4.destroy = createDebug.destroy;
        Object.defineProperty(debug4, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug4);
        }
        return debug4;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split3 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split3.length;
        for (i = 0; i < len; i++) {
          if (!split3[i]) {
            continue;
          }
          namespaces = split3[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name20) {
        if (name20[name20.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name20)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name20)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce5(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// ../../node_modules/.pnpm/debug@4.3.6/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../node_modules/.pnpm/debug@4.3.6/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match5) => {
        if (match5 === "%%") {
          return;
        }
        index2++;
        if (match5 === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error3) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error3) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error3) {
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error3) {
        return "[UnexpectedJSONParseError]: " + error3.message;
      }
    };
  }
});

// ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix2 = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix2 + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version3 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version3 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// ../../node_modules/.pnpm/debug@4.3.6/node_modules/debug/src/node.js
var require_node = __commonJS({
  "../../node_modules/.pnpm/debug@4.3.6/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init2;
    exports2.log = log4;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error3) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name20, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix2 = `  ${colorCode};1m${name20} \x1B[0m`;
        args[0] = prefix2 + args[0].split("\n").join("\n" + prefix2);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name20 + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log4(...args) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init2(debug4) {
      debug4.inspectOpts = {};
      const keys2 = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys2.length; i++) {
        debug4.inspectOpts[keys2[i]] = exports2.inspectOpts[keys2[i]];
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// ../../node_modules/.pnpm/debug@4.3.6/node_modules/debug/src/index.js
var require_src3 = __commonJS({
  "../../node_modules/.pnpm/debug@4.3.6/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// ../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/fetch.js
var require_fetch = __commonJS({
  "../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/fetch.js"(exports2, module2) {
    "use strict";
    var { isElectronMain } = require_env2();
    var impl = "native-fetch";
    if (isElectronMain) {
      impl = "electron-fetch";
    }
    module2.exports = require(impl);
  }
});

// ../../node_modules/.pnpm/get-iterator@1.0.2/node_modules/get-iterator/index.js
var require_get_iterator = __commonJS({
  "../../node_modules/.pnpm/get-iterator@1.0.2/node_modules/get-iterator/index.js"(exports2, module2) {
    module2.exports = function getIterator(obj) {
      if (obj) {
        if (typeof obj[Symbol.iterator] === "function") {
          return obj[Symbol.iterator]();
        }
        if (typeof obj[Symbol.asyncIterator] === "function") {
          return obj[Symbol.asyncIterator]();
        }
        if (typeof obj.next === "function") {
          return obj;
        }
      }
      throw new Error("argument is not an iterator or iterable");
    };
  }
});

// ../../node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/fixed-size.js
var require_fixed_size = __commonJS({
  "../../node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/fixed-size.js"(exports2, module2) {
    module2.exports = class FixedFIFO {
      constructor(hwm) {
        if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) throw new Error("Max size for a FixedFIFO should be a power of two");
        this.buffer = new Array(hwm);
        this.mask = hwm - 1;
        this.top = 0;
        this.btm = 0;
        this.next = null;
      }
      clear() {
        this.top = this.btm = 0;
        this.next = null;
        this.buffer.fill(void 0);
      }
      push(data) {
        if (this.buffer[this.top] !== void 0) return false;
        this.buffer[this.top] = data;
        this.top = this.top + 1 & this.mask;
        return true;
      }
      shift() {
        const last5 = this.buffer[this.btm];
        if (last5 === void 0) return void 0;
        this.buffer[this.btm] = void 0;
        this.btm = this.btm + 1 & this.mask;
        return last5;
      }
      peek() {
        return this.buffer[this.btm];
      }
      isEmpty() {
        return this.buffer[this.btm] === void 0;
      }
    };
  }
});

// ../../node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/index.js
var require_fast_fifo = __commonJS({
  "../../node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/index.js"(exports2, module2) {
    var FixedFIFO = require_fixed_size();
    module2.exports = class FastFIFO {
      constructor(hwm) {
        this.hwm = hwm || 16;
        this.head = new FixedFIFO(this.hwm);
        this.tail = this.head;
        this.length = 0;
      }
      clear() {
        this.head = this.tail;
        this.head.clear();
        this.length = 0;
      }
      push(val) {
        this.length++;
        if (!this.head.push(val)) {
          const prev = this.head;
          this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
          this.head.push(val);
        }
      }
      shift() {
        if (this.length !== 0) this.length--;
        const val = this.tail.shift();
        if (val === void 0 && this.tail.next) {
          const next = this.tail.next;
          this.tail.next = null;
          this.tail = next;
          return this.tail.shift();
        }
        return val;
      }
      peek() {
        const val = this.tail.peek();
        if (val === void 0 && this.tail.next) return this.tail.next.peek();
        return val;
      }
      isEmpty() {
        return this.length === 0;
      }
    };
  }
});

// ../../node_modules/.pnpm/p-defer@3.0.0/node_modules/p-defer/index.js
var require_p_defer = __commonJS({
  "../../node_modules/.pnpm/p-defer@3.0.0/node_modules/p-defer/index.js"(exports2, module2) {
    "use strict";
    var pDefer = () => {
      const deferred = {};
      deferred.promise = new Promise((resolve2, reject) => {
        deferred.resolve = resolve2;
        deferred.reject = reject;
      });
      return deferred;
    };
    module2.exports = pDefer;
  }
});

// ../../node_modules/.pnpm/p-fifo@1.0.0/node_modules/p-fifo/index.js
var require_p_fifo = __commonJS({
  "../../node_modules/.pnpm/p-fifo@1.0.0/node_modules/p-fifo/index.js"(exports2, module2) {
    var Fifo = require_fast_fifo();
    var defer = require_p_defer();
    module2.exports = class PFifo {
      constructor() {
        this._buffer = new Fifo();
        this._waitingConsumers = new Fifo();
      }
      push(chunk) {
        const { promise, resolve: resolve2 } = defer();
        this._buffer.push({ chunk, resolve: resolve2 });
        this._consume();
        return promise;
      }
      _consume() {
        while (!this._waitingConsumers.isEmpty() && !this._buffer.isEmpty()) {
          const nextConsumer = this._waitingConsumers.shift();
          const nextChunk = this._buffer.shift();
          nextConsumer.resolve(nextChunk.chunk);
          nextChunk.resolve();
        }
      }
      shift() {
        const { promise, resolve: resolve2 } = defer();
        this._waitingConsumers.push({ resolve: resolve2 });
        this._consume();
        return promise;
      }
      isEmpty() {
        return this._buffer.isEmpty();
      }
    };
  }
});

// ../../node_modules/.pnpm/it-to-stream@1.0.0/node_modules/it-to-stream/src/duplex.js
var require_duplex = __commonJS({
  "../../node_modules/.pnpm/it-to-stream@1.0.0/node_modules/it-to-stream/src/duplex.js"(exports2, module2) {
    var { Readable, Writable, Duplex } = require("stream");
    var getIterator = require_get_iterator();
    var Fifo = require_p_fifo();
    var { Buffer: Buffer5 } = require("buffer");
    var END_CHUNK = Buffer5.alloc(0);
    module2.exports = function toDuplex(duplex, options) {
      options = options || {};
      let reading = false;
      const fifo = new Fifo();
      duplex = {
        sink: duplex.sink,
        source: duplex.source ? getIterator(duplex.source) : null
      };
      let Stream = Duplex;
      if (!duplex.source) {
        Stream = Writable;
      } else if (!duplex.sink) {
        Stream = Readable;
      }
      let readable;
      if (duplex.source) {
        readable = {
          async read(size5) {
            if (reading) return;
            reading = true;
            try {
              while (true) {
                const { value, done } = await duplex.source.next(size5);
                if (done) return this.push(null);
                if (!this.push(value)) break;
              }
            } catch (err) {
              this.emit("error", err);
            } finally {
              reading = false;
            }
          }
        };
      }
      let writable;
      if (duplex.sink) {
        writable = {
          write(chunk, enc, cb) {
            fifo.push(chunk).then(() => cb(), cb);
          },
          final(cb) {
            fifo.push(END_CHUNK).then(() => cb(), cb);
          }
        };
      }
      Object.assign(options, readable, writable);
      const stream = new Stream(options);
      if (duplex.sink) {
        duplex.sink({
          [Symbol.asyncIterator]() {
            return this;
          },
          async next() {
            const chunk = await fifo.shift();
            return chunk === END_CHUNK ? { done: true } : { value: chunk };
          },
          async throw(err) {
            stream.destroy(err);
            return { done: true };
          },
          async return() {
            stream.destroy();
            return { done: true };
          }
        });
      }
      return stream;
    };
  }
});

// ../../node_modules/.pnpm/it-to-stream@1.0.0/node_modules/it-to-stream/src/transform.js
var require_transform = __commonJS({
  "../../node_modules/.pnpm/it-to-stream@1.0.0/node_modules/it-to-stream/src/transform.js"(exports2, module2) {
    var toDuplex = require_duplex();
    var defer = require_p_defer();
    module2.exports = function toTransform(transform, options) {
      const { promise, resolve: resolve2 } = defer();
      const source = async function* () {
        const it2 = await promise;
        for await (const chunk of it2) yield chunk;
      }();
      return toDuplex({ sink: (s) => resolve2(transform(s)), source }, options);
    };
  }
});

// ../../node_modules/.pnpm/it-to-stream@1.0.0/node_modules/it-to-stream/src/index.js
var require_src4 = __commonJS({
  "../../node_modules/.pnpm/it-to-stream@1.0.0/node_modules/it-to-stream/src/index.js"(exports2, module2) {
    "use strict";
    var toTransform = require_transform();
    var toDuplex = require_duplex();
    function toReadable(source, options) {
      return toDuplex({ source }, options);
    }
    function toWritable(sink, options) {
      return toDuplex({ sink }, options);
    }
    module2.exports = toReadable;
    module2.exports.readable = toReadable;
    module2.exports.writable = toWritable;
    module2.exports.transform = toTransform;
    module2.exports.duplex = toDuplex;
  }
});

// ../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/http/fetch.node.js
var require_fetch_node = __commonJS({
  "../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/http/fetch.node.js"(exports2, module2) {
    "use strict";
    var { Request: Request2, Response: Response2, Headers: Headers2, default: defaultFetch, fetch: fetchFetch } = require_fetch();
    var toStream2 = require_src4();
    var { Buffer: Buffer5 } = require("buffer");
    var nativeFetch = defaultFetch ?? fetchFetch;
    var fetch3 = (url, options = {}) => (
      // @ts-ignore
      nativeFetch(url, withUploadProgress(options))
    );
    var withUploadProgress = (options) => {
      const { onUploadProgress, body } = options;
      if (onUploadProgress && body) {
        const content2 = normalizeBody(body);
        const rsp = new Response2(content2);
        const source = iterateBodyWithProgress(
          /** @type {NodeReadableStream} */
          rsp.body,
          onUploadProgress
        );
        return {
          ...options,
          body: toStream2.readable(source)
        };
      } else {
        return options;
      }
    };
    var normalizeBody = (input10) => {
      if (input10 instanceof ArrayBuffer) {
        return Buffer5.from(input10);
      } else if (ArrayBuffer.isView(input10)) {
        return Buffer5.from(input10.buffer, input10.byteOffset, input10.byteLength);
      } else if (typeof input10 === "string") {
        return Buffer5.from(input10);
      }
      return input10;
    };
    var iterateBodyWithProgress = async function* (body, onUploadProgress) {
      if (body == null) {
        onUploadProgress({ total: 0, loaded: 0, lengthComputable: true });
      } else if (Buffer5.isBuffer(body)) {
        const total = body.byteLength;
        const lengthComputable = true;
        yield body;
        onUploadProgress({ total, loaded: total, lengthComputable });
      } else {
        const total = 0;
        const lengthComputable = false;
        let loaded = 0;
        for await (const chunk of body) {
          loaded += chunk.byteLength;
          yield chunk;
          onUploadProgress({ total, loaded, lengthComputable });
        }
      }
    };
    module2.exports = {
      fetch: fetch3,
      Request: Request2,
      Headers: Headers2
    };
  }
});

// ../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/http/error.js
var require_error = __commonJS({
  "../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/http/error.js"(exports2) {
    "use strict";
    var TimeoutError = class extends Error {
      constructor(message = "Request timed out") {
        super(message);
        this.name = "TimeoutError";
      }
    };
    exports2.TimeoutError = TimeoutError;
    var AbortError2 = class extends Error {
      constructor(message = "The operation was aborted.") {
        super(message);
        this.name = "AbortError";
      }
    };
    exports2.AbortError = AbortError2;
    var HTTPError3 = class extends Error {
      /**
       * @param {Response} response
       */
      constructor(response) {
        super(response.statusText);
        this.name = "HTTPError";
        this.response = response;
      }
    };
    exports2.HTTPError = HTTPError3;
  }
});

// ../../node_modules/.pnpm/is-plain-obj@2.1.0/node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "../../node_modules/.pnpm/is-plain-obj@2.1.0/node_modules/is-plain-obj/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (value) => {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    };
  }
});

// ../../node_modules/.pnpm/merge-options@3.0.4/node_modules/merge-options/index.js
var require_merge_options = __commonJS({
  "../../node_modules/.pnpm/merge-options@3.0.4/node_modules/merge-options/index.js"(exports2, module2) {
    "use strict";
    var isOptionObject = require_is_plain_obj();
    var { hasOwnProperty } = Object.prototype;
    var { propertyIsEnumerable } = Object;
    var defineProperty = (object, name20, value) => Object.defineProperty(object, name20, {
      value,
      writable: true,
      enumerable: true,
      configurable: true
    });
    var globalThis2 = exports2;
    var defaultMergeOptions = {
      concatArrays: false,
      ignoreUndefined: false
    };
    var getEnumerableOwnPropertyKeys = (value) => {
      const keys2 = [];
      for (const key in value) {
        if (hasOwnProperty.call(value, key)) {
          keys2.push(key);
        }
      }
      if (Object.getOwnPropertySymbols) {
        const symbols = Object.getOwnPropertySymbols(value);
        for (const symbol2 of symbols) {
          if (propertyIsEnumerable.call(value, symbol2)) {
            keys2.push(symbol2);
          }
        }
      }
      return keys2;
    };
    function clone(value) {
      if (Array.isArray(value)) {
        return cloneArray(value);
      }
      if (isOptionObject(value)) {
        return cloneOptionObject(value);
      }
      return value;
    }
    function cloneArray(array2) {
      const result = array2.slice(0, 0);
      getEnumerableOwnPropertyKeys(array2).forEach((key) => {
        defineProperty(result, key, clone(array2[key]));
      });
      return result;
    }
    function cloneOptionObject(object) {
      const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
      getEnumerableOwnPropertyKeys(object).forEach((key) => {
        defineProperty(result, key, clone(object[key]));
      });
      return result;
    }
    var mergeKeys = (merged, source, keys2, config2) => {
      keys2.forEach((key) => {
        if (typeof source[key] === "undefined" && config2.ignoreUndefined) {
          return;
        }
        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
          defineProperty(merged, key, merge3(merged[key], source[key], config2));
        } else {
          defineProperty(merged, key, clone(source[key]));
        }
      });
      return merged;
    };
    var concatArrays = (merged, source, config2) => {
      let result = merged.slice(0, 0);
      let resultIndex = 0;
      [merged, source].forEach((array2) => {
        const indices = [];
        for (let k = 0; k < array2.length; k++) {
          if (!hasOwnProperty.call(array2, k)) {
            continue;
          }
          indices.push(String(k));
          if (array2 === merged) {
            defineProperty(result, resultIndex++, array2[k]);
          } else {
            defineProperty(result, resultIndex++, clone(array2[k]));
          }
        }
        result = mergeKeys(result, array2, getEnumerableOwnPropertyKeys(array2).filter((key) => !indices.includes(key)), config2);
      });
      return result;
    };
    function merge3(merged, source, config2) {
      if (config2.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
        return concatArrays(merged, source, config2);
      }
      if (!isOptionObject(source) || !isOptionObject(merged)) {
        return clone(source);
      }
      return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config2);
    }
    module2.exports = function(...options) {
      const config2 = merge3(clone(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
      let merged = { _: {} };
      for (const option of options) {
        if (option === void 0) {
          continue;
        }
        if (!isOptionObject(option)) {
          throw new TypeError("`" + option + "` is not an Option Object");
        }
        merged = merge3(merged, { _: option }, config2);
      }
      return merged._;
    };
  }
});

// ../../node_modules/.pnpm/iso-url@1.2.1/node_modules/iso-url/src/url.js
var require_url = __commonJS({
  "../../node_modules/.pnpm/iso-url@1.2.1/node_modules/iso-url/src/url.js"(exports2, module2) {
    "use strict";
    var { URL: URL2, URLSearchParams: URLSearchParams2, format: format11 } = require("url");
    var defaultBase = "http://localhost";
    var URLWithLegacySupport = class extends URL2 {
      constructor(url = "", base6 = defaultBase) {
        super(url, base6);
        this.path = this.pathname + this.search;
        this.auth = this.username && this.password ? this.username + ":" + this.password : null;
        this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
      }
      format() {
        return this.toString();
      }
    };
    module2.exports = {
      URLWithLegacySupport,
      URLSearchParams: URLSearchParams2,
      format: format11,
      defaultBase
    };
  }
});

// ../../node_modules/.pnpm/iso-url@1.2.1/node_modules/iso-url/src/relative.js
var require_relative = __commonJS({
  "../../node_modules/.pnpm/iso-url@1.2.1/node_modules/iso-url/src/relative.js"(exports2, module2) {
    "use strict";
    var { URLWithLegacySupport, format: format11 } = require_url();
    module2.exports = (url, location2 = {}, protocolMap = {}, defaultProtocol) => {
      let protocol = location2.protocol ? location2.protocol.replace(":", "") : "http";
      protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
      let urlParsed;
      try {
        urlParsed = new URLWithLegacySupport(url);
      } catch (err) {
        urlParsed = {};
      }
      const base6 = Object.assign({}, location2, {
        protocol: protocol || urlParsed.protocol,
        host: location2.host || urlParsed.host
      });
      return new URLWithLegacySupport(url, format11(base6)).toString();
    };
  }
});

// ../../node_modules/.pnpm/iso-url@1.2.1/node_modules/iso-url/index.js
var require_iso_url = __commonJS({
  "../../node_modules/.pnpm/iso-url@1.2.1/node_modules/iso-url/index.js"(exports2, module2) {
    "use strict";
    var {
      URLWithLegacySupport,
      format: format11,
      URLSearchParams: URLSearchParams2,
      defaultBase
    } = require_url();
    var relative = require_relative();
    module2.exports = {
      URL: URLWithLegacySupport,
      URLSearchParams: URLSearchParams2,
      format: format11,
      relative,
      defaultBase
    };
  }
});

// ../../node_modules/.pnpm/any-signal@3.0.1/node_modules/any-signal/index.js
var require_any_signal = __commonJS({
  "../../node_modules/.pnpm/any-signal@3.0.1/node_modules/any-signal/index.js"(exports2, module2) {
    function anySignal2(signals) {
      const controller = new globalThis.AbortController();
      function onAbort() {
        controller.abort();
        for (const signal of signals) {
          if (!signal || !signal.removeEventListener) continue;
          signal.removeEventListener("abort", onAbort);
        }
      }
      for (const signal of signals) {
        if (!signal || !signal.addEventListener) continue;
        if (signal.aborted) {
          onAbort();
          break;
        }
        signal.addEventListener("abort", onAbort);
      }
      return controller.signal;
    }
    module2.exports = anySignal2;
    module2.exports.anySignal = anySignal2;
  }
});

// ../../node_modules/.pnpm/browser-readablestream-to-it@1.0.3/node_modules/browser-readablestream-to-it/index.js
var require_browser_readablestream_to_it = __commonJS({
  "../../node_modules/.pnpm/browser-readablestream-to-it@1.0.3/node_modules/browser-readablestream-to-it/index.js"(exports2, module2) {
    "use strict";
    async function* browserReadableStreamToIt(stream, options = {}) {
      const reader = stream.getReader();
      try {
        while (true) {
          const result = await reader.read();
          if (result.done) {
            return;
          }
          yield result.value;
        }
      } finally {
        if (options.preventCancel !== true) {
          reader.cancel();
        }
        reader.releaseLock();
      }
    }
    module2.exports = browserReadableStreamToIt;
  }
});

// ../../node_modules/.pnpm/it-all@1.0.6/node_modules/it-all/index.js
var require_it_all = __commonJS({
  "../../node_modules/.pnpm/it-all@1.0.6/node_modules/it-all/index.js"(exports2, module2) {
    "use strict";
    var all5 = async (source) => {
      const arr = [];
      for await (const entry of source) {
        arr.push(entry);
      }
      return arr;
    };
    module2.exports = all5;
  }
});

// ../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/http.js
var require_http = __commonJS({
  "../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/http.js"(exports2, module2) {
    "use strict";
    var { fetch: fetch3, Request: Request2, Headers: Headers2 } = require_fetch_node();
    var { TimeoutError, HTTPError: HTTPError3 } = require_error();
    var merge3 = require_merge_options().bind({ ignoreUndefined: true });
    var { URL: URL2, URLSearchParams: URLSearchParams2 } = require_iso_url();
    var anySignal2 = require_any_signal();
    var browserReableStreamToIt = require_browser_readablestream_to_it();
    var { isBrowser: isBrowser2, isWebWorker: isWebWorker2 } = require_env2();
    var all5 = require_it_all();
    var timeout = (promise, ms, abortController) => {
      if (ms === void 0) {
        return promise;
      }
      const start = Date.now();
      const timedOut = () => {
        const time = Date.now() - start;
        return time >= ms;
      };
      return new Promise((resolve2, reject) => {
        const timeoutID = setTimeout(() => {
          if (timedOut()) {
            reject(new TimeoutError());
            abortController.abort();
          }
        }, ms);
        const after = (next) => {
          const fn = (res) => {
            clearTimeout(timeoutID);
            if (timedOut()) {
              reject(new TimeoutError());
              return;
            }
            next(res);
          };
          return fn;
        };
        promise.then(after(resolve2), after(reject));
      });
    };
    var defaults5 = {
      throwHttpErrors: true,
      credentials: "same-origin"
    };
    var HTTP3 = class {
      /**
       *
       * @param {HTTPOptions} options
       */
      constructor(options = {}) {
        this.opts = merge3(defaults5, options);
      }
      /**
       * Fetch
       *
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       * @returns {Promise<ExtendedResponse>}
       */
      async fetch(resource, options = {}) {
        const opts = merge3(this.opts, options);
        const headers = new Headers2(opts.headers);
        if (typeof resource !== "string" && !(resource instanceof URL2 || resource instanceof Request2)) {
          throw new TypeError("`resource` must be a string, URL, or Request");
        }
        const url = new URL2(resource.toString(), opts.base);
        const {
          searchParams,
          transformSearchParams,
          json
        } = opts;
        if (searchParams) {
          if (typeof transformSearchParams === "function") {
            url.search = transformSearchParams(new URLSearchParams2(opts.searchParams));
          } else {
            url.search = new URLSearchParams2(opts.searchParams);
          }
        }
        if (json) {
          opts.body = JSON.stringify(opts.json);
          headers.set("content-type", "application/json");
        }
        const abortController = new AbortController();
        const signal = anySignal2([abortController.signal, opts.signal]);
        if (globalThis.ReadableStream != null && opts.body instanceof globalThis.ReadableStream && (isBrowser2 || isWebWorker2)) {
          opts.body = new Blob(await all5(browserReableStreamToIt(opts.body)));
        }
        const response = await timeout(
          fetch3(
            url.toString(),
            {
              ...opts,
              signal,
              // @ts-expect-error non-browser fetch implementations may take extra options
              timeout: void 0,
              headers,
              // https://fetch.spec.whatwg.org/#dom-requestinit-duplex
              // https://github.com/whatwg/fetch/issues/1254
              duplex: "half"
            }
          ),
          opts.timeout,
          abortController
        );
        if (!response.ok && opts.throwHttpErrors) {
          if (opts.handleError) {
            await opts.handleError(response);
          }
          throw new HTTPError3(response);
        }
        response.iterator = async function* () {
          yield* fromStream(response.body);
        };
        response.ndjson = async function* () {
          for await (const chunk of ndjson(response.iterator())) {
            if (options.transform) {
              yield options.transform(chunk);
            } else {
              yield chunk;
            }
          }
        };
        return response;
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      post(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "POST" });
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      get(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "GET" });
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      put(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "PUT" });
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      delete(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "DELETE" });
      }
      /**
       * @param {string | Request} resource
       * @param {HTTPOptions} options
       */
      options(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "OPTIONS" });
      }
    };
    var ndjson = async function* (source) {
      const decoder3 = new TextDecoder();
      let buf3 = "";
      for await (const chunk of source) {
        buf3 += decoder3.decode(chunk, { stream: true });
        const lines = buf3.split(/\r?\n/);
        for (let i = 0; i < lines.length - 1; i++) {
          const l = lines[i].trim();
          if (l.length > 0) {
            yield JSON.parse(l);
          }
        }
        buf3 = lines[lines.length - 1];
      }
      buf3 += decoder3.decode();
      buf3 = buf3.trim();
      if (buf3.length !== 0) {
        yield JSON.parse(buf3);
      }
    };
    var fromStream = (source) => {
      if (isAsyncIterable(source)) {
        return source;
      }
      if (isNodeReadableStream(source)) {
        const iter = source[Symbol.asyncIterator]();
        return {
          [Symbol.asyncIterator]() {
            return {
              next: iter.next.bind(iter),
              return(value) {
                source.destroy();
                if (typeof iter.return === "function") {
                  return iter.return();
                }
                return Promise.resolve({ done: true, value });
              }
            };
          }
        };
      }
      if (isWebReadableStream(source)) {
        const reader = source.getReader();
        return async function* () {
          try {
            while (true) {
              const { done, value } = await reader.read();
              if (done) return;
              if (value) {
                yield value;
              }
            }
          } finally {
            reader.releaseLock();
          }
        }();
      }
      throw new TypeError("Body can't be converted to AsyncIterable");
    };
    var isAsyncIterable = (value) => {
      return typeof value === "object" && value !== null && typeof /** @type {any} */
      value[Symbol.asyncIterator] === "function";
    };
    var isWebReadableStream = (value) => {
      return value && typeof /** @type {any} */
      value.getReader === "function";
    };
    var isNodeReadableStream = (value) => Object.prototype.hasOwnProperty.call(value, "readable") && Object.prototype.hasOwnProperty.call(value, "writable");
    HTTP3.HTTPError = HTTPError3;
    HTTP3.TimeoutError = TimeoutError;
    HTTP3.streamToAsyncIterator = fromStream;
    HTTP3.post = (resource, options) => new HTTP3(options).post(resource, options);
    HTTP3.get = (resource, options) => new HTTP3(options).get(resource, options);
    HTTP3.put = (resource, options) => new HTTP3(options).put(resource, options);
    HTTP3.delete = (resource, options) => new HTTP3(options).delete(resource, options);
    HTTP3.options = (resource, options) => new HTTP3(options).options(resource, options);
    module2.exports = HTTP3;
  }
});

// ../../node_modules/.pnpm/merge-options@3.0.4/node_modules/merge-options/index.mjs
var import_index2, merge_options_default;
var init_merge_options = __esm({
  "../../node_modules/.pnpm/merge-options@3.0.4/node_modules/merge-options/index.mjs"() {
    import_index2 = __toESM(require_merge_options(), 1);
    merge_options_default = import_index2.default;
  }
});

// ../../node_modules/.pnpm/multiaddr-to-uri@8.0.0/node_modules/multiaddr-to-uri/index.js
var require_multiaddr_to_uri = __commonJS({
  "../../node_modules/.pnpm/multiaddr-to-uri@8.0.0/node_modules/multiaddr-to-uri/index.js"(exports2, module2) {
    var { Multiaddr: Multiaddr14 } = require_src2();
    var reduceValue = (_, v) => v;
    var tcpUri = (str, port, parts, opts) => {
      if (opts && opts.assumeHttp === false) return `tcp://${str}:${port}`;
      let protocol = "tcp";
      let explicitPort = `:${port}`;
      const last5 = parts[parts.length - 1];
      if (last5.protocol === "tcp") {
        protocol = port === "443" ? "https" : "http";
        explicitPort = port === "443" || port === "80" ? "" : explicitPort;
      }
      return `${protocol}://${str}${explicitPort}`;
    };
    var Reducers = {
      ip4: reduceValue,
      ip6: (str, content2, i, parts) => parts.length === 1 && parts[0].protocol === "ip6" ? content2 : `[${content2}]`,
      tcp: (str, content2, i, parts, opts) => parts.some((p) => ["http", "https", "ws", "wss"].includes(p.protocol)) ? `${str}:${content2}` : tcpUri(str, content2, parts, opts),
      udp: (str, content2) => `udp://${str}:${content2}`,
      dnsaddr: reduceValue,
      dns4: reduceValue,
      dns6: reduceValue,
      ipfs: (str, content2) => `${str}/ipfs/${content2}`,
      p2p: (str, content2) => `${str}/p2p/${content2}`,
      http: (str) => `http://${str}`,
      https: (str) => `https://${str}`,
      ws: (str) => `ws://${str}`,
      wss: (str) => `wss://${str}`,
      "p2p-websocket-star": (str) => `${str}/p2p-websocket-star`,
      "p2p-webrtc-star": (str) => `${str}/p2p-webrtc-star`,
      "p2p-webrtc-direct": (str) => `${str}/p2p-webrtc-direct`
    };
    module2.exports = (multiaddr, opts) => {
      const ma = new Multiaddr14(multiaddr);
      const parts = multiaddr.toString().split("/").slice(1);
      return ma.tuples().map((tuple2) => ({
        protocol: parts.shift(),
        content: tuple2[1] ? parts.shift() : null
      })).reduce((str, part, i, parts2) => {
        const reduce = Reducers[part.protocol];
        if (!reduce) throw new Error(`Unsupported protocol ${part.protocol}`);
        return reduce(str, part.content, i, parts2, opts);
      }, "");
    };
  }
});

// ../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/to-url-string.js
function toUrlString(url) {
  try {
    url = (0, import_multiaddr_to_uri.default)(new import_multiaddr.Multiaddr(url));
  } catch (err) {
  }
  url = url.toString();
  return url;
}
var import_multiaddr, import_multiaddr_to_uri;
var init_to_url_string = __esm({
  "../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/to-url-string.js"() {
    import_multiaddr = __toESM(require_src2(), 1);
    import_multiaddr_to_uri = __toESM(require_multiaddr_to_uri(), 1);
  }
});

// ../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/agent.js
var import_http, import_https, agent_default;
var init_agent = __esm({
  "../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/agent.js"() {
    import_http = __toESM(require("http"), 1);
    import_https = __toESM(require("https"), 1);
    agent_default = (url) => {
      if (!url) {
        throw new Error("URL required");
      }
      return url.protocol.startsWith("https") ? import_https.default.Agent : import_http.default.Agent;
    };
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/core.js
var import_multiaddr2, import_env, import_debug, import_http2, log, merge, DEFAULT_PROTOCOL, DEFAULT_HOST, DEFAULT_PORT, normalizeOptions, errorHandler, KEBAB_REGEX, kebabCase, parseTimeout, Client, HTTPError;
var init_core = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/core.js"() {
    import_multiaddr2 = __toESM(require_src2(), 1);
    import_env = __toESM(require_env2(), 1);
    init_parse_duration();
    import_debug = __toESM(require_src3(), 1);
    import_http2 = __toESM(require_http(), 1);
    init_merge_options();
    init_to_url_string();
    init_agent();
    log = (0, import_debug.default)("ipfs-http-client:lib:error-handler");
    merge = merge_options_default.bind({ ignoreUndefined: true });
    DEFAULT_PROTOCOL = import_env.isBrowser || import_env.isWebWorker ? location.protocol : "http";
    DEFAULT_HOST = import_env.isBrowser || import_env.isWebWorker ? location.hostname : "localhost";
    DEFAULT_PORT = import_env.isBrowser || import_env.isWebWorker ? location.port : "5001";
    normalizeOptions = (options = {}) => {
      let url;
      let opts = {};
      let agent;
      if (typeof options === "string" || import_multiaddr2.Multiaddr.isMultiaddr(options)) {
        url = new URL(toUrlString(options));
      } else if (options instanceof URL) {
        url = options;
      } else if (typeof options.url === "string" || import_multiaddr2.Multiaddr.isMultiaddr(options.url)) {
        url = new URL(toUrlString(options.url));
        opts = options;
      } else if (options.url instanceof URL) {
        url = options.url;
        opts = options;
      } else {
        opts = options || {};
        const protocol = (opts.protocol || DEFAULT_PROTOCOL).replace(":", "");
        const host = (opts.host || DEFAULT_HOST).split(":")[0];
        const port = opts.port || DEFAULT_PORT;
        url = new URL(`${protocol}://${host}:${port}`);
      }
      if (opts.apiPath) {
        url.pathname = opts.apiPath;
      } else if (url.pathname === "/" || url.pathname === void 0) {
        url.pathname = "api/v0";
      }
      if (import_env.isNode) {
        const Agent = agent_default(url);
        agent = opts.agent || new Agent({
          keepAlive: true,
          maxSockets: 6
        });
      }
      return {
        ...opts,
        host: url.host,
        protocol: url.protocol.replace(":", ""),
        port: Number(url.port),
        apiPath: url.pathname,
        url,
        agent
      };
    };
    errorHandler = async (response) => {
      let msg;
      try {
        if ((response.headers.get("Content-Type") || "").startsWith("application/json")) {
          const data = await response.json();
          log(data);
          msg = data.Message || data.message;
        } else {
          msg = await response.text();
        }
      } catch (err) {
        log("Failed to parse error response", err);
        msg = err.message;
      }
      let error3 = new import_http2.default.HTTPError(response);
      if (msg) {
        if (msg.includes("deadline has elapsed")) {
          error3 = new import_http2.default.TimeoutError();
        }
        if (msg && msg.includes("context deadline exceeded")) {
          error3 = new import_http2.default.TimeoutError();
        }
      }
      if (msg && msg.includes("request timed out")) {
        error3 = new import_http2.default.TimeoutError();
      }
      if (msg) {
        error3.message = msg;
      }
      throw error3;
    };
    KEBAB_REGEX = /[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g;
    kebabCase = (str) => {
      return str.replace(KEBAB_REGEX, function(match5) {
        return "-" + match5.toLowerCase();
      });
    };
    parseTimeout = (value) => {
      return typeof value === "string" ? parse_duration_default(value) : value;
    };
    Client = class extends import_http2.default {
      constructor(options = {}) {
        const opts = normalizeOptions(options);
        super({
          timeout: parseTimeout(opts.timeout || 0) || void 0,
          headers: opts.headers,
          base: `${opts.url}`,
          handleError: errorHandler,
          transformSearchParams: (search) => {
            const out = new URLSearchParams();
            for (const [key, value] of search) {
              if (value !== "undefined" && value !== "null" && key !== "signal") {
                out.append(kebabCase(key), value);
              }
              if (key === "timeout" && !isNaN(value)) {
                out.append(kebabCase(key), value);
              }
            }
            return out;
          },
          agent: opts.agent
        });
        delete this.get;
        delete this.put;
        delete this.delete;
        delete this.options;
        const fetch3 = this.fetch;
        this.fetch = (resource, options2 = {}) => {
          if (typeof resource === "string" && !resource.startsWith("/")) {
            resource = `${opts.url}/${resource}`;
          }
          return fetch3.call(this, resource, merge(options2, { method: "POST" }));
        };
      }
    };
    HTTPError = import_http2.default.HTTPError;
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/configure.js
var configure;
var init_configure = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/configure.js"() {
    init_core();
    configure = (fn) => {
      return (options) => {
        return fn(new Client(options), options);
      };
    };
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/mode-to-string.js
function modeToString(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}
var init_mode_to_string = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/mode-to-string.js"() {
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/parse-mtime.js
function parseMtime(input10) {
  if (input10 == null) {
    return void 0;
  }
  let mtime;
  if (input10.secs != null) {
    mtime = {
      secs: input10.secs,
      nsecs: input10.nsecs
    };
  }
  if (input10.Seconds != null) {
    mtime = {
      secs: input10.Seconds,
      nsecs: input10.FractionalNanoseconds
    };
  }
  if (Array.isArray(input10)) {
    mtime = {
      secs: input10[0],
      nsecs: input10[1]
    };
  }
  if (input10 instanceof Date) {
    const ms = input10.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}
var import_err_code;
var init_parse_mtime = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/parse-mtime.js"() {
    import_err_code = __toESM(require_err_code(), 1);
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/to-url-search-params.js
function toUrlSearchParams({ arg, searchParams, hashAlg, mtime, mode, ...options } = {}) {
  if (searchParams) {
    options = {
      ...options,
      ...searchParams
    };
  }
  if (hashAlg) {
    options.hash = hashAlg;
  }
  if (mtime != null) {
    mtime = parseMtime(mtime);
    options.mtime = mtime.secs;
    options.mtimeNsecs = mtime.nsecs;
  }
  if (mode != null) {
    options.mode = modeToString(mode);
  }
  if (options.timeout && !isNaN(options.timeout)) {
    options.timeout = `${options.timeout}ms`;
  }
  if (arg === void 0 || arg === null) {
    arg = [];
  } else if (!Array.isArray(arg)) {
    arg = [arg];
  }
  const urlSearchParams = new URLSearchParams(options);
  arg.forEach((arg2) => urlSearchParams.append("arg", arg2));
  return urlSearchParams;
}
var init_to_url_search_params = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/to-url-search-params.js"() {
    init_mode_to_string();
    init_parse_mtime();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bitswap/wantlist.js
var createWantlist;
var init_wantlist = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bitswap/wantlist.js"() {
    init_cid();
    init_configure();
    init_to_url_search_params();
    createWantlist = configure((api) => {
      async function wantlist(options = {}) {
        const res = await (await api.post("bitswap/wantlist", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        })).json();
        return (res.Keys || []).map((k) => CID.parse(k["/"]));
      }
      return wantlist;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bitswap/wantlist-for-peer.js
var createWantlistForPeer;
var init_wantlist_for_peer = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bitswap/wantlist-for-peer.js"() {
    init_cid();
    init_configure();
    init_to_url_search_params();
    createWantlistForPeer = configure((api) => {
      async function wantlistForPeer(peerId, options = {}) {
        const res = await (await api.post("bitswap/wantlist", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            ...options,
            peer: peerId.toString()
          }),
          headers: options.headers
        })).json();
        return (res.Keys || []).map((k) => CID.parse(k["/"]));
      }
      return wantlistForPeer;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bitswap/stat.js
function toCoreInterface(res) {
  return {
    provideBufLen: res.ProvideBufLen,
    wantlist: (res.Wantlist || []).map((k) => CID.parse(k["/"])),
    peers: res.Peers || [],
    blocksReceived: BigInt(res.BlocksReceived),
    dataReceived: BigInt(res.DataReceived),
    blocksSent: BigInt(res.BlocksSent),
    dataSent: BigInt(res.DataSent),
    dupBlksReceived: BigInt(res.DupBlksReceived),
    dupDataReceived: BigInt(res.DupDataReceived)
  };
}
var createStat;
var init_stat = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bitswap/stat.js"() {
    init_cid();
    init_configure();
    init_to_url_search_params();
    createStat = configure((api) => {
      async function stat(options = {}) {
        const res = await api.post("bitswap/stat", {
          searchParams: toUrlSearchParams(options),
          signal: options.signal,
          headers: options.headers
        });
        return toCoreInterface(await res.json());
      }
      return stat;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bitswap/unwant.js
var createUnwant;
var init_unwant = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bitswap/unwant.js"() {
    init_configure();
    init_to_url_search_params();
    createUnwant = configure((api) => {
      async function unwant(cid, options = {}) {
        const res = await api.post("bitswap/unwant", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: cid.toString(),
            ...options
          }),
          headers: options.headers
        });
        return res.json();
      }
      return unwant;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bitswap/index.js
function createBitswap(config2) {
  return {
    wantlist: createWantlist(config2),
    wantlistForPeer: createWantlistForPeer(config2),
    unwant: createUnwant(config2),
    stat: createStat(config2)
  };
}
var init_bitswap = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bitswap/index.js"() {
    init_wantlist();
    init_wantlist_for_peer();
    init_stat();
    init_unwant();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/block/get.js
var createGet;
var init_get = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/block/get.js"() {
    init_configure();
    init_to_url_search_params();
    createGet = configure((api) => {
      async function get15(cid, options = {}) {
        const res = await api.post("block/get", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: cid.toString(),
            ...options
          }),
          headers: options.headers
        });
        return new Uint8Array(await res.arrayBuffer());
      }
      return get15;
    });
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array(buf3) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf3.buffer, buf3.byteOffset, buf3.byteLength);
  }
  return buf3;
}
var init_as_uint8array = __esm({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/util/as-uint8array.js"() {
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size5 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size5));
  }
  return new Uint8Array(size5);
}
var init_alloc = __esm({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/alloc.js"() {
    init_as_uint8array();
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name20, prefix2, encode45, decode53) {
  return {
    name: name20,
    prefix: prefix2,
    encoder: {
      name: name20,
      prefix: prefix2,
      encode: encode45
    },
    decoder: { decode: decode53 }
  };
}
var string, ascii, BASES, bases_default;
var init_bases = __esm({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/util/bases.js"() {
    init_basics();
    init_alloc();
    string = createCodec("utf8", "u", (buf3) => {
      const decoder3 = new TextDecoder("utf8");
      return "u" + decoder3.decode(buf3);
    }, (str) => {
      const encoder3 = new TextEncoder();
      return encoder3.encode(str.substring(1));
    });
    ascii = createCodec("ascii", "a", (buf3) => {
      let string4 = "a";
      for (let i = 0; i < buf3.length; i++) {
        string4 += String.fromCharCode(buf3[i]);
      }
      return string4;
    }, (str) => {
      str = str.substring(1);
      const buf3 = allocUnsafe(str.length);
      for (let i = 0; i < str.length; i++) {
        buf3[i] = str.charCodeAt(i);
      }
      return buf3;
    });
    BASES = {
      utf8: string,
      "utf-8": string,
      hex: bases.base16,
      latin1: ascii,
      ascii,
      binary: ascii,
      ...bases
    };
    bases_default = BASES;
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/from-string.js
function fromString3(string4, encoding = "utf8") {
  const base6 = bases_default[encoding];
  if (!base6) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string4, "utf-8"));
  }
  return base6.decoder.decode(`${base6.prefix}${string4}`);
}
var init_from_string = __esm({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/from-string.js"() {
    init_bases();
    init_as_uint8array();
  }
});

// ../../node_modules/.pnpm/blob-to-it@1.0.4/node_modules/blob-to-it/index.js
var require_blob_to_it = __commonJS({
  "../../node_modules/.pnpm/blob-to-it@1.0.4/node_modules/blob-to-it/index.js"(exports2, module2) {
    "use strict";
    var browserReadableStreamToIt = require_browser_readablestream_to_it();
    function blobToIt2(blob3) {
      if (typeof blob3.stream === "function") {
        return browserReadableStreamToIt(blob3.stream());
      }
      return browserReadableStreamToIt(new Response(blob3).body);
    }
    module2.exports = blobToIt2;
  }
});

// ../../node_modules/.pnpm/it-peekable@1.0.3/node_modules/it-peekable/index.js
var require_it_peekable = __commonJS({
  "../../node_modules/.pnpm/it-peekable@1.0.3/node_modules/it-peekable/index.js"(exports2, module2) {
    "use strict";
    function peekableIterator(iterable) {
      const [iterator, symbol2] = iterable[Symbol.asyncIterator] ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
      const queue = [];
      return {
        peek: () => {
          return iterator.next();
        },
        push: (value) => {
          queue.push(value);
        },
        next: () => {
          if (queue.length) {
            return {
              done: false,
              value: queue.shift()
            };
          }
          return iterator.next();
        },
        [symbol2]() {
          return this;
        }
      };
    }
    module2.exports = peekableIterator;
  }
});

// ../../node_modules/.pnpm/it-map@1.0.6/node_modules/it-map/index.js
var require_it_map = __commonJS({
  "../../node_modules/.pnpm/it-map@1.0.6/node_modules/it-map/index.js"(exports2, module2) {
    "use strict";
    var map3 = async function* (source, func) {
      for await (const val of source) {
        yield func(val);
      }
    };
    module2.exports = map3;
  }
});

// ../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/files/utils.js
function isBytes(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob(obj) {
  return obj.constructor && (obj.constructor.name === "Blob" || obj.constructor.name === "File") && typeof obj.stream === "function";
}
function isFileObject(obj) {
  return typeof obj === "object" && (obj.path || obj.content);
}
var isReadableStream;
var init_utils = __esm({
  "../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/files/utils.js"() {
    isReadableStream = (value) => value && typeof value.getReader === "function";
  }
});

// ../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/files/normalise-content.js
async function* toAsyncIterable(thing) {
  yield thing;
}
async function normaliseContent(input10) {
  if (isBytes(input10)) {
    return toAsyncIterable(toBytes(input10));
  }
  if (typeof input10 === "string" || input10 instanceof String) {
    return toAsyncIterable(toBytes(input10.toString()));
  }
  if (isBlob(input10)) {
    return (0, import_blob_to_it.default)(input10);
  }
  if (isReadableStream(input10)) {
    input10 = (0, import_browser_readablestream_to_it.default)(input10);
  }
  if (Symbol.iterator in input10 || Symbol.asyncIterator in input10) {
    const peekable = (0, import_it_peekable.default)(input10);
    const { value, done } = await peekable.peek();
    if (done) {
      return toAsyncIterable(new Uint8Array(0));
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      return toAsyncIterable(Uint8Array.from(await (0, import_it_all.default)(peekable)));
    }
    if (isBytes(value) || typeof value === "string" || value instanceof String) {
      return (0, import_it_map.default)(peekable, toBytes);
    }
  }
  throw (0, import_err_code2.default)(new Error(`Unexpected input: ${input10}`), "ERR_UNEXPECTED_INPUT");
}
function toBytes(chunk) {
  if (chunk instanceof Uint8Array) {
    return chunk;
  }
  if (ArrayBuffer.isView(chunk)) {
    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  }
  if (chunk instanceof ArrayBuffer) {
    return new Uint8Array(chunk);
  }
  if (Array.isArray(chunk)) {
    return Uint8Array.from(chunk);
  }
  return fromString3(chunk.toString());
}
var import_err_code2, import_browser_readablestream_to_it, import_blob_to_it, import_it_peekable, import_it_all, import_it_map;
var init_normalise_content = __esm({
  "../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/files/normalise-content.js"() {
    import_err_code2 = __toESM(require_err_code(), 1);
    init_from_string();
    import_browser_readablestream_to_it = __toESM(require_browser_readablestream_to_it(), 1);
    import_blob_to_it = __toESM(require_blob_to_it(), 1);
    import_it_peekable = __toESM(require_it_peekable(), 1);
    import_it_all = __toESM(require_it_all(), 1);
    import_it_map = __toESM(require_it_map(), 1);
    init_utils();
  }
});

// ../../node_modules/.pnpm/@protobufjs+aspromise@1.1.2/node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+aspromise@1.1.2/node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset2 = 0, index2 = 2, pending = true;
      while (index2 < arguments.length)
        params[offset2++] = arguments[index2++];
      return new Promise(function executor(resolve2, reject) {
        params[offset2] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset3 = 0;
              while (offset3 < params2.length)
                params2[offset3++] = arguments[offset3];
              resolve2.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// ../../node_modules/.pnpm/@protobufjs+base64@1.1.2/node_modules/@protobufjs/base64/index.js
var require_base642 = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+base64@1.1.2/node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base644 = exports2;
    base644.length = function length5(string4) {
      var p = string4.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string4.charAt(p) === "=")
        ++n;
      return Math.ceil(string4.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base644.encode = function encode45(buffer3, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer3[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base644.decode = function decode53(string4, buffer3, offset2) {
      var start = offset2;
      var j = 0, t;
      for (var i2 = 0; i2 < string4.length; ) {
        var c = string4.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer3[offset2++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer3[offset2++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer3[offset2++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset2 - start;
    };
    base644.test = function test(string4) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string4);
    };
  }
});

// ../../node_modules/.pnpm/@protobufjs+eventemitter@1.1.0/node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+eventemitter@1.1.0/node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// ../../node_modules/.pnpm/@protobufjs+float@1.0.2/node_modules/@protobufjs/float/index.js
var require_float2 = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+float@1.0.2/node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf3, pos) {
          f32[0] = val;
          buf3[pos] = f8b[0];
          buf3[pos + 1] = f8b[1];
          buf3[pos + 2] = f8b[2];
          buf3[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf3, pos) {
          f32[0] = val;
          buf3[pos] = f8b[3];
          buf3[pos + 1] = f8b[2];
          buf3[pos + 2] = f8b[1];
          buf3[pos + 3] = f8b[0];
        }
        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf3, pos) {
          f8b[0] = buf3[pos];
          f8b[1] = buf3[pos + 1];
          f8b[2] = buf3[pos + 2];
          f8b[3] = buf3[pos + 3];
          return f32[0];
        }
        function readFloat_f32_rev(buf3, pos) {
          f8b[3] = buf3[pos];
          f8b[2] = buf3[pos + 1];
          f8b[1] = buf3[pos + 2];
          f8b[0] = buf3[pos + 3];
          return f32[0];
        }
        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
      else (function() {
        function writeFloat_ieee754(writeUint, val, buf3, pos) {
          var sign2 = val < 0 ? 1 : 0;
          if (sign2)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf3, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf3, pos);
          else if (val > 34028234663852886e22)
            writeUint((sign2 << 31 | 2139095040) >>> 0, buf3, pos);
          else if (val < 11754943508222875e-54)
            writeUint((sign2 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf3, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign2 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf3, pos);
          }
        }
        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf3, pos) {
          var uint = readUint(buf3, pos), sign2 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 1401298464324817e-60 * mantissa : sign2 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
      if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf3, pos) {
          f64[0] = val;
          buf3[pos] = f8b[0];
          buf3[pos + 1] = f8b[1];
          buf3[pos + 2] = f8b[2];
          buf3[pos + 3] = f8b[3];
          buf3[pos + 4] = f8b[4];
          buf3[pos + 5] = f8b[5];
          buf3[pos + 6] = f8b[6];
          buf3[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf3, pos) {
          f64[0] = val;
          buf3[pos] = f8b[7];
          buf3[pos + 1] = f8b[6];
          buf3[pos + 2] = f8b[5];
          buf3[pos + 3] = f8b[4];
          buf3[pos + 4] = f8b[3];
          buf3[pos + 5] = f8b[2];
          buf3[pos + 6] = f8b[1];
          buf3[pos + 7] = f8b[0];
        }
        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf3, pos) {
          f8b[0] = buf3[pos];
          f8b[1] = buf3[pos + 1];
          f8b[2] = buf3[pos + 2];
          f8b[3] = buf3[pos + 3];
          f8b[4] = buf3[pos + 4];
          f8b[5] = buf3[pos + 5];
          f8b[6] = buf3[pos + 6];
          f8b[7] = buf3[pos + 7];
          return f64[0];
        }
        function readDouble_f64_rev(buf3, pos) {
          f8b[7] = buf3[pos];
          f8b[6] = buf3[pos + 1];
          f8b[5] = buf3[pos + 2];
          f8b[4] = buf3[pos + 3];
          f8b[3] = buf3[pos + 4];
          f8b[2] = buf3[pos + 5];
          f8b[1] = buf3[pos + 6];
          f8b[0] = buf3[pos + 7];
          return f64[0];
        }
        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
      else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf3, pos) {
          var sign2 = val < 0 ? 1 : 0;
          if (sign2)
            val = -val;
          if (val === 0) {
            writeUint(0, buf3, pos + off0);
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf3, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf3, pos + off0);
            writeUint(2146959360, buf3, pos + off1);
          } else if (val > 17976931348623157e292) {
            writeUint(0, buf3, pos + off0);
            writeUint((sign2 << 31 | 2146435072) >>> 0, buf3, pos + off1);
          } else {
            var mantissa;
            if (val < 22250738585072014e-324) {
              mantissa = val / 5e-324;
              writeUint(mantissa >>> 0, buf3, pos + off0);
              writeUint((sign2 << 31 | mantissa / 4294967296) >>> 0, buf3, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf3, pos + off0);
              writeUint((sign2 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf3, pos + off1);
            }
          }
        }
        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf3, pos) {
          var lo = readUint(buf3, pos + off0), hi = readUint(buf3, pos + off1);
          var sign2 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 5e-324 * mantissa : sign2 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
      return exports3;
    }
    function writeUintLE(val, buf3, pos) {
      buf3[pos] = val & 255;
      buf3[pos + 1] = val >>> 8 & 255;
      buf3[pos + 2] = val >>> 16 & 255;
      buf3[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf3, pos) {
      buf3[pos] = val >>> 24;
      buf3[pos + 1] = val >>> 16 & 255;
      buf3[pos + 2] = val >>> 8 & 255;
      buf3[pos + 3] = val & 255;
    }
    function readUintLE(buf3, pos) {
      return (buf3[pos] | buf3[pos + 1] << 8 | buf3[pos + 2] << 16 | buf3[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf3, pos) {
      return (buf3[pos] << 24 | buf3[pos + 1] << 16 | buf3[pos + 2] << 8 | buf3[pos + 3]) >>> 0;
    }
  }
});

// ../../node_modules/.pnpm/@protobufjs+inquire@1.1.0/node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+inquire@1.1.0/node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// ../../node_modules/.pnpm/@protobufjs+utf8@1.1.0/node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+utf8@1.1.0/node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf84 = exports2;
    utf84.length = function utf8_length(string4) {
      var len = 0, c = 0;
      for (var i = 0; i < string4.length; ++i) {
        c = string4.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string4.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf84.read = function utf8_read(buffer3, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer3[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer3[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer3[start++] & 63) << 12 | (buffer3[start++] & 63) << 6 | buffer3[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer3[start++] & 63) << 6 | buffer3[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf84.write = function utf8_write(string4, buffer3, offset2) {
      var start = offset2, c1, c2;
      for (var i = 0; i < string4.length; ++i) {
        c1 = string4.charCodeAt(i);
        if (c1 < 128) {
          buffer3[offset2++] = c1;
        } else if (c1 < 2048) {
          buffer3[offset2++] = c1 >> 6 | 192;
          buffer3[offset2++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string4.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer3[offset2++] = c1 >> 18 | 240;
          buffer3[offset2++] = c1 >> 12 & 63 | 128;
          buffer3[offset2++] = c1 >> 6 & 63 | 128;
          buffer3[offset2++] = c1 & 63 | 128;
        } else {
          buffer3[offset2++] = c1 >> 12 | 224;
          buffer3[offset2++] = c1 >> 6 & 63 | 128;
          buffer3[offset2++] = c1 & 63 | 128;
        }
      }
      return offset2 - start;
    };
  }
});

// ../../node_modules/.pnpm/@protobufjs+pool@1.1.0/node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+pool@1.1.0/node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool2;
    function pool2(alloc4, slice4, size5) {
      var SIZE3 = size5 || 8192;
      var MAX = SIZE3 >>> 1;
      var slab = null;
      var offset2 = SIZE3;
      return function pool_alloc(size6) {
        if (size6 < 1 || size6 > MAX)
          return alloc4(size6);
        if (offset2 + size6 > SIZE3) {
          slab = alloc4(SIZE3);
          offset2 = 0;
        }
        var buf3 = slice4.call(slab, offset2, offset2 += size6);
        if (offset2 & 7)
          offset2 = (offset2 | 7) + 1;
        return buf3;
      };
    }
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign2 = value < 0;
      if (sign2)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign2) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from21(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask2 = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask2) >>> 0;
      this.lo = (this.lo << 1 ^ mask2) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask2 = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask2) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask2) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length5() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base642();
    util.EventEmitter = require_eventemitter();
    util.float = require_float2();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer5 = util.inquire("buffer").Buffer;
        return Buffer5.prototype.utf8Write ? Buffer5 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge3(dst, src5, ifNotSet) {
      for (var keys2 = Object.keys(src5), i = 0; i < keys2.length; ++i)
        if (dst[keys2[i]] === void 0 || !ifNotSet)
          dst[keys2[i]] = src5[keys2[i]];
      return dst;
    }
    util.merge = merge3;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name20) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge3(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name20;
      } });
      CustomError.prototype.toString = function toString8() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys2 = Object.keys(this), i2 = keys2.length - 1; i2 > -1; --i2)
          if (fieldMap[keys2[i2]] === 1 && this[keys2[i2]] !== void 0 && this[keys2[i2]] !== null)
            return keys2[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name20) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name20)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer5 = util.Buffer;
      if (!Buffer5) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer5.from !== Uint8Array.from && Buffer5.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer5(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer5.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size5) {
        return new Buffer5(size5);
      };
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer2;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base644 = util.base64;
    var utf84 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop2() {
    }
    function State2(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer2() {
      this.len = 0;
      this.head = new Op(noop2, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create21 = function create22() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer2.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer2();
      };
    };
    Writer2.create = create21();
    Writer2.alloc = function alloc4(size5) {
      return new util.Array(size5);
    };
    if (util.Array !== Array)
      Writer2.alloc = util.pool(Writer2.alloc, util.Array.prototype.subarray);
    Writer2.prototype._push = function push2(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf3, pos) {
      buf3[pos] = val & 255;
    }
    function writeVarint32(val, buf3, pos) {
      while (val > 127) {
        buf3[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf3[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer2.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer2.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer2.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf3, pos) {
      while (val.hi) {
        buf3[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf3[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf3[pos++] = val.lo;
    }
    Writer2.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer2.prototype.int64 = Writer2.prototype.uint64;
    Writer2.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer2.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf3, pos) {
      buf3[pos] = val & 255;
      buf3[pos + 1] = val >>> 8 & 255;
      buf3[pos + 2] = val >>> 16 & 255;
      buf3[pos + 3] = val >>> 24;
    }
    Writer2.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer2.prototype.sfixed32 = Writer2.prototype.fixed32;
    Writer2.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer2.prototype.sfixed64 = Writer2.prototype.fixed64;
    Writer2.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer2.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes2 = util.Array.prototype.set ? function writeBytes_set(val, buf3, pos) {
      buf3.set(val, pos);
    } : function writeBytes_for(val, buf3, pos) {
      for (var i = 0; i < val.length; ++i)
        buf3[pos + i] = val[i];
    };
    Writer2.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf3 = Writer2.alloc(len = base644.length(value));
        base644.decode(value, buf3, 0);
        value = buf3;
      }
      return this.uint32(len)._push(writeBytes2, len, value);
    };
    Writer2.prototype.string = function write_string(value) {
      var len = utf84.length(value);
      return len ? this.uint32(len)._push(utf84.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer2.prototype.fork = function fork5() {
      this.states = new State2(this);
      this.head = this.tail = new Op(noop2, 0, 0);
      this.len = 0;
      return this;
    };
    Writer2.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop2, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer2.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer2.prototype.finish = function finish() {
      var head = this.head.next, buf3 = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf3, pos);
        pos += head.len;
        head = head.next;
      }
      return buf3;
    };
    Writer2._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer2.create = create21();
      BufferWriter._configure();
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer2 = require_writer();
    (BufferWriter.prototype = Object.create(Writer2.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer2.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf3, pos) {
        buf3.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf3, pos) {
        if (val.copy)
          val.copy(buf3, pos, 0, val.length);
        else for (var i = 0; i < val.length; )
          buf3[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf3, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf3, pos);
      else if (buf3.utf8Write)
        buf3.utf8Write(val, pos);
      else
        buf3.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf84 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer3) {
      this.buf = buffer3;
      this.pos = 0;
      this.len = buffer3.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer3) {
      if (buffer3 instanceof Uint8Array || Array.isArray(buffer3))
        return new Reader(buffer3);
      throw Error("illegal buffer");
    } : function create_array2(buffer3) {
      if (Array.isArray(buffer3))
        return new Reader(buffer3);
      throw Error("illegal buffer");
    };
    var create21 = function create22() {
      return util.Buffer ? function create_buffer_setup(buffer3) {
        return (Reader.create = function create_buffer(buffer4) {
          return util.Buffer.isBuffer(buffer4) ? new BufferReader(buffer4) : create_array(buffer4);
        })(buffer3);
      } : create_array;
    };
    Reader.create = create21();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf3, end) {
      return (buf3[end - 4] | buf3[end - 3] << 8 | buf3[end - 2] << 16 | buf3[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length5 = this.uint32(), start = this.pos, end = this.pos + length5;
      if (end > this.len)
        throw indexOutOfRange(this, length5);
      this.pos += length5;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes2 = this.bytes();
      return utf84.read(bytes2, 0, bytes2.length);
    };
    Reader.prototype.skip = function skip2(length5) {
      if (typeof length5 === "number") {
        if (this.pos + length5 > this.len)
          throw indexOutOfRange(this, length5);
        this.pos += length5;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create21();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer3) {
      Reader.call(this, buffer3);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure7;
    function configure7() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure7();
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// ../../node_modules/.pnpm/ipfs-unixfs@6.0.9/node_modules/ipfs-unixfs/esm/src/unixfs.js
var import_minimal, $Reader, $Writer, $util, $root, Data, UnixTime, Metadata;
var init_unixfs = __esm({
  "../../node_modules/.pnpm/ipfs-unixfs@6.0.9/node_modules/ipfs-unixfs/esm/src/unixfs.js"() {
    import_minimal = __toESM(require_minimal2(), 1);
    $Reader = import_minimal.default.Reader;
    $Writer = import_minimal.default.Writer;
    $util = import_minimal.default.util;
    $root = import_minimal.default.roots["ipfs-unixfs"] || (import_minimal.default.roots["ipfs-unixfs"] = {});
    Data = $root.Data = (() => {
      function Data3(p) {
        this.blocksizes = [];
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Data3.prototype.Type = 0;
      Data3.prototype.Data = $util.newBuffer([]);
      Data3.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
      Data3.prototype.blocksizes = $util.emptyArray;
      Data3.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
      Data3.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
      Data3.prototype.mode = 0;
      Data3.prototype.mtime = null;
      Data3.encode = function encode45(m, w) {
        if (!w)
          w = $Writer.create();
        w.uint32(8).int32(m.Type);
        if (m.Data != null && Object.hasOwnProperty.call(m, "Data"))
          w.uint32(18).bytes(m.Data);
        if (m.filesize != null && Object.hasOwnProperty.call(m, "filesize"))
          w.uint32(24).uint64(m.filesize);
        if (m.blocksizes != null && m.blocksizes.length) {
          for (var i = 0; i < m.blocksizes.length; ++i)
            w.uint32(32).uint64(m.blocksizes[i]);
        }
        if (m.hashType != null && Object.hasOwnProperty.call(m, "hashType"))
          w.uint32(40).uint64(m.hashType);
        if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
          w.uint32(48).uint64(m.fanout);
        if (m.mode != null && Object.hasOwnProperty.call(m, "mode"))
          w.uint32(56).uint32(m.mode);
        if (m.mtime != null && Object.hasOwnProperty.call(m, "mtime"))
          $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
        return w;
      };
      Data3.decode = function decode53(r, l) {
        if (!(r instanceof $Reader))
          r = $Reader.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root.Data();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.Type = r.int32();
              break;
            case 2:
              m.Data = r.bytes();
              break;
            case 3:
              m.filesize = r.uint64();
              break;
            case 4:
              if (!(m.blocksizes && m.blocksizes.length))
                m.blocksizes = [];
              if ((t & 7) === 2) {
                var c2 = r.uint32() + r.pos;
                while (r.pos < c2)
                  m.blocksizes.push(r.uint64());
              } else
                m.blocksizes.push(r.uint64());
              break;
            case 5:
              m.hashType = r.uint64();
              break;
            case 6:
              m.fanout = r.uint64();
              break;
            case 7:
              m.mode = r.uint32();
              break;
            case 8:
              m.mtime = $root.UnixTime.decode(r, r.uint32());
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        if (!m.hasOwnProperty("Type"))
          throw $util.ProtocolError("missing required 'Type'", { instance: m });
        return m;
      };
      Data3.fromObject = function fromObject(d) {
        if (d instanceof $root.Data)
          return d;
        var m = new $root.Data();
        switch (d.Type) {
          case "Raw":
          case 0:
            m.Type = 0;
            break;
          case "Directory":
          case 1:
            m.Type = 1;
            break;
          case "File":
          case 2:
            m.Type = 2;
            break;
          case "Metadata":
          case 3:
            m.Type = 3;
            break;
          case "Symlink":
          case 4:
            m.Type = 4;
            break;
          case "HAMTShard":
          case 5:
            m.Type = 5;
            break;
        }
        if (d.Data != null) {
          if (typeof d.Data === "string")
            $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
          else if (d.Data.length)
            m.Data = d.Data;
        }
        if (d.filesize != null) {
          if ($util.Long)
            (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;
          else if (typeof d.filesize === "string")
            m.filesize = parseInt(d.filesize, 10);
          else if (typeof d.filesize === "number")
            m.filesize = d.filesize;
          else if (typeof d.filesize === "object")
            m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
        }
        if (d.blocksizes) {
          if (!Array.isArray(d.blocksizes))
            throw TypeError(".Data.blocksizes: array expected");
          m.blocksizes = [];
          for (var i = 0; i < d.blocksizes.length; ++i) {
            if ($util.Long)
              (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;
            else if (typeof d.blocksizes[i] === "string")
              m.blocksizes[i] = parseInt(d.blocksizes[i], 10);
            else if (typeof d.blocksizes[i] === "number")
              m.blocksizes[i] = d.blocksizes[i];
            else if (typeof d.blocksizes[i] === "object")
              m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);
          }
        }
        if (d.hashType != null) {
          if ($util.Long)
            (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;
          else if (typeof d.hashType === "string")
            m.hashType = parseInt(d.hashType, 10);
          else if (typeof d.hashType === "number")
            m.hashType = d.hashType;
          else if (typeof d.hashType === "object")
            m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
        }
        if (d.fanout != null) {
          if ($util.Long)
            (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;
          else if (typeof d.fanout === "string")
            m.fanout = parseInt(d.fanout, 10);
          else if (typeof d.fanout === "number")
            m.fanout = d.fanout;
          else if (typeof d.fanout === "object")
            m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
        }
        if (d.mode != null) {
          m.mode = d.mode >>> 0;
        }
        if (d.mtime != null) {
          if (typeof d.mtime !== "object")
            throw TypeError(".Data.mtime: object expected");
          m.mtime = $root.UnixTime.fromObject(d.mtime);
        }
        return m;
      };
      Data3.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.arrays || o.defaults) {
          d.blocksizes = [];
        }
        if (o.defaults) {
          d.Type = o.enums === String ? "Raw" : 0;
          if (o.bytes === String)
            d.Data = "";
          else {
            d.Data = [];
            if (o.bytes !== Array)
              d.Data = $util.newBuffer(d.Data);
          }
          if ($util.Long) {
            var n = new $util.Long(0, 0, true);
            d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.filesize = o.longs === String ? "0" : 0;
          if ($util.Long) {
            var n = new $util.Long(0, 0, true);
            d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.hashType = o.longs === String ? "0" : 0;
          if ($util.Long) {
            var n = new $util.Long(0, 0, true);
            d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.fanout = o.longs === String ? "0" : 0;
          d.mode = 0;
          d.mtime = null;
        }
        if (m.Type != null && m.hasOwnProperty("Type")) {
          d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;
        }
        if (m.Data != null && m.hasOwnProperty("Data")) {
          d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
        }
        if (m.filesize != null && m.hasOwnProperty("filesize")) {
          if (typeof m.filesize === "number")
            d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
          else
            d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
        }
        if (m.blocksizes && m.blocksizes.length) {
          d.blocksizes = [];
          for (var j = 0; j < m.blocksizes.length; ++j) {
            if (typeof m.blocksizes[j] === "number")
              d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
            else
              d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
          }
        }
        if (m.hashType != null && m.hasOwnProperty("hashType")) {
          if (typeof m.hashType === "number")
            d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
          else
            d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
        }
        if (m.fanout != null && m.hasOwnProperty("fanout")) {
          if (typeof m.fanout === "number")
            d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
          else
            d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
        }
        if (m.mode != null && m.hasOwnProperty("mode")) {
          d.mode = m.mode;
        }
        if (m.mtime != null && m.hasOwnProperty("mtime")) {
          d.mtime = $root.UnixTime.toObject(m.mtime, o);
        }
        return d;
      };
      Data3.prototype.toJSON = function toJSON6() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      };
      Data3.DataType = function() {
        const valuesById = {}, values2 = Object.create(valuesById);
        values2[valuesById[0] = "Raw"] = 0;
        values2[valuesById[1] = "Directory"] = 1;
        values2[valuesById[2] = "File"] = 2;
        values2[valuesById[3] = "Metadata"] = 3;
        values2[valuesById[4] = "Symlink"] = 4;
        values2[valuesById[5] = "HAMTShard"] = 5;
        return values2;
      }();
      return Data3;
    })();
    UnixTime = $root.UnixTime = (() => {
      function UnixTime3(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      UnixTime3.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
      UnixTime3.prototype.FractionalNanoseconds = 0;
      UnixTime3.encode = function encode45(m, w) {
        if (!w)
          w = $Writer.create();
        w.uint32(8).int64(m.Seconds);
        if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, "FractionalNanoseconds"))
          w.uint32(21).fixed32(m.FractionalNanoseconds);
        return w;
      };
      UnixTime3.decode = function decode53(r, l) {
        if (!(r instanceof $Reader))
          r = $Reader.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root.UnixTime();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.Seconds = r.int64();
              break;
            case 2:
              m.FractionalNanoseconds = r.fixed32();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        if (!m.hasOwnProperty("Seconds"))
          throw $util.ProtocolError("missing required 'Seconds'", { instance: m });
        return m;
      };
      UnixTime3.fromObject = function fromObject(d) {
        if (d instanceof $root.UnixTime)
          return d;
        var m = new $root.UnixTime();
        if (d.Seconds != null) {
          if ($util.Long)
            (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;
          else if (typeof d.Seconds === "string")
            m.Seconds = parseInt(d.Seconds, 10);
          else if (typeof d.Seconds === "number")
            m.Seconds = d.Seconds;
          else if (typeof d.Seconds === "object")
            m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
        }
        if (d.FractionalNanoseconds != null) {
          m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
        }
        return m;
      };
      UnixTime3.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if ($util.Long) {
            var n = new $util.Long(0, 0, false);
            d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.Seconds = o.longs === String ? "0" : 0;
          d.FractionalNanoseconds = 0;
        }
        if (m.Seconds != null && m.hasOwnProperty("Seconds")) {
          if (typeof m.Seconds === "number")
            d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
          else
            d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
        }
        if (m.FractionalNanoseconds != null && m.hasOwnProperty("FractionalNanoseconds")) {
          d.FractionalNanoseconds = m.FractionalNanoseconds;
        }
        return d;
      };
      UnixTime3.prototype.toJSON = function toJSON6() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      };
      return UnixTime3;
    })();
    Metadata = $root.Metadata = (() => {
      function Metadata3(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Metadata3.prototype.MimeType = "";
      Metadata3.encode = function encode45(m, w) {
        if (!w)
          w = $Writer.create();
        if (m.MimeType != null && Object.hasOwnProperty.call(m, "MimeType"))
          w.uint32(10).string(m.MimeType);
        return w;
      };
      Metadata3.decode = function decode53(r, l) {
        if (!(r instanceof $Reader))
          r = $Reader.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root.Metadata();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.MimeType = r.string();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Metadata3.fromObject = function fromObject(d) {
        if (d instanceof $root.Metadata)
          return d;
        var m = new $root.Metadata();
        if (d.MimeType != null) {
          m.MimeType = String(d.MimeType);
        }
        return m;
      };
      Metadata3.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.MimeType = "";
        }
        if (m.MimeType != null && m.hasOwnProperty("MimeType")) {
          d.MimeType = m.MimeType;
        }
        return d;
      };
      Metadata3.prototype.toJSON = function toJSON6() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      };
      return Metadata3;
    })();
  }
});

// ../../node_modules/.pnpm/ipfs-unixfs@6.0.9/node_modules/ipfs-unixfs/esm/src/index.js
function parseMode(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "number") {
    return mode & 4095;
  }
  mode = mode.toString();
  if (mode.substring(0, 1) === "0") {
    return parseInt(mode, 8) & 4095;
  }
  return parseInt(mode, 10) & 4095;
}
function parseMtime2(input10) {
  if (input10 == null) {
    return void 0;
  }
  let mtime;
  if (input10.secs != null) {
    mtime = {
      secs: input10.secs,
      nsecs: input10.nsecs
    };
  }
  if (input10.Seconds != null) {
    mtime = {
      secs: input10.Seconds,
      nsecs: input10.FractionalNanoseconds
    };
  }
  if (Array.isArray(input10)) {
    mtime = {
      secs: input10[0],
      nsecs: input10[1]
    };
  }
  if (input10 instanceof Date) {
    const ms = input10.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code3.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}
var import_err_code3, DEFAULT_FILE_MODE, DEFAULT_DIRECTORY_MODE;
var init_src3 = __esm({
  "../../node_modules/.pnpm/ipfs-unixfs@6.0.9/node_modules/ipfs-unixfs/esm/src/index.js"() {
    import_err_code3 = __toESM(require_err_code(), 1);
    init_unixfs();
    DEFAULT_FILE_MODE = parseInt("0644", 8);
    DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
  }
});

// ../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/files/normalise-candidate-multiple.js
async function* normaliseCandidateMultiple(input10, normaliseContent3) {
  if (typeof input10 === "string" || input10 instanceof String || isBytes(input10) || isBlob(input10) || input10._readableState) {
    throw (0, import_err_code4.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isReadableStream(input10)) {
    input10 = (0, import_browser_readablestream_to_it2.default)(input10);
  }
  if (Symbol.iterator in input10 || Symbol.asyncIterator in input10) {
    const peekable = (0, import_it_peekable2.default)(input10);
    const { value, done } = await peekable.peek();
    if (done) {
      yield* [];
      return;
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      throw (0, import_err_code4.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
    }
    if (value._readableState) {
      yield* (0, import_it_map2.default)(peekable, (value2) => toFileObject({ content: value2 }, normaliseContent3));
      return;
    }
    if (isBytes(value)) {
      yield toFileObject({ content: peekable }, normaliseContent3);
      return;
    }
    if (isFileObject(value) || value[Symbol.iterator] || value[Symbol.asyncIterator] || isReadableStream(value) || isBlob(value)) {
      yield* (0, import_it_map2.default)(peekable, (value2) => toFileObject(value2, normaliseContent3));
      return;
    }
  }
  if (isFileObject(input10)) {
    throw (0, import_err_code4.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  throw (0, import_err_code4.default)(new Error("Unexpected input: " + typeof input10), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject(input10, normaliseContent3) {
  const { path, mode, mtime, content: content2 } = input10;
  const file = {
    path: path || "",
    mode: parseMode(mode),
    mtime: parseMtime2(mtime)
  };
  if (content2) {
    file.content = await normaliseContent3(content2);
  } else if (!path) {
    file.content = await normaliseContent3(input10);
  }
  return file;
}
var import_err_code4, import_browser_readablestream_to_it2, import_it_peekable2, import_it_map2;
var init_normalise_candidate_multiple = __esm({
  "../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/files/normalise-candidate-multiple.js"() {
    import_err_code4 = __toESM(require_err_code(), 1);
    import_browser_readablestream_to_it2 = __toESM(require_browser_readablestream_to_it(), 1);
    import_it_peekable2 = __toESM(require_it_peekable(), 1);
    import_it_map2 = __toESM(require_it_map(), 1);
    init_utils();
    init_src3();
  }
});

// ../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/files/normalise-input-multiple.js
function normaliseInput(input10) {
  return normaliseCandidateMultiple(input10, normaliseContent);
}
var init_normalise_input_multiple = __esm({
  "../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/files/normalise-input-multiple.js"() {
    init_normalise_content();
    init_normalise_candidate_multiple();
  }
});

// ../../node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/url-alphabet/index.js
var urlAlphabet;
var init_url_alphabet = __esm({
  "../../node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/url-alphabet/index.js"() {
    urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  }
});

// ../../node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/index.js
var import_crypto2, POOL_SIZE_MULTIPLIER, pool, poolOffset, fillPool, nanoid;
var init_nanoid = __esm({
  "../../node_modules/.pnpm/nanoid@3.3.7/node_modules/nanoid/index.js"() {
    import_crypto2 = __toESM(require("crypto"), 1);
    init_url_alphabet();
    POOL_SIZE_MULTIPLIER = 128;
    fillPool = (bytes2) => {
      if (!pool || pool.length < bytes2) {
        pool = Buffer.allocUnsafe(bytes2 * POOL_SIZE_MULTIPLIER);
        import_crypto2.default.randomFillSync(pool);
        poolOffset = 0;
      } else if (poolOffset + bytes2 > pool.length) {
        import_crypto2.default.randomFillSync(pool);
        poolOffset = 0;
      }
      poolOffset += bytes2;
    };
    nanoid = (size5 = 21) => {
      fillPool(size5 -= 0);
      let id = "";
      for (let i = poolOffset - size5; i < poolOffset; i++) {
        id += urlAlphabet[pool[i] & 63];
      }
      return id;
    };
  }
});

// ../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/mode-to-string.js
function modeToString2(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}
var init_mode_to_string2 = __esm({
  "../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/mode-to-string.js"() {
  }
});

// ../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/multipart-request.node.js
async function multipartRequest(source, abortController, headers = {}, boundary = `-----------------------------${nanoid()}`) {
  async function* streamFiles(source2) {
    try {
      let index2 = 0;
      for await (const { content: content2, path, mode, mtime } of source2) {
        let fileSuffix = "";
        const type2 = content2 ? "file" : "dir";
        if (index2 > 0) {
          yield "\r\n";
          fileSuffix = `-${index2}`;
        }
        let fieldName = type2 + fileSuffix;
        const qs = [];
        if (mode !== null && mode !== void 0) {
          qs.push(`mode=${modeToString2(mode)}`);
        }
        if (mtime != null) {
          const { secs, nsecs } = mtime;
          qs.push(`mtime=${secs}`);
          if (nsecs != null) {
            qs.push(`mtime-nsecs=${nsecs}`);
          }
        }
        if (qs.length) {
          fieldName = `${fieldName}?${qs.join("&")}`;
        }
        yield `--${boundary}\r
`;
        yield `Content-Disposition: form-data; name="${fieldName}"; filename="${encodeURIComponent(path || "")}"\r
`;
        yield `Content-Type: ${content2 ? "application/octet-stream" : "application/x-directory"}\r
`;
        yield "\r\n";
        if (content2) {
          yield* content2;
        }
        index2++;
      }
    } catch (err) {
      log2(err);
      abortController.abort();
    } finally {
      yield `\r
--${boundary}--\r
`;
    }
  }
  const peekable = (0, import_it_peekable3.default)(normaliseInput(source));
  const { value, done } = await peekable.peek();
  if (!done) {
    peekable.push(value);
  }
  return {
    parts: null,
    total: -1,
    headers: merge2(headers, { "Content-Type": `multipart/form-data; boundary=${boundary}` }),
    body: (0, import_it_to_stream.default)(streamFiles(peekable))
  };
}
var import_it_to_stream, import_debug2, import_it_peekable3, merge2, log2;
var init_multipart_request_node = __esm({
  "../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/multipart-request.node.js"() {
    init_normalise_input_multiple();
    init_nanoid();
    init_mode_to_string2();
    init_merge_options();
    import_it_to_stream = __toESM(require_src4(), 1);
    import_debug2 = __toESM(require_src3(), 1);
    import_it_peekable3 = __toESM(require_it_peekable(), 1);
    merge2 = merge_options_default.bind({ ignoreUndefined: true });
    log2 = (0, import_debug2.default)("ipfs:core-utils:multipart-request");
  }
});

// ../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/files/normalise-content.browser.js
async function normaliseContent2(input10) {
  if (isBytes(input10)) {
    return new Blob([input10]);
  }
  if (typeof input10 === "string" || input10 instanceof String) {
    return new Blob([input10.toString()]);
  }
  if (isBlob(input10)) {
    return input10;
  }
  if (isReadableStream(input10)) {
    input10 = (0, import_browser_readablestream_to_it3.default)(input10);
  }
  if (Symbol.iterator in input10 || Symbol.asyncIterator in input10) {
    const peekable = (0, import_it_peekable4.default)(input10);
    const { value, done } = await peekable.peek();
    if (done) {
      return itToBlob(peekable);
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      return new Blob([Uint8Array.from(await (0, import_it_all2.default)(peekable))]);
    }
    if (isBytes(value) || typeof value === "string" || value instanceof String) {
      return itToBlob(peekable);
    }
  }
  throw (0, import_err_code5.default)(new Error(`Unexpected input: ${input10}`), "ERR_UNEXPECTED_INPUT");
}
async function itToBlob(stream) {
  const parts = [];
  for await (const chunk of stream) {
    parts.push(chunk);
  }
  return new Blob(parts);
}
var import_err_code5, import_it_peekable4, import_browser_readablestream_to_it3, import_it_all2;
var init_normalise_content_browser = __esm({
  "../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/files/normalise-content.browser.js"() {
    import_err_code5 = __toESM(require_err_code(), 1);
    import_it_peekable4 = __toESM(require_it_peekable(), 1);
    import_browser_readablestream_to_it3 = __toESM(require_browser_readablestream_to_it(), 1);
    import_it_all2 = __toESM(require_it_all(), 1);
    init_utils();
  }
});

// ../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/files/normalise-input-multiple.browser.js
function normaliseInput2(input10) {
  return normaliseCandidateMultiple(input10, normaliseContent2, true);
}
var init_normalise_input_multiple_browser = __esm({
  "../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/files/normalise-input-multiple.browser.js"() {
    init_normalise_content_browser();
    init_normalise_candidate_multiple();
  }
});

// ../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/multipart-request.browser.js
async function multipartRequest2(source, abortController, headers = {}) {
  const parts = [];
  const formData = new FormData();
  let index2 = 0;
  let total = 0;
  for await (const { content: content2, path, mode, mtime } of normaliseInput2(source)) {
    let fileSuffix = "";
    const type2 = content2 ? "file" : "dir";
    if (index2 > 0) {
      fileSuffix = `-${index2}`;
    }
    let fieldName = type2 + fileSuffix;
    const qs = [];
    if (mode !== null && mode !== void 0) {
      qs.push(`mode=${modeToString2(mode)}`);
    }
    if (mtime != null) {
      const { secs, nsecs } = mtime;
      qs.push(`mtime=${secs}`);
      if (nsecs != null) {
        qs.push(`mtime-nsecs=${nsecs}`);
      }
    }
    if (qs.length) {
      fieldName = `${fieldName}?${qs.join("&")}`;
    }
    if (content2) {
      formData.set(fieldName, content2, path != null ? encodeURIComponent(path) : void 0);
      const end = total + content2.size;
      parts.push({
        name: path,
        start: total,
        end
      });
      total = end;
    } else if (path != null) {
      formData.set(fieldName, new File([""], encodeURIComponent(path), { type: "application/x-directory" }));
    } else {
      throw new Error("path or content or both must be set");
    }
    index2++;
  }
  return {
    total,
    parts,
    headers,
    body: formData
  };
}
var init_multipart_request_browser = __esm({
  "../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/multipart-request.browser.js"() {
    init_normalise_input_multiple_browser();
    init_mode_to_string2();
  }
});

// ../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/multipart-request.js
async function multipartRequest3(source, abortController, headers = {}, boundary = `-----------------------------${nanoid()}`) {
  let req = multipartRequest;
  if (import_env2.isElectronRenderer) {
    req = multipartRequest2;
  }
  return req(source, abortController, headers, boundary);
}
var import_env2;
var init_multipart_request = __esm({
  "../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/multipart-request.js"() {
    import_env2 = __toESM(require_env2(), 1);
    init_multipart_request_node();
    init_multipart_request_browser();
    init_nanoid();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/abort-signal.js
function filter(signals) {
  return signals.filter(Boolean);
}
function abortSignal(...signals) {
  return (0, import_any_signal.anySignal)(filter(signals));
}
var import_any_signal;
var init_abort_signal = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/abort-signal.js"() {
    import_any_signal = __toESM(require_any_signal(), 1);
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/block/put.js
var createPut;
var init_put = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/block/put.js"() {
    init_cid();
    init_multipart_request();
    init_configure();
    init_to_url_search_params();
    init_abort_signal();
    createPut = configure((api) => {
      async function put2(data, options = {}) {
        const controller = new AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        let res;
        try {
          const response = await api.post("block/put", {
            signal,
            searchParams: toUrlSearchParams(options),
            ...await multipartRequest3([data], controller, options.headers)
          });
          res = await response.json();
        } catch (err) {
          if (options.format === "dag-pb") {
            return put2(data, {
              ...options,
              format: "protobuf"
            });
          } else if (options.format === "dag-cbor") {
            return put2(data, {
              ...options,
              format: "cbor"
            });
          }
          throw err;
        }
        return CID.parse(res.Key);
      }
      return put2;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/block/rm.js
function toCoreInterface2(removed) {
  const out = { cid: CID.parse(removed.Hash) };
  if (removed.Error) {
    out.error = new Error(removed.Error);
  }
  return out;
}
var createRm;
var init_rm = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/block/rm.js"() {
    init_cid();
    init_configure();
    init_to_url_search_params();
    createRm = configure((api) => {
      async function* rm(cid, options = {}) {
        if (!Array.isArray(cid)) {
          cid = [cid];
        }
        const res = await api.post("block/rm", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: cid.map((cid2) => cid2.toString()),
            "stream-channels": true,
            ...options
          }),
          headers: options.headers
        });
        for await (const removed of res.ndjson()) {
          yield toCoreInterface2(removed);
        }
      }
      return rm;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/block/stat.js
var createStat2;
var init_stat2 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/block/stat.js"() {
    init_cid();
    init_configure();
    init_to_url_search_params();
    createStat2 = configure((api) => {
      async function stat(cid, options = {}) {
        const res = await api.post("block/stat", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: cid.toString(),
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return {
          cid: CID.parse(data.Key),
          size: data.Size
        };
      }
      return stat;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/block/index.js
function createBlock(config2) {
  return {
    get: createGet(config2),
    put: createPut(config2),
    rm: createRm(config2),
    stat: createStat2(config2)
  };
}
var init_block = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/block/index.js"() {
    init_get();
    init_put();
    init_rm();
    init_stat2();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bootstrap/add.js
var import_multiaddr3, createAdd;
var init_add = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bootstrap/add.js"() {
    init_configure();
    init_to_url_search_params();
    import_multiaddr3 = __toESM(require_src2(), 1);
    createAdd = configure((api) => {
      async function add9(addr, options = {}) {
        const res = await api.post("bootstrap/add", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: addr,
            ...options
          }),
          headers: options.headers
        });
        const { Peers } = await res.json();
        return { Peers: Peers.map((ma) => new import_multiaddr3.Multiaddr(ma)) };
      }
      return add9;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bootstrap/clear.js
var import_multiaddr4, createClear;
var init_clear = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bootstrap/clear.js"() {
    init_configure();
    init_to_url_search_params();
    import_multiaddr4 = __toESM(require_src2(), 1);
    createClear = configure((api) => {
      async function clear(options = {}) {
        const res = await api.post("bootstrap/rm", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            ...options,
            all: true
          }),
          headers: options.headers
        });
        const { Peers } = await res.json();
        return { Peers: Peers.map((ma) => new import_multiaddr4.Multiaddr(ma)) };
      }
      return clear;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bootstrap/list.js
var import_multiaddr5, createList;
var init_list = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bootstrap/list.js"() {
    init_configure();
    init_to_url_search_params();
    import_multiaddr5 = __toESM(require_src2(), 1);
    createList = configure((api) => {
      async function list7(options = {}) {
        const res = await api.post("bootstrap/list", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const { Peers } = await res.json();
        return { Peers: Peers.map((ma) => new import_multiaddr5.Multiaddr(ma)) };
      }
      return list7;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bootstrap/reset.js
var import_multiaddr6, createReset;
var init_reset = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bootstrap/reset.js"() {
    init_configure();
    init_to_url_search_params();
    import_multiaddr6 = __toESM(require_src2(), 1);
    createReset = configure((api) => {
      async function reset(options = {}) {
        const res = await api.post("bootstrap/add", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            ...options,
            default: true
          }),
          headers: options.headers
        });
        const { Peers } = await res.json();
        return { Peers: Peers.map((ma) => new import_multiaddr6.Multiaddr(ma)) };
      }
      return reset;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bootstrap/rm.js
var import_multiaddr7, createRm2;
var init_rm2 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bootstrap/rm.js"() {
    init_configure();
    init_to_url_search_params();
    import_multiaddr7 = __toESM(require_src2(), 1);
    createRm2 = configure((api) => {
      async function rm(addr, options = {}) {
        const res = await api.post("bootstrap/rm", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: addr,
            ...options
          }),
          headers: options.headers
        });
        const { Peers } = await res.json();
        return { Peers: Peers.map((ma) => new import_multiaddr7.Multiaddr(ma)) };
      }
      return rm;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bootstrap/index.js
function createBootstrap(config2) {
  return {
    add: createAdd(config2),
    clear: createClear(config2),
    list: createList(config2),
    reset: createReset(config2),
    rm: createRm2(config2)
  };
}
var init_bootstrap = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/bootstrap/index.js"() {
    init_add();
    init_clear();
    init_list();
    init_reset();
    init_rm2();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/config/profiles/apply.js
var createApply;
var init_apply = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/config/profiles/apply.js"() {
    init_configure();
    init_to_url_search_params();
    createApply = configure((api) => {
      async function apply(profile, options = {}) {
        const res = await api.post("config/profile/apply", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: profile,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return {
          original: data.OldCfg,
          updated: data.NewCfg
        };
      }
      return apply;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/object-to-camel.js
function objectToCamel(obj) {
  if (obj == null) {
    return obj;
  }
  const caps = /^[A-Z]+$/;
  const output = {};
  return Object.keys(obj).reduce((camelObj, k) => {
    if (caps.test(k)) {
      camelObj[k.toLowerCase()] = obj[k];
    } else if (caps.test(k[0])) {
      camelObj[k[0].toLowerCase() + k.slice(1)] = obj[k];
    } else {
      camelObj[k] = obj[k];
    }
    return camelObj;
  }, output);
}
var init_object_to_camel = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/object-to-camel.js"() {
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/config/profiles/list.js
var createList2;
var init_list2 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/config/profiles/list.js"() {
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createList2 = configure((api) => {
      async function list7(options = {}) {
        const res = await api.post("config/profile/list", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const data = await res.json();
        return data.map((profile) => objectToCamel(profile));
      }
      return list7;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/config/profiles/index.js
function createProfiles(config2) {
  return {
    apply: createApply(config2),
    list: createList2(config2)
  };
}
var init_profiles = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/config/profiles/index.js"() {
    init_apply();
    init_list2();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/config/get.js
var createGet2;
var init_get2 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/config/get.js"() {
    init_configure();
    init_to_url_search_params();
    createGet2 = configure((api) => {
      const get15 = async (key, options = {}) => {
        if (!key) {
          throw new Error("key argument is required");
        }
        const res = await api.post("config", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: key,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return data.Value;
      };
      return get15;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/config/get-all.js
var createGetAll;
var init_get_all = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/config/get-all.js"() {
    init_configure();
    init_to_url_search_params();
    createGetAll = configure((api) => {
      const getAll = async (options = {}) => {
        const res = await api.post("config/show", {
          signal: options.signal,
          searchParams: toUrlSearchParams({ ...options }),
          headers: options.headers
        });
        const data = await res.json();
        return data;
      };
      return getAll;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/config/replace.js
var createReplace;
var init_replace = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/config/replace.js"() {
    init_from_string();
    init_multipart_request();
    init_configure();
    init_to_url_search_params();
    init_abort_signal();
    createReplace = configure((api) => {
      const replace = async (config2, options = {}) => {
        const controller = new AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const res = await api.post("config/replace", {
          signal,
          searchParams: toUrlSearchParams(options),
          ...await multipartRequest3([fromString3(JSON.stringify(config2))], controller, options.headers)
        });
        await res.text();
      };
      return replace;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/config/set.js
var createSet, encodeParam;
var init_set = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/config/set.js"() {
    init_configure();
    init_to_url_search_params();
    createSet = configure((api) => {
      const set5 = async (key, value, options = {}) => {
        if (typeof key !== "string") {
          throw new Error("Invalid key type");
        }
        const params = {
          ...options,
          ...encodeParam(key, value)
        };
        const res = await api.post("config", {
          signal: options.signal,
          searchParams: toUrlSearchParams(params),
          headers: options.headers
        });
        await res.text();
      };
      return set5;
    });
    encodeParam = (key, value) => {
      switch (typeof value) {
        case "boolean":
          return {
            arg: [
              key,
              value.toString()
            ],
            bool: true
          };
        case "string":
          return {
            arg: [
              key,
              value
            ]
          };
        default:
          return {
            arg: [
              key,
              JSON.stringify(value)
            ],
            json: true
          };
      }
    };
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/config/index.js
function createConfig(config2) {
  return {
    getAll: createGetAll(config2),
    get: createGet2(config2),
    set: createSet(config2),
    replace: createReplace(config2),
    profiles: createProfiles(config2)
  };
}
var init_config = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/config/index.js"() {
    init_profiles();
    init_get2();
    init_get_all();
    init_replace();
    init_set();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dag/export.js
var createExport;
var init_export = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dag/export.js"() {
    init_configure();
    init_to_url_search_params();
    createExport = configure((api) => {
      async function* dagExport(root2, options = {}) {
        const res = await api.post("dag/export", {
          signal: options.signal,
          searchParams: toUrlSearchParams({ arg: root2.toString() }),
          headers: options.headers
        });
        yield* res.iterator();
      }
      return dagExport;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/resolve.js
async function* resolve(cid, path, codecs2, getBlock, options) {
  const load = async (cid2) => {
    const codec = await codecs2.getCodec(cid2.code);
    const block = await getBlock(cid2, options);
    return codec.decode(block);
  };
  const parts = path.split("/").filter(Boolean);
  let value = await load(cid);
  let lastCid = cid;
  while (parts.length) {
    const key = parts.shift();
    if (!key) {
      throw (0, import_err_code6.default)(new Error(`Could not resolve path "${path}"`), "ERR_INVALID_PATH");
    }
    if (Object.prototype.hasOwnProperty.call(value, key)) {
      value = value[key];
      yield {
        value,
        remainderPath: parts.join("/")
      };
    } else {
      throw (0, import_err_code6.default)(new Error(`no link named "${key}" under ${lastCid}`), "ERR_NO_LINK");
    }
    const cid2 = CID.asCID(value);
    if (cid2) {
      lastCid = cid2;
      value = await load(value);
    }
  }
  yield {
    value,
    remainderPath: ""
  };
}
var import_err_code6;
var init_resolve = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/resolve.js"() {
    init_cid();
    import_err_code6 = __toESM(require_err_code(), 1);
  }
});

// ../../node_modules/.pnpm/it-first@1.0.7/node_modules/it-first/index.js
var require_it_first = __commonJS({
  "../../node_modules/.pnpm/it-first@1.0.7/node_modules/it-first/index.js"(exports2, module2) {
    "use strict";
    var first2 = async (source) => {
      for await (const entry of source) {
        return entry;
      }
      return void 0;
    };
    module2.exports = first2;
  }
});

// ../../node_modules/.pnpm/it-last@1.0.6/node_modules/it-last/index.js
var require_it_last = __commonJS({
  "../../node_modules/.pnpm/it-last@1.0.6/node_modules/it-last/index.js"(exports2, module2) {
    "use strict";
    var last5 = async (source) => {
      let res;
      for await (const entry of source) {
        res = entry;
      }
      return res;
    };
    module2.exports = last5;
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dag/get.js
var import_it_first, import_it_last, import_err_code7, createGet3;
var init_get3 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dag/get.js"() {
    init_configure();
    init_resolve();
    import_it_first = __toESM(require_it_first(), 1);
    import_it_last = __toESM(require_it_last(), 1);
    import_err_code7 = __toESM(require_err_code(), 1);
    init_get();
    createGet3 = (codecs2, options) => {
      const fn = configure((api, opts) => {
        const getBlock = createGet(opts);
        const get15 = async (cid, options2 = {}) => {
          if (options2.path) {
            const entry = options2.localResolve ? await (0, import_it_first.default)(resolve(cid, options2.path, codecs2, getBlock, options2)) : await (0, import_it_last.default)(resolve(cid, options2.path, codecs2, getBlock, options2));
            const result = entry;
            if (!result) {
              throw (0, import_err_code7.default)(new Error("Not found"), "ERR_NOT_FOUND");
            }
            return result;
          }
          const codec = await codecs2.getCodec(cid.code);
          const block = await getBlock(cid, options2);
          const node = codec.decode(block);
          return {
            value: node,
            remainderPath: ""
          };
        };
        return get15;
      });
      return fn(options);
    };
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dag/import.js
var createImport;
var init_import = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dag/import.js"() {
    init_configure();
    init_to_url_search_params();
    init_abort_signal();
    init_multipart_request();
    init_cid();
    createImport = configure((api) => {
      async function* dagImport(source, options = {}) {
        const controller = new AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const { headers, body } = await multipartRequest3(source, controller, options.headers);
        const res = await api.post("dag/import", {
          signal,
          headers,
          body,
          searchParams: toUrlSearchParams({ "pin-roots": options.pinRoots })
        });
        for await (const { Root } of res.ndjson()) {
          if (Root !== void 0) {
            const {
              Cid: { "/": Cid },
              PinErrorMsg
            } = Root;
            yield {
              root: {
                cid: CID.parse(Cid),
                pinErrorMsg: PinErrorMsg
              }
            };
          }
        }
      }
      return dagImport;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dag/put.js
var createPut2;
var init_put2 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dag/put.js"() {
    init_cid();
    init_configure();
    init_multipart_request();
    init_to_url_search_params();
    init_abort_signal();
    createPut2 = (codecs2, options) => {
      const fn = configure((api) => {
        const put2 = async (dagNode, options2 = {}) => {
          const settings = {
            storeCodec: "dag-cbor",
            hashAlg: "sha2-256",
            ...options2
          };
          let serialized;
          if (settings.inputCodec) {
            if (!(dagNode instanceof Uint8Array)) {
              throw new Error("Can only inputCodec on raw bytes that can be decoded");
            }
            serialized = dagNode;
          } else {
            const storeCodec = await codecs2.getCodec(settings.storeCodec);
            serialized = storeCodec.encode(dagNode);
            settings.inputCodec = settings.storeCodec;
          }
          const controller = new AbortController();
          const signal = abortSignal(controller.signal, settings.signal);
          const res = await api.post("dag/put", {
            timeout: settings.timeout,
            signal,
            searchParams: toUrlSearchParams(settings),
            ...await multipartRequest3([serialized], controller, settings.headers)
          });
          const data = await res.json();
          return CID.parse(data.Cid["/"]);
        };
        return put2;
      });
      return fn(options);
    };
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dag/resolve.js
var createResolve;
var init_resolve2 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dag/resolve.js"() {
    init_cid();
    init_configure();
    init_to_url_search_params();
    createResolve = configure((api) => {
      const resolve2 = async (ipfsPath, options = {}) => {
        const res = await api.post("dag/resolve", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${ipfsPath}${options.path ? `/${options.path}`.replace(/\/[/]+/g, "/") : ""}`,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return {
          cid: CID.parse(data.Cid["/"]),
          remainderPath: data.RemPath
        };
      };
      return resolve2;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dag/index.js
function createDag(codecs2, config2) {
  return {
    export: createExport(config2),
    get: createGet3(codecs2, config2),
    import: createImport(config2),
    put: createPut2(codecs2, config2),
    resolve: createResolve(config2)
  };
}
var init_dag = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dag/index.js"() {
    init_export();
    init_get3();
    init_import();
    init_put2();
    init_resolve2();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dht/response-types.js
var SendingQuery, PeerResponse, FinalPeer, QueryError, Provider, Value, AddingPeer, DialingPeer;
var init_response_types = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dht/response-types.js"() {
    SendingQuery = 0;
    PeerResponse = 1;
    FinalPeer = 2;
    QueryError = 3;
    Provider = 4;
    Value = 5;
    AddingPeer = 6;
    DialingPeer = 7;
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dht/map-event.js
var import_multiaddr8, mapEvent;
var init_map_event = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dht/map-event.js"() {
    init_from_string();
    init_response_types();
    import_multiaddr8 = __toESM(require_src2(), 1);
    mapEvent = (event) => {
      if (event.Type === SendingQuery) {
        return {
          to: event.ID,
          name: "SENDING_QUERY",
          type: event.Type
        };
      }
      if (event.Type === PeerResponse) {
        return {
          from: event.ID,
          name: "PEER_RESPONSE",
          type: event.Type,
          messageType: 0,
          messageName: "PUT_VALUE",
          closer: (event.Responses || []).map(({ ID: ID2, Addrs }) => ({
            id: ID2,
            multiaddrs: Addrs.map((addr) => new import_multiaddr8.Multiaddr(addr))
          })),
          providers: (event.Responses || []).map(({ ID: ID2, Addrs }) => ({
            id: ID2,
            multiaddrs: Addrs.map((addr) => new import_multiaddr8.Multiaddr(addr))
          }))
        };
      }
      if (event.Type === FinalPeer) {
        let peer = {
          id: event.ID,
          multiaddrs: []
        };
        if (event.Responses && event.Responses.length) {
          peer = {
            id: event.Responses[0].ID,
            multiaddrs: event.Responses[0].Addrs.map((addr) => new import_multiaddr8.Multiaddr(addr))
          };
        }
        return {
          from: event.ID,
          name: "FINAL_PEER",
          type: event.Type,
          peer
        };
      }
      if (event.Type === QueryError) {
        return {
          from: event.ID,
          name: "QUERY_ERROR",
          type: event.Type,
          error: new Error(event.Extra)
        };
      }
      if (event.Type === Provider) {
        return {
          from: event.ID,
          name: "PROVIDER",
          type: event.Type,
          providers: event.Responses.map(({ ID: ID2, Addrs }) => ({
            id: ID2,
            multiaddrs: Addrs.map((addr) => new import_multiaddr8.Multiaddr(addr))
          }))
        };
      }
      if (event.Type === Value) {
        return {
          from: event.ID,
          name: "VALUE",
          type: event.Type,
          value: fromString3(event.Extra, "base64pad")
        };
      }
      if (event.Type === AddingPeer) {
        const peers = event.Responses.map(({ ID: ID2 }) => ID2);
        if (!peers.length) {
          throw new Error("No peer found");
        }
        return {
          name: "ADDING_PEER",
          type: event.Type,
          peer: peers[0]
        };
      }
      if (event.Type === DialingPeer) {
        return {
          name: "DIALING_PEER",
          type: event.Type,
          peer: event.ID
        };
      }
      throw new Error("Unknown DHT event type");
    };
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dht/find-peer.js
var createFindPeer;
var init_find_peer = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dht/find-peer.js"() {
    init_configure();
    init_to_url_search_params();
    init_map_event();
    createFindPeer = configure((api) => {
      async function* findPeer(peerId, options = {}) {
        const res = await api.post("dht/findpeer", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: peerId,
            ...options
          }),
          headers: options.headers
        });
        for await (const event of res.ndjson()) {
          yield mapEvent(event);
        }
      }
      return findPeer;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dht/find-provs.js
var createFindProvs;
var init_find_provs = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dht/find-provs.js"() {
    init_configure();
    init_to_url_search_params();
    init_map_event();
    createFindProvs = configure((api) => {
      async function* findProvs(cid, options = {}) {
        const res = await api.post("dht/findprovs", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: cid.toString(),
            ...options
          }),
          headers: options.headers
        });
        for await (const event of res.ndjson()) {
          yield mapEvent(event);
        }
      }
      return findProvs;
    });
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/to-string.js
function toString3(array2, encoding = "utf8") {
  const base6 = bases_default[encoding];
  if (!base6) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array2.buffer, array2.byteOffset, array2.byteLength).toString("utf8");
  }
  return base6.encoder.encode(array2).substring(1);
}
var init_to_string = __esm({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/to-string.js"() {
    init_bases();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dht/get.js
var createGet4;
var init_get4 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dht/get.js"() {
    init_configure();
    init_to_url_search_params();
    init_map_event();
    init_to_string();
    createGet4 = configure((api) => {
      async function* get15(key, options = {}) {
        const res = await api.post("dht/get", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: key instanceof Uint8Array ? toString3(key) : key.toString(),
            ...options
          }),
          headers: options.headers
        });
        for await (const event of res.ndjson()) {
          yield mapEvent(event);
        }
      }
      return get15;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dht/provide.js
var createProvide;
var init_provide = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dht/provide.js"() {
    init_configure();
    init_to_url_search_params();
    init_map_event();
    createProvide = configure((api) => {
      async function* provide(cids, options = { recursive: false }) {
        const cidArr = Array.isArray(cids) ? cids : [cids];
        const res = await api.post("dht/provide", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: cidArr.map((cid) => cid.toString()),
            ...options
          }),
          headers: options.headers
        });
        for await (const event of res.ndjson()) {
          yield mapEvent(event);
        }
      }
      return provide;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dht/put.js
var createPut3;
var init_put3 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dht/put.js"() {
    init_configure();
    init_to_url_search_params();
    init_multipart_request();
    init_abort_signal();
    init_to_string();
    init_map_event();
    createPut3 = configure((api) => {
      async function* put2(key, value, options = {}) {
        const controller = new AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const res = await api.post("dht/put", {
          signal,
          searchParams: toUrlSearchParams({
            arg: key instanceof Uint8Array ? toString3(key) : key.toString(),
            ...options
          }),
          ...await multipartRequest3([value], controller, options.headers)
        });
        for await (const event of res.ndjson()) {
          yield mapEvent(event);
        }
      }
      return put2;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dht/query.js
var createQuery;
var init_query = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dht/query.js"() {
    init_configure();
    init_to_url_search_params();
    init_map_event();
    createQuery = configure((api) => {
      async function* query(peerId, options = {}) {
        const res = await api.post("dht/query", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: peerId.toString(),
            ...options
          }),
          headers: options.headers
        });
        for await (const event of res.ndjson()) {
          yield mapEvent(event);
        }
      }
      return query;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dht/index.js
function createDht(config2) {
  return {
    findPeer: createFindPeer(config2),
    findProvs: createFindProvs(config2),
    get: createGet4(config2),
    provide: createProvide(config2),
    put: createPut3(config2),
    query: createQuery(config2)
  };
}
var init_dht = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dht/index.js"() {
    init_find_peer();
    init_find_provs();
    init_get4();
    init_provide();
    init_put3();
    init_query();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/diag/cmds.js
var createCmds;
var init_cmds = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/diag/cmds.js"() {
    init_configure();
    init_to_url_search_params();
    createCmds = configure((api) => {
      async function cmds(options = {}) {
        const res = await api.post("diag/cmds", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return res.json();
      }
      return cmds;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/diag/net.js
var createNet;
var init_net = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/diag/net.js"() {
    init_configure();
    init_to_url_search_params();
    createNet = configure((api) => {
      async function net(options = {}) {
        const res = await api.post("diag/net", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return res.json();
      }
      return net;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/diag/sys.js
var createSys;
var init_sys = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/diag/sys.js"() {
    init_configure();
    init_to_url_search_params();
    createSys = configure((api) => {
      async function sys(options = {}) {
        const res = await api.post("diag/sys", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return res.json();
      }
      return sys;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/diag/index.js
function createDiag(config2) {
  return {
    cmds: createCmds(config2),
    net: createNet(config2),
    sys: createSys(config2)
  };
}
var init_diag = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/diag/index.js"() {
    init_cmds();
    init_net();
    init_sys();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/chmod.js
var createChmod;
var init_chmod = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/chmod.js"() {
    init_configure();
    init_to_url_search_params();
    createChmod = configure((api) => {
      async function chmod(path, mode, options = {}) {
        const res = await api.post("files/chmod", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            mode,
            ...options
          }),
          headers: options.headers
        });
        await res.text();
      }
      return chmod;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/cp.js
var createCp;
var init_cp = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/cp.js"() {
    init_cid();
    init_configure();
    init_to_url_search_params();
    createCp = configure((api) => {
      async function cp(sources, destination, options = {}) {
        const sourceArr = Array.isArray(sources) ? sources : [sources];
        const res = await api.post("files/cp", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: sourceArr.concat(destination).map((src5) => CID.asCID(src5) ? `/ipfs/${src5}` : src5),
            ...options
          }),
          headers: options.headers
        });
        await res.text();
      }
      return cp;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/flush.js
var createFlush;
var init_flush = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/flush.js"() {
    init_cid();
    init_configure();
    init_to_url_search_params();
    createFlush = configure((api) => {
      async function flush3(path, options = {}) {
        if (!path || typeof path !== "string") {
          throw new Error("ipfs.files.flush requires a path");
        }
        const res = await api.post("files/flush", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return CID.parse(data.Cid);
      }
      return flush3;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/object-to-camel-with-metadata.js
function objectToCamelWithMetadata(entry) {
  const file = objectToCamel(entry);
  if (Object.prototype.hasOwnProperty.call(file, "mode")) {
    file.mode = parseInt(file.mode, 8);
  }
  if (Object.prototype.hasOwnProperty.call(file, "mtime")) {
    file.mtime = {
      secs: file.mtime,
      nsecs: file.mtimeNsecs || 0
    };
    delete file.mtimeNsecs;
  }
  return file;
}
var init_object_to_camel_with_metadata = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/object-to-camel-with-metadata.js"() {
    init_object_to_camel();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/ls.js
function toCoreInterface3(entry) {
  if (entry.hash) {
    entry.cid = CID.parse(entry.hash);
  }
  delete entry.hash;
  entry.type = entry.type === 1 ? "directory" : "file";
  return entry;
}
var createLs;
var init_ls = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/ls.js"() {
    init_cid();
    init_object_to_camel_with_metadata();
    init_configure();
    init_to_url_search_params();
    createLs = configure((api) => {
      async function* ls(path, options = {}) {
        if (!path) {
          throw new Error("ipfs.files.ls requires a path");
        }
        const res = await api.post("files/ls", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: CID.asCID(path) ? `/ipfs/${path}` : path,
            long: true,
            ...options,
            stream: true
          }),
          headers: options.headers
        });
        for await (const result of res.ndjson()) {
          if ("Entries" in result) {
            for (const entry of result.Entries || []) {
              yield toCoreInterface3(objectToCamelWithMetadata(entry));
            }
          } else {
            yield toCoreInterface3(objectToCamelWithMetadata(result));
          }
        }
      }
      return ls;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/mkdir.js
var createMkdir;
var init_mkdir = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/mkdir.js"() {
    init_configure();
    init_to_url_search_params();
    createMkdir = configure((api) => {
      async function mkdir(path, options = {}) {
        const res = await api.post("files/mkdir", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            ...options
          }),
          headers: options.headers
        });
        await res.text();
      }
      return mkdir;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/mv.js
var createMv;
var init_mv = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/mv.js"() {
    init_configure();
    init_to_url_search_params();
    createMv = configure((api) => {
      async function mv(sources, destination, options = {}) {
        if (!Array.isArray(sources)) {
          sources = [sources];
        }
        const res = await api.post("files/mv", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: sources.concat(destination),
            ...options
          }),
          headers: options.headers
        });
        await res.text();
      }
      return mv;
    });
  }
});

// ../../node_modules/.pnpm/stream-to-it@0.2.4/node_modules/stream-to-it/source.js
var require_source = __commonJS({
  "../../node_modules/.pnpm/stream-to-it@0.2.4/node_modules/stream-to-it/source.js"(exports2, module2) {
    module2.exports = (readable) => {
      if (readable[Symbol.asyncIterator]) return readable;
      if (readable.getReader) {
        return async function* () {
          const reader = readable.getReader();
          try {
            while (true) {
              const { done, value } = await reader.read();
              if (done) return;
              yield value;
            }
          } finally {
            reader.releaseLock();
          }
        }();
      }
      throw new Error("unknown stream");
    };
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/read.js
var import_source, createRead;
var init_read = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/read.js"() {
    init_configure();
    init_to_url_search_params();
    import_source = __toESM(require_source(), 1);
    createRead = configure((api) => {
      async function* read10(path, options = {}) {
        const res = await api.post("files/read", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            count: options.length,
            ...options
          }),
          headers: options.headers
        });
        yield* (0, import_source.default)(res.body);
      }
      return read10;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/rm.js
var import_http3, createRm3;
var init_rm3 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/rm.js"() {
    init_configure();
    init_to_url_search_params();
    import_http3 = __toESM(require_http(), 1);
    createRm3 = configure((api) => {
      async function rm(path, options = {}) {
        const res = await api.post("files/rm", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            ...options
          }),
          headers: options.headers
        });
        const body = await res.text();
        if (body !== "") {
          const error3 = new import_http3.default.HTTPError(res);
          error3.message = body;
          throw error3;
        }
      }
      return rm;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/stat.js
function toCoreInterface4(entry) {
  entry.cid = CID.parse(entry.hash);
  delete entry.hash;
  return entry;
}
var createStat3;
var init_stat3 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/stat.js"() {
    init_cid();
    init_object_to_camel_with_metadata();
    init_configure();
    init_to_url_search_params();
    createStat3 = configure((api) => {
      async function stat(path, options = {}) {
        const res = await api.post("files/stat", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        data.WithLocality = data.WithLocality || false;
        return toCoreInterface4(objectToCamelWithMetadata(data));
      }
      return stat;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/touch.js
var createTouch;
var init_touch = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/touch.js"() {
    init_configure();
    init_to_url_search_params();
    createTouch = configure((api) => {
      async function touch(path, options = {}) {
        const res = await api.post("files/touch", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            ...options
          }),
          headers: options.headers
        });
        await res.text();
      }
      return touch;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/write.js
var createWrite;
var init_write = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/write.js"() {
    init_mode_to_string();
    init_parse_mtime();
    init_configure();
    init_multipart_request();
    init_to_url_search_params();
    init_abort_signal();
    createWrite = configure((api) => {
      async function write8(path, input10, options = {}) {
        const controller = new AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const res = await api.post("files/write", {
          signal,
          searchParams: toUrlSearchParams({
            arg: path,
            streamChannels: true,
            count: options.length,
            ...options
          }),
          ...await multipartRequest3([{
            content: input10,
            path: "arg",
            mode: modeToString(options.mode),
            mtime: parseMtime(options.mtime)
          }], controller, options.headers)
        });
        await res.text();
      }
      return write8;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/index.js
function createFiles(config2) {
  return {
    chmod: createChmod(config2),
    cp: createCp(config2),
    flush: createFlush(config2),
    ls: createLs(config2),
    mkdir: createMkdir(config2),
    mv: createMv(config2),
    read: createRead(config2),
    rm: createRm3(config2),
    stat: createStat3(config2),
    touch: createTouch(config2),
    write: createWrite(config2)
  };
}
var init_files = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/files/index.js"() {
    init_chmod();
    init_cp();
    init_flush();
    init_ls();
    init_mkdir();
    init_mv();
    init_read();
    init_rm3();
    init_stat3();
    init_touch();
    init_write();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/key/export.js
var import_err_code8, createExport2;
var init_export2 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/key/export.js"() {
    init_configure();
    import_err_code8 = __toESM(require_err_code(), 1);
    createExport2 = configure((api) => {
      const exportKey = async (name20, password, options = {}) => {
        throw (0, import_err_code8.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
      };
      return exportKey;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/key/gen.js
var createGen;
var init_gen = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/key/gen.js"() {
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createGen = configure((api) => {
      async function gen(name20, options = {
        type: "rsa",
        size: 2048
      }) {
        const res = await api.post("key/gen", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: name20,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return objectToCamel(data);
      }
      return gen;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/key/import.js
var createImport2;
var init_import2 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/key/import.js"() {
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createImport2 = configure((api) => {
      async function importKey(name20, pem, password, options = {}) {
        const res = await api.post("key/import", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: name20,
            pem,
            password,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return objectToCamel(data);
      }
      return importKey;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/key/info.js
var import_err_code9, createInfo;
var init_info = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/key/info.js"() {
    init_configure();
    import_err_code9 = __toESM(require_err_code(), 1);
    createInfo = configure((api) => {
      const info = async (name20, options = {}) => {
        throw (0, import_err_code9.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
      };
      return info;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/key/list.js
var createList3;
var init_list3 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/key/list.js"() {
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createList3 = configure((api) => {
      async function list7(options = {}) {
        const res = await api.post("key/list", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const data = await res.json();
        return (data.Keys || []).map((k) => objectToCamel(k));
      }
      return list7;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/key/rename.js
var createRename;
var init_rename = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/key/rename.js"() {
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createRename = configure((api) => {
      async function rename(oldName, newName, options = {}) {
        const res = await api.post("key/rename", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: [
              oldName,
              newName
            ],
            ...options
          }),
          headers: options.headers
        });
        return objectToCamel(await res.json());
      }
      return rename;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/key/rm.js
var createRm4;
var init_rm4 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/key/rm.js"() {
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createRm4 = configure((api) => {
      async function rm(name20, options = {}) {
        const res = await api.post("key/rm", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: name20,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return objectToCamel(data.Keys[0]);
      }
      return rm;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/key/index.js
function createKey(config2) {
  return {
    export: createExport2(config2),
    gen: createGen(config2),
    import: createImport2(config2),
    info: createInfo(config2),
    list: createList3(config2),
    rename: createRename(config2),
    rm: createRm4(config2)
  };
}
var init_key = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/key/index.js"() {
    init_export2();
    init_gen();
    init_import2();
    init_info();
    init_list3();
    init_rename();
    init_rm4();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/log/level.js
var createLevel;
var init_level = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/log/level.js"() {
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createLevel = configure((api) => {
      async function level(subsystem, level2, options = {}) {
        const res = await api.post("log/level", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: [
              subsystem,
              level2
            ],
            ...options
          }),
          headers: options.headers
        });
        return objectToCamel(await res.json());
      }
      return level;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/log/ls.js
var createLs2;
var init_ls2 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/log/ls.js"() {
    init_configure();
    init_to_url_search_params();
    createLs2 = configure((api) => {
      async function ls(options = {}) {
        const res = await api.post("log/ls", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const data = await res.json();
        return data.Strings;
      }
      return ls;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/log/tail.js
var createTail;
var init_tail = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/log/tail.js"() {
    init_configure();
    init_to_url_search_params();
    createTail = configure((api) => {
      async function* tail(options = {}) {
        const res = await api.post("log/tail", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        yield* res.ndjson();
      }
      return tail;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/log/index.js
function createLog(config2) {
  return {
    level: createLevel(config2),
    ls: createLs2(config2),
    tail: createTail(config2)
  };
}
var init_log = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/log/index.js"() {
    init_level();
    init_ls2();
    init_tail();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/name/publish.js
var createPublish;
var init_publish = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/name/publish.js"() {
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createPublish = configure((api) => {
      async function publish(path, options = {}) {
        const res = await api.post("name/publish", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${path}`,
            ...options
          }),
          headers: options.headers
        });
        return objectToCamel(await res.json());
      }
      return publish;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/name/resolve.js
var createResolve2;
var init_resolve3 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/name/resolve.js"() {
    init_configure();
    init_to_url_search_params();
    createResolve2 = configure((api) => {
      async function* resolve2(path, options = {}) {
        const res = await api.post("name/resolve", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            stream: true,
            ...options
          }),
          headers: options.headers
        });
        for await (const result of res.ndjson()) {
          yield result.Path;
        }
      }
      return resolve2;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/name/pubsub/cancel.js
var createCancel;
var init_cancel = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/name/pubsub/cancel.js"() {
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createCancel = configure((api) => {
      async function cancel(name20, options = {}) {
        const res = await api.post("name/pubsub/cancel", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: name20,
            ...options
          }),
          headers: options.headers
        });
        return objectToCamel(await res.json());
      }
      return cancel;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/name/pubsub/state.js
var createState;
var init_state = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/name/pubsub/state.js"() {
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createState = configure((api) => {
      async function state(options = {}) {
        const res = await api.post("name/pubsub/state", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return objectToCamel(await res.json());
      }
      return state;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/name/pubsub/subs.js
var createSubs;
var init_subs = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/name/pubsub/subs.js"() {
    init_configure();
    init_to_url_search_params();
    createSubs = configure((api) => {
      async function subs(options = {}) {
        const res = await api.post("name/pubsub/subs", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const data = await res.json();
        return data.Strings || [];
      }
      return subs;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/name/pubsub/index.js
function createPubsub(config2) {
  return {
    cancel: createCancel(config2),
    state: createState(config2),
    subs: createSubs(config2)
  };
}
var init_pubsub = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/name/pubsub/index.js"() {
    init_cancel();
    init_state();
    init_subs();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/name/index.js
function createName(config2) {
  return {
    publish: createPublish(config2),
    resolve: createResolve2(config2),
    pubsub: createPubsub(config2)
  };
}
var init_name = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/name/index.js"() {
    init_publish();
    init_resolve3();
    init_pubsub();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/data.js
var createData;
var init_data = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/data.js"() {
    init_cid();
    init_configure();
    init_to_url_search_params();
    createData = configure((api) => {
      async function data(cid, options = {}) {
        const res = await api.post("object/data", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
            ...options
          }),
          headers: options.headers
        });
        const data2 = await res.arrayBuffer();
        return new Uint8Array(data2, 0, data2.byteLength);
      }
      return data;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/get.js
var createGet5;
var init_get5 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/get.js"() {
    init_cid();
    init_configure();
    init_to_url_search_params();
    init_from_string();
    createGet5 = configure((api) => {
      async function get15(cid, options = {}) {
        const res = await api.post("object/get", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
            dataEncoding: "base64",
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return {
          Data: fromString3(data.Data, "base64pad"),
          Links: (data.Links || []).map((link5) => ({
            Name: link5.Name,
            Hash: CID.parse(link5.Hash),
            Tsize: link5.Size
          }))
        };
      }
      return get15;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/links.js
var createLinks;
var init_links = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/links.js"() {
    init_cid();
    init_configure();
    init_to_url_search_params();
    createLinks = configure((api) => {
      async function links3(cid, options = {}) {
        const res = await api.post("object/links", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return (data.Links || []).map((l) => ({
          Name: l.Name,
          Tsize: l.Size,
          Hash: CID.parse(l.Hash)
        }));
      }
      return links3;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/new.js
var createNew;
var init_new = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/new.js"() {
    init_cid();
    init_configure();
    init_to_url_search_params();
    createNew = configure((api) => {
      async function newObject(options = {}) {
        const res = await api.post("object/new", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: options.template,
            ...options
          }),
          headers: options.headers
        });
        const { Hash } = await res.json();
        return CID.parse(Hash);
      }
      return newObject;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/put.js
var createPut4;
var init_put4 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/put.js"() {
    init_configure();
    init_put2();
    createPut4 = (codecs2, options) => {
      const fn = configure((api) => {
        const dagPut = createPut2(codecs2, options);
        async function put2(obj, options2 = {}) {
          return dagPut(obj, {
            ...options2,
            storeCodec: "dag-pb",
            hashAlg: "sha2-256",
            version: 1
          });
        }
        return put2;
      });
      return fn(options);
    };
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/stat.js
var createStat4;
var init_stat4 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/stat.js"() {
    init_cid();
    init_configure();
    init_to_url_search_params();
    createStat4 = configure((api) => {
      async function stat(cid, options = {}) {
        const res = await api.post("object/stat", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${cid}`,
            ...options
          }),
          headers: options.headers
        });
        const output = await res.json();
        return {
          ...output,
          Hash: CID.parse(output.Hash)
        };
      }
      return stat;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/patch/add-link.js
var createAddLink;
var init_add_link = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/patch/add-link.js"() {
    init_cid();
    init_configure();
    init_to_url_search_params();
    createAddLink = configure((api) => {
      async function addLink2(cid, dLink, options = {}) {
        const res = await api.post("object/patch/add-link", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: [
              `${cid}`,
              dLink.Name || dLink.name || "",
              (dLink.Hash || dLink.cid || "").toString() || null
            ],
            ...options
          }),
          headers: options.headers
        });
        const { Hash } = await res.json();
        return CID.parse(Hash);
      }
      return addLink2;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/patch/append-data.js
var createAppendData;
var init_append_data = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/patch/append-data.js"() {
    init_cid();
    init_multipart_request();
    init_configure();
    init_to_url_search_params();
    init_abort_signal();
    createAppendData = configure((api) => {
      async function appendData(cid, data, options = {}) {
        const controller = new AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const res = await api.post("object/patch/append-data", {
          signal,
          searchParams: toUrlSearchParams({
            arg: `${cid}`,
            ...options
          }),
          ...await multipartRequest3([data], controller, options.headers)
        });
        const { Hash } = await res.json();
        return CID.parse(Hash);
      }
      return appendData;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/patch/rm-link.js
var createRmLink;
var init_rm_link = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/patch/rm-link.js"() {
    init_cid();
    init_configure();
    init_to_url_search_params();
    createRmLink = configure((api) => {
      async function rmLink(cid, dLink, options = {}) {
        const res = await api.post("object/patch/rm-link", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: [
              `${cid}`,
              dLink.Name || dLink.name || null
            ],
            ...options
          }),
          headers: options.headers
        });
        const { Hash } = await res.json();
        return CID.parse(Hash);
      }
      return rmLink;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/patch/set-data.js
var createSetData;
var init_set_data = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/patch/set-data.js"() {
    init_cid();
    init_multipart_request();
    init_configure();
    init_to_url_search_params();
    init_abort_signal();
    createSetData = configure((api) => {
      async function setData(cid, data, options = {}) {
        const controller = new AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const res = await api.post("object/patch/set-data", {
          signal,
          searchParams: toUrlSearchParams({
            arg: [`${cid}`],
            ...options
          }),
          ...await multipartRequest3([data], controller, options.headers)
        });
        const { Hash } = await res.json();
        return CID.parse(Hash);
      }
      return setData;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/patch/index.js
function createPatch(config2) {
  return {
    addLink: createAddLink(config2),
    appendData: createAppendData(config2),
    rmLink: createRmLink(config2),
    setData: createSetData(config2)
  };
}
var init_patch = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/patch/index.js"() {
    init_add_link();
    init_append_data();
    init_rm_link();
    init_set_data();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/index.js
function createObject(codecs2, config2) {
  return {
    data: createData(config2),
    get: createGet5(config2),
    links: createLinks(config2),
    new: createNew(config2),
    put: createPut4(codecs2, config2),
    stat: createStat4(config2),
    patch: createPatch(config2)
  };
}
var init_object = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/object/index.js"() {
    init_data();
    init_get5();
    init_links();
    init_new();
    init_put4();
    init_stat4();
    init_patch();
  }
});

// ../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/pins/normalise-input.js
async function* normaliseInput3(input10) {
  if (input10 === null || input10 === void 0) {
    throw (0, import_err_code10.default)(new Error(`Unexpected input: ${input10}`), "ERR_UNEXPECTED_INPUT");
  }
  const cid = CID.asCID(input10);
  if (cid) {
    yield toPin({ cid });
    return;
  }
  if (input10 instanceof String || typeof input10 === "string") {
    yield toPin({ path: input10 });
    return;
  }
  if (input10.cid != null || input10.path != null) {
    return yield toPin(input10);
  }
  if (Symbol.iterator in input10) {
    const iterator = input10[Symbol.iterator]();
    const first2 = iterator.next();
    if (first2.done)
      return iterator;
    if (CID.asCID(first2.value) || first2.value instanceof String || typeof first2.value === "string") {
      yield toPin({ cid: first2.value });
      for (const cid2 of iterator) {
        yield toPin({ cid: cid2 });
      }
      return;
    }
    if (first2.value.cid != null || first2.value.path != null) {
      yield toPin(first2.value);
      for (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw (0, import_err_code10.default)(new Error("Unexpected input: " + typeof input10), "ERR_UNEXPECTED_INPUT");
  }
  if (Symbol.asyncIterator in input10) {
    const iterator = input10[Symbol.asyncIterator]();
    const first2 = await iterator.next();
    if (first2.done)
      return iterator;
    if (CID.asCID(first2.value) || first2.value instanceof String || typeof first2.value === "string") {
      yield toPin({ cid: first2.value });
      for await (const cid2 of iterator) {
        yield toPin({ cid: cid2 });
      }
      return;
    }
    if (first2.value.cid != null || first2.value.path != null) {
      yield toPin(first2.value);
      for await (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw (0, import_err_code10.default)(new Error("Unexpected input: " + typeof input10), "ERR_UNEXPECTED_INPUT");
  }
  throw (0, import_err_code10.default)(new Error("Unexpected input: " + typeof input10), "ERR_UNEXPECTED_INPUT");
}
function toPin(input10) {
  const path = input10.cid || `${input10.path}`;
  if (!path) {
    throw (0, import_err_code10.default)(new Error("Unexpected input: Please path either a CID or an IPFS path"), "ERR_UNEXPECTED_INPUT");
  }
  const pin = {
    path,
    recursive: input10.recursive !== false
  };
  if (input10.metadata != null) {
    pin.metadata = input10.metadata;
  }
  return pin;
}
var import_err_code10;
var init_normalise_input = __esm({
  "../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/pins/normalise-input.js"() {
    import_err_code10 = __toESM(require_err_code(), 1);
    init_cid();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/add-all.js
var createAddAll;
var init_add_all = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/add-all.js"() {
    init_cid();
    init_configure();
    init_normalise_input();
    init_to_url_search_params();
    createAddAll = configure((api) => {
      async function* addAll(source, options = {}) {
        for await (const { path, recursive, metadata } of normaliseInput3(source)) {
          const res = await api.post("pin/add", {
            signal: options.signal,
            searchParams: toUrlSearchParams({
              ...options,
              arg: path,
              recursive,
              metadata: metadata ? JSON.stringify(metadata) : void 0,
              stream: true
            }),
            headers: options.headers
          });
          for await (const pin of res.ndjson()) {
            if (pin.Pins) {
              for (const cid of pin.Pins) {
                yield CID.parse(cid);
              }
              continue;
            }
            yield CID.parse(pin);
          }
        }
      }
      return addAll;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/add.js
function createAdd2(config2) {
  const all5 = createAddAll(config2);
  return configure(() => {
    async function add9(path, options = {}) {
      return (0, import_it_last2.default)(all5([{
        path,
        ...options
      }], options));
    }
    return add9;
  })(config2);
}
var import_it_last2;
var init_add2 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/add.js"() {
    init_add_all();
    import_it_last2 = __toESM(require_it_last(), 1);
    init_configure();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/ls.js
function toPin2(type2, cid, metadata) {
  const pin = {
    type: type2,
    cid: CID.parse(cid)
  };
  if (metadata) {
    pin.metadata = metadata;
  }
  return pin;
}
var createLs3;
var init_ls3 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/ls.js"() {
    init_cid();
    init_configure();
    init_to_url_search_params();
    createLs3 = configure((api) => {
      async function* ls(options = {}) {
        let paths = [];
        if (options.paths) {
          paths = Array.isArray(options.paths) ? options.paths : [options.paths];
        }
        const res = await api.post("pin/ls", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            ...options,
            arg: paths.map((path) => `${path}`),
            stream: true
          }),
          headers: options.headers
        });
        for await (const pin of res.ndjson()) {
          if (pin.Keys) {
            for (const cid of Object.keys(pin.Keys)) {
              yield toPin2(pin.Keys[cid].Type, cid, pin.Keys[cid].Metadata);
            }
            return;
          }
          yield toPin2(pin.Type, pin.Cid, pin.Metadata);
        }
      }
      return ls;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/rm-all.js
var createRmAll;
var init_rm_all = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/rm-all.js"() {
    init_cid();
    init_configure();
    init_normalise_input();
    init_to_url_search_params();
    createRmAll = configure((api) => {
      async function* rmAll(source, options = {}) {
        for await (const { path, recursive } of normaliseInput3(source)) {
          const searchParams = new URLSearchParams(options.searchParams);
          searchParams.append("arg", `${path}`);
          if (recursive != null)
            searchParams.set("recursive", String(recursive));
          const res = await api.post("pin/rm", {
            signal: options.signal,
            headers: options.headers,
            searchParams: toUrlSearchParams({
              ...options,
              arg: `${path}`,
              recursive
            })
          });
          for await (const pin of res.ndjson()) {
            if (pin.Pins) {
              yield* pin.Pins.map((cid) => CID.parse(cid));
              continue;
            }
            yield CID.parse(pin);
          }
        }
      }
      return rmAll;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/rm.js
var import_it_last3, createRm5;
var init_rm5 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/rm.js"() {
    init_rm_all();
    import_it_last3 = __toESM(require_it_last(), 1);
    init_configure();
    createRm5 = (config2) => {
      const all5 = createRmAll(config2);
      return configure(() => {
        async function rm(path, options = {}) {
          return (0, import_it_last3.default)(all5([{
            path,
            ...options
          }], options));
        }
        return rm;
      })(config2);
    };
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/utils.js
var decodePin, encodeService, encodeCID2, encodeQuery, encodeAddParams;
var init_utils2 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/utils.js"() {
    init_cid();
    init_to_url_search_params();
    decodePin = ({
      Name: name20,
      Status: status,
      Cid: cid
    }) => {
      return {
        cid: CID.parse(cid),
        name: name20,
        status
      };
    };
    encodeService = (service) => {
      if (typeof service === "string" && service !== "") {
        return service;
      } else {
        throw new TypeError("service name must be passed");
      }
    };
    encodeCID2 = (cid) => {
      if (CID.asCID(cid)) {
        return cid.toString();
      } else {
        throw new TypeError(`CID instance expected instead of ${typeof cid}`);
      }
    };
    encodeQuery = ({ service, cid, name: name20, status, all: all5 }) => {
      const query = toUrlSearchParams({
        service: encodeService(service),
        name: name20,
        force: all5 ? true : void 0
      });
      if (cid) {
        for (const value of cid) {
          query.append("cid", encodeCID2(value));
        }
      }
      if (status) {
        for (const value of status) {
          query.append("status", value);
        }
      }
      return query;
    };
    encodeAddParams = ({ cid, service, background, name: name20, origins }) => {
      const params = toUrlSearchParams({
        arg: encodeCID2(cid),
        service: encodeService(service),
        name: name20,
        background: background ? true : void 0
      });
      if (origins) {
        for (const origin of origins) {
          params.append("origin", origin.toString());
        }
      }
      return params;
    };
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/add.js
function createAdd3(client) {
  async function add9(cid, { timeout, signal, headers, ...query }) {
    const response = await client.post("pin/remote/add", {
      timeout,
      signal,
      headers,
      searchParams: encodeAddParams({
        cid,
        ...query
      })
    });
    return decodePin(await response.json());
  }
  return add9;
}
var init_add3 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/add.js"() {
    init_utils2();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/ls.js
function createLs4(client) {
  async function* ls({ timeout, signal, headers, ...query }) {
    const response = await client.post("pin/remote/ls", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery(query)
    });
    for await (const pin of response.ndjson()) {
      yield decodePin(pin);
    }
  }
  return ls;
}
var init_ls4 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/ls.js"() {
    init_utils2();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/rm.js
function createRm6(client) {
  async function rm({ timeout, signal, headers, ...query }) {
    await client.post("pin/remote/rm", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: false
      })
    });
  }
  return rm;
}
var init_rm6 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/rm.js"() {
    init_utils2();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/rm-all.js
function createRmAll2(client) {
  async function rmAll({ timeout, signal, headers, ...query }) {
    await client.post("pin/remote/rm", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: true
      })
    });
  }
  return rmAll;
}
var init_rm_all2 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/rm-all.js"() {
    init_utils2();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/service/utils.js
function encodeEndpoint(url) {
  const href = String(url);
  if (href === "undefined") {
    throw Error("endpoint is required");
  }
  return href[href.length - 1] === "/" ? href.slice(0, -1) : href;
}
function decodeRemoteService(json) {
  return {
    service: json.Service,
    endpoint: new URL(json.ApiEndpoint),
    ...json.Stat && { stat: decodeStat(json.Stat) }
  };
}
function decodeStat(json) {
  switch (json.Status) {
    case "valid": {
      const { Pinning, Pinned, Queued, Failed } = json.PinCount;
      return {
        status: "valid",
        pinCount: {
          queued: Queued,
          pinning: Pinning,
          pinned: Pinned,
          failed: Failed
        }
      };
    }
    case "invalid": {
      return { status: "invalid" };
    }
    default: {
      return { status: json.Status };
    }
  }
}
var init_utils3 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/service/utils.js"() {
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/service/add.js
function createAdd4(client) {
  async function add9(name20, options) {
    const { endpoint, key, headers, timeout, signal } = options;
    await client.post("pin/remote/service/add", {
      timeout,
      signal,
      searchParams: toUrlSearchParams({
        arg: [
          name20,
          encodeEndpoint(endpoint),
          key
        ]
      }),
      headers
    });
  }
  return add9;
}
var init_add4 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/service/add.js"() {
    init_to_url_search_params();
    init_utils3();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/service/ls.js
function createLs5(client) {
  async function ls(options = {}) {
    const { stat, headers, timeout, signal } = options;
    const response = await client.post("pin/remote/service/ls", {
      timeout,
      signal,
      headers,
      searchParams: stat === true ? toUrlSearchParams({ stat }) : void 0
    });
    const { RemoteServices } = await response.json();
    return RemoteServices.map(decodeRemoteService);
  }
  return ls;
}
var init_ls5 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/service/ls.js"() {
    init_to_url_search_params();
    init_utils3();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/service/rm.js
function createRm7(client) {
  async function rm(name20, options = {}) {
    await client.post("pin/remote/service/rm", {
      signal: options.signal,
      headers: options.headers,
      searchParams: toUrlSearchParams({ arg: name20 })
    });
  }
  return rm;
}
var init_rm7 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/service/rm.js"() {
    init_to_url_search_params();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/service/index.js
function createService(config2) {
  const client = new Client(config2);
  return {
    add: createAdd4(client),
    ls: createLs5(client),
    rm: createRm7(client)
  };
}
var init_service = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/service/index.js"() {
    init_core();
    init_add4();
    init_ls5();
    init_rm7();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/index.js
function createRemote(config2) {
  const client = new Client(config2);
  return {
    add: createAdd3(client),
    ls: createLs4(client),
    rm: createRm6(client),
    rmAll: createRmAll2(client),
    service: createService(config2)
  };
}
var init_remote = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/remote/index.js"() {
    init_core();
    init_add3();
    init_ls4();
    init_rm6();
    init_rm_all2();
    init_service();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/index.js
function createPin(config2) {
  return {
    addAll: createAddAll(config2),
    add: createAdd2(config2),
    ls: createLs3(config2),
    rmAll: createRmAll(config2),
    rm: createRm5(config2),
    remote: createRemote(config2)
  };
}
var init_pin = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pin/index.js"() {
    init_add_all();
    init_add2();
    init_ls3();
    init_rm_all();
    init_rm5();
    init_remote();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/http-rpc-wire-format.js
var rpcArrayToTextArray, rpcToText, rpcToBytes, textToUrlSafeRpc;
var init_http_rpc_wire_format = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/lib/http-rpc-wire-format.js"() {
    init_from_string();
    init_to_string();
    init_base64();
    rpcArrayToTextArray = (strings) => {
      if (Array.isArray(strings)) {
        return strings.map(rpcToText);
      }
      return strings;
    };
    rpcToText = (mb) => toString3(rpcToBytes(mb));
    rpcToBytes = (mb) => base64url.decode(mb);
    textToUrlSafeRpc = (text2) => base64url.encode(fromString3(text2));
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pubsub/ls.js
var createLs6;
var init_ls6 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pubsub/ls.js"() {
    init_configure();
    init_to_url_search_params();
    init_http_rpc_wire_format();
    createLs6 = configure((api) => {
      async function ls(options = {}) {
        const { Strings } = await (await api.post("pubsub/ls", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        })).json();
        return rpcArrayToTextArray(Strings) || [];
      }
      return ls;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pubsub/peers.js
var createPeers;
var init_peers = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pubsub/peers.js"() {
    init_configure();
    init_to_url_search_params();
    init_http_rpc_wire_format();
    createPeers = configure((api) => {
      async function peers(topic, options = {}) {
        const res = await api.post("pubsub/peers", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: textToUrlSafeRpc(topic),
            ...options
          }),
          headers: options.headers
        });
        const { Strings } = await res.json();
        return Strings || [];
      }
      return peers;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pubsub/publish.js
var createPublish2;
var init_publish2 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pubsub/publish.js"() {
    init_configure();
    init_to_url_search_params();
    init_multipart_request();
    init_abort_signal();
    init_http_rpc_wire_format();
    createPublish2 = configure((api) => {
      async function publish(topic, data, options = {}) {
        const searchParams = toUrlSearchParams({
          arg: textToUrlSafeRpc(topic),
          ...options
        });
        const controller = new AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const res = await api.post("pubsub/pub", {
          signal,
          searchParams,
          ...await multipartRequest3([data], controller, options.headers)
        });
        await res.text();
      }
      return publish;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pubsub/subscribe.js
async function readMessages(response, { onMessage, onEnd, onError }) {
  onError = onError || log3;
  try {
    for await (const msg of response.ndjson()) {
      try {
        if (!msg.from) {
          continue;
        }
        onMessage({
          from: msg.from,
          data: rpcToBytes(msg.data),
          seqno: rpcToBytes(msg.seqno),
          topicIDs: rpcArrayToTextArray(msg.topicIDs)
        });
      } catch (err) {
        err.message = `Failed to parse pubsub message: ${err.message}`;
        onError(err, false, msg);
      }
    }
  } catch (err) {
    if (!isAbortError(err)) {
      onError(err, true);
    }
  } finally {
    onEnd();
  }
}
var import_debug3, log3, createSubscribe, isAbortError;
var init_subscribe = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pubsub/subscribe.js"() {
    import_debug3 = __toESM(require_src3(), 1);
    init_configure();
    init_to_url_search_params();
    init_http_rpc_wire_format();
    log3 = (0, import_debug3.default)("ipfs-http-client:pubsub:subscribe");
    createSubscribe = (options, subsTracker) => {
      return configure((api) => {
        async function subscribe(topic, handler, options2 = {}) {
          options2.signal = subsTracker.subscribe(topic, handler, options2.signal);
          let done;
          let fail3;
          const result = new Promise((resolve2, reject) => {
            done = resolve2;
            fail3 = reject;
          });
          const ffWorkaround = setTimeout(() => done(), 1e3);
          api.post("pubsub/sub", {
            signal: options2.signal,
            searchParams: toUrlSearchParams({
              arg: textToUrlSafeRpc(topic),
              ...options2
            }),
            headers: options2.headers
          }).catch((err) => {
            subsTracker.unsubscribe(topic, handler);
            fail3(err);
          }).then((response) => {
            clearTimeout(ffWorkaround);
            if (!response) {
              return;
            }
            readMessages(response, {
              onMessage: handler,
              onEnd: () => subsTracker.unsubscribe(topic, handler),
              onError: options2.onError
            });
            done();
          });
          return result;
        }
        return subscribe;
      })(options);
    };
    isAbortError = (error3) => {
      switch (error3.type) {
        case "aborted":
          return true;
        case "abort":
          return true;
        default:
          return error3.name === "AbortError";
      }
    };
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pubsub/unsubscribe.js
var createUnsubscribe;
var init_unsubscribe = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pubsub/unsubscribe.js"() {
    createUnsubscribe = (options, subsTracker) => {
      async function unsubscribe(topic, handler) {
        subsTracker.unsubscribe(topic, handler);
      }
      return unsubscribe;
    };
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pubsub/subscription-tracker.js
var SubscriptionTracker;
var init_subscription_tracker = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pubsub/subscription-tracker.js"() {
    SubscriptionTracker = class {
      constructor() {
        this._subs = /* @__PURE__ */ new Map();
      }
      subscribe(topic, handler, signal) {
        const topicSubs = this._subs.get(topic) || [];
        if (topicSubs.find((s) => s.handler === handler)) {
          throw new Error(`Already subscribed to ${topic} with this handler`);
        }
        const controller = new AbortController();
        this._subs.set(topic, [{
          handler,
          controller
        }].concat(topicSubs));
        if (signal) {
          signal.addEventListener("abort", () => this.unsubscribe(topic, handler));
        }
        return controller.signal;
      }
      unsubscribe(topic, handler) {
        const subs = this._subs.get(topic) || [];
        let unsubs;
        if (handler) {
          this._subs.set(topic, subs.filter((s) => s.handler !== handler));
          unsubs = subs.filter((s) => s.handler === handler);
        } else {
          this._subs.set(topic, []);
          unsubs = subs;
        }
        if (!(this._subs.get(topic) || []).length) {
          this._subs.delete(topic);
        }
        unsubs.forEach((s) => s.controller.abort());
      }
    };
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pubsub/index.js
function createPubsub2(config2) {
  const subscriptionTracker = new SubscriptionTracker();
  return {
    ls: createLs6(config2),
    peers: createPeers(config2),
    publish: createPublish2(config2),
    subscribe: createSubscribe(config2, subscriptionTracker),
    unsubscribe: createUnsubscribe(config2, subscriptionTracker)
  };
}
var init_pubsub2 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/pubsub/index.js"() {
    init_ls6();
    init_peers();
    init_publish2();
    init_subscribe();
    init_unsubscribe();
    init_subscription_tracker();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/refs/local.js
var createLocal;
var init_local = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/refs/local.js"() {
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createLocal = configure((api) => {
      async function* refsLocal(options = {}) {
        const res = await api.post("refs/local", {
          signal: options.signal,
          transform: objectToCamel,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        yield* res.ndjson();
      }
      return refsLocal;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/refs/index.js
var createRefs;
var init_refs = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/refs/index.js"() {
    init_cid();
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    init_local();
    createRefs = configure((api, opts) => {
      const refs = async function* (args, options = {}) {
        const argsArr = Array.isArray(args) ? args : [args];
        const res = await api.post("refs", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: argsArr.map((arg) => `${arg instanceof Uint8Array ? CID.decode(arg) : arg}`),
            ...options
          }),
          headers: options.headers,
          transform: objectToCamel
        });
        yield* res.ndjson();
      };
      return Object.assign(refs, { local: createLocal(opts) });
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/repo/gc.js
var createGc;
var init_gc = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/repo/gc.js"() {
    init_cid();
    init_configure();
    init_to_url_search_params();
    createGc = configure((api) => {
      async function* gc(options = {}) {
        const res = await api.post("repo/gc", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers,
          transform: (res2) => {
            return {
              err: res2.Error ? new Error(res2.Error) : null,
              cid: (res2.Key || {})["/"] ? CID.parse(res2.Key["/"]) : null
            };
          }
        });
        yield* res.ndjson();
      }
      return gc;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/repo/stat.js
var createStat5;
var init_stat5 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/repo/stat.js"() {
    init_configure();
    init_to_url_search_params();
    createStat5 = configure((api) => {
      async function stat(options = {}) {
        const res = await api.post("repo/stat", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const data = await res.json();
        return {
          numObjects: BigInt(data.NumObjects),
          repoSize: BigInt(data.RepoSize),
          repoPath: data.RepoPath,
          version: data.Version,
          storageMax: BigInt(data.StorageMax)
        };
      }
      return stat;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/repo/version.js
var createVersion;
var init_version = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/repo/version.js"() {
    init_configure();
    init_to_url_search_params();
    createVersion = configure((api) => {
      async function version3(options = {}) {
        const res = await (await api.post("repo/version", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        })).json();
        return res.Version;
      }
      return version3;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/repo/index.js
function createRepo(config2) {
  return {
    gc: createGc(config2),
    stat: createStat5(config2),
    version: createVersion(config2)
  };
}
var init_repo = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/repo/index.js"() {
    init_gc();
    init_stat5();
    init_version();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/stats/bw.js
var createBw;
var init_bw = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/stats/bw.js"() {
    init_configure();
    init_to_url_search_params();
    createBw = configure((api) => {
      async function* bw(options = {}) {
        const res = await api.post("stats/bw", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers,
          transform: (stats) => ({
            totalIn: BigInt(stats.TotalIn),
            totalOut: BigInt(stats.TotalOut),
            rateIn: parseFloat(stats.RateIn),
            rateOut: parseFloat(stats.RateOut)
          })
        });
        yield* res.ndjson();
      }
      return bw;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/stats/index.js
function createStats(config2) {
  return {
    bitswap: createStat(config2),
    repo: createStat5(config2),
    bw: createBw(config2)
  };
}
var init_stats = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/stats/index.js"() {
    init_stat();
    init_stat5();
    init_bw();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/swarm/addrs.js
var import_multiaddr9, createAddrs;
var init_addrs = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/swarm/addrs.js"() {
    import_multiaddr9 = __toESM(require_src2(), 1);
    init_configure();
    init_to_url_search_params();
    createAddrs = configure((api) => {
      async function addrs(options = {}) {
        const res = await api.post("swarm/addrs", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const { Addrs } = await res.json();
        return Object.keys(Addrs).map((id) => ({
          id,
          addrs: (Addrs[id] || []).map((a) => new import_multiaddr9.Multiaddr(a))
        }));
      }
      return addrs;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/swarm/connect.js
var createConnect;
var init_connect = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/swarm/connect.js"() {
    init_configure();
    init_to_url_search_params();
    createConnect = configure((api) => {
      async function connect2(addr, options = {}) {
        const res = await api.post("swarm/connect", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: addr,
            ...options
          }),
          headers: options.headers
        });
        const { Strings } = await res.json();
        return Strings || [];
      }
      return connect2;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/swarm/disconnect.js
var createDisconnect;
var init_disconnect = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/swarm/disconnect.js"() {
    init_configure();
    init_to_url_search_params();
    createDisconnect = configure((api) => {
      async function disconnect(addr, options = {}) {
        const res = await api.post("swarm/disconnect", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: addr,
            ...options
          }),
          headers: options.headers
        });
        const { Strings } = await res.json();
        return Strings || [];
      }
      return disconnect;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/swarm/local-addrs.js
var import_multiaddr10, createLocalAddrs;
var init_local_addrs = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/swarm/local-addrs.js"() {
    import_multiaddr10 = __toESM(require_src2(), 1);
    init_configure();
    init_to_url_search_params();
    createLocalAddrs = configure((api) => {
      async function localAddrs(options = {}) {
        const res = await api.post("swarm/addrs/local", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const { Strings } = await res.json();
        return (Strings || []).map((a) => new import_multiaddr10.Multiaddr(a));
      }
      return localAddrs;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/swarm/peers.js
var import_multiaddr11, createPeers2;
var init_peers2 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/swarm/peers.js"() {
    import_multiaddr11 = __toESM(require_src2(), 1);
    init_configure();
    init_to_url_search_params();
    createPeers2 = configure((api) => {
      async function peers(options = {}) {
        const res = await api.post("swarm/peers", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const { Peers } = await res.json();
        return (Peers || []).map((peer) => {
          return {
            addr: new import_multiaddr11.Multiaddr(peer.Addr),
            peer: peer.Peer,
            muxer: peer.Muxer,
            latency: peer.Latency,
            streams: peer.Streams,
            direction: peer.Direction == null ? void 0 : peer.Direction === 0 ? "inbound" : "outbound"
          };
        });
      }
      return peers;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/swarm/index.js
function createSwarm(config2) {
  return {
    addrs: createAddrs(config2),
    connect: createConnect(config2),
    disconnect: createDisconnect(config2),
    localAddrs: createLocalAddrs(config2),
    peers: createPeers2(config2)
  };
}
var init_swarm = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/swarm/index.js"() {
    init_addrs();
    init_connect();
    init_disconnect();
    init_local_addrs();
    init_peers2();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/add-all.js
function toCoreInterface5({ name: name20, hash, size: size5, mode, mtime, mtimeNsecs }) {
  const output = {
    path: name20,
    cid: CID.parse(hash),
    size: parseInt(size5)
  };
  if (mode != null) {
    output.mode = parseInt(mode, 8);
  }
  if (mtime != null) {
    output.mtime = {
      secs: mtime,
      nsecs: mtimeNsecs || 0
    };
  }
  return output;
}
var createAddAll2, createProgressHandler, createOnUploadProgress;
var init_add_all2 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/add-all.js"() {
    init_cid();
    init_object_to_camel();
    init_configure();
    init_multipart_request();
    init_to_url_search_params();
    init_abort_signal();
    createAddAll2 = configure((api) => {
      async function* addAll(source, options = {}) {
        const controller = new AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const { headers, body, total, parts } = await multipartRequest3(source, controller, options.headers);
        const [progressFn, onUploadProgress] = typeof options.progress === "function" ? createProgressHandler(total, parts, options.progress) : [
          void 0,
          void 0
        ];
        const res = await api.post("add", {
          searchParams: toUrlSearchParams({
            "stream-channels": true,
            ...options,
            progress: Boolean(progressFn)
          }),
          onUploadProgress,
          signal,
          headers,
          body
        });
        for await (let file of res.ndjson()) {
          file = objectToCamel(file);
          if (file.hash !== void 0) {
            yield toCoreInterface5(file);
          } else if (progressFn) {
            progressFn(file.bytes || 0, file.name);
          }
        }
      }
      return addAll;
    });
    createProgressHandler = (total, parts, progress) => parts ? [
      void 0,
      createOnUploadProgress(total, parts, progress)
    ] : [
      progress,
      void 0
    ];
    createOnUploadProgress = (size5, parts, progress) => {
      let index2 = 0;
      const count = parts.length;
      return ({ loaded, total }) => {
        const position = Math.floor(loaded / total * size5);
        while (index2 < count) {
          const { start, end, name: name20 } = parts[index2];
          if (position < end) {
            progress(position - start, name20);
            break;
          } else {
            progress(end - start, name20);
            index2 += 1;
          }
        }
      };
    };
  }
});

// ../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/files/normalise-candidate-single.js
async function* normaliseCandidateSingle(input10, normaliseContent3) {
  if (input10 === null || input10 === void 0) {
    throw (0, import_err_code11.default)(new Error(`Unexpected input: ${input10}`), "ERR_UNEXPECTED_INPUT");
  }
  if (typeof input10 === "string" || input10 instanceof String) {
    yield toFileObject2(input10.toString(), normaliseContent3);
    return;
  }
  if (isBytes(input10) || isBlob(input10)) {
    yield toFileObject2(input10, normaliseContent3);
    return;
  }
  if (isReadableStream(input10)) {
    input10 = (0, import_browser_readablestream_to_it4.default)(input10);
  }
  if (Symbol.iterator in input10 || Symbol.asyncIterator in input10) {
    const peekable = (0, import_it_peekable5.default)(input10);
    const { value, done } = await peekable.peek();
    if (done) {
      yield { content: [] };
      return;
    }
    peekable.push(value);
    if (Number.isInteger(value) || isBytes(value) || typeof value === "string" || value instanceof String) {
      yield toFileObject2(peekable, normaliseContent3);
      return;
    }
    throw (0, import_err_code11.default)(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isFileObject(input10)) {
    yield toFileObject2(input10, normaliseContent3);
    return;
  }
  throw (0, import_err_code11.default)(new Error('Unexpected input: cannot convert "' + typeof input10 + '" into ImportCandidate'), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject2(input10, normaliseContent3) {
  const { path, mode, mtime, content: content2 } = input10;
  const file = {
    path: path || "",
    mode: parseMode(mode),
    mtime: parseMtime2(mtime)
  };
  if (content2) {
    file.content = await normaliseContent3(content2);
  } else if (!path) {
    file.content = await normaliseContent3(input10);
  }
  return file;
}
var import_err_code11, import_browser_readablestream_to_it4, import_it_peekable5;
var init_normalise_candidate_single = __esm({
  "../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/files/normalise-candidate-single.js"() {
    import_err_code11 = __toESM(require_err_code(), 1);
    import_browser_readablestream_to_it4 = __toESM(require_browser_readablestream_to_it(), 1);
    import_it_peekable5 = __toESM(require_it_peekable(), 1);
    init_utils();
    init_src3();
  }
});

// ../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/files/normalise-input-single.js
function normaliseInput4(input10) {
  return normaliseCandidateSingle(input10, normaliseContent);
}
var init_normalise_input_single = __esm({
  "../../node_modules/.pnpm/ipfs-core-utils@0.14.3/node_modules/ipfs-core-utils/esm/src/files/normalise-input-single.js"() {
    init_normalise_content();
    init_normalise_candidate_single();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/add.js
function createAdd5(options) {
  const all5 = createAddAll2(options);
  return configure(() => {
    async function add9(input10, options2 = {}) {
      return await (0, import_it_last4.default)(all5(normaliseInput4(input10), options2));
    }
    return add9;
  })(options);
}
var import_it_last4;
var init_add5 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/add.js"() {
    init_add_all2();
    import_it_last4 = __toESM(require_it_last(), 1);
    init_configure();
    init_normalise_input_single();
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/cat.js
var createCat;
var init_cat = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/cat.js"() {
    init_configure();
    init_to_url_search_params();
    createCat = configure((api) => {
      async function* cat(path, options = {}) {
        const res = await api.post("cat", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path.toString(),
            ...options
          }),
          headers: options.headers
        });
        yield* res.iterator();
      }
      return cat;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/commands.js
var createCommands;
var init_commands = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/commands.js"() {
    init_configure();
    init_to_url_search_params();
    createCommands = configure((api) => {
      const commands = async (options = {}) => {
        const res = await api.post("commands", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return res.json();
      };
      return commands;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dns.js
var createDns;
var init_dns = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/dns.js"() {
    init_configure();
    init_to_url_search_params();
    createDns = configure((api) => {
      const dns = async (domain, options = {}) => {
        const res = await api.post("dns", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: domain,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return data.Path;
      };
      return dns;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/get-endpoint-config.js
var createGetEndpointConfig;
var init_get_endpoint_config = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/get-endpoint-config.js"() {
    init_configure();
    createGetEndpointConfig = configure((api) => {
      return () => {
        const url = new URL(api.opts.base || "");
        return {
          host: url.hostname,
          port: url.port,
          protocol: url.protocol,
          pathname: url.pathname,
          "api-path": url.pathname
        };
      };
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/get.js
var createGet6;
var init_get6 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/get.js"() {
    init_cid();
    init_configure();
    init_to_url_search_params();
    createGet6 = configure((api) => {
      async function* get15(path, options = {}) {
        const opts = {
          arg: `${path instanceof Uint8Array ? CID.decode(path) : path}`,
          ...options
        };
        if (opts.compressionLevel) {
          opts["compression-level"] = opts.compressionLevel;
          delete opts.compressionLevel;
        }
        const res = await api.post("get", {
          signal: options.signal,
          searchParams: toUrlSearchParams(opts),
          headers: options.headers
        });
        yield* res.iterator();
      }
      return get15;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/id.js
var import_multiaddr12, createId;
var init_id = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/id.js"() {
    init_object_to_camel();
    import_multiaddr12 = __toESM(require_src2(), 1);
    init_configure();
    init_to_url_search_params();
    createId = configure((api) => {
      async function id(options = {}) {
        const res = await api.post("id", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: options.peerId ? options.peerId.toString() : void 0,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        const output = { ...objectToCamel(data) };
        if (output.addresses) {
          output.addresses = output.addresses.map((ma) => new import_multiaddr12.Multiaddr(ma));
        }
        return output;
      }
      return id;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/is-online.js
var createIsOnline;
var init_is_online = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/is-online.js"() {
    init_id();
    createIsOnline = (options) => {
      const id = createId(options);
      async function isOnline(options2 = {}) {
        const res = await id(options2);
        return Boolean(res && res.addresses && res.addresses.length);
      }
      return isOnline;
    };
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/ls.js
function typeOf(link5) {
  switch (link5.Type) {
    case 1:
    case 5:
      return "dir";
    case 2:
      return "file";
    default:
      return "file";
  }
}
var createLs7;
var init_ls7 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/ls.js"() {
    init_cid();
    init_configure();
    init_to_url_search_params();
    init_stat3();
    createLs7 = configure((api, opts) => {
      async function* ls(path, options = {}) {
        const pathStr = `${path instanceof Uint8Array ? CID.decode(path) : path}`;
        async function mapLink(link5) {
          let hash = link5.Hash;
          if (hash.includes("/")) {
            const ipfsPath = hash.startsWith("/ipfs/") ? hash : `/ipfs/${hash}`;
            const stats = await createStat3(opts)(ipfsPath);
            hash = stats.cid;
          } else {
            hash = CID.parse(hash);
          }
          const entry = {
            name: link5.Name,
            path: pathStr + (link5.Name ? `/${link5.Name}` : ""),
            size: link5.Size,
            cid: hash,
            type: typeOf(link5)
          };
          if (link5.Mode) {
            entry.mode = parseInt(link5.Mode, 8);
          }
          if (link5.Mtime !== void 0 && link5.Mtime !== null) {
            entry.mtime = { secs: link5.Mtime };
            if (link5.MtimeNsecs !== void 0 && link5.MtimeNsecs !== null) {
              entry.mtime.nsecs = link5.MtimeNsecs;
            }
          }
          return entry;
        }
        const res = await api.post("ls", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: pathStr,
            ...options
          }),
          headers: options.headers
        });
        for await (let result of res.ndjson()) {
          result = result.Objects;
          if (!result) {
            throw new Error("expected .Objects in results");
          }
          result = result[0];
          if (!result) {
            throw new Error("expected one array in results.Objects");
          }
          const links3 = result.Links;
          if (!Array.isArray(links3)) {
            throw new Error("expected one array in results.Objects[0].Links");
          }
          if (!links3.length) {
            yield mapLink(result);
            return;
          }
          yield* links3.map(mapLink);
        }
      }
      return ls;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/mount.js
var createMount;
var init_mount = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/mount.js"() {
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createMount = configure((api) => {
      async function mount(options = {}) {
        const res = await api.post("dns", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return objectToCamel(await res.json());
      }
      return mount;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/ping.js
var createPing;
var init_ping = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/ping.js"() {
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createPing = configure((api) => {
      async function* ping(peerId, options = {}) {
        const res = await api.post("ping", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${peerId}`,
            ...options
          }),
          headers: options.headers,
          transform: objectToCamel
        });
        yield* res.ndjson();
      }
      return ping;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/resolve.js
var createResolve3;
var init_resolve4 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/resolve.js"() {
    init_configure();
    init_to_url_search_params();
    createResolve3 = configure((api) => {
      async function resolve2(path, options = {}) {
        const res = await api.post("resolve", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            ...options
          }),
          headers: options.headers
        });
        const { Path } = await res.json();
        return Path;
      }
      return resolve2;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/start.js
var import_err_code12, createStart;
var init_start = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/start.js"() {
    init_configure();
    import_err_code12 = __toESM(require_err_code(), 1);
    createStart = configure((api) => {
      const start = async (options = {}) => {
        throw (0, import_err_code12.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
      };
      return start;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/stop.js
var createStop;
var init_stop = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/stop.js"() {
    init_configure();
    init_to_url_search_params();
    createStop = configure((api) => {
      async function stop(options = {}) {
        const res = await api.post("shutdown", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        await res.text();
      }
      return stop;
    });
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/version.js
var createVersion2;
var init_version2 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/version.js"() {
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createVersion2 = configure((api) => {
      async function version3(options = {}) {
        const res = await api.post("version", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return {
          ...objectToCamel(await res.json()),
          "ipfs-http-client": "1.0.0"
        };
      }
      return version3;
    });
  }
});

// ../../node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "../../node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js"(exports2, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// ../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../../node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "../../node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js"(exports2, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre)) return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad2 = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad2) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// ../../node_modules/.pnpm/minimatch@3.1.2/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "../../node_modules/.pnpm/minimatch@3.1.2/node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = function() {
      try {
        return require("path");
      } catch (e) {
      }
    }() || {
      sep: "/"
    };
    minimatch.sep = path.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set5, c) {
        set5[c] = true;
        return set5;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter2;
    function filter2(pattern, options) {
      options = options || {};
      return function(p, i, list7) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m.Minimatch.defaults = function defaults5(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m.filter = function filter3(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m.defaults = function defaults5(options) {
        return orig.defaults(ext(def, options));
      };
      m.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m.match = function(list7, pattern, options) {
        return orig.match(list7, pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      assertValidPattern(pattern);
      if (!options) options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options) options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set5 = this.globSet = this.braceExpand();
      if (options.debug) this.debug = function debug4() {
        console.error.apply(console, arguments);
      };
      this.debug(this.pattern, set5);
      set5 = this.globParts = set5.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set5);
      set5 = set5.map(function(s, si, set6) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set5);
      set5 = set5.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set5);
      this.set = set5;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate) return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset) this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse8;
    var SUBPARSE = {};
    function parse8(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "") return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1) c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext) clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false) return this.regexp;
      var set5 = this.set;
      if (!set5.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set5.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate) re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list7, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list7 = list7.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list7.length) {
        list7.push(pattern);
      }
      return list7;
    };
    Minimatch.prototype.match = function match5(f, partial) {
      if (typeof partial === "undefined") partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment) return false;
      if (this.empty) return f === "";
      if (f === "/" && partial) return true;
      var options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set5 = this.set;
      this.debug(this.pattern, "set", set5);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename) break;
      }
      for (i = 0; i < set5.length; i++) {
        var pattern = set5[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate) return true;
          return !this.negate;
        }
      }
      if (options.flipNegate) return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false) return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl) return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit) return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// ../../node_modules/.pnpm/it-glob@1.0.2/node_modules/it-glob/index.js
var require_it_glob = __commonJS({
  "../../node_modules/.pnpm/it-glob@1.0.2/node_modules/it-glob/index.js"(exports2, module2) {
    "use strict";
    var fs4 = require("fs").promises;
    var path = require("path");
    var minimatch = require_minimatch();
    async function* glob(dir, pattern, options = {}) {
      const absoluteDir = path.resolve(dir);
      const relativeDir = path.relative(options.cwd || process.cwd(), dir);
      const stats = await fs4.stat(absoluteDir);
      if (stats.isDirectory()) {
        for await (const entry of _glob(absoluteDir, "", pattern, options)) {
          yield entry;
        }
        return;
      }
      if (minimatch(relativeDir, pattern, options)) {
        yield options.absolute ? absoluteDir : relativeDir;
      }
    }
    async function* _glob(base6, dir, pattern, options) {
      for await (const entry of await fs4.opendir(path.join(base6, dir))) {
        const relativeEntryPath = path.join(dir, entry.name);
        const absoluteEntryPath = path.join(base6, dir, entry.name);
        let match5 = minimatch(relativeEntryPath, pattern, options);
        const isDirectory = entry.isDirectory();
        if (isDirectory && options.nodir) {
          match5 = false;
        }
        if (match5) {
          yield options.absolute ? absoluteEntryPath : relativeEntryPath;
        }
        if (isDirectory) {
          yield* _glob(base6, relativeEntryPath, pattern, options);
        }
      }
    }
    module2.exports = glob;
  }
});

// ../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/files/glob-source.js
var require_glob_source = __commonJS({
  "../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/files/glob-source.js"(exports2, module2) {
    "use strict";
    var fsp = require("fs").promises;
    var fs4 = require("fs");
    var glob = require_it_glob();
    var Path = require("path");
    var errCode12 = require_err_code();
    module2.exports = async function* globSource2(cwd, pattern, options) {
      options = options || {};
      if (typeof pattern !== "string") {
        throw errCode12(
          new Error("Pattern must be a string"),
          "ERR_INVALID_PATH",
          { pattern }
        );
      }
      if (!Path.isAbsolute(cwd)) {
        cwd = Path.resolve(process.cwd(), cwd);
      }
      const globOptions = Object.assign({}, {
        nodir: false,
        realpath: false,
        absolute: true,
        dot: Boolean(options.hidden),
        follow: options.followSymlinks != null ? options.followSymlinks : true
      });
      for await (const p of glob(cwd, pattern, globOptions)) {
        const stat = await fsp.stat(p);
        let mode = options.mode;
        if (options.preserveMode) {
          mode = stat.mode;
        }
        let mtime = options.mtime;
        if (options.preserveMtime) {
          mtime = stat.mtime;
        }
        yield {
          path: toPosix(p.replace(cwd, "")),
          content: stat.isFile() ? fs4.createReadStream(p) : void 0,
          mode,
          mtime
        };
      }
    };
    var toPosix = (path) => path.replace(/\\/g, "/");
  }
});

// ../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/files/url-source.js
var require_url_source = __commonJS({
  "../../node_modules/.pnpm/ipfs-utils@9.0.14/node_modules/ipfs-utils/src/files/url-source.js"(exports2, module2) {
    "use strict";
    var HTTP3 = require_http();
    var urlSource = (url, options) => {
      return {
        path: decodeURIComponent(new URL(url).pathname.split("/").pop() || ""),
        content: readURLContent(url, options)
      };
    };
    async function* readURLContent(url, options) {
      const http2 = new HTTP3();
      const response = await http2.get(url, options);
      yield* response.iterator();
    }
    module2.exports = urlSource;
  }
});

// ../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  CID: () => CID,
  create: () => create2,
  globSource: () => globSource,
  multiaddr: () => import_multiaddr13.Multiaddr,
  urlSource: () => import_url_source.default
});
function create2(options = {}) {
  const id = {
    name: identity.name,
    code: identity.code,
    encode: (id2) => id2,
    decode: (id2) => id2
  };
  const multibaseCodecs = Object.values(bases);
  (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach((base6) => multibaseCodecs.push(base6));
  const multibases = new Multibases({
    bases: multibaseCodecs,
    loadBase: options.ipld && options.ipld.loadBase
  });
  const blockCodecs = Object.values(codecs);
  [
    src_exports,
    esm_exports,
    esm_exports2,
    dagJOSE,
    id
  ].concat(options.ipld && options.ipld.codecs || []).forEach((codec) => blockCodecs.push(codec));
  const multicodecs = new Multicodecs({
    codecs: blockCodecs,
    loadCodec: options.ipld && options.ipld.loadCodec
  });
  const multihashHashers = Object.values(hashes);
  (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach((hasher) => multihashHashers.push(hasher));
  const multihashes = new Multihashes({
    hashers: multihashHashers,
    loadHasher: options.ipld && options.ipld.loadHasher
  });
  const client = {
    add: createAdd5(options),
    addAll: createAddAll2(options),
    bitswap: createBitswap(options),
    block: createBlock(options),
    bootstrap: createBootstrap(options),
    cat: createCat(options),
    commands: createCommands(options),
    config: createConfig(options),
    dag: createDag(multicodecs, options),
    dht: createDht(options),
    diag: createDiag(options),
    dns: createDns(options),
    files: createFiles(options),
    get: createGet6(options),
    getEndpointConfig: createGetEndpointConfig(options),
    id: createId(options),
    isOnline: createIsOnline(options),
    key: createKey(options),
    log: createLog(options),
    ls: createLs7(options),
    mount: createMount(options),
    name: createName(options),
    object: createObject(multicodecs, options),
    pin: createPin(options),
    ping: createPing(options),
    pubsub: createPubsub2(options),
    refs: createRefs(options),
    repo: createRepo(options),
    resolve: createResolve3(options),
    start: createStart(options),
    stats: createStats(options),
    stop: createStop(options),
    swarm: createSwarm(options),
    version: createVersion2(options),
    bases: multibases,
    codecs: multicodecs,
    hashers: multihashes
  };
  return client;
}
var dagJOSE, import_glob_source, import_multiaddr13, import_url_source, globSource;
var init_src4 = __esm({
  "../../node_modules/.pnpm/ipfs-http-client@56.0.3/node_modules/ipfs-http-client/esm/src/index.js"() {
    init_multibases();
    init_multicodecs();
    init_multihashes();
    init_src();
    init_esm();
    init_esm2();
    dagJOSE = __toESM(require_lib(), 1);
    init_identity();
    init_basics();
    init_bitswap();
    init_block();
    init_bootstrap();
    init_config();
    init_dag();
    init_dht();
    init_diag();
    init_files();
    init_key();
    init_log();
    init_name();
    init_object();
    init_pin();
    init_pubsub2();
    init_refs();
    init_repo();
    init_stats();
    init_swarm();
    init_add5();
    init_add_all2();
    init_cat();
    init_commands();
    init_dns();
    init_get_endpoint_config();
    init_get6();
    init_id();
    init_is_online();
    init_ls7();
    init_mount();
    init_ping();
    init_resolve4();
    init_start();
    init_stop();
    init_version2();
    import_glob_source = __toESM(require_glob_source(), 1);
    init_cid();
    import_multiaddr13 = __toESM(require_src2(), 1);
    import_url_source = __toESM(require_url_source(), 1);
    globSource = import_glob_source.default;
  }
});

// ../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/api.js
var init_api = __esm({
  "../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/api.js"() {
  }
});

// ../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/constant.js
var BITS_PER_BYTE, FRS_PER_QUAD, LEAFS_PER_QUAD, IN_BITS_FR, OUT_BITS_FR, IN_BYTES_PER_QUAD, OUT_BYTES_PER_QUAD, PADDED_BYTES_PER_QUAD, EXPANDED_BYTES_PER_QUAD, BYTES_PER_FR, FR_RATIO, NODE_SIZE, EXPANDED_BYTES_PER_NODE, MIN_PAYLOAD_SIZE;
var init_constant = __esm({
  "../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/constant.js"() {
    BITS_PER_BYTE = 8;
    FRS_PER_QUAD = 4;
    LEAFS_PER_QUAD = /** @type {4n} */
    BigInt(FRS_PER_QUAD);
    IN_BITS_FR = 254;
    OUT_BITS_FR = 256;
    IN_BYTES_PER_QUAD = /** @type {127} */
    FRS_PER_QUAD * IN_BITS_FR / BITS_PER_BYTE;
    OUT_BYTES_PER_QUAD = /** @type {128} */
    FRS_PER_QUAD * OUT_BITS_FR / BITS_PER_BYTE;
    PADDED_BYTES_PER_QUAD = /** @type {127n} */
    BigInt(IN_BYTES_PER_QUAD);
    EXPANDED_BYTES_PER_QUAD = /** @type {128n} */
    BigInt(OUT_BYTES_PER_QUAD);
    BYTES_PER_FR = /** @type {32} */
    OUT_BYTES_PER_QUAD / FRS_PER_QUAD;
    FR_RATIO = IN_BITS_FR / OUT_BITS_FR;
    NODE_SIZE = /** @type {32} */
    OUT_BYTES_PER_QUAD / FRS_PER_QUAD;
    EXPANDED_BYTES_PER_NODE = /** @type {32n} */
    BigInt(NODE_SIZE);
    MIN_PAYLOAD_SIZE = 2 * NODE_SIZE + 1;
  }
});

// ../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/node.js
var from3, empty2, EMPTY;
var init_node = __esm({
  "../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/node.js"() {
    init_api();
    init_constant();
    from3 = (bytes2) => {
      if (bytes2 instanceof Uint8Array) {
        if (bytes2.length > NODE_SIZE) {
          return bytes2.subarray(0, NODE_SIZE);
        } else if (bytes2.length == NODE_SIZE) {
          return bytes2;
        }
      }
      const node = new Uint8Array(NODE_SIZE);
      node.set([...bytes2]);
      return node;
    };
    empty2 = () => EMPTY;
    EMPTY = from3(new Uint8Array(NODE_SIZE).fill(0));
    Object.freeze(EMPTY.buffer);
  }
});

// ../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bytes.js
var empty3, equals3, coerce2;
var init_bytes3 = __esm({
  "../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bytes.js"() {
    empty3 = new Uint8Array(0);
    equals3 = (aa, bb) => {
      if (aa === bb) return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    coerce2 = (o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") return o;
      if (o instanceof ArrayBuffer) return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
  }
});

// ../../node_modules/.pnpm/sync-multihash-sha2@1.0.0/node_modules/sync-multihash-sha2/src/sha256/digest.js
var name7, code7, size, prefix, Digest2;
var init_digest2 = __esm({
  "../../node_modules/.pnpm/sync-multihash-sha2@1.0.0/node_modules/sync-multihash-sha2/src/sha256/digest.js"() {
    name7 = "sha2-256";
    code7 = 18;
    size = 32;
    prefix = new Uint8Array([18, 32]);
    Digest2 = class {
      /**
       * @param {Uint8Array} bytes
       */
      constructor(bytes2) {
        this.code = code7;
        this.name = name7;
        this.bytes = bytes2;
        this.size = size;
        this.digest = bytes2.subarray(2);
      }
    };
  }
});

// ../../node_modules/.pnpm/sync-multihash-sha2@1.0.0/node_modules/sync-multihash-sha2/src/sha256/node.js
var import_node_crypto, digest2;
var init_node2 = __esm({
  "../../node_modules/.pnpm/sync-multihash-sha2@1.0.0/node_modules/sync-multihash-sha2/src/sha256/node.js"() {
    import_node_crypto = __toESM(require("node:crypto"), 1);
    init_digest2();
    digest2 = (payload) => {
      const digest6 = new Uint8Array(prefix.length + size);
      digest6.set(prefix, 0);
      digest6.set(
        import_node_crypto.default.createHash("sha256").update(payload).digest(),
        prefix.length
      );
      return new Digest2(digest6);
    };
  }
});

// ../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/ipld/sha256.js
var sha256_exports = {};
__export(sha256_exports, {
  code: () => code8,
  digest: () => digest2,
  name: () => name7,
  size: () => size
});
var code8;
var init_sha256 = __esm({
  "../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/ipld/sha256.js"() {
    init_api();
    init_node2();
    init_node2();
    code8 = code7;
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/is.js
function is2(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf2 = typeof value;
  if (typeofs2.includes(typeOf2)) {
    return typeOf2;
  }
  if (typeOf2 === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer3(value)) {
    return "Buffer";
  }
  const objectType = getObjectType2(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer3(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType2(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames2.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
var typeofs2, objectTypeNames2;
var init_is2 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/is.js"() {
    typeofs2 = [
      "string",
      "number",
      "bigint",
      "symbol"
    ];
    objectTypeNames2 = [
      "Function",
      "Generator",
      "AsyncGenerator",
      "GeneratorFunction",
      "AsyncGeneratorFunction",
      "AsyncFunction",
      "Observable",
      "Array",
      "Buffer",
      "Object",
      "RegExp",
      "Date",
      "Error",
      "Map",
      "Set",
      "WeakMap",
      "WeakSet",
      "ArrayBuffer",
      "SharedArrayBuffer",
      "DataView",
      "Promise",
      "URL",
      "HTMLElement",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Uint16Array",
      "Int32Array",
      "Uint32Array",
      "Float32Array",
      "Float64Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/token.js
var Type2, Token2;
var init_token2 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/token.js"() {
    Type2 = class {
      /**
       * @param {number} major
       * @param {string} name
       * @param {boolean} terminal
       */
      constructor(major, name20, terminal) {
        this.major = major;
        this.majorEncoded = major << 5;
        this.name = name20;
        this.terminal = terminal;
      }
      /* c8 ignore next 3 */
      toString() {
        return `Type[${this.major}].${this.name}`;
      }
      /**
       * @param {Type} typ
       * @returns {number}
       */
      compare(typ) {
        return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
      }
    };
    Type2.uint = new Type2(0, "uint", true);
    Type2.negint = new Type2(1, "negint", true);
    Type2.bytes = new Type2(2, "bytes", true);
    Type2.string = new Type2(3, "string", true);
    Type2.array = new Type2(4, "array", false);
    Type2.map = new Type2(5, "map", false);
    Type2.tag = new Type2(6, "tag", false);
    Type2.float = new Type2(7, "float", true);
    Type2.false = new Type2(7, "false", true);
    Type2.true = new Type2(7, "true", true);
    Type2.null = new Type2(7, "null", true);
    Type2.undefined = new Type2(7, "undefined", true);
    Type2.break = new Type2(7, "break", true);
    Token2 = class {
      /**
       * @param {Type} type
       * @param {any} [value]
       * @param {number} [encodedLength]
       */
      constructor(type2, value, encodedLength) {
        this.type = type2;
        this.value = value;
        this.encodedLength = encodedLength;
        this.encodedBytes = void 0;
        this.byteValue = void 0;
      }
      /* c8 ignore next 3 */
      toString() {
        return `Token[${this.type}].${this.value}`;
      }
    };
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/byte-utils.js
function isBuffer4(buf3) {
  return useBuffer2 && globalThis.Buffer.isBuffer(buf3);
}
function asU8A2(buf3) {
  if (!(buf3 instanceof Uint8Array)) {
    return Uint8Array.from(buf3);
  }
  return isBuffer4(buf3) ? new Uint8Array(buf3.buffer, buf3.byteOffset, buf3.byteLength) : buf3;
}
function compare2(b1, b2) {
  if (isBuffer4(b1) && isBuffer4(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes2(str) {
  const out = [];
  let p = 0;
  for (let i = 0; i < str.length; i++) {
    let c = str.charCodeAt(i);
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }
  return out;
}
function utf8Slice2(buf3, offset2, end) {
  const res = [];
  while (offset2 < end) {
    const firstByte = buf3[offset2];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset2 + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf3[offset2 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf3[offset2 + 1];
          thirdByte = buf3[offset2 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf3[offset2 + 1];
          thirdByte = buf3[offset2 + 2];
          fourthByte = buf3[offset2 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset2 += bytesPerSequence;
  }
  return decodeCodePointsArray2(res);
}
function decodeCodePointsArray2(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH2) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2)
    );
  }
  return res;
}
var useBuffer2, textDecoder4, textEncoder5, toString4, fromString4, fromArray2, slice2, concat2, alloc2, MAX_ARGUMENTS_LENGTH2;
var init_byte_utils2 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/byte-utils.js"() {
    useBuffer2 = globalThis.process && // @ts-ignore
    !globalThis.process.browser && // @ts-ignore
    globalThis.Buffer && // @ts-ignore
    typeof globalThis.Buffer.isBuffer === "function";
    textDecoder4 = new TextDecoder();
    textEncoder5 = new TextEncoder();
    toString4 = useBuffer2 ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array} bytes
       * @param {number} start
       * @param {number} end
       */
      (bytes2, start, end) => {
        return end - start > 64 ? (
          // eslint-disable-line operator-linebreak
          // @ts-ignore
          globalThis.Buffer.from(bytes2.subarray(start, end)).toString("utf8")
        ) : utf8Slice2(bytes2, start, end);
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array} bytes
       * @param {number} start
       * @param {number} end
       */
      (bytes2, start, end) => {
        return end - start > 64 ? textDecoder4.decode(bytes2.subarray(start, end)) : utf8Slice2(bytes2, start, end);
      }
    );
    fromString4 = useBuffer2 ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {string} string
       */
      (string4) => {
        return string4.length > 64 ? (
          // eslint-disable-line operator-linebreak
          // @ts-ignore
          globalThis.Buffer.from(string4)
        ) : utf8ToBytes2(string4);
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {string} string
       */
      (string4) => {
        return string4.length > 64 ? textEncoder5.encode(string4) : utf8ToBytes2(string4);
      }
    );
    fromArray2 = (arr) => {
      return Uint8Array.from(arr);
    };
    slice2 = useBuffer2 ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array} bytes
       * @param {number} start
       * @param {number} end
       */
      (bytes2, start, end) => {
        if (isBuffer4(bytes2)) {
          return new Uint8Array(bytes2.subarray(start, end));
        }
        return bytes2.slice(start, end);
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array} bytes
       * @param {number} start
       * @param {number} end
       */
      (bytes2, start, end) => {
        return bytes2.slice(start, end);
      }
    );
    concat2 = useBuffer2 ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array[]} chunks
       * @param {number} length
       * @returns {Uint8Array}
       */
      (chunks, length5) => {
        chunks = chunks.map((c) => c instanceof Uint8Array ? c : (
          // eslint-disable-line operator-linebreak
          // @ts-ignore
          globalThis.Buffer.from(c)
        ));
        return asU8A2(globalThis.Buffer.concat(chunks, length5));
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array[]} chunks
       * @param {number} length
       * @returns {Uint8Array}
       */
      (chunks, length5) => {
        const out = new Uint8Array(length5);
        let off = 0;
        for (let b of chunks) {
          if (off + b.length > out.length) {
            b = b.subarray(0, out.length - off);
          }
          out.set(b, off);
          off += b.length;
        }
        return out;
      }
    );
    alloc2 = useBuffer2 ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {number} size
       * @returns {Uint8Array}
       */
      (size5) => {
        return globalThis.Buffer.allocUnsafe(size5);
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {number} size
       * @returns {Uint8Array}
       */
      (size5) => {
        return new Uint8Array(size5);
      }
    );
    MAX_ARGUMENTS_LENGTH2 = 4096;
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/bl.js
var defaultChunkSize2, Bl2;
var init_bl2 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/bl.js"() {
    init_byte_utils2();
    defaultChunkSize2 = 256;
    Bl2 = class {
      /**
       * @param {number} [chunkSize]
       */
      constructor(chunkSize = defaultChunkSize2) {
        this.chunkSize = chunkSize;
        this.cursor = 0;
        this.maxCursor = -1;
        this.chunks = [];
        this._initReuseChunk = null;
      }
      reset() {
        this.cursor = 0;
        this.maxCursor = -1;
        if (this.chunks.length) {
          this.chunks = [];
        }
        if (this._initReuseChunk !== null) {
          this.chunks.push(this._initReuseChunk);
          this.maxCursor = this._initReuseChunk.length - 1;
        }
      }
      /**
       * @param {Uint8Array|number[]} bytes
       */
      push(bytes2) {
        let topChunk = this.chunks[this.chunks.length - 1];
        const newMax = this.cursor + bytes2.length;
        if (newMax <= this.maxCursor + 1) {
          const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
          topChunk.set(bytes2, chunkPos);
        } else {
          if (topChunk) {
            const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
            if (chunkPos < topChunk.length) {
              this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
              this.maxCursor = this.cursor - 1;
            }
          }
          if (bytes2.length < 64 && bytes2.length < this.chunkSize) {
            topChunk = alloc2(this.chunkSize);
            this.chunks.push(topChunk);
            this.maxCursor += topChunk.length;
            if (this._initReuseChunk === null) {
              this._initReuseChunk = topChunk;
            }
            topChunk.set(bytes2, 0);
          } else {
            this.chunks.push(bytes2);
            this.maxCursor += bytes2.length;
          }
        }
        this.cursor += bytes2.length;
      }
      /**
       * @param {boolean} [reset]
       * @returns {Uint8Array}
       */
      toBytes(reset = false) {
        let byts;
        if (this.chunks.length === 1) {
          const chunk = this.chunks[0];
          if (reset && this.cursor > chunk.length / 2) {
            byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
            this._initReuseChunk = null;
            this.chunks = [];
          } else {
            byts = slice2(chunk, 0, this.cursor);
          }
        } else {
          byts = concat2(this.chunks, this.cursor);
        }
        if (reset) {
          this.reset();
        }
        return byts;
      }
    };
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/common.js
function assertEnoughData2(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix2} not enough data for type`);
  }
}
var decodeErrPrefix2, encodeErrPrefix2, uintMinorPrefixBytes2;
var init_common2 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/common.js"() {
    decodeErrPrefix2 = "CBOR decode error:";
    encodeErrPrefix2 = "CBOR encode error:";
    uintMinorPrefixBytes2 = [];
    uintMinorPrefixBytes2[23] = 1;
    uintMinorPrefixBytes2[24] = 2;
    uintMinorPrefixBytes2[25] = 3;
    uintMinorPrefixBytes2[26] = 5;
    uintMinorPrefixBytes2[27] = 9;
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/0uint.js
function readUint82(data, offset2, options) {
  assertEnoughData2(data, offset2, 1);
  const value = data[offset2];
  if (options.strict === true && value < uintBoundaries2[0]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint162(data, offset2, options) {
  assertEnoughData2(data, offset2, 2);
  const value = data[offset2] << 8 | data[offset2 + 1];
  if (options.strict === true && value < uintBoundaries2[1]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint322(data, offset2, options) {
  assertEnoughData2(data, offset2, 4);
  const value = data[offset2] * 16777216 + (data[offset2 + 1] << 16) + (data[offset2 + 2] << 8) + data[offset2 + 3];
  if (options.strict === true && value < uintBoundaries2[2]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint642(data, offset2, options) {
  assertEnoughData2(data, offset2, 8);
  const hi = data[offset2] * 16777216 + (data[offset2 + 1] << 16) + (data[offset2 + 2] << 8) + data[offset2 + 3];
  const lo = data[offset2 + 4] * 16777216 + (data[offset2 + 5] << 16) + (data[offset2 + 6] << 8) + data[offset2 + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries2[3]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix2} integers outside of the safe integer range are not supported`);
}
function decodeUint82(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint82(data, pos + 1, options), 2);
}
function decodeUint162(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint162(data, pos + 1, options), 3);
}
function decodeUint322(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint322(data, pos + 1, options), 5);
}
function decodeUint642(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint642(data, pos + 1, options), 9);
}
function encodeUint2(buf3, token) {
  return encodeUintValue2(buf3, 0, token.value);
}
function encodeUintValue2(buf3, major, uint) {
  if (uint < uintBoundaries2[0]) {
    const nuint = Number(uint);
    buf3.push([major | nuint]);
  } else if (uint < uintBoundaries2[1]) {
    const nuint = Number(uint);
    buf3.push([major | 24, nuint]);
  } else if (uint < uintBoundaries2[2]) {
    const nuint = Number(uint);
    buf3.push([major | 25, nuint >>> 8, nuint & 255]);
  } else if (uint < uintBoundaries2[3]) {
    const nuint = Number(uint);
    buf3.push([major | 26, nuint >>> 24 & 255, nuint >>> 16 & 255, nuint >>> 8 & 255, nuint & 255]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries2[4]) {
      const set5 = [major | 27, 0, 0, 0, 0, 0, 0, 0];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set5[8] = lo & 255;
      lo = lo >> 8;
      set5[7] = lo & 255;
      lo = lo >> 8;
      set5[6] = lo & 255;
      lo = lo >> 8;
      set5[5] = lo & 255;
      set5[4] = hi & 255;
      hi = hi >> 8;
      set5[3] = hi & 255;
      hi = hi >> 8;
      set5[2] = hi & 255;
      hi = hi >> 8;
      set5[1] = hi & 255;
      buf3.push(set5);
    } else {
      throw new Error(`${decodeErrPrefix2} encountered BigInt larger than allowable range`);
    }
  }
}
var uintBoundaries2;
var init_uint2 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/0uint.js"() {
    init_token2();
    init_common2();
    uintBoundaries2 = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
    encodeUint2.encodedSize = function encodedSize9(token) {
      return encodeUintValue2.encodedSize(token.value);
    };
    encodeUintValue2.encodedSize = function encodedSize10(uint) {
      if (uint < uintBoundaries2[0]) {
        return 1;
      }
      if (uint < uintBoundaries2[1]) {
        return 2;
      }
      if (uint < uintBoundaries2[2]) {
        return 3;
      }
      if (uint < uintBoundaries2[3]) {
        return 5;
      }
      return 9;
    };
    encodeUint2.compareTokens = function compareTokens4(tok1, tok2) {
      return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : (
        /* c8 ignore next */
        0
      );
    };
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/1negint.js
function decodeNegint82(data, pos, _minor, options) {
  return new Token2(Type2.negint, -1 - readUint82(data, pos + 1, options), 2);
}
function decodeNegint162(data, pos, _minor, options) {
  return new Token2(Type2.negint, -1 - readUint162(data, pos + 1, options), 3);
}
function decodeNegint322(data, pos, _minor, options) {
  return new Token2(Type2.negint, -1 - readUint322(data, pos + 1, options), 5);
}
function decodeNegint642(data, pos, _minor, options) {
  const int = readUint642(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token2(Type2.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix2} integers outside of the safe integer range are not supported`);
  }
  return new Token2(Type2.negint, neg1b2 - BigInt(int), 9);
}
function encodeNegint2(buf3, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b2 - pos1b2 : negint * -1 - 1;
  encodeUintValue2(buf3, token.type.majorEncoded, unsigned);
}
var neg1b2, pos1b2;
var init_negint2 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/1negint.js"() {
    init_token2();
    init_uint2();
    init_common2();
    neg1b2 = BigInt(-1);
    pos1b2 = BigInt(1);
    encodeNegint2.encodedSize = function encodedSize11(token) {
      const negint = token.value;
      const unsigned = typeof negint === "bigint" ? negint * neg1b2 - pos1b2 : negint * -1 - 1;
      if (unsigned < uintBoundaries2[0]) {
        return 1;
      }
      if (unsigned < uintBoundaries2[1]) {
        return 2;
      }
      if (unsigned < uintBoundaries2[2]) {
        return 3;
      }
      if (unsigned < uintBoundaries2[3]) {
        return 5;
      }
      return 9;
    };
    encodeNegint2.compareTokens = function compareTokens5(tok1, tok2) {
      return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : (
        /* c8 ignore next */
        0
      );
    };
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/2bytes.js
function toToken5(data, pos, prefix2, length5) {
  assertEnoughData2(data, pos, prefix2 + length5);
  const buf3 = slice2(data, pos + prefix2, pos + prefix2 + length5);
  return new Token2(Type2.bytes, buf3, prefix2 + length5);
}
function decodeBytesCompact2(data, pos, minor, _options) {
  return toToken5(data, pos, 1, minor);
}
function decodeBytes82(data, pos, _minor, options) {
  return toToken5(data, pos, 2, readUint82(data, pos + 1, options));
}
function decodeBytes162(data, pos, _minor, options) {
  return toToken5(data, pos, 3, readUint162(data, pos + 1, options));
}
function decodeBytes322(data, pos, _minor, options) {
  return toToken5(data, pos, 5, readUint322(data, pos + 1, options));
}
function decodeBytes642(data, pos, _minor, options) {
  const l = readUint642(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer bytes lengths not supported`);
  }
  return toToken5(data, pos, 9, l);
}
function tokenBytes2(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type2.string ? fromString4(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes2(buf3, token) {
  const bytes2 = tokenBytes2(token);
  encodeUintValue2(buf3, token.type.majorEncoded, bytes2.length);
  buf3.push(bytes2);
}
function compareBytes2(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare2(b1, b2);
}
var init_bytes4 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/2bytes.js"() {
    init_token2();
    init_common2();
    init_uint2();
    init_byte_utils2();
    encodeBytes2.encodedSize = function encodedSize12(token) {
      const bytes2 = tokenBytes2(token);
      return encodeUintValue2.encodedSize(bytes2.length) + bytes2.length;
    };
    encodeBytes2.compareTokens = function compareTokens6(tok1, tok2) {
      return compareBytes2(tokenBytes2(tok1), tokenBytes2(tok2));
    };
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/3string.js
function toToken6(data, pos, prefix2, length5, options) {
  const totLength = prefix2 + length5;
  assertEnoughData2(data, pos, totLength);
  const tok = new Token2(Type2.string, toString4(data, pos + prefix2, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice2(data, pos + prefix2, pos + totLength);
  }
  return tok;
}
function decodeStringCompact2(data, pos, minor, options) {
  return toToken6(data, pos, 1, minor, options);
}
function decodeString82(data, pos, _minor, options) {
  return toToken6(data, pos, 2, readUint82(data, pos + 1, options), options);
}
function decodeString162(data, pos, _minor, options) {
  return toToken6(data, pos, 3, readUint162(data, pos + 1, options), options);
}
function decodeString322(data, pos, _minor, options) {
  return toToken6(data, pos, 5, readUint322(data, pos + 1, options), options);
}
function decodeString642(data, pos, _minor, options) {
  const l = readUint642(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer string lengths not supported`);
  }
  return toToken6(data, pos, 9, l, options);
}
var encodeString2;
var init_string2 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/3string.js"() {
    init_token2();
    init_common2();
    init_uint2();
    init_bytes4();
    init_byte_utils2();
    encodeString2 = encodeBytes2;
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/4array.js
function toToken7(_data, _pos, prefix2, length5) {
  return new Token2(Type2.array, length5, prefix2);
}
function decodeArrayCompact2(data, pos, minor, _options) {
  return toToken7(data, pos, 1, minor);
}
function decodeArray82(data, pos, _minor, options) {
  return toToken7(data, pos, 2, readUint82(data, pos + 1, options));
}
function decodeArray162(data, pos, _minor, options) {
  return toToken7(data, pos, 3, readUint162(data, pos + 1, options));
}
function decodeArray322(data, pos, _minor, options) {
  return toToken7(data, pos, 5, readUint322(data, pos + 1, options));
}
function decodeArray642(data, pos, _minor, options) {
  const l = readUint642(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer array lengths not supported`);
  }
  return toToken7(data, pos, 9, l);
}
function decodeArrayIndefinite2(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
  }
  return toToken7(data, pos, 1, Infinity);
}
function encodeArray2(buf3, token) {
  encodeUintValue2(buf3, Type2.array.majorEncoded, token.value);
}
var init_array2 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/4array.js"() {
    init_token2();
    init_uint2();
    init_common2();
    encodeArray2.compareTokens = encodeUint2.compareTokens;
    encodeArray2.encodedSize = function encodedSize13(token) {
      return encodeUintValue2.encodedSize(token.value);
    };
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/5map.js
function toToken8(_data, _pos, prefix2, length5) {
  return new Token2(Type2.map, length5, prefix2);
}
function decodeMapCompact2(data, pos, minor, _options) {
  return toToken8(data, pos, 1, minor);
}
function decodeMap82(data, pos, _minor, options) {
  return toToken8(data, pos, 2, readUint82(data, pos + 1, options));
}
function decodeMap162(data, pos, _minor, options) {
  return toToken8(data, pos, 3, readUint162(data, pos + 1, options));
}
function decodeMap322(data, pos, _minor, options) {
  return toToken8(data, pos, 5, readUint322(data, pos + 1, options));
}
function decodeMap642(data, pos, _minor, options) {
  const l = readUint642(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer map lengths not supported`);
  }
  return toToken8(data, pos, 9, l);
}
function decodeMapIndefinite2(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
  }
  return toToken8(data, pos, 1, Infinity);
}
function encodeMap2(buf3, token) {
  encodeUintValue2(buf3, Type2.map.majorEncoded, token.value);
}
var init_map2 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/5map.js"() {
    init_token2();
    init_uint2();
    init_common2();
    encodeMap2.compareTokens = encodeUint2.compareTokens;
    encodeMap2.encodedSize = function encodedSize14(token) {
      return encodeUintValue2.encodedSize(token.value);
    };
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/6tag.js
function decodeTagCompact2(_data, _pos, minor, _options) {
  return new Token2(Type2.tag, minor, 1);
}
function decodeTag82(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint82(data, pos + 1, options), 2);
}
function decodeTag162(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint162(data, pos + 1, options), 3);
}
function decodeTag322(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint322(data, pos + 1, options), 5);
}
function decodeTag642(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint642(data, pos + 1, options), 9);
}
function encodeTag2(buf3, token) {
  encodeUintValue2(buf3, Type2.tag.majorEncoded, token.value);
}
var init_tag2 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/6tag.js"() {
    init_token2();
    init_uint2();
    encodeTag2.compareTokens = encodeUint2.compareTokens;
    encodeTag2.encodedSize = function encodedSize15(token) {
      return encodeUintValue2.encodedSize(token.value);
    };
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/7float.js
function decodeUndefined2(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix2} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token2(Type2.null, null, 1);
  }
  return new Token2(Type2.undefined, void 0, 1);
}
function decodeBreak2(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
  }
  return new Token2(Type2.break, void 0, 1);
}
function createToken2(value, bytes2, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix2} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix2} Infinity values are not supported`);
    }
  }
  return new Token2(Type2.float, value, bytes2);
}
function decodeFloat162(data, pos, _minor, options) {
  return createToken2(readFloat162(data, pos + 1), 3, options);
}
function decodeFloat322(data, pos, _minor, options) {
  return createToken2(readFloat322(data, pos + 1), 5, options);
}
function decodeFloat642(data, pos, _minor, options) {
  return createToken2(readFloat642(data, pos + 1), 9, options);
}
function encodeFloat2(buf3, token, options) {
  const float2 = token.value;
  if (float2 === false) {
    buf3.push([Type2.float.majorEncoded | MINOR_FALSE2]);
  } else if (float2 === true) {
    buf3.push([Type2.float.majorEncoded | MINOR_TRUE2]);
  } else if (float2 === null) {
    buf3.push([Type2.float.majorEncoded | MINOR_NULL2]);
  } else if (float2 === void 0) {
    buf3.push([Type2.float.majorEncoded | MINOR_UNDEFINED2]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat162(float2);
      decoded = readFloat162(ui8a2, 1);
      if (float2 === decoded || Number.isNaN(float2)) {
        ui8a2[0] = 249;
        buf3.push(ui8a2.slice(0, 3));
        success = true;
      } else {
        encodeFloat322(float2);
        decoded = readFloat322(ui8a2, 1);
        if (float2 === decoded) {
          ui8a2[0] = 250;
          buf3.push(ui8a2.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat642(float2);
      decoded = readFloat642(ui8a2, 1);
      ui8a2[0] = 251;
      buf3.push(ui8a2.slice(0, 9));
    }
  }
}
function encodeFloat162(inp) {
  if (inp === Infinity) {
    dataView2.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView2.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView2.setUint16(0, 32256, false);
  } else {
    dataView2.setFloat32(0, inp);
    const valu32 = dataView2.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView2.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView2.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView2.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView2.setUint16(0, (valu32 & 2147483648) >> 16 | /* sign bit */
        1 << 24 + logicalExponent, false);
      } else {
        dataView2.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat162(ui8a3, pos) {
  if (ui8a3.length - pos < 2) {
    throw new Error(`${decodeErrPrefix2} not enough data for float16`);
  }
  const half = (ui8a3[pos] << 8) + ui8a3[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat322(inp) {
  dataView2.setFloat32(0, inp, false);
}
function readFloat322(ui8a3, pos) {
  if (ui8a3.length - pos < 4) {
    throw new Error(`${decodeErrPrefix2} not enough data for float32`);
  }
  const offset2 = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset2, 4).getFloat32(0, false);
}
function encodeFloat642(inp) {
  dataView2.setFloat64(0, inp, false);
}
function readFloat642(ui8a3, pos) {
  if (ui8a3.length - pos < 8) {
    throw new Error(`${decodeErrPrefix2} not enough data for float64`);
  }
  const offset2 = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset2, 8).getFloat64(0, false);
}
var MINOR_FALSE2, MINOR_TRUE2, MINOR_NULL2, MINOR_UNDEFINED2, buffer2, dataView2, ui8a2;
var init_float2 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/7float.js"() {
    init_token2();
    init_common2();
    init_uint2();
    MINOR_FALSE2 = 20;
    MINOR_TRUE2 = 21;
    MINOR_NULL2 = 22;
    MINOR_UNDEFINED2 = 23;
    encodeFloat2.encodedSize = function encodedSize16(token, options) {
      const float2 = token.value;
      if (float2 === false || float2 === true || float2 === null || float2 === void 0) {
        return 1;
      }
      if (!options || options.float64 !== true) {
        encodeFloat162(float2);
        let decoded = readFloat162(ui8a2, 1);
        if (float2 === decoded || Number.isNaN(float2)) {
          return 3;
        }
        encodeFloat322(float2);
        decoded = readFloat322(ui8a2, 1);
        if (float2 === decoded) {
          return 5;
        }
      }
      return 9;
    };
    buffer2 = new ArrayBuffer(9);
    dataView2 = new DataView(buffer2, 1);
    ui8a2 = new Uint8Array(buffer2, 0);
    encodeFloat2.compareTokens = encodeUint2.compareTokens;
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/jump.js
function invalidMinor2(data, pos, minor) {
  throw new Error(`${decodeErrPrefix2} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer2(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix2} ${msg}`);
  };
}
function quickEncodeToken2(token) {
  switch (token.type) {
    case Type2.false:
      return fromArray2([244]);
    case Type2.true:
      return fromArray2([245]);
    case Type2.null:
      return fromArray2([246]);
    case Type2.bytes:
      if (!token.value.length) {
        return fromArray2([64]);
      }
      return;
    case Type2.string:
      if (token.value === "") {
        return fromArray2([96]);
      }
      return;
    case Type2.array:
      if (token.value === 0) {
        return fromArray2([128]);
      }
      return;
    case Type2.map:
      if (token.value === 0) {
        return fromArray2([160]);
      }
      return;
    case Type2.uint:
      if (token.value < 24) {
        return fromArray2([Number(token.value)]);
      }
      return;
    case Type2.negint:
      if (token.value >= -24) {
        return fromArray2([31 - Number(token.value)]);
      }
  }
}
var jump2, quick2;
var init_jump2 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/jump.js"() {
    init_token2();
    init_uint2();
    init_negint2();
    init_bytes4();
    init_string2();
    init_array2();
    init_map2();
    init_tag2();
    init_float2();
    init_common2();
    init_byte_utils2();
    jump2 = [];
    for (let i = 0; i <= 23; i++) {
      jump2[i] = invalidMinor2;
    }
    jump2[24] = decodeUint82;
    jump2[25] = decodeUint162;
    jump2[26] = decodeUint322;
    jump2[27] = decodeUint642;
    jump2[28] = invalidMinor2;
    jump2[29] = invalidMinor2;
    jump2[30] = invalidMinor2;
    jump2[31] = invalidMinor2;
    for (let i = 32; i <= 55; i++) {
      jump2[i] = invalidMinor2;
    }
    jump2[56] = decodeNegint82;
    jump2[57] = decodeNegint162;
    jump2[58] = decodeNegint322;
    jump2[59] = decodeNegint642;
    jump2[60] = invalidMinor2;
    jump2[61] = invalidMinor2;
    jump2[62] = invalidMinor2;
    jump2[63] = invalidMinor2;
    for (let i = 64; i <= 87; i++) {
      jump2[i] = decodeBytesCompact2;
    }
    jump2[88] = decodeBytes82;
    jump2[89] = decodeBytes162;
    jump2[90] = decodeBytes322;
    jump2[91] = decodeBytes642;
    jump2[92] = invalidMinor2;
    jump2[93] = invalidMinor2;
    jump2[94] = invalidMinor2;
    jump2[95] = errorer2("indefinite length bytes/strings are not supported");
    for (let i = 96; i <= 119; i++) {
      jump2[i] = decodeStringCompact2;
    }
    jump2[120] = decodeString82;
    jump2[121] = decodeString162;
    jump2[122] = decodeString322;
    jump2[123] = decodeString642;
    jump2[124] = invalidMinor2;
    jump2[125] = invalidMinor2;
    jump2[126] = invalidMinor2;
    jump2[127] = errorer2("indefinite length bytes/strings are not supported");
    for (let i = 128; i <= 151; i++) {
      jump2[i] = decodeArrayCompact2;
    }
    jump2[152] = decodeArray82;
    jump2[153] = decodeArray162;
    jump2[154] = decodeArray322;
    jump2[155] = decodeArray642;
    jump2[156] = invalidMinor2;
    jump2[157] = invalidMinor2;
    jump2[158] = invalidMinor2;
    jump2[159] = decodeArrayIndefinite2;
    for (let i = 160; i <= 183; i++) {
      jump2[i] = decodeMapCompact2;
    }
    jump2[184] = decodeMap82;
    jump2[185] = decodeMap162;
    jump2[186] = decodeMap322;
    jump2[187] = decodeMap642;
    jump2[188] = invalidMinor2;
    jump2[189] = invalidMinor2;
    jump2[190] = invalidMinor2;
    jump2[191] = decodeMapIndefinite2;
    for (let i = 192; i <= 215; i++) {
      jump2[i] = decodeTagCompact2;
    }
    jump2[216] = decodeTag82;
    jump2[217] = decodeTag162;
    jump2[218] = decodeTag322;
    jump2[219] = decodeTag642;
    jump2[220] = invalidMinor2;
    jump2[221] = invalidMinor2;
    jump2[222] = invalidMinor2;
    jump2[223] = invalidMinor2;
    for (let i = 224; i <= 243; i++) {
      jump2[i] = errorer2("simple values are not supported");
    }
    jump2[244] = invalidMinor2;
    jump2[245] = invalidMinor2;
    jump2[246] = invalidMinor2;
    jump2[247] = decodeUndefined2;
    jump2[248] = errorer2("simple values are not supported");
    jump2[249] = decodeFloat162;
    jump2[250] = decodeFloat322;
    jump2[251] = decodeFloat642;
    jump2[252] = invalidMinor2;
    jump2[253] = invalidMinor2;
    jump2[254] = invalidMinor2;
    jump2[255] = decodeBreak2;
    quick2 = [];
    for (let i = 0; i < 24; i++) {
      quick2[i] = new Token2(Type2.uint, i, 1);
    }
    for (let i = -1; i >= -24; i--) {
      quick2[31 - i] = new Token2(Type2.negint, i, 1);
    }
    quick2[64] = new Token2(Type2.bytes, new Uint8Array(0), 1);
    quick2[96] = new Token2(Type2.string, "", 1);
    quick2[128] = new Token2(Type2.array, 0, 1);
    quick2[160] = new Token2(Type2.map, 0, 1);
    quick2[244] = new Token2(Type2.false, false, 1);
    quick2[245] = new Token2(Type2.true, true, 1);
    quick2[246] = new Token2(Type2.null, null, 1);
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/encode.js
function makeCborEncoders2() {
  const encoders = [];
  encoders[Type2.uint.major] = encodeUint2;
  encoders[Type2.negint.major] = encodeNegint2;
  encoders[Type2.bytes.major] = encodeBytes2;
  encoders[Type2.string.major] = encodeString2;
  encoders[Type2.array.major] = encodeArray2;
  encoders[Type2.map.major] = encodeMap2;
  encoders[Type2.tag.major] = encodeTag2;
  encoders[Type2.float.major] = encodeFloat2;
  return encoders;
}
function objectToTokens2(obj, options = {}, refStack) {
  const typ = is2(obj);
  const customTypeEncoder = options && options.typeEncoders && /** @type {OptionalTypeEncoder} */
  options.typeEncoders[typ] || typeEncoders2[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders2[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix2} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries2(entries3, options) {
  if (options.mapSorter) {
    entries3.sort(options.mapSorter);
  }
}
function mapSorter3(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders2[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded2(buf3, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded2(buf3, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf3, tokens, options);
  }
}
function encodeCustom2(data, encoders, options) {
  const tokens = objectToTokens2(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder3 = encoders[tokens.type.major];
    if (encoder3.encodedSize) {
      const size5 = encoder3.encodedSize(tokens, options);
      const buf3 = new Bl2(size5);
      encoder3(buf3, tokens, options);
      if (buf3.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A2(buf3.chunks[0]);
    }
  }
  buf2.reset();
  tokensToEncoded2(buf2, tokens, encoders, options);
  return buf2.toBytes(true);
}
function encode12(data, options) {
  options = Object.assign({}, defaultEncodeOptions3, options);
  return encodeCustom2(data, cborEncoders2, options);
}
var defaultEncodeOptions3, cborEncoders2, buf2, Ref2, simpleTokens2, typeEncoders2;
var init_encode3 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/encode.js"() {
    init_is2();
    init_token2();
    init_bl2();
    init_common2();
    init_jump2();
    init_byte_utils2();
    init_uint2();
    init_negint2();
    init_bytes4();
    init_string2();
    init_array2();
    init_map2();
    init_tag2();
    init_float2();
    defaultEncodeOptions3 = {
      float64: false,
      mapSorter: mapSorter3,
      quickEncodeToken: quickEncodeToken2
    };
    cborEncoders2 = makeCborEncoders2();
    buf2 = new Bl2();
    Ref2 = class _Ref {
      /**
       * @param {object|any[]} obj
       * @param {Reference|undefined} parent
       */
      constructor(obj, parent) {
        this.obj = obj;
        this.parent = parent;
      }
      /**
       * @param {object|any[]} obj
       * @returns {boolean}
       */
      includes(obj) {
        let p = this;
        do {
          if (p.obj === obj) {
            return true;
          }
        } while (p = p.parent);
        return false;
      }
      /**
       * @param {Reference|undefined} stack
       * @param {object|any[]} obj
       * @returns {Reference}
       */
      static createCheck(stack, obj) {
        if (stack && stack.includes(obj)) {
          throw new Error(`${encodeErrPrefix2} object contains circular references`);
        }
        return new _Ref(obj, stack);
      }
    };
    simpleTokens2 = {
      null: new Token2(Type2.null, null),
      undefined: new Token2(Type2.undefined, void 0),
      true: new Token2(Type2.true, true),
      false: new Token2(Type2.false, false),
      emptyArray: new Token2(Type2.array, 0),
      emptyMap: new Token2(Type2.map, 0)
    };
    typeEncoders2 = {
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      number(obj, _typ, _options, _refStack) {
        if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
          return new Token2(Type2.float, obj);
        } else if (obj >= 0) {
          return new Token2(Type2.uint, obj);
        } else {
          return new Token2(Type2.negint, obj);
        }
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      bigint(obj, _typ, _options, _refStack) {
        if (obj >= BigInt(0)) {
          return new Token2(Type2.uint, obj);
        } else {
          return new Token2(Type2.negint, obj);
        }
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      Uint8Array(obj, _typ, _options, _refStack) {
        return new Token2(Type2.bytes, obj);
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      string(obj, _typ, _options, _refStack) {
        return new Token2(Type2.string, obj);
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      boolean(obj, _typ, _options, _refStack) {
        return obj ? simpleTokens2.true : simpleTokens2.false;
      },
      /**
       * @param {any} _obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      null(_obj, _typ, _options, _refStack) {
        return simpleTokens2.null;
      },
      /**
       * @param {any} _obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      undefined(_obj, _typ, _options, _refStack) {
        return simpleTokens2.undefined;
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      ArrayBuffer(obj, _typ, _options, _refStack) {
        return new Token2(Type2.bytes, new Uint8Array(obj));
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      DataView(obj, _typ, _options, _refStack) {
        return new Token2(Type2.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} options
       * @param {Reference} [refStack]
       * @returns {TokenOrNestedTokens}
       */
      Array(obj, _typ, options, refStack) {
        if (!obj.length) {
          if (options.addBreakTokens === true) {
            return [simpleTokens2.emptyArray, new Token2(Type2.break)];
          }
          return simpleTokens2.emptyArray;
        }
        refStack = Ref2.createCheck(refStack, obj);
        const entries3 = [];
        let i = 0;
        for (const e of obj) {
          entries3[i++] = objectToTokens2(e, options, refStack);
        }
        if (options.addBreakTokens) {
          return [new Token2(Type2.array, obj.length), entries3, new Token2(Type2.break)];
        }
        return [new Token2(Type2.array, obj.length), entries3];
      },
      /**
       * @param {any} obj
       * @param {string} typ
       * @param {EncodeOptions} options
       * @param {Reference} [refStack]
       * @returns {TokenOrNestedTokens}
       */
      Object(obj, typ, options, refStack) {
        const isMap = typ !== "Object";
        const keys2 = isMap ? obj.keys() : Object.keys(obj);
        const length5 = isMap ? obj.size : keys2.length;
        if (!length5) {
          if (options.addBreakTokens === true) {
            return [simpleTokens2.emptyMap, new Token2(Type2.break)];
          }
          return simpleTokens2.emptyMap;
        }
        refStack = Ref2.createCheck(refStack, obj);
        const entries3 = [];
        let i = 0;
        for (const key of keys2) {
          entries3[i++] = [
            objectToTokens2(key, options, refStack),
            objectToTokens2(isMap ? obj.get(key) : obj[key], options, refStack)
          ];
        }
        sortMapEntries2(entries3, options);
        if (options.addBreakTokens) {
          return [new Token2(Type2.map, length5), entries3, new Token2(Type2.break)];
        }
        return [new Token2(Type2.map, length5), entries3];
      }
    };
    typeEncoders2.Map = typeEncoders2.Object;
    typeEncoders2.Buffer = typeEncoders2.Uint8Array;
    for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
      typeEncoders2[`${typ}Array`] = typeEncoders2.DataView;
    }
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/decode.js
function tokenToArray2(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject2(tokeniser, options);
    if (value === BREAK2) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix2} got unexpected break to lengthed array`);
    }
    if (value === DONE2) {
      throw new Error(`${decodeErrPrefix2} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
function tokenToMap2(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject2(tokeniser, options);
    if (key === BREAK2) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix2} got unexpected break to lengthed map`);
    }
    if (key === DONE2) {
      throw new Error(`${decodeErrPrefix2} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix2} non-string keys not supported (got ${typeof key})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix2} found repeat map key "${key}"`);
      }
    }
    const value = tokensToObject2(tokeniser, options);
    if (value === DONE2) {
      throw new Error(`${decodeErrPrefix2} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject2(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE2;
  }
  const token = tokeniser.next();
  if (token.type === Type2.break) {
    return BREAK2;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type2.array) {
    return tokenToArray2(token, tokeniser, options);
  }
  if (token.type === Type2.map) {
    return tokenToMap2(token, tokeniser, options);
  }
  if (token.type === Type2.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject2(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix2} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decodeFirst(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix2} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions2, options);
  const tokeniser = options.tokenizer || new Tokeniser2(data, options);
  const decoded = tokensToObject2(tokeniser, options);
  if (decoded === DONE2) {
    throw new Error(`${decodeErrPrefix2} did not find any content to decode`);
  }
  if (decoded === BREAK2) {
    throw new Error(`${decodeErrPrefix2} got unexpected break`);
  }
  return [decoded, data.subarray(tokeniser.pos())];
}
function decode13(data, options) {
  const [decoded, remainder] = decodeFirst(data, options);
  if (remainder.length > 0) {
    throw new Error(`${decodeErrPrefix2} too many terminals, data makes no sense`);
  }
  return decoded;
}
var defaultDecodeOptions2, Tokeniser2, DONE2, BREAK2;
var init_decode3 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/decode.js"() {
    init_common2();
    init_token2();
    init_jump2();
    defaultDecodeOptions2 = {
      strict: false,
      allowIndefinite: true,
      allowUndefined: true,
      allowBigInt: true
    };
    Tokeniser2 = class {
      /**
       * @param {Uint8Array} data
       * @param {DecodeOptions} options
       */
      constructor(data, options = {}) {
        this._pos = 0;
        this.data = data;
        this.options = options;
      }
      pos() {
        return this._pos;
      }
      done() {
        return this._pos >= this.data.length;
      }
      next() {
        const byt = this.data[this._pos];
        let token = quick2[byt];
        if (token === void 0) {
          const decoder3 = jump2[byt];
          if (!decoder3) {
            throw new Error(`${decodeErrPrefix2} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
          }
          const minor = byt & 31;
          token = decoder3(this.data, this._pos, minor, this.options);
        }
        this._pos += token.encodedLength;
        return token;
      }
    };
    DONE2 = Symbol.for("DONE");
    BREAK2 = Symbol.for("BREAK");
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/cborg.js
var init_cborg2 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/cborg.js"() {
    init_encode3();
    init_decode3();
    init_token2();
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bytes.js
var bytes_exports4 = {};
__export(bytes_exports4, {
  coerce: () => coerce3,
  empty: () => empty4,
  equals: () => equals4,
  fromHex: () => fromHex,
  fromString: () => fromString5,
  isBinary: () => isBinary,
  toHex: () => toHex,
  toString: () => toString5
});
function toHex(d) {
  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
}
function fromHex(hex) {
  const hexes2 = hex.match(/../g);
  return hexes2 != null ? new Uint8Array(hexes2.map((b) => parseInt(b, 16))) : empty4;
}
function equals4(aa, bb) {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce3(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function isBinary(o) {
  return o instanceof ArrayBuffer || ArrayBuffer.isView(o);
}
function fromString5(str) {
  return new TextEncoder().encode(str);
}
function toString5(b) {
  return new TextDecoder().decode(b);
}
var empty4;
var init_bytes5 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bytes.js"() {
    empty4 = new Uint8Array(0);
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/vendor/base-x.js
function base3(ALPHABET, name20) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode45(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length5 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size5 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size5);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size5 - 1; (carry !== 0 || i2 < length5) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i2;
      pbegin++;
    }
    var it2 = size5 - length5;
    while (it2 !== size5 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size5; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length5 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size5 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size5);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size5 - 1; (carry !== 0 || i2 < length5) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size5 - length5;
    while (it4 !== size5 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size5 - it4));
    var j2 = zeroes;
    while (it4 !== size5) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode53(string4) {
    var buffer3 = decodeUnsafe(string4);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name20} character`);
  }
  return {
    encode: encode45,
    decodeUnsafe,
    decode: decode53
  };
}
var src2, _brrp__multiformats_scope_baseX2, base_x_default2;
var init_base_x2 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/vendor/base-x.js"() {
    src2 = base3;
    _brrp__multiformats_scope_baseX2 = src2;
    base_x_default2 = _brrp__multiformats_scope_baseX2;
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base.js
function or2(left, right) {
  return new ComposedDecoder2({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
function from4({ name: name20, prefix: prefix2, encode: encode45, decode: decode53 }) {
  return new Codec2(name20, prefix2, encode45, decode53);
}
function baseX2({ name: name20, prefix: prefix2, alphabet: alphabet3 }) {
  const { encode: encode45, decode: decode53 } = base_x_default2(alphabet3, name20);
  return from4({
    prefix: prefix2,
    name: name20,
    encode: encode45,
    decode: (text2) => coerce3(decode53(text2))
  });
}
function decode14(string4, alphabet3, bitsPerChar, name20) {
  const codes = {};
  for (let i = 0; i < alphabet3.length; ++i) {
    codes[alphabet3[i]] = i;
  }
  let end = string4.length;
  while (string4[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes[string4[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name20} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer3 >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer3 << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode13(data, alphabet3, bitsPerChar) {
  const pad2 = alphabet3[alphabet3.length - 1] === "=";
  const mask2 = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet3[mask2 & buffer3 >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet3[mask2 & buffer3 << bitsPerChar - bits];
  }
  if (pad2) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function rfc46482({ name: name20, prefix: prefix2, bitsPerChar, alphabet: alphabet3 }) {
  return from4({
    prefix: prefix2,
    name: name20,
    encode(input10) {
      return encode13(input10, alphabet3, bitsPerChar);
    },
    decode(input10) {
      return decode14(input10, alphabet3, bitsPerChar, name20);
    }
  });
}
var Encoder2, Decoder2, ComposedDecoder2, Codec2;
var init_base3 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base.js"() {
    init_bytes5();
    init_base_x2();
    Encoder2 = class {
      name;
      prefix;
      baseEncode;
      constructor(name20, prefix2, baseEncode) {
        this.name = name20;
        this.prefix = prefix2;
        this.baseEncode = baseEncode;
      }
      encode(bytes2) {
        if (bytes2 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes2)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder2 = class {
      name;
      prefix;
      baseDecode;
      prefixCodePoint;
      constructor(name20, prefix2, baseDecode) {
        this.name = name20;
        this.prefix = prefix2;
        if (prefix2.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix2.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text2) {
        if (typeof text2 === "string") {
          if (text2.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text2.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder3) {
        return or2(this, decoder3);
      }
    };
    ComposedDecoder2 = class {
      decoders;
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder3) {
        return or2(this, decoder3);
      }
      decode(input10) {
        const prefix2 = input10[0];
        const decoder3 = this.decoders[prefix2];
        if (decoder3 != null) {
          return decoder3.decode(input10);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input10)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    Codec2 = class {
      name;
      prefix;
      baseEncode;
      baseDecode;
      encoder;
      decoder;
      constructor(name20, prefix2, baseEncode, baseDecode) {
        this.name = name20;
        this.prefix = prefix2;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder2(name20, prefix2, baseEncode);
        this.decoder = new Decoder2(name20, prefix2, baseDecode);
      }
      encode(input10) {
        return this.encoder.encode(input10);
      }
      decode(input10) {
        return this.decoder.decode(input10);
      }
    };
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base32.js
var base32_exports2 = {};
__export(base32_exports2, {
  base32: () => base322,
  base32hex: () => base32hex2,
  base32hexpad: () => base32hexpad2,
  base32hexpadupper: () => base32hexpadupper2,
  base32hexupper: () => base32hexupper2,
  base32pad: () => base32pad2,
  base32padupper: () => base32padupper2,
  base32upper: () => base32upper2,
  base32z: () => base32z2
});
var base322, base32upper2, base32pad2, base32padupper2, base32hex2, base32hexupper2, base32hexpad2, base32hexpadupper2, base32z2;
var init_base322 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base32.js"() {
    init_base3();
    base322 = rfc46482({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper2 = rfc46482({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad2 = rfc46482({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper2 = rfc46482({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex2 = rfc46482({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper2 = rfc46482({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad2 = rfc46482({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper2 = rfc46482({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z2 = rfc46482({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base58.js
var base58_exports2 = {};
__export(base58_exports2, {
  base58btc: () => base58btc2,
  base58flickr: () => base58flickr2
});
var base58btc2, base58flickr2;
var init_base582 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base58.js"() {
    init_base3();
    base58btc2 = baseX2({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr2 = baseX2({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/vendor/varint.js
function encode14(num, out, offset2) {
  out = out || [];
  offset2 = offset2 || 0;
  var oldOffset = offset2;
  while (num >= INT2) {
    out[offset2++] = num & 255 | MSB2;
    num /= 128;
  }
  while (num & MSBALL2) {
    out[offset2++] = num & 255 | MSB2;
    num >>>= 7;
  }
  out[offset2] = num | 0;
  encode14.bytes = offset2 - oldOffset + 1;
  return out;
}
function read2(buf3, offset2) {
  var res = 0, offset2 = offset2 || 0, shift = 0, counter = offset2, b, l = buf3.length;
  do {
    if (counter >= l) {
      read2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$12);
  read2.bytes = counter - offset2;
  return res;
}
var encode_12, MSB2, REST2, MSBALL2, INT2, decode15, MSB$12, REST$12, N12, N22, N32, N42, N52, N62, N72, N82, N92, length2, varint2, _brrp_varint2, varint_default2;
var init_varint3 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/vendor/varint.js"() {
    encode_12 = encode14;
    MSB2 = 128;
    REST2 = 127;
    MSBALL2 = ~REST2;
    INT2 = Math.pow(2, 31);
    decode15 = read2;
    MSB$12 = 128;
    REST$12 = 127;
    N12 = Math.pow(2, 7);
    N22 = Math.pow(2, 14);
    N32 = Math.pow(2, 21);
    N42 = Math.pow(2, 28);
    N52 = Math.pow(2, 35);
    N62 = Math.pow(2, 42);
    N72 = Math.pow(2, 49);
    N82 = Math.pow(2, 56);
    N92 = Math.pow(2, 63);
    length2 = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
    varint2 = {
      encode: encode_12,
      decode: decode15,
      encodingLength: length2
    };
    _brrp_varint2 = varint2;
    varint_default2 = _brrp_varint2;
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/varint.js
function decode16(data, offset2 = 0) {
  const code25 = varint_default2.decode(data, offset2);
  return [code25, varint_default2.decode.bytes];
}
function encodeTo2(int, target, offset2 = 0) {
  varint_default2.encode(int, target, offset2);
  return target;
}
function encodingLength2(int) {
  return varint_default2.encodingLength(int);
}
var init_varint4 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/varint.js"() {
    init_varint3();
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/hashes/digest.js
function create3(code25, digest6) {
  const size5 = digest6.byteLength;
  const sizeOffset = encodingLength2(code25);
  const digestOffset = sizeOffset + encodingLength2(size5);
  const bytes2 = new Uint8Array(digestOffset + size5);
  encodeTo2(code25, bytes2, 0);
  encodeTo2(size5, bytes2, sizeOffset);
  bytes2.set(digest6, digestOffset);
  return new Digest3(code25, size5, digest6, bytes2);
}
function decode17(multihash) {
  const bytes2 = coerce3(multihash);
  const [code25, sizeOffset] = decode16(bytes2);
  const [size5, digestOffset] = decode16(bytes2.subarray(sizeOffset));
  const digest6 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest6.byteLength !== size5) {
    throw new Error("Incorrect length");
  }
  return new Digest3(code25, size5, digest6, bytes2);
}
function equals5(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals4(a.bytes, data.bytes);
  }
}
var Digest3;
var init_digest3 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/hashes/digest.js"() {
    init_bytes5();
    init_varint4();
    Digest3 = class {
      code;
      size;
      digest;
      bytes;
      /**
       * Creates a multihash digest.
       */
      constructor(code25, size5, digest6, bytes2) {
        this.code = code25;
        this.size = size5;
        this.digest = digest6;
        this.bytes = bytes2;
      }
    };
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/link/interface.js
var init_interface = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/link/interface.js"() {
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/cid.js
function format(link5, base6) {
  const { bytes: bytes2, version: version3 } = link5;
  switch (version3) {
    case 0:
      return toStringV02(bytes2, baseCache(link5), base6 ?? base58btc2.encoder);
    default:
      return toStringV12(bytes2, baseCache(link5), base6 ?? base322.encoder);
  }
}
function baseCache(cid) {
  const baseCache4 = cache.get(cid);
  if (baseCache4 == null) {
    const baseCache5 = /* @__PURE__ */ new Map();
    cache.set(cid, baseCache5);
    return baseCache5;
  }
  return baseCache4;
}
function parseCIDtoBytes2(source, base6) {
  switch (source[0]) {
    case "Q": {
      const decoder3 = base6 ?? base58btc2;
      return [
        base58btc2.prefix,
        decoder3.decode(`${base58btc2.prefix}${source}`)
      ];
    }
    case base58btc2.prefix: {
      const decoder3 = base6 ?? base58btc2;
      return [base58btc2.prefix, decoder3.decode(source)];
    }
    case base322.prefix: {
      const decoder3 = base6 ?? base322;
      return [base322.prefix, decoder3.decode(source)];
    }
    default: {
      if (base6 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base6.decode(source)];
    }
  }
}
function toStringV02(bytes2, cache5, base6) {
  const { prefix: prefix2 } = base6;
  if (prefix2 !== base58btc2.prefix) {
    throw Error(`Cannot string encode V0 in ${base6.name} encoding`);
  }
  const cid = cache5.get(prefix2);
  if (cid == null) {
    const cid2 = base6.encode(bytes2).slice(1);
    cache5.set(prefix2, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV12(bytes2, cache5, base6) {
  const { prefix: prefix2 } = base6;
  const cid = cache5.get(prefix2);
  if (cid == null) {
    const cid2 = base6.encode(bytes2);
    cache5.set(prefix2, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function encodeCID3(version3, code25, multihash) {
  const codeOffset = encodingLength2(version3);
  const hashOffset = codeOffset + encodingLength2(code25);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo2(version3, bytes2, 0);
  encodeTo2(code25, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
}
var cache, CID2, DAG_PB_CODE2, SHA_256_CODE2, cidSymbol2;
var init_cid2 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/cid.js"() {
    init_base322();
    init_base582();
    init_bytes5();
    init_digest3();
    init_varint4();
    init_interface();
    cache = /* @__PURE__ */ new WeakMap();
    CID2 = class _CID {
      code;
      version;
      multihash;
      bytes;
      "/";
      /**
       * @param version - Version of the CID
       * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param multihash - (Multi)hash of the of the content.
       */
      constructor(version3, code25, multihash, bytes2) {
        this.code = code25;
        this.version = version3;
        this.multihash = multihash;
        this.bytes = bytes2;
        this["/"] = bytes2;
      }
      /**
       * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
       * please either use `CID.asCID(cid)` or switch to new signalling mechanism
       *
       * @deprecated
       */
      get asCID() {
        return this;
      }
      // ArrayBufferView
      get byteOffset() {
        return this.bytes.byteOffset;
      }
      // ArrayBufferView
      get byteLength() {
        return this.bytes.byteLength;
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          case 1: {
            const { code: code25, multihash } = this;
            if (code25 !== DAG_PB_CODE2) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE2) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return _CID.createV0(multihash);
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code25, digest: digest6 } = this.multihash;
            const multihash = create3(code25, digest6);
            return _CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return _CID.equals(this, other);
      }
      static equals(self2, other) {
        const unknown2 = other;
        return unknown2 != null && self2.code === unknown2.code && self2.version === unknown2.version && equals5(self2.multihash, unknown2.multihash);
      }
      toString(base6) {
        return format(this, base6);
      }
      toJSON() {
        return { "/": format(this) };
      }
      link() {
        return this;
      }
      [Symbol.toStringTag] = "CID";
      // Legacy
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return `CID(${this.toString()})`;
      }
      /**
       * Takes any input `value` and returns a `CID` instance if it was
       * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
       * it will return value back. If `value` is not instance of this CID
       * class, but is compatible CID it will return new instance of this
       * `CID` class. Otherwise returns null.
       *
       * This allows two different incompatible versions of CID library to
       * co-exist and interop as long as binary interface is compatible.
       */
      static asCID(input10) {
        if (input10 == null) {
          return null;
        }
        const value = input10;
        if (value instanceof _CID) {
          return value;
        } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
          const { version: version3, code: code25, multihash, bytes: bytes2 } = value;
          return new _CID(version3, code25, multihash, bytes2 ?? encodeCID3(version3, code25, multihash.bytes));
        } else if (value[cidSymbol2] === true) {
          const { version: version3, multihash, code: code25 } = value;
          const digest6 = decode17(multihash);
          return _CID.create(version3, code25, digest6);
        } else {
          return null;
        }
      }
      /**
       * @param version - Version of the CID
       * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param digest - (Multi)hash of the of the content.
       */
      static create(version3, code25, digest6) {
        if (typeof code25 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        if (!(digest6.bytes instanceof Uint8Array)) {
          throw new Error("Invalid digest");
        }
        switch (version3) {
          case 0: {
            if (code25 !== DAG_PB_CODE2) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`);
            } else {
              return new _CID(version3, code25, digest6, digest6.bytes);
            }
          }
          case 1: {
            const bytes2 = encodeCID3(version3, code25, digest6.bytes);
            return new _CID(version3, code25, digest6, bytes2);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      /**
       * Simplified version of `create` for CIDv0.
       */
      static createV0(digest6) {
        return _CID.create(0, DAG_PB_CODE2, digest6);
      }
      /**
       * Simplified version of `create` for CIDv1.
       *
       * @param code - Content encoding format code.
       * @param digest - Multihash of the content.
       */
      static createV1(code25, digest6) {
        return _CID.create(1, code25, digest6);
      }
      /**
       * Decoded a CID from its binary representation. The byte array must contain
       * only the CID with no additional bytes.
       *
       * An error will be thrown if the bytes provided do not contain a valid
       * binary representation of a CID.
       */
      static decode(bytes2) {
        const [cid, remainder] = _CID.decodeFirst(bytes2);
        if (remainder.length !== 0) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      /**
       * Decoded a CID from its binary representation at the beginning of a byte
       * array.
       *
       * Returns an array with the first element containing the CID and the second
       * element containing the remainder of the original byte array. The remainder
       * will be a zero-length byte array if the provided bytes only contained a
       * binary CID representation.
       */
      static decodeFirst(bytes2) {
        const specs = _CID.inspectBytes(bytes2);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce3(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest6 = new Digest3(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? _CID.createV0(digest6) : _CID.createV1(specs.codec, digest6);
        return [cid, bytes2.subarray(specs.size)];
      }
      /**
       * Inspect the initial bytes of a CID to determine its properties.
       *
       * Involves decoding up to 4 varints. Typically this will require only 4 to 6
       * bytes but for larger multicodec code values and larger multihash digest
       * lengths these varints can be quite large. It is recommended that at least
       * 10 bytes be made available in the `initialBytes` argument for a complete
       * inspection.
       */
      static inspectBytes(initialBytes) {
        let offset2 = 0;
        const next = () => {
          const [i, length5] = decode16(initialBytes.subarray(offset2));
          offset2 += length5;
          return i;
        };
        let version3 = next();
        let codec = DAG_PB_CODE2;
        if (version3 === 18) {
          version3 = 0;
          offset2 = 0;
        } else {
          codec = next();
        }
        if (version3 !== 0 && version3 !== 1) {
          throw new RangeError(`Invalid CID version ${version3}`);
        }
        const prefixSize = offset2;
        const multihashCode = next();
        const digestSize = next();
        const size5 = offset2 + digestSize;
        const multihashSize = size5 - prefixSize;
        return { version: version3, codec, multihashCode, digestSize, multihashSize, size: size5 };
      }
      /**
       * Takes cid in a string representation and creates an instance. If `base`
       * decoder is not provided will use a default from the configuration. It will
       * throw an error if encoding of the CID is not compatible with supplied (or
       * a default decoder).
       */
      static parse(source, base6) {
        const [prefix2, bytes2] = parseCIDtoBytes2(source, base6);
        const cid = _CID.decode(bytes2);
        if (cid.version === 0 && source[0] !== "Q") {
          throw Error("Version 0 CID string must not include multibase prefix");
        }
        baseCache(cid).set(prefix2, source);
        return cid;
      }
    };
    DAG_PB_CODE2 = 112;
    SHA_256_CODE2 = 18;
    cidSymbol2 = Symbol.for("@ipld/js-cid/CID");
  }
});

// ../../node_modules/.pnpm/@ipld+dag-cbor@9.2.1/node_modules/@ipld/dag-cbor/src/index.js
function toByteView(buf3) {
  if (buf3 instanceof ArrayBuffer) {
    return new Uint8Array(buf3, 0, buf3.byteLength);
  }
  return buf3;
}
function cidEncoder3(obj) {
  if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
    return null;
  }
  const cid = CID2.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token2(Type2.tag, CID_CBOR_TAG2),
    new Token2(Type2.bytes, bytes2)
  ];
}
function undefinedEncoder3() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder3(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
function cidDecoder2(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID2.decode(bytes2.subarray(1));
}
var CID_CBOR_TAG2, _encodeOptions, encodeOptions3, _decodeOptions, decodeOptions3, name8, code9, encode15, decode18;
var init_src5 = __esm({
  "../../node_modules/.pnpm/@ipld+dag-cbor@9.2.1/node_modules/@ipld/dag-cbor/src/index.js"() {
    init_cborg2();
    init_cid2();
    CID_CBOR_TAG2 = 42;
    _encodeOptions = {
      float64: true,
      typeEncoders: {
        Object: cidEncoder3,
        undefined: undefinedEncoder3,
        number: numberEncoder3
      }
    };
    encodeOptions3 = {
      ..._encodeOptions,
      typeEncoders: {
        ..._encodeOptions.typeEncoders
      }
    };
    _decodeOptions = {
      allowIndefinite: false,
      coerceUndefinedToNull: true,
      allowNaN: false,
      allowInfinity: false,
      allowBigInt: true,
      // this will lead to BigInt for ints outside of
      // safe-integer range, which may surprise users
      strict: true,
      useMaps: false,
      rejectDuplicateMapKeys: true,
      /** @type {import('cborg').TagDecoder[]} */
      tags: []
    };
    _decodeOptions.tags[CID_CBOR_TAG2] = cidDecoder2;
    decodeOptions3 = {
      ..._decodeOptions,
      tags: _decodeOptions.tags.slice()
    };
    name8 = "dag-cbor";
    code9 = 113;
    encode15 = (node) => encode12(node, _encodeOptions);
    decode18 = (data) => decode13(toByteView(data), _decodeOptions);
  }
});

// ../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/ipld/cbor.js
var init_cbor = __esm({
  "../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/ipld/cbor.js"() {
    init_api();
    init_src5();
  }
});

// ../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/link/interface.js
var init_interface2 = __esm({
  "../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/link/interface.js"() {
  }
});

// ../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/vendor/varint.js
function encode16(num, out, offset2) {
  out = out || [];
  offset2 = offset2 || 0;
  var oldOffset = offset2;
  while (num >= INT3) {
    out[offset2++] = num & 255 | MSB3;
    num /= 128;
  }
  while (num & MSBALL3) {
    out[offset2++] = num & 255 | MSB3;
    num >>>= 7;
  }
  out[offset2] = num | 0;
  encode16.bytes = offset2 - oldOffset + 1;
  return out;
}
function read3(buf3, offset2) {
  var res = 0, offset2 = offset2 || 0, shift = 0, counter = offset2, b, l = buf3.length;
  do {
    if (counter >= l) {
      read3.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$13) << shift : (b & REST$13) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$13);
  read3.bytes = counter - offset2;
  return res;
}
var encode_13, MSB3, REST3, MSBALL3, INT3, decode19, MSB$13, REST$13, N13, N23, N33, N43, N53, N63, N73, N83, N93, length3, varint3, _brrp_varint3, varint_default3;
var init_varint5 = __esm({
  "../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/vendor/varint.js"() {
    encode_13 = encode16;
    MSB3 = 128;
    REST3 = 127;
    MSBALL3 = ~REST3;
    INT3 = Math.pow(2, 31);
    decode19 = read3;
    MSB$13 = 128;
    REST$13 = 127;
    N13 = Math.pow(2, 7);
    N23 = Math.pow(2, 14);
    N33 = Math.pow(2, 21);
    N43 = Math.pow(2, 28);
    N53 = Math.pow(2, 35);
    N63 = Math.pow(2, 42);
    N73 = Math.pow(2, 49);
    N83 = Math.pow(2, 56);
    N93 = Math.pow(2, 63);
    length3 = function(value) {
      return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N53 ? 5 : value < N63 ? 6 : value < N73 ? 7 : value < N83 ? 8 : value < N93 ? 9 : 10;
    };
    varint3 = {
      encode: encode_13,
      decode: decode19,
      encodingLength: length3
    };
    _brrp_varint3 = varint3;
    varint_default3 = _brrp_varint3;
  }
});

// ../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/varint.js
var varint_exports3 = {};
__export(varint_exports3, {
  decode: () => decode20,
  encodeTo: () => encodeTo3,
  encodingLength: () => encodingLength3
});
var decode20, encodeTo3, encodingLength3;
var init_varint6 = __esm({
  "../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/varint.js"() {
    init_varint5();
    decode20 = (data, offset2 = 0) => {
      const code25 = varint_default3.decode(data, offset2);
      return [code25, varint_default3.decode.bytes];
    };
    encodeTo3 = (int, target, offset2 = 0) => {
      varint_default3.encode(int, target, offset2);
      return target;
    };
    encodingLength3 = (int) => {
      return varint_default3.encodingLength(int);
    };
  }
});

// ../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/digest.js
var create4, decode21, equals6, Digest4;
var init_digest4 = __esm({
  "../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/digest.js"() {
    init_bytes3();
    init_varint6();
    create4 = (code25, digest6) => {
      const size5 = digest6.byteLength;
      const sizeOffset = encodingLength3(code25);
      const digestOffset = sizeOffset + encodingLength3(size5);
      const bytes2 = new Uint8Array(digestOffset + size5);
      encodeTo3(code25, bytes2, 0);
      encodeTo3(size5, bytes2, sizeOffset);
      bytes2.set(digest6, digestOffset);
      return new Digest4(code25, size5, digest6, bytes2);
    };
    decode21 = (multihash) => {
      const bytes2 = coerce2(multihash);
      const [code25, sizeOffset] = decode20(bytes2);
      const [size5, digestOffset] = decode20(bytes2.subarray(sizeOffset));
      const digest6 = bytes2.subarray(sizeOffset + digestOffset);
      if (digest6.byteLength !== size5) {
        throw new Error("Incorrect length");
      }
      return new Digest4(code25, size5, digest6, bytes2);
    };
    equals6 = (a, b) => {
      if (a === b) {
        return true;
      } else {
        const data = (
          /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
          b
        );
        return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals3(a.bytes, data.bytes);
      }
    };
    Digest4 = class {
      /**
       * Creates a multihash digest.
       *
       * @param {Code} code
       * @param {Size} size
       * @param {Uint8Array} digest
       * @param {Uint8Array} bytes
       */
      constructor(code25, size5, digest6, bytes2) {
        this.code = code25;
        this.size = size5;
        this.digest = digest6;
        this.bytes = bytes2;
      }
    };
  }
});

// ../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/vendor/base-x.js
function base4(ALPHABET, name20) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode45(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length5 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size5 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size5);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size5 - 1; (carry !== 0 || i2 < length5) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i2;
      pbegin++;
    }
    var it2 = size5 - length5;
    while (it2 !== size5 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size5; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length5 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size5 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size5);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size5 - 1; (carry !== 0 || i2 < length5) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size5 - length5;
    while (it4 !== size5 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size5 - it4));
    var j2 = zeroes;
    while (it4 !== size5) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode53(string4) {
    var buffer3 = decodeUnsafe(string4);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name20} character`);
  }
  return {
    encode: encode45,
    decodeUnsafe,
    decode: decode53
  };
}
var src3, _brrp__multiformats_scope_baseX3, base_x_default3;
var init_base_x3 = __esm({
  "../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/vendor/base-x.js"() {
    src3 = base4;
    _brrp__multiformats_scope_baseX3 = src3;
    base_x_default3 = _brrp__multiformats_scope_baseX3;
  }
});

// ../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base.js
var Encoder3, Decoder3, ComposedDecoder3, or3, Codec3, from5, baseX3, decode22, encode17, rfc46483;
var init_base4 = __esm({
  "../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base.js"() {
    init_base_x3();
    init_bytes3();
    Encoder3 = class {
      /**
       * @param {Base} name
       * @param {Prefix} prefix
       * @param {(bytes:Uint8Array) => string} baseEncode
       */
      constructor(name20, prefix2, baseEncode) {
        this.name = name20;
        this.prefix = prefix2;
        this.baseEncode = baseEncode;
      }
      /**
       * @param {Uint8Array} bytes
       * @returns {API.Multibase<Prefix>}
       */
      encode(bytes2) {
        if (bytes2 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes2)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder3 = class {
      /**
       * @param {Base} name
       * @param {Prefix} prefix
       * @param {(text:string) => Uint8Array} baseDecode
       */
      constructor(name20, prefix2, baseDecode) {
        this.name = name20;
        this.prefix = prefix2;
        if (prefix2.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = /** @type {number} */
        prefix2.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      /**
       * @param {string} text
       */
      decode(text2) {
        if (typeof text2 === "string") {
          if (text2.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text2.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      /**
       * @template {string} OtherPrefix
       * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
       * @returns {ComposedDecoder<Prefix|OtherPrefix>}
       */
      or(decoder3) {
        return or3(this, decoder3);
      }
    };
    ComposedDecoder3 = class {
      /**
       * @param {Decoders<Prefix>} decoders
       */
      constructor(decoders) {
        this.decoders = decoders;
      }
      /**
       * @template {string} OtherPrefix
       * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
       * @returns {ComposedDecoder<Prefix|OtherPrefix>}
       */
      or(decoder3) {
        return or3(this, decoder3);
      }
      /**
       * @param {string} input
       * @returns {Uint8Array}
       */
      decode(input10) {
        const prefix2 = (
          /** @type {Prefix} */
          input10[0]
        );
        const decoder3 = this.decoders[prefix2];
        if (decoder3) {
          return decoder3.decode(input10);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input10)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    or3 = (left, right) => new ComposedDecoder3(
      /** @type {Decoders<L|R>} */
      {
        ...left.decoders || { [
          /** @type API.UnibaseDecoder<L> */
          left.prefix
        ]: left },
        ...right.decoders || { [
          /** @type API.UnibaseDecoder<R> */
          right.prefix
        ]: right }
      }
    );
    Codec3 = class {
      /**
       * @param {Base} name
       * @param {Prefix} prefix
       * @param {(bytes:Uint8Array) => string} baseEncode
       * @param {(text:string) => Uint8Array} baseDecode
       */
      constructor(name20, prefix2, baseEncode, baseDecode) {
        this.name = name20;
        this.prefix = prefix2;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder3(name20, prefix2, baseEncode);
        this.decoder = new Decoder3(name20, prefix2, baseDecode);
      }
      /**
       * @param {Uint8Array} input
       */
      encode(input10) {
        return this.encoder.encode(input10);
      }
      /**
       * @param {string} input
       */
      decode(input10) {
        return this.decoder.decode(input10);
      }
    };
    from5 = ({ name: name20, prefix: prefix2, encode: encode45, decode: decode53 }) => new Codec3(name20, prefix2, encode45, decode53);
    baseX3 = ({ prefix: prefix2, name: name20, alphabet: alphabet3 }) => {
      const { encode: encode45, decode: decode53 } = base_x_default3(alphabet3, name20);
      return from5({
        prefix: prefix2,
        name: name20,
        encode: encode45,
        /**
         * @param {string} text
         */
        decode: (text2) => coerce2(decode53(text2))
      });
    };
    decode22 = (string4, alphabet3, bitsPerChar, name20) => {
      const codes = {};
      for (let i = 0; i < alphabet3.length; ++i) {
        codes[alphabet3[i]] = i;
      }
      let end = string4.length;
      while (string4[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer3 = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string4[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name20} character`);
        }
        buffer3 = buffer3 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer3 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer3 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    encode17 = (data, alphabet3, bitsPerChar) => {
      const pad2 = alphabet3[alphabet3.length - 1] === "=";
      const mask2 = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer3 = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer3 = buffer3 << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet3[mask2 & buffer3 >> bits];
        }
      }
      if (bits) {
        out += alphabet3[mask2 & buffer3 << bitsPerChar - bits];
      }
      if (pad2) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    rfc46483 = ({ name: name20, prefix: prefix2, bitsPerChar, alphabet: alphabet3 }) => {
      return from5({
        prefix: prefix2,
        name: name20,
        encode(input10) {
          return encode17(input10, alphabet3, bitsPerChar);
        },
        decode(input10) {
          return decode22(input10, alphabet3, bitsPerChar, name20);
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base58.js
var base58btc3, base58flickr3;
var init_base583 = __esm({
  "../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base58.js"() {
    init_base4();
    base58btc3 = baseX3({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr3 = baseX3({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});

// ../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base32.js
var base323, base32upper3, base32pad3, base32padupper3, base32hex3, base32hexupper3, base32hexpad3, base32hexpadupper3, base32z3;
var init_base323 = __esm({
  "../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base32.js"() {
    init_base4();
    base323 = rfc46483({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper3 = rfc46483({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad3 = rfc46483({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper3 = rfc46483({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex3 = rfc46483({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper3 = rfc46483({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad3 = rfc46483({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper3 = rfc46483({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z3 = rfc46483({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});

// ../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/cid.js
var format2, cache2, baseCache2, CID3, parseCIDtoBytes3, toStringV03, toStringV13, DAG_PB_CODE3, SHA_256_CODE3, encodeCID4, cidSymbol3;
var init_cid3 = __esm({
  "../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/cid.js"() {
    init_varint6();
    init_digest4();
    init_base583();
    init_base323();
    init_bytes3();
    init_interface2();
    format2 = (link5, base6) => {
      const { bytes: bytes2, version: version3 } = link5;
      switch (version3) {
        case 0:
          return toStringV03(
            bytes2,
            baseCache2(link5),
            /** @type {API.MultibaseEncoder<"z">} */
            base6 || base58btc3.encoder
          );
        default:
          return toStringV13(
            bytes2,
            baseCache2(link5),
            /** @type {API.MultibaseEncoder<Prefix>} */
            base6 || base323.encoder
          );
      }
    };
    cache2 = /* @__PURE__ */ new WeakMap();
    baseCache2 = (cid) => {
      const baseCache4 = cache2.get(cid);
      if (baseCache4 == null) {
        const baseCache5 = /* @__PURE__ */ new Map();
        cache2.set(cid, baseCache5);
        return baseCache5;
      }
      return baseCache4;
    };
    CID3 = class _CID {
      /**
       * @param {Version} version - Version of the CID
       * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
       * @param {Uint8Array} bytes
       *
       */
      constructor(version3, code25, multihash, bytes2) {
        this.code = code25;
        this.version = version3;
        this.multihash = multihash;
        this.bytes = bytes2;
        this["/"] = bytes2;
      }
      /**
       * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
       * please either use `CID.asCID(cid)` or switch to new signalling mechanism
       *
       * @deprecated
       */
      get asCID() {
        return this;
      }
      // ArrayBufferView
      get byteOffset() {
        return this.bytes.byteOffset;
      }
      // ArrayBufferView
      get byteLength() {
        return this.bytes.byteLength;
      }
      /**
       * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
       */
      toV0() {
        switch (this.version) {
          case 0: {
            return (
              /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
              this
            );
          }
          case 1: {
            const { code: code25, multihash } = this;
            if (code25 !== DAG_PB_CODE3) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE3) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return (
              /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
              _CID.createV0(
                /** @type {API.MultihashDigest<API.SHA_256>} */
                multihash
              )
            );
          }
          default: {
            throw Error(
              `Can not convert CID version ${this.version} to version 0. This is a bug please report`
            );
          }
        }
      }
      /**
       * @returns {CID<Data, Format, Alg, 1>}
       */
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code25, digest: digest6 } = this.multihash;
            const multihash = create4(code25, digest6);
            return (
              /** @type {CID<Data, Format, Alg, 1>} */
              _CID.createV1(this.code, multihash)
            );
          }
          case 1: {
            return (
              /** @type {CID<Data, Format, Alg, 1>} */
              this
            );
          }
          default: {
            throw Error(
              `Can not convert CID version ${this.version} to version 1. This is a bug please report`
            );
          }
        }
      }
      /**
       * @param {unknown} other
       * @returns {other is CID<Data, Format, Alg, Version>}
       */
      equals(other) {
        return _CID.equals(this, other);
      }
      /**
       * @template {unknown} Data
       * @template {number} Format
       * @template {number} Alg
       * @template {API.Version} Version
       * @param {API.Link<Data, Format, Alg, Version>} self
       * @param {unknown} other
       * @returns {other is CID}
       */
      static equals(self2, other) {
        const unknown2 = (
          /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
          other
        );
        return unknown2 && self2.code === unknown2.code && self2.version === unknown2.version && equals6(self2.multihash, unknown2.multihash);
      }
      /**
       * @param {API.MultibaseEncoder<string>} [base]
       * @returns {string}
       */
      toString(base6) {
        return format2(this, base6);
      }
      toJSON() {
        return { "/": format2(this) };
      }
      link() {
        return this;
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      // Legacy
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return `CID(${this.toString()})`;
      }
      /**
       * Takes any input `value` and returns a `CID` instance if it was
       * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
       * it will return value back. If `value` is not instance of this CID
       * class, but is compatible CID it will return new instance of this
       * `CID` class. Otherwise returns null.
       *
       * This allows two different incompatible versions of CID library to
       * co-exist and interop as long as binary interface is compatible.
       *
       * @template {unknown} Data
       * @template {number} Format
       * @template {number} Alg
       * @template {API.Version} Version
       * @template {unknown} U
       * @param {API.Link<Data, Format, Alg, Version>|U} input
       * @returns {CID<Data, Format, Alg, Version>|null}
       */
      static asCID(input10) {
        if (input10 == null) {
          return null;
        }
        const value = (
          /** @type {any} */
          input10
        );
        if (value instanceof _CID) {
          return value;
        } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
          const { version: version3, code: code25, multihash, bytes: bytes2 } = value;
          return new _CID(
            version3,
            code25,
            /** @type {API.MultihashDigest<Alg>} */
            multihash,
            bytes2 || encodeCID4(version3, code25, multihash.bytes)
          );
        } else if (value[cidSymbol3] === true) {
          const { version: version3, multihash, code: code25 } = value;
          const digest6 = (
            /** @type {API.MultihashDigest<Alg>} */
            decode21(multihash)
          );
          return _CID.create(version3, code25, digest6);
        } else {
          return null;
        }
      }
      /**
       *
       * @template {unknown} Data
       * @template {number} Format
       * @template {number} Alg
       * @template {API.Version} Version
       * @param {Version} version - Version of the CID
       * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
       * @returns {CID<Data, Format, Alg, Version>}
       */
      static create(version3, code25, digest6) {
        if (typeof code25 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        if (!(digest6.bytes instanceof Uint8Array)) {
          throw new Error("Invalid digest");
        }
        switch (version3) {
          case 0: {
            if (code25 !== DAG_PB_CODE3) {
              throw new Error(
                `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE3}) block encoding`
              );
            } else {
              return new _CID(version3, code25, digest6, digest6.bytes);
            }
          }
          case 1: {
            const bytes2 = encodeCID4(version3, code25, digest6.bytes);
            return new _CID(version3, code25, digest6, bytes2);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      /**
       * Simplified version of `create` for CIDv0.
       *
       * @template {unknown} [T=unknown]
       * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
       * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
       */
      static createV0(digest6) {
        return _CID.create(0, DAG_PB_CODE3, digest6);
      }
      /**
       * Simplified version of `create` for CIDv1.
       *
       * @template {unknown} Data
       * @template {number} Code
       * @template {number} Alg
       * @param {Code} code - Content encoding format code.
       * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
       * @returns {CID<Data, Code, Alg, 1>}
       */
      static createV1(code25, digest6) {
        return _CID.create(1, code25, digest6);
      }
      /**
       * Decoded a CID from its binary representation. The byte array must contain
       * only the CID with no additional bytes.
       *
       * An error will be thrown if the bytes provided do not contain a valid
       * binary representation of a CID.
       *
       * @template {unknown} Data
       * @template {number} Code
       * @template {number} Alg
       * @template {API.Version} Ver
       * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
       * @returns {CID<Data, Code, Alg, Ver>}
       */
      static decode(bytes2) {
        const [cid, remainder] = _CID.decodeFirst(bytes2);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      /**
       * Decoded a CID from its binary representation at the beginning of a byte
       * array.
       *
       * Returns an array with the first element containing the CID and the second
       * element containing the remainder of the original byte array. The remainder
       * will be a zero-length byte array if the provided bytes only contained a
       * binary CID representation.
       *
       * @template {unknown} T
       * @template {number} C
       * @template {number} A
       * @template {API.Version} V
       * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
       * @returns {[CID<T, C, A, V>, Uint8Array]}
       */
      static decodeFirst(bytes2) {
        const specs = _CID.inspectBytes(bytes2);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce2(
          bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
        );
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(
          specs.multihashSize - specs.digestSize
        );
        const digest6 = new Digest4(
          specs.multihashCode,
          specs.digestSize,
          digestBytes,
          multihashBytes
        );
        const cid = specs.version === 0 ? _CID.createV0(
          /** @type {API.MultihashDigest<API.SHA_256>} */
          digest6
        ) : _CID.createV1(specs.codec, digest6);
        return [
          /** @type {CID<T, C, A, V>} */
          cid,
          bytes2.subarray(specs.size)
        ];
      }
      /**
       * Inspect the initial bytes of a CID to determine its properties.
       *
       * Involves decoding up to 4 varints. Typically this will require only 4 to 6
       * bytes but for larger multicodec code values and larger multihash digest
       * lengths these varints can be quite large. It is recommended that at least
       * 10 bytes be made available in the `initialBytes` argument for a complete
       * inspection.
       *
       * @template {unknown} T
       * @template {number} C
       * @template {number} A
       * @template {API.Version} V
       * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
       * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
       */
      static inspectBytes(initialBytes) {
        let offset2 = 0;
        const next = () => {
          const [i, length5] = decode20(initialBytes.subarray(offset2));
          offset2 += length5;
          return i;
        };
        let version3 = (
          /** @type {V} */
          next()
        );
        let codec = (
          /** @type {C} */
          DAG_PB_CODE3
        );
        if (
          /** @type {number} */
          version3 === 18
        ) {
          version3 = /** @type {V} */
          0;
          offset2 = 0;
        } else {
          codec = /** @type {C} */
          next();
        }
        if (version3 !== 0 && version3 !== 1) {
          throw new RangeError(`Invalid CID version ${version3}`);
        }
        const prefixSize = offset2;
        const multihashCode = (
          /** @type {A} */
          next()
        );
        const digestSize = next();
        const size5 = offset2 + digestSize;
        const multihashSize = size5 - prefixSize;
        return { version: version3, codec, multihashCode, digestSize, multihashSize, size: size5 };
      }
      /**
       * Takes cid in a string representation and creates an instance. If `base`
       * decoder is not provided will use a default from the configuration. It will
       * throw an error if encoding of the CID is not compatible with supplied (or
       * a default decoder).
       *
       * @template {string} Prefix
       * @template {unknown} Data
       * @template {number} Code
       * @template {number} Alg
       * @template {API.Version} Ver
       * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
       * @param {API.MultibaseDecoder<Prefix>} [base]
       * @returns {CID<Data, Code, Alg, Ver>}
       */
      static parse(source, base6) {
        const [prefix2, bytes2] = parseCIDtoBytes3(source, base6);
        const cid = _CID.decode(bytes2);
        if (cid.version === 0 && source[0] !== "Q") {
          throw Error("Version 0 CID string must not include multibase prefix");
        }
        baseCache2(cid).set(prefix2, source);
        return cid;
      }
    };
    parseCIDtoBytes3 = (source, base6) => {
      switch (source[0]) {
        case "Q": {
          const decoder3 = base6 || base58btc3;
          return [
            /** @type {Prefix} */
            base58btc3.prefix,
            decoder3.decode(`${base58btc3.prefix}${source}`)
          ];
        }
        case base58btc3.prefix: {
          const decoder3 = base6 || base58btc3;
          return [
            /** @type {Prefix} */
            base58btc3.prefix,
            decoder3.decode(source)
          ];
        }
        case base323.prefix: {
          const decoder3 = base6 || base323;
          return [
            /** @type {Prefix} */
            base323.prefix,
            decoder3.decode(source)
          ];
        }
        default: {
          if (base6 == null) {
            throw Error(
              "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
            );
          }
          return [
            /** @type {Prefix} */
            source[0],
            base6.decode(source)
          ];
        }
      }
    };
    toStringV03 = (bytes2, cache5, base6) => {
      const { prefix: prefix2 } = base6;
      if (prefix2 !== base58btc3.prefix) {
        throw Error(`Cannot string encode V0 in ${base6.name} encoding`);
      }
      const cid = cache5.get(prefix2);
      if (cid == null) {
        const cid2 = base6.encode(bytes2).slice(1);
        cache5.set(prefix2, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    toStringV13 = (bytes2, cache5, base6) => {
      const { prefix: prefix2 } = base6;
      const cid = cache5.get(prefix2);
      if (cid == null) {
        const cid2 = base6.encode(bytes2);
        cache5.set(prefix2, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    DAG_PB_CODE3 = 112;
    SHA_256_CODE3 = 18;
    encodeCID4 = (version3, code25, multihash) => {
      const codeOffset = encodingLength3(version3);
      const hashOffset = codeOffset + encodingLength3(code25);
      const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo3(version3, bytes2, 0);
      encodeTo3(code25, bytes2, codeOffset);
      bytes2.set(multihash, hashOffset);
      return bytes2;
    };
    cidSymbol3 = Symbol.for("@ipld/js-cid/CID");
  }
});

// ../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/link.js
var DAG_PB_CODE4, createLegacy, create5, isLink, parse2;
var init_link = __esm({
  "../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/link.js"() {
    init_cid3();
    init_interface2();
    DAG_PB_CODE4 = 112;
    createLegacy = (digest6) => CID3.create(0, DAG_PB_CODE4, digest6);
    create5 = (code25, digest6) => CID3.create(1, code25, digest6);
    isLink = (value) => {
      if (value == null) {
        return false;
      }
      const withSlash = (
        /** @type {{'/'?: Uint8Array, bytes: Uint8Array}} */
        value
      );
      if (withSlash["/"] != null && withSlash["/"] === withSlash.bytes) {
        return true;
      }
      const withAsCID = (
        /** @type {{'asCID'?: unknown}} */
        value
      );
      if (withAsCID.asCID === value) {
        return true;
      }
      return false;
    };
    parse2 = (source, base6) => CID3.parse(source, base6);
  }
});

// ../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/ipld.js
var init_ipld = __esm({
  "../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/ipld.js"() {
    init_api();
    init_sha256();
    init_cbor();
    init_link();
  }
});

// ../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/proof.js
function truncatedHash(payload) {
  const { digest: digest6 } = sha256_exports.digest(payload);
  return truncate(digest6);
}
function truncate(node) {
  node[NODE_SIZE - 1] &= 63;
  return node;
}
var computeNode;
var init_proof = __esm({
  "../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/proof.js"() {
    init_api();
    init_bytes3();
    init_node();
    init_ipld();
    computeNode = (left, right) => {
      const payload = new Uint8Array(left.length + right.length);
      payload.set(left, 0);
      payload.set(right, left.length);
      return truncatedHash(payload);
    };
  }
});

// ../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/zero-comm.js
var MAX_LEVEL, ZeroComm, ZERO_COMM, fromLevel;
var init_zero_comm = __esm({
  "../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/zero-comm.js"() {
    init_api();
    init_node();
    init_proof();
    MAX_LEVEL = 64;
    ZeroComm = class {
      constructor() {
        this.bytes = new Uint8Array(MAX_LEVEL * NODE_SIZE);
        this.bytes.set(empty2(), 0);
        this.node = empty2();
        this.length = NODE_SIZE;
      }
      /**
       * @param {number} start
       * @param {number} end
       */
      slice(start, end) {
        while (this.length < end) {
          this.node = computeNode(this.node, this.node);
          this.bytes.set(this.node, this.length);
          this.length += NODE_SIZE;
        }
        return this.bytes.subarray(start, end);
      }
    };
    ZERO_COMM = new ZeroComm();
    fromLevel = (level) => {
      if (level < 0 || level >= MAX_LEVEL) {
        throw new Error(
          `Only levels between 0 and ${MAX_LEVEL - 1} inclusive are available`
        );
      }
      return ZERO_COMM.slice(NODE_SIZE * level, NODE_SIZE * (level + 1));
    };
  }
});

// ../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/piece/tree.js
var MAX_LEAF_COUNT, split;
var init_tree = __esm({
  "../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/piece/tree.js"() {
    init_api();
    init_node();
    init_proof();
    init_proof();
    MAX_LEAF_COUNT = 2 ** 32 - 1;
    split = (source) => {
      const count = source.length / NODE_SIZE;
      const chunks = new Array(count);
      for (let n = 0; n < count; n++) {
        const offset2 = n * NODE_SIZE;
        const chunk = source.subarray(offset2, offset2 + NODE_SIZE);
        chunks[n] = chunk;
      }
      return chunks;
    };
  }
});

// ../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/fr32.js
function toZeroPaddedSize(payloadSize) {
  const size5 = Math.max(payloadSize, MIN_PAYLOAD_SIZE);
  const highestBit = Math.floor(Math.log2(size5));
  const bound = Math.ceil(FR_RATIO * 2 ** (highestBit + 1));
  return size5 <= bound ? bound : Math.ceil(FR_RATIO * 2 ** (highestBit + 2));
}
var toPieceSize, pad;
var init_fr32 = __esm({
  "../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/fr32.js"() {
    init_api();
    init_constant();
    toPieceSize = (size5) => toZeroPaddedSize(size5) / FR_RATIO;
    pad = (source, output = new Uint8Array(toPieceSize(source.length))) => {
      const size5 = toZeroPaddedSize(source.byteLength);
      const quadCount = size5 / IN_BYTES_PER_QUAD;
      for (let n = 0; n < quadCount; n++) {
        const readOffset = n * IN_BYTES_PER_QUAD;
        const writeOffset = n * OUT_BYTES_PER_QUAD;
        output.set(source.subarray(readOffset, readOffset + 32), writeOffset);
        output[writeOffset + 31] &= 63;
        for (let i = 32; i < 64; i++) {
          output[writeOffset + i] = source[readOffset + i] << 2 | source[readOffset + i - 1] >> 6;
        }
        output[writeOffset + 63] &= 63;
        for (let i = 64; i < 96; i++) {
          output[writeOffset + i] = source[readOffset + i] << 4 | source[readOffset + i - 1] >> 4;
        }
        output[writeOffset + 95] &= 63;
        for (let i = 96; i < 127; i++) {
          output[writeOffset + i] = source[readOffset + i] << 6 | source[readOffset + i - 1] >> 2;
        }
        output[writeOffset + 127] = source[readOffset + 126] >> 2;
      }
      return output;
    };
  }
});

// ../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/uint64.js
var log2Floor, log2Ceil;
var init_uint64 = __esm({
  "../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/uint64.js"() {
    init_api();
    log2Floor = (n) => {
      let result = 0n;
      while (n >>= 1n) result++;
      return Number(result);
    };
    log2Ceil = (n) => n <= 1n ? 0 : log2Floor(BigInt(n) - 1n) + 1;
  }
});

// ../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/piece/size/padded.js
var fromHeight;
var init_padded = __esm({
  "../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/piece/size/padded.js"() {
    init_api();
    init_uint64();
    init_constant();
    fromHeight = (height2) => {
      const quads = 2n ** BigInt(height2 - 2);
      return quads * PADDED_BYTES_PER_QUAD;
    };
  }
});

// ../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/piece/size/unpadded.js
var unpadded_exports = {};
__export(unpadded_exports, {
  fromPiece: () => fromPiece,
  toExpanded: () => toExpanded,
  toHeight: () => toHeight,
  toPadded: () => toPadded,
  toPadding: () => toPadding,
  toWidth: () => toWidth
});
var fromPiece, toPadding, toPadded, toExpanded, toWidth, toHeight, toQauds;
var init_unpadded = __esm({
  "../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/piece/size/unpadded.js"() {
    init_api();
    init_constant();
    init_uint64();
    init_padded();
    fromPiece = ({ height: height2, padding: padding2 }) => fromHeight(height2) - padding2;
    toPadding = (size5) => toPadded(size5) - size5;
    toPadded = (size5) => toQauds(size5) * PADDED_BYTES_PER_QUAD;
    toExpanded = (size5) => toQauds(size5) * EXPANDED_BYTES_PER_QUAD;
    toWidth = (size5) => toQauds(size5) * LEAFS_PER_QUAD;
    toHeight = (size5) => log2Ceil(toWidth(size5));
    toQauds = (size5) => {
      const quadCount = (size5 + PADDED_BYTES_PER_QUAD - 1n) / PADDED_BYTES_PER_QUAD;
      return 2n ** BigInt(log2Ceil(quadCount));
    };
  }
});

// ../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/piece/size/expanded.js
var fromHeight2, fromWidth;
var init_expanded = __esm({
  "../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/piece/size/expanded.js"() {
    init_api();
    init_constant();
    init_uint64();
    init_padded();
    init_unpadded();
    fromHeight2 = (height2) => fromWidth(2n ** BigInt(height2));
    fromWidth = (width) => width * EXPANDED_BYTES_PER_NODE;
  }
});

// ../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/piece/size.js
var init_size = __esm({
  "../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/piece/size.js"() {
    init_unpadded();
    init_padded();
    init_expanded();
    init_expanded();
  }
});

// ../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/hasher.js
var from6, Hasher2;
var init_hasher2 = __esm({
  "../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/hasher.js"() {
    init_digest4();
    from6 = ({ name: name20, code: code25, encode: encode45 }) => new Hasher2(name20, code25, encode45);
    Hasher2 = class {
      /**
       *
       * @param {Name} name
       * @param {Code} code
       * @param {(input: Uint8Array) => Await<Uint8Array>} encode
       */
      constructor(name20, code25, encode45) {
        this.name = name20;
        this.code = code25;
        this.encode = encode45;
      }
      /**
       * @param {Uint8Array} input
       * @returns {Await<Digest.Digest<Code, number>>}
       */
      digest(input10) {
        if (input10 instanceof Uint8Array) {
          const result = this.encode(input10);
          return result instanceof Uint8Array ? create4(this.code, result) : result.then((digest6) => create4(this.code, digest6));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/interface.js
var init_interface3 = __esm({
  "../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/interface.js"() {
  }
});

// ../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/index.js
var init_src6 = __esm({
  "../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/index.js"() {
    init_cid3();
    init_varint6();
    init_bytes3();
    init_hasher2();
    init_digest4();
    init_interface3();
  }
});

// ../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/digest.js
var digest_exports4 = {};
__export(digest_exports4, {
  HEIGHT_SIZE: () => HEIGHT_SIZE,
  MAX_DIGEST_SIZE: () => MAX_DIGEST_SIZE,
  MAX_HEIGHT: () => MAX_HEIGHT,
  MAX_PAYLOAD_SIZE: () => MAX_PAYLOAD_SIZE,
  MAX_SIZE: () => MAX_SIZE,
  ROOT_SIZE: () => ROOT_SIZE,
  TAG_SIZE: () => TAG_SIZE,
  code: () => code10,
  fromBytes: () => fromBytes,
  fromPiece: () => fromPiece2,
  height: () => height,
  name: () => name9,
  padding: () => padding,
  root: () => root,
  toBytes: () => toBytes2
});
var name9, code10, MAX_PADDING_SIZE, HEIGHT_SIZE, ROOT_SIZE, MAX_DIGEST_SIZE, TAG_SIZE, MAX_SIZE, MAX_HEIGHT, MAX_PAYLOAD_SIZE, fromPiece2, fromBytes, toBytes2, height, padding, root, Digest5;
var init_digest5 = __esm({
  "../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/digest.js"() {
    init_src6();
    init_api();
    init_constant();
    init_ipld();
    init_expanded();
    name9 = /** @type {const} */
    "fr32-sha2-256-trunc254-padded-binary-tree";
    code10 = 4113;
    MAX_PADDING_SIZE = 9;
    HEIGHT_SIZE = 1;
    ROOT_SIZE = sha256_exports.size;
    MAX_DIGEST_SIZE = MAX_PADDING_SIZE + HEIGHT_SIZE + sha256_exports.size;
    TAG_SIZE = varint_exports3.encodingLength(code10);
    MAX_SIZE = TAG_SIZE + varint_exports3.encodingLength(MAX_DIGEST_SIZE) + MAX_DIGEST_SIZE;
    MAX_HEIGHT = 255;
    MAX_PAYLOAD_SIZE = fromHeight2(MAX_HEIGHT) * BigInt(IN_BITS_FR) / BigInt(OUT_BITS_FR);
    fromPiece2 = ({ padding: padding2, height: height2, root: root2 }) => {
      const paddingLength = varint_exports3.encodingLength(Number(padding2));
      const size5 = paddingLength + HEIGHT_SIZE + ROOT_SIZE;
      const sizeLength = varint_exports3.encodingLength(size5);
      const multihashLength = TAG_SIZE + sizeLength + size5;
      let offset2 = 0;
      const bytes2 = new Uint8Array(multihashLength);
      varint_exports3.encodeTo(code10, bytes2, offset2);
      offset2 += TAG_SIZE;
      varint_exports3.encodeTo(size5, bytes2, offset2);
      offset2 += sizeLength;
      varint_exports3.encodeTo(Number(padding2), bytes2, offset2);
      offset2 += paddingLength;
      bytes2[offset2] = height2;
      offset2 += HEIGHT_SIZE;
      bytes2.set(root2, offset2);
      return new Digest5(bytes2);
    };
    fromBytes = (bytes2) => new Digest5(bytes2);
    toBytes2 = ({ digest: digest6 }) => {
      const SIZE_BYTE_LENGTH = varint_exports3.encodingLength(digest6.length);
      const prefixByteLength = SIZE_BYTE_LENGTH + TAG_SIZE;
      if (digest6.byteOffset >= prefixByteLength) {
        const bytes3 = new Uint8Array(
          digest6.buffer,
          digest6.byteOffset - prefixByteLength,
          digest6.byteOffset + digest6.length
        );
        const [tag2, offset2] = varint_exports3.decode(bytes3);
        if (tag2 === code10 && varint_exports3.decode(bytes3, offset2)[0] === digest6.length) {
          return bytes3;
        }
      }
      const bytes2 = new Uint8Array(digest6.length + prefixByteLength);
      varint_exports3.encodeTo(code10, bytes2);
      varint_exports3.encodeTo(digest6.length, bytes2, TAG_SIZE);
      bytes2.set(digest6, prefixByteLength);
      return bytes2;
    };
    height = ({ digest: digest6 }) => {
      const [, offset2] = varint_exports3.decode(digest6);
      return digest6[offset2];
    };
    padding = ({ digest: digest6 }) => {
      const [padding2] = varint_exports3.decode(digest6);
      return BigInt(padding2);
    };
    root = ({ digest: digest6 }) => {
      const [, offset2] = varint_exports3.decode(digest6);
      return digest6.subarray(
        offset2 + HEIGHT_SIZE,
        offset2 + HEIGHT_SIZE + sha256_exports.size
      );
    };
    Digest5 = class {
      /**
       * @param {Uint8Array} bytes
       */
      constructor(bytes2) {
        this.bytes = bytes2;
        const [tag2] = varint_exports3.decode(bytes2);
        if (tag2 !== code10) {
          throw new RangeError(`Expected multihash with code ${code10}`);
        }
        let offset2 = TAG_SIZE;
        const [size5, length5] = varint_exports3.decode(bytes2, offset2);
        offset2 += length5;
        const digest6 = bytes2.subarray(offset2);
        if (digest6.length !== size5) {
          throw new RangeError(
            `Invalid multihash size expected ${offset2 + size5} bytes, got ${bytes2.length} bytes`
          );
        }
        this.digest = digest6;
      }
      get name() {
        return name9;
      }
      get code() {
        return code10;
      }
      get size() {
        return this.digest.length;
      }
      get padding() {
        return padding(this);
      }
      get height() {
        return height(this);
      }
      get root() {
        return root(this);
      }
    };
  }
});

// ../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/multihash.js
var multihash_exports = {};
__export(multihash_exports, {
  Digest: () => digest_exports4,
  MAX_HEIGHT: () => MAX_HEIGHT2,
  MAX_PAYLOAD_SIZE: () => MAX_PAYLOAD_SIZE2,
  code: () => code11,
  create: () => create6,
  digest: () => digest3,
  name: () => name10
});
var name10, code11, MAX_HEIGHT2, MAX_PAYLOAD_SIZE2, digest3, create6, Hasher3, prune, build, flush;
var init_multihash = __esm({
  "../../node_modules/.pnpm/@web3-storage+data-segment@5.1.0/node_modules/@web3-storage/data-segment/src/multihash.js"() {
    init_api();
    init_constant();
    init_zero_comm();
    init_proof();
    init_tree();
    init_fr32();
    init_expanded();
    init_size();
    init_digest5();
    init_src6();
    name10 = /** @type {const} */
    "fr32-sha2-256-trunc254-padded-binary-tree";
    code11 = 4113;
    MAX_HEIGHT2 = 255;
    MAX_PAYLOAD_SIZE2 = fromHeight2(MAX_HEIGHT2) * BigInt(IN_BITS_FR) / BigInt(OUT_BITS_FR);
    digest3 = (payload) => {
      const hasher = new Hasher3();
      hasher.write(payload);
      return hasher.digest();
    };
    create6 = () => new Hasher3();
    Hasher3 = class {
      constructor() {
        this.bytesWritten = 0n;
        this.buffer = new Uint8Array(IN_BYTES_PER_QUAD);
        this.offset = 0;
        this.layers = [[]];
      }
      /**
       * Return the total number of bytes written into the hasher. Calling
       * {@link reset} will reset the hasher and the count will be reset to 0.
       *
       * @returns {bigint}
       */
      count() {
        return this.bytesWritten;
      }
      /**
       * Computes the digest of all the data that has been written into this hasher.
       * This method does not have side-effects, meaning that you can continue
       * writing and call this method again to compute digest of all the data
       * written from the very beginning.
       */
      digest() {
        const bytes2 = new Uint8Array(MAX_SIZE);
        const count = this.digestInto(bytes2, 0, true);
        return fromBytes(bytes2.subarray(0, count));
      }
      /**
       * Computes the digest and writes into the given buffer. You can provide
       * optional `byteOffset` to write digest at that offset in the buffer. By
       * default the multihash prefix will be written into the buffer, but you can
       * opt-out by passing `false` as the `asMultihash` argument.
       *
       * @param {Uint8Array} output
       * @param {number} [byteOffset]
       * @param {boolean} asMultihash
       */
      digestInto(output, byteOffset = 0, asMultihash = true) {
        const { buffer: buffer3, layers, offset: offset2, bytesWritten } = this;
        let [leaves, ...nodes] = layers;
        if (offset2 > 0 || bytesWritten === 0n) {
          leaves = [...leaves, ...split(pad(buffer3.fill(0, offset2)))];
        }
        const tree2 = build([leaves, ...nodes]);
        const height2 = tree2.length - 1;
        const [root2] = tree2[height2];
        const padding2 = Number(unpadded_exports.toPadding(this.bytesWritten));
        const paddingLength = varint_exports3.encodingLength(
          /** @type {number & bigint} */
          padding2
        );
        let endOffset = byteOffset;
        if (asMultihash) {
          varint_exports3.encodeTo(code11, output, endOffset);
          endOffset += TAG_SIZE;
          const size5 = paddingLength + HEIGHT_SIZE + ROOT_SIZE;
          const sizeLength = varint_exports3.encodingLength(size5);
          varint_exports3.encodeTo(size5, output, endOffset);
          endOffset += sizeLength;
        }
        varint_exports3.encodeTo(padding2, output, endOffset);
        endOffset += paddingLength;
        output[endOffset] = height2;
        endOffset += 1;
        output.set(root2, endOffset);
        endOffset += root2.length;
        return endOffset - byteOffset;
      }
      /**
       * @param {Uint8Array} bytes
       */
      write(bytes2) {
        const { buffer: buffer3, offset: offset2, layers } = this;
        const leaves = layers[0];
        const { length: length5 } = bytes2;
        if (length5 === 0) {
          return this;
        } else if (this.bytesWritten + BigInt(length5) > MAX_PAYLOAD_SIZE2) {
          throw new RangeError(
            `Writing ${length5} bytes exceeds max payload size of ${MAX_PAYLOAD_SIZE2}`
          );
        } else if (offset2 + length5 < buffer3.length) {
          buffer3.set(bytes2, offset2);
          this.offset += length5;
          this.bytesWritten += BigInt(length5);
          return this;
        } else {
          const bytesRequired = buffer3.length - offset2;
          buffer3.set(bytes2.subarray(0, bytesRequired), offset2);
          leaves.push(...split(pad(buffer3)));
          let readOffset = bytesRequired;
          while (readOffset + IN_BYTES_PER_QUAD < length5) {
            const quad = bytes2.subarray(readOffset, readOffset + IN_BYTES_PER_QUAD);
            leaves.push(...split(pad(quad)));
            readOffset += IN_BYTES_PER_QUAD;
          }
          this.buffer.set(bytes2.subarray(readOffset), 0);
          this.offset = length5 - readOffset;
          this.bytesWritten += BigInt(length5);
          prune(this.layers);
          return this;
        }
      }
      /**
       * Resets this hasher to its initial state so it could be recycled as new
       * instance.
       */
      reset() {
        this.offset = 0;
        this.bytesWritten = 0n;
        this.layers.length = 1;
        this.layers[0].length = 0;
        return this;
      }
      /* c8 ignore next 3 */
      dispose() {
        this.reset();
      }
      get code() {
        return code11;
      }
      get name() {
        return name10;
      }
    };
    prune = (layers) => flush(layers, false);
    build = (layers) => flush([...layers], true);
    flush = (layers, build3) => {
      let level = 0;
      while (level < layers.length) {
        let next = layers[level + 1];
        const layer = layers[level];
        if (build3 && layer.length % 2 > 0 && next) {
          layer.push(fromLevel(level));
        }
        level += 1;
        next = next ? build3 ? [...next] : next : [];
        let index2 = 0;
        while (index2 + 1 < layer.length) {
          const node = computeNode(layer[index2], layer[index2 + 1]);
          delete layer[index2];
          delete layer[index2 + 1];
          next.push(node);
          index2 += 2;
        }
        if (next.length) {
          layers[level] = next;
        }
        layer.splice(0, index2);
      }
      return layers;
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+interface@10.0.1/node_modules/@ucanto/interface/src/lib.js
var init_lib = __esm({
  "../../node_modules/.pnpm/@ucanto+interface@10.0.1/node_modules/@ucanto/interface/src/lib.js"() {
  }
});

// ../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/ucan.js
var init_ucan = __esm({
  "../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/ucan.js"() {
  }
});

// ../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/utf8.js
var encoder, decoder, encode18, decode23;
var init_utf8 = __esm({
  "../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/utf8.js"() {
    encoder = new TextEncoder();
    decoder = new TextDecoder();
    encode18 = (text2) => encoder.encode(text2);
    decode23 = (bytes2) => decoder.decode(bytes2);
  }
});

// ../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/identity.js
var code12, name11, encode19, digest4, identity3;
var init_identity3 = __esm({
  "../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/identity.js"() {
    init_bytes3();
    init_digest4();
    code12 = 0;
    name11 = "identity";
    encode19 = coerce2;
    digest4 = (input10) => create4(code12, encode19(input10));
    identity3 = { code: code12, name: name11, encode: encode19, digest: digest4 };
  }
});

// ../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/did.js
var DID_PREFIX, DID_PREFIX_SIZE, DID_KEY_PREFIX, DID_KEY_PREFIX_SIZE, ED25519, RSA, P256, P384, P521, SECP256K1, BLS12381G1, BLS12381G2, DID_CORE, METHOD_OFFSET, parse3, format3, from7, decode24, encode20, DID, DIDKey;
var init_did = __esm({
  "../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/did.js"() {
    init_base583();
    init_src6();
    init_utf8();
    DID_PREFIX = "did:";
    DID_PREFIX_SIZE = DID_PREFIX.length;
    DID_KEY_PREFIX = `did:key:`;
    DID_KEY_PREFIX_SIZE = DID_KEY_PREFIX.length;
    ED25519 = 237;
    RSA = 4613;
    P256 = 4608;
    P384 = 4609;
    P521 = 4610;
    SECP256K1 = 231;
    BLS12381G1 = 234;
    BLS12381G2 = 235;
    DID_CORE = 3357;
    METHOD_OFFSET = varint_exports3.encodingLength(DID_CORE);
    parse3 = (did2) => {
      if (!did2.startsWith(DID_PREFIX)) {
        throw new RangeError(`Invalid DID "${did2}", must start with 'did:'`);
      } else if (did2.startsWith(DID_KEY_PREFIX)) {
        const key = base58btc3.decode(did2.slice(DID_KEY_PREFIX_SIZE));
        return decode24(key);
      } else {
        const suffix = encode18(did2.slice(DID_PREFIX_SIZE));
        const bytes2 = new Uint8Array(suffix.byteLength + METHOD_OFFSET);
        varint_exports3.encodeTo(DID_CORE, bytes2);
        bytes2.set(suffix, METHOD_OFFSET);
        return new DID(bytes2);
      }
    };
    format3 = (id) => id.did();
    from7 = (principal) => {
      if (principal instanceof DID) {
        return principal;
      } else if (principal instanceof Uint8Array) {
        return decode24(principal);
      } else if (typeof principal === "string") {
        return parse3(principal);
      } else {
        return parse3(principal.did());
      }
    };
    decode24 = (bytes2) => {
      const [code25] = varint_exports3.decode(bytes2);
      const { buffer: buffer3, byteOffset, byteLength } = bytes2;
      switch (code25) {
        case P256:
          if (bytes2.length > 35) {
            throw new RangeError(`Only p256-pub compressed is supported.`);
          }
        case ED25519:
        case RSA:
        case P384:
        case P521:
        case BLS12381G1:
        case BLS12381G2:
        case SECP256K1:
          return (
            /** @type {UCAN.PrincipalView<any>} */
            new DIDKey(buffer3, byteOffset, byteLength)
          );
        case DID_CORE:
          return new DID(buffer3, byteOffset, byteLength);
        default:
          throw new RangeError(
            `Unsupported DID encoding, unknown multicode 0x${code25.toString(16)}.`
          );
      }
    };
    encode20 = (principal) => parse3(principal.did());
    DID = class extends Uint8Array {
      /**
       * @returns {ID}
       */
      did() {
        const bytes2 = new Uint8Array(this.buffer, this.byteOffset + METHOD_OFFSET);
        return (
          /** @type {ID} */
          `did:${decode23(bytes2)}`
        );
      }
      toJSON() {
        return this.did();
      }
    };
    DIDKey = class extends DID {
      /**
       * @return {`did:key:${string}`}
       */
      did() {
        return `did:key:${base58btc3.encode(this)}`;
      }
    };
  }
});

// ../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/codecs/raw.js
var code13;
var init_raw2 = __esm({
  "../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/codecs/raw.js"() {
    init_bytes3();
    code13 = 85;
  }
});

// ../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base64.js
var base642, base64pad2, base64url2, base64urlpad2;
var init_base642 = __esm({
  "../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base64.js"() {
    init_base4();
    base642 = rfc46483({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    base64pad2 = rfc46483({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    base64url2 = rfc46483({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    base64urlpad2 = rfc46483({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
  }
});

// ../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/signature.js
var signature_exports = {};
__export(signature_exports, {
  BLS12381G1: () => BLS12381G12,
  BLS12381G2: () => BLS12381G22,
  EIP191: () => EIP191,
  ES256: () => ES256,
  ES256K: () => ES256K,
  ES384: () => ES384,
  ES512: () => ES512,
  EdDSA: () => EdDSA,
  NON_STANDARD: () => NON_STANDARD,
  RS256: () => RS256,
  Signature: () => Signature,
  create: () => create7,
  createNamed: () => createNamed,
  createNonStandard: () => createNonStandard,
  decode: () => decode25,
  encode: () => encode21,
  format: () => format4,
  fromJSON: () => fromJSON2,
  nameCode: () => nameCode,
  parse: () => parse4,
  toJSON: () => toJSON2,
  view: () => view
});
var NON_STANDARD, ES256K, BLS12381G12, BLS12381G22, EdDSA, ES256, ES384, ES512, RS256, EIP191, codeName, nameCode, Signature, algorithm, size2, create7, createNamed, createNonStandard, view, decode25, encode21, format4, parse4, toJSON2, fromJSON2;
var init_signature = __esm({
  "../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/signature.js"() {
    init_src6();
    init_base642();
    init_utf8();
    NON_STANDARD = 53248;
    ES256K = 53479;
    BLS12381G12 = 53482;
    BLS12381G22 = 53483;
    EdDSA = 53485;
    ES256 = 13636096;
    ES384 = 13636097;
    ES512 = 13636098;
    RS256 = 13636101;
    EIP191 = 53649;
    codeName = (code25) => {
      switch (code25) {
        case ES256K:
          return "ES256K";
        case BLS12381G12:
          return "BLS12381G1";
        case BLS12381G22:
          return "BLS12381G2";
        case EdDSA:
          return "EdDSA";
        case ES256:
          return "ES256";
        case ES384:
          return "ES384";
        case ES512:
          return "ES512";
        case RS256:
          return "RS256";
        case EIP191:
          return "EIP191";
        default:
          throw new RangeError(
            `Unknown signature algorithm code 0x${code25.toString(16)}`
          );
      }
    };
    nameCode = (name20) => {
      switch (name20) {
        case "ES256K":
          return ES256K;
        case "BLS12381G1":
          return BLS12381G12;
        case "BLS12381G2":
          return BLS12381G22;
        case "EdDSA":
          return EdDSA;
        case "ES256":
          return ES256;
        case "ES384":
          return ES384;
        case "ES512":
          return ES512;
        case "RS256":
          return RS256;
        case "EIP191":
          return EIP191;
        default:
          return NON_STANDARD;
      }
    };
    Signature = class extends Uint8Array {
      get code() {
        const [code25] = varint_exports3.decode(this);
        Object.defineProperties(this, { code: { value: code25 } });
        return (
          /** @type {A} */
          code25
        );
      }
      get size() {
        const value = size2(this);
        Object.defineProperties(this, { size: { value } });
        return value;
      }
      get algorithm() {
        const value = algorithm(this);
        Object.defineProperties(this, { algorithm: { value } });
        return value;
      }
      get raw() {
        const { buffer: buffer3, byteOffset, size: size5, code: code25 } = this;
        const codeSize = varint_exports3.encodingLength(code25);
        const rawSize = varint_exports3.encodingLength(size5);
        const value = new Uint8Array(buffer3, byteOffset + codeSize + rawSize, size5);
        Object.defineProperties(this, { raw: { value } });
        return value;
      }
      /**
       * Verify that this signature was created by the given key.
       *
       * @param {UCAN.Crypto.Verifier<A>} signer
       * @param {UCAN.ByteView<T>} payload
       */
      async verify(signer, payload) {
        try {
          if (await signer.verify(payload, this) === true) {
            return { ok: {} };
          } else {
            throw new Error("Invalid signature");
          }
        } catch (cause) {
          return { error: (
            /** @type {Error} */
            cause
          ) };
        }
      }
      toJSON() {
        return toJSON2(this);
      }
    };
    algorithm = (signature) => {
      const { code: code25, raw, buffer: buffer3, byteOffset } = signature;
      if (code25 === NON_STANDARD) {
        const offset2 = raw.byteLength + varint_exports3.encodingLength(code25) + varint_exports3.encodingLength(raw.byteLength);
        const bytes2 = new Uint8Array(buffer3, byteOffset + offset2);
        return decode23(bytes2);
      } else {
        return codeName(code25);
      }
    };
    size2 = (signature) => {
      const offset2 = varint_exports3.encodingLength(signature.code);
      const [size5] = varint_exports3.decode(
        new Uint8Array(signature.buffer, signature.byteOffset + offset2)
      );
      return size5;
    };
    create7 = (code25, raw) => {
      const _ = codeName(code25);
      const codeSize = varint_exports3.encodingLength(code25);
      const rawSize = varint_exports3.encodingLength(raw.byteLength);
      const signature = new Signature(codeSize + rawSize + raw.byteLength);
      varint_exports3.encodeTo(code25, signature);
      varint_exports3.encodeTo(raw.byteLength, signature, codeSize);
      signature.set(raw, codeSize + rawSize);
      Object.defineProperties(signature, {
        code: { value: code25 },
        size: { value: raw.byteLength }
      });
      return signature;
    };
    createNamed = (name20, raw) => {
      const code25 = nameCode(name20);
      return code25 === NON_STANDARD ? createNonStandard(name20, raw) : create7(code25, raw);
    };
    createNonStandard = (name20, raw) => {
      const code25 = NON_STANDARD;
      const codeSize = varint_exports3.encodingLength(code25);
      const rawSize = varint_exports3.encodingLength(raw.byteLength);
      const nameBytes = encode18(name20);
      const signature = new Signature(
        codeSize + rawSize + raw.byteLength + nameBytes.byteLength
      );
      varint_exports3.encodeTo(code25, signature);
      varint_exports3.encodeTo(raw.byteLength, signature, codeSize);
      signature.set(raw, codeSize + rawSize);
      signature.set(nameBytes, codeSize + rawSize + raw.byteLength);
      return signature;
    };
    view = (bytes2) => new Signature(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
    decode25 = (bytes2) => {
      if (!(bytes2 instanceof Uint8Array)) {
        throw new TypeError(
          `Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(
            bytes2
          )}`
        );
      }
      const signature = view(bytes2);
      const { code: code25, algorithm: algorithm2, raw } = signature;
      return signature;
    };
    encode21 = (signature) => decode25(signature);
    format4 = (signature, base6) => (base6 || base64url2).encode(signature);
    parse4 = (signature, base6) => (
      /** @type {UCAN.SignatureView<T, A>} */
      decode25((base6 || base64url2).decode(signature))
    );
    toJSON2 = (signature) => ({
      "/": { bytes: base642.baseEncode(signature) }
    });
    fromJSON2 = (json) => decode25(base642.baseDecode(json["/"].bytes));
  }
});

// ../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/schema.js
var readPayload, readJWTPayload, readPayloadWith, readSignature, readInt, readCapability, readCapabilities, asCapability, readAbility, readResource, parseURL, readArray, readOptionalArray, readStruct, readFact, readProof, readStringProof, parseProof, readPrincipal, readStringPrincipal, readOptional, readNullable, readString, readBytes, readVersion, readLiteral, ParseError, fail;
var init_schema = __esm({
  "../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/schema.js"() {
    init_utf8();
    init_link();
    init_identity3();
    init_did();
    init_raw2();
    init_signature();
    readPayload = (data) => readPayloadWith(data, {
      readPrincipal,
      readProof
    });
    readJWTPayload = (data) => readPayloadWith(data, {
      readPrincipal: readStringPrincipal,
      readProof: readStringProof
    });
    readPayloadWith = (data, { readPrincipal: readPrincipal2, readProof: readProof2 }) => ({
      iss: readPrincipal2(data.iss, "iss"),
      aud: readPrincipal2(data.aud, "aud"),
      att: readCapabilities(data.att, "att"),
      prf: readOptionalArray(data.prf, readProof2, "prf") || [],
      exp: readNullable(data.exp === Infinity ? null : data.exp, readInt, "exp"),
      nbf: readOptional(data.nbf, readInt, "nbf"),
      fct: readOptionalArray(data.fct, readFact, "fct") || [],
      nnc: readOptional(data.nnc, readString, "nnc")
    });
    readSignature = (source) => {
      if (source instanceof Uint8Array) {
        return decode25(source);
      } else {
        throw new TypeError(
          `Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(
            source
          )}`
        );
      }
    };
    readInt = (input10, name20) => Number.isInteger(input10) ? (
      /** @type {number} */
      input10
    ) : ParseError.throw(
      `Expected ${name20} to be integer, instead got ${JSON.stringify(input10)}`
    );
    readCapability = (input10, context2) => readStruct(input10, asCapability, context2);
    readCapabilities = (input10, context2) => (
      /** @type {C} */
      readArray(input10, readCapability, context2)
    );
    asCapability = (input10) => (
      /** @type {C} */
      {
        ...input10,
        can: readAbility(input10.can),
        with: readResource(input10.with)
      }
    );
    readAbility = (input10) => typeof input10 !== "string" ? ParseError.throw(
      `Capability has invalid 'can: ${JSON.stringify(
        input10
      )}', value must be a string`
    ) : input10.slice(1, -1).includes("/") ? (
      /** @type {UCAN.Ability} */
      input10.toLocaleLowerCase()
    ) : input10 === "*" ? input10 : ParseError.throw(
      `Capability has invalid 'can: "${input10}"', value must have at least one path segment`
    );
    readResource = (input10) => typeof input10 !== "string" ? ParseError.throw(
      `Capability has invalid 'with: ${JSON.stringify(
        input10
      )}', value must be a string`
    ) : parseURL(input10) || ParseError.throw(
      `Capability has invalid 'with: "${input10}"', value must be a valid URI string`
    );
    parseURL = (input10) => {
      try {
        new URL(input10);
        return input10;
      } catch (_) {
        return null;
      }
    };
    readArray = (input10, read10, context2) => Array.isArray(input10) ? input10.map((element, n) => read10(element, `${context2}[${n}]`)) : ParseError.throw(`${context2} must be an array`);
    readOptionalArray = (input10, reader, context2) => input10 === void 0 ? input10 : readArray(input10, reader, context2);
    readStruct = (input10, reader, context2) => input10 != null && typeof input10 === "object" ? reader(input10) : ParseError.throw(
      `${context2} must be of type object, instead got ${input10}`
    );
    readFact = (input10, context2) => readStruct(input10, Object, context2);
    readProof = (source, context2) => isLink(source) ? (
      /** @type {UCAN.Link} */
      source
    ) : fail(
      `Expected ${context2} to be IPLD link, instead got ${JSON.stringify(
        source
      )}`
    );
    readStringProof = (source, context2) => parseProof(readString(source, context2));
    parseProof = (source) => {
      try {
        return parse2(source);
      } catch (error3) {
        return create5(code13, identity3.digest(encode18(source)));
      }
    };
    readPrincipal = (input10, context2) => decode24(readBytes(input10, context2));
    readStringPrincipal = (source, context2) => parse3(readString(source, context2));
    readOptional = (source, read10, context2 = "Field") => source !== void 0 ? read10(source, context2) : void 0;
    readNullable = (source, read10, context2) => source === null ? null : read10(source, context2);
    readString = (source, context2 = "Field") => typeof source === "string" ? source : fail(`${context2} has invalid value ${source}`);
    readBytes = (source, context2) => source instanceof Uint8Array ? source : fail(
      `Expected ${context2} to be Uint8Array, instead got ${JSON.stringify(
        source
      )}`
    );
    readVersion = (input10, context2) => /\d+\.\d+\.\d+/.test(
      /** @type {string} */
      input10
    ) ? (
      /** @type {UCAN.Version} */
      input10
    ) : ParseError.throw(`Invalid version '${context2}: ${JSON.stringify(input10)}'`);
    readLiteral = (input10, literal2, context2) => input10 === literal2 ? literal2 : ParseError.throw(
      `Expected ${context2} to be a ${JSON.stringify(
        literal2
      )} instead got ${JSON.stringify(input10)}`
    );
    ParseError = class extends TypeError {
      get name() {
        return "ParseError";
      }
      /**
       * @param {string} message
       * @returns {never}
       */
      static throw(message) {
        throw new this(message);
      }
    };
    fail = (reason) => ParseError.throw(reason);
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/json/encode.js
function mapSorter4(e1, e2) {
  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {
    throw new Error(`${encodeErrPrefix2} complex map keys are not supported`);
  }
  const keyToken1 = e1[0];
  const keyToken2 = e2[0];
  if (keyToken1.type !== Type2.string || keyToken2.type !== Type2.string) {
    throw new Error(`${encodeErrPrefix2} non-string map keys are not supported`);
  }
  if (keyToken1 < keyToken2) {
    return -1;
  }
  if (keyToken1 > keyToken2) {
    return 1;
  }
  throw new Error(`${encodeErrPrefix2} unexpected duplicate map keys, this is not supported`);
}
function encode22(data, options) {
  options = Object.assign({}, defaultEncodeOptions4, options);
  return encodeCustom2(data, new JSONEncoder2(), options);
}
var JSONEncoder2, defaultEncodeOptions4;
var init_encode4 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/json/encode.js"() {
    init_token2();
    init_encode3();
    init_common2();
    init_byte_utils2();
    JSONEncoder2 = class extends Array {
      constructor() {
        super();
        this.inRecursive = [];
      }
      /**
       * @param {Bl} buf
       */
      prefix(buf3) {
        const recurs = this.inRecursive[this.inRecursive.length - 1];
        if (recurs) {
          if (recurs.type === Type2.array) {
            recurs.elements++;
            if (recurs.elements !== 1) {
              buf3.push([44]);
            }
          }
          if (recurs.type === Type2.map) {
            recurs.elements++;
            if (recurs.elements !== 1) {
              if (recurs.elements % 2 === 1) {
                buf3.push([44]);
              } else {
                buf3.push([58]);
              }
            }
          }
        }
      }
      /**
       * @param {Bl} buf
       * @param {Token} token
       */
      [Type2.uint.major](buf3, token) {
        this.prefix(buf3);
        const is3 = String(token.value);
        const isa = [];
        for (let i = 0; i < is3.length; i++) {
          isa[i] = is3.charCodeAt(i);
        }
        buf3.push(isa);
      }
      /**
       * @param {Bl} buf
       * @param {Token} token
       */
      [Type2.negint.major](buf3, token) {
        this[Type2.uint.major](buf3, token);
      }
      /**
       * @param {Bl} _buf
       * @param {Token} _token
       */
      [Type2.bytes.major](_buf, _token) {
        throw new Error(`${encodeErrPrefix2} unsupported type: Uint8Array`);
      }
      /**
       * @param {Bl} buf
       * @param {Token} token
       */
      [Type2.string.major](buf3, token) {
        this.prefix(buf3);
        const byts = fromString4(JSON.stringify(token.value));
        buf3.push(byts.length > 32 ? asU8A2(byts) : byts);
      }
      /**
       * @param {Bl} buf
       * @param {Token} _token
       */
      [Type2.array.major](buf3, _token) {
        this.prefix(buf3);
        this.inRecursive.push({ type: Type2.array, elements: 0 });
        buf3.push([91]);
      }
      /**
       * @param {Bl} buf
       * @param {Token} _token
       */
      [Type2.map.major](buf3, _token) {
        this.prefix(buf3);
        this.inRecursive.push({ type: Type2.map, elements: 0 });
        buf3.push([123]);
      }
      /**
       * @param {Bl} _buf
       * @param {Token} _token
       */
      [Type2.tag.major](_buf, _token) {
      }
      /**
       * @param {Bl} buf
       * @param {Token} token
       */
      [Type2.float.major](buf3, token) {
        if (token.type.name === "break") {
          const recurs = this.inRecursive.pop();
          if (recurs) {
            if (recurs.type === Type2.array) {
              buf3.push([93]);
            } else if (recurs.type === Type2.map) {
              buf3.push([125]);
            } else {
              throw new Error("Unexpected recursive type; this should not happen!");
            }
            return;
          }
          throw new Error("Unexpected break; this should not happen!");
        }
        if (token.value === void 0) {
          throw new Error(`${encodeErrPrefix2} unsupported type: undefined`);
        }
        this.prefix(buf3);
        if (token.type.name === "true") {
          buf3.push([116, 114, 117, 101]);
          return;
        } else if (token.type.name === "false") {
          buf3.push([102, 97, 108, 115, 101]);
          return;
        } else if (token.type.name === "null") {
          buf3.push([110, 117, 108, 108]);
          return;
        }
        const is3 = String(token.value);
        const isa = [];
        let dp = false;
        for (let i = 0; i < is3.length; i++) {
          isa[i] = is3.charCodeAt(i);
          if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {
            dp = true;
          }
        }
        if (!dp) {
          isa.push(46);
          isa.push(48);
        }
        buf3.push(isa);
      }
    };
    defaultEncodeOptions4 = { addBreakTokens: true, mapSorter: mapSorter4 };
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/json/decode.js
function decode26(data, options) {
  options = Object.assign({ tokenizer: new Tokenizer2(data, options) }, options);
  return decode13(data, options);
}
var Tokenizer2;
var init_decode4 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/json/decode.js"() {
    init_decode3();
    init_token2();
    init_byte_utils2();
    init_common2();
    Tokenizer2 = class {
      /**
       * @param {Uint8Array} data
       * @param {DecodeOptions} options
       */
      constructor(data, options = {}) {
        this._pos = 0;
        this.data = data;
        this.options = options;
        this.modeStack = ["value"];
        this.lastToken = "";
      }
      pos() {
        return this._pos;
      }
      /**
       * @returns {boolean}
       */
      done() {
        return this._pos >= this.data.length;
      }
      /**
       * @returns {number}
       */
      ch() {
        return this.data[this._pos];
      }
      /**
       * @returns {string}
       */
      currentMode() {
        return this.modeStack[this.modeStack.length - 1];
      }
      skipWhitespace() {
        let c = this.ch();
        while (c === 32 || c === 9 || c === 13 || c === 10) {
          c = this.data[++this._pos];
        }
      }
      /**
       * @param {number[]} str
       */
      expect(str) {
        if (this.data.length - this._pos < str.length) {
          throw new Error(`${decodeErrPrefix2} unexpected end of input at position ${this._pos}`);
        }
        for (let i = 0; i < str.length; i++) {
          if (this.data[this._pos++] !== str[i]) {
            throw new Error(`${decodeErrPrefix2} unexpected token at position ${this._pos}, expected to find '${String.fromCharCode(...str)}'`);
          }
        }
      }
      parseNumber() {
        const startPos = this._pos;
        let negative = false;
        let float2 = false;
        const swallow = (chars) => {
          while (!this.done()) {
            const ch = this.ch();
            if (chars.includes(ch)) {
              this._pos++;
            } else {
              break;
            }
          }
        };
        if (this.ch() === 45) {
          negative = true;
          this._pos++;
        }
        if (this.ch() === 48) {
          this._pos++;
          if (this.ch() === 46) {
            this._pos++;
            float2 = true;
          } else {
            return new Token2(Type2.uint, 0, this._pos - startPos);
          }
        }
        swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
        if (negative && this._pos === startPos + 1) {
          throw new Error(`${decodeErrPrefix2} unexpected token at position ${this._pos}`);
        }
        if (!this.done() && this.ch() === 46) {
          if (float2) {
            throw new Error(`${decodeErrPrefix2} unexpected token at position ${this._pos}`);
          }
          float2 = true;
          this._pos++;
          swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
        }
        if (!this.done() && (this.ch() === 101 || this.ch() === 69)) {
          float2 = true;
          this._pos++;
          if (!this.done() && (this.ch() === 43 || this.ch() === 45)) {
            this._pos++;
          }
          swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
        }
        const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this._pos));
        const num = parseFloat(numStr);
        if (float2) {
          return new Token2(Type2.float, num, this._pos - startPos);
        }
        if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {
          return new Token2(num >= 0 ? Type2.uint : Type2.negint, num, this._pos - startPos);
        }
        return new Token2(num >= 0 ? Type2.uint : Type2.negint, BigInt(numStr), this._pos - startPos);
      }
      /**
       * @returns {Token}
       */
      parseString() {
        if (this.ch() !== 34) {
          throw new Error(`${decodeErrPrefix2} unexpected character at position ${this._pos}; this shouldn't happen`);
        }
        this._pos++;
        for (let i = this._pos, l = 0; i < this.data.length && l < 65536; i++, l++) {
          const ch = this.data[i];
          if (ch === 92 || ch < 32 || ch >= 128) {
            break;
          }
          if (ch === 34) {
            const str = String.fromCharCode.apply(null, this.data.subarray(this._pos, i));
            this._pos = i + 1;
            return new Token2(Type2.string, str, l);
          }
        }
        const startPos = this._pos;
        const chars = [];
        const readu4 = () => {
          if (this._pos + 4 >= this.data.length) {
            throw new Error(`${decodeErrPrefix2} unexpected end of unicode escape sequence at position ${this._pos}`);
          }
          let u4 = 0;
          for (let i = 0; i < 4; i++) {
            let ch = this.ch();
            if (ch >= 48 && ch <= 57) {
              ch -= 48;
            } else if (ch >= 97 && ch <= 102) {
              ch = ch - 97 + 10;
            } else if (ch >= 65 && ch <= 70) {
              ch = ch - 65 + 10;
            } else {
              throw new Error(`${decodeErrPrefix2} unexpected unicode escape character at position ${this._pos}`);
            }
            u4 = u4 * 16 + ch;
            this._pos++;
          }
          return u4;
        };
        const readUtf8Char = () => {
          const firstByte = this.ch();
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (this._pos + bytesPerSequence > this.data.length) {
            throw new Error(`${decodeErrPrefix2} unexpected unicode sequence at position ${this._pos}`);
          }
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = this.data[this._pos + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = this.data[this._pos + 1];
              thirdByte = this.data[this._pos + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = this.data[this._pos + 1];
              thirdByte = this.data[this._pos + 2];
              fourthByte = this.data[this._pos + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            chars.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          chars.push(codePoint);
          this._pos += bytesPerSequence;
        };
        while (!this.done()) {
          const ch = this.ch();
          let ch1;
          switch (ch) {
            case 92:
              this._pos++;
              if (this.done()) {
                throw new Error(`${decodeErrPrefix2} unexpected string termination at position ${this._pos}`);
              }
              ch1 = this.ch();
              this._pos++;
              switch (ch1) {
                case 34:
                case 39:
                case 92:
                case 47:
                  chars.push(ch1);
                  break;
                case 98:
                  chars.push(8);
                  break;
                case 116:
                  chars.push(9);
                  break;
                case 110:
                  chars.push(10);
                  break;
                case 102:
                  chars.push(12);
                  break;
                case 114:
                  chars.push(13);
                  break;
                case 117:
                  chars.push(readu4());
                  break;
                default:
                  throw new Error(`${decodeErrPrefix2} unexpected string escape character at position ${this._pos}`);
              }
              break;
            case 34:
              this._pos++;
              return new Token2(Type2.string, decodeCodePointsArray2(chars), this._pos - startPos);
            default:
              if (ch < 32) {
                throw new Error(`${decodeErrPrefix2} invalid control character at position ${this._pos}`);
              } else if (ch < 128) {
                chars.push(ch);
                this._pos++;
              } else {
                readUtf8Char();
              }
          }
        }
        throw new Error(`${decodeErrPrefix2} unexpected end of string at position ${this._pos}`);
      }
      /**
       * @returns {Token}
       */
      parseValue() {
        switch (this.ch()) {
          case 123:
            this.modeStack.push("obj-start");
            this._pos++;
            return new Token2(Type2.map, Infinity, 1);
          case 91:
            this.modeStack.push("array-start");
            this._pos++;
            return new Token2(Type2.array, Infinity, 1);
          case 34: {
            return this.parseString();
          }
          case 110:
            this.expect([110, 117, 108, 108]);
            return new Token2(Type2.null, null, 4);
          case 102:
            this.expect([102, 97, 108, 115, 101]);
            return new Token2(Type2.false, false, 5);
          case 116:
            this.expect([116, 114, 117, 101]);
            return new Token2(Type2.true, true, 4);
          case 45:
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.parseNumber();
          default:
            throw new Error(`${decodeErrPrefix2} unexpected character at position ${this._pos}`);
        }
      }
      /**
       * @returns {Token}
       */
      next() {
        this.skipWhitespace();
        switch (this.currentMode()) {
          case "value":
            this.modeStack.pop();
            return this.parseValue();
          case "array-value": {
            this.modeStack.pop();
            if (this.ch() === 93) {
              this._pos++;
              this.skipWhitespace();
              return new Token2(Type2.break, void 0, 1);
            }
            if (this.ch() !== 44) {
              throw new Error(`${decodeErrPrefix2} unexpected character at position ${this._pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
            }
            this._pos++;
            this.modeStack.push("array-value");
            this.skipWhitespace();
            return this.parseValue();
          }
          case "array-start": {
            this.modeStack.pop();
            if (this.ch() === 93) {
              this._pos++;
              this.skipWhitespace();
              return new Token2(Type2.break, void 0, 1);
            }
            this.modeStack.push("array-value");
            this.skipWhitespace();
            return this.parseValue();
          }
          case "obj-key":
            if (this.ch() === 125) {
              this.modeStack.pop();
              this._pos++;
              this.skipWhitespace();
              return new Token2(Type2.break, void 0, 1);
            }
            if (this.ch() !== 44) {
              throw new Error(`${decodeErrPrefix2} unexpected character at position ${this._pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
            }
            this._pos++;
            this.skipWhitespace();
          case "obj-start": {
            this.modeStack.pop();
            if (this.ch() === 125) {
              this._pos++;
              this.skipWhitespace();
              return new Token2(Type2.break, void 0, 1);
            }
            const token = this.parseString();
            this.skipWhitespace();
            if (this.ch() !== 58) {
              throw new Error(`${decodeErrPrefix2} unexpected character at position ${this._pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
            }
            this._pos++;
            this.modeStack.push("obj-value");
            return token;
          }
          case "obj-value": {
            this.modeStack.pop();
            this.modeStack.push("obj-key");
            this.skipWhitespace();
            return this.parseValue();
          }
          default:
            throw new Error(`${decodeErrPrefix2} unexpected parse state at position ${this._pos}; this shouldn't happen`);
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/json/json.js
var init_json3 = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/json/json.js"() {
    init_encode4();
    init_decode4();
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/hashes/hasher.js
function from8({ name: name20, code: code25, encode: encode45 }) {
  return new Hasher4(name20, code25, encode45);
}
var Hasher4;
var init_hasher3 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/hashes/hasher.js"() {
    init_digest3();
    Hasher4 = class {
      name;
      code;
      encode;
      constructor(name20, code25, encode45) {
        this.name = name20;
        this.code = code25;
        this.encode = encode45;
      }
      digest(input10) {
        if (input10 instanceof Uint8Array) {
          const result = this.encode(input10);
          return result instanceof Uint8Array ? create3(this.code, result) : result.then((digest6) => create3(this.code, digest6));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/interface.js
var init_interface4 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/interface.js"() {
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/hashes/interface.js
var init_interface5 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/hashes/interface.js"() {
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/codecs/interface.js
var init_interface6 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/codecs/interface.js"() {
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/block/interface.js
var init_interface7 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/block/interface.js"() {
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/interface.js
var init_interface8 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/interface.js"() {
    init_interface4();
    init_interface5();
    init_interface6();
    init_interface();
    init_interface7();
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/index.js
var init_src7 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/index.js"() {
    init_bytes5();
    init_cid2();
    init_digest3();
    init_hasher3();
    init_varint4();
    init_interface8();
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base64.js
var base64_exports2 = {};
__export(base64_exports2, {
  base64: () => base643,
  base64pad: () => base64pad3,
  base64url: () => base64url3,
  base64urlpad: () => base64urlpad3
});
var base643, base64pad3, base64url3, base64urlpad3;
var init_base643 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base64.js"() {
    init_base3();
    base643 = rfc46482({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    base64pad3 = rfc46482({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    base64url3 = rfc46482({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    base64urlpad3 = rfc46482({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
  }
});

// ../../node_modules/.pnpm/@ipld+dag-json@10.2.2/node_modules/@ipld/dag-json/src/index.js
function toByteView2(buf3) {
  if (buf3 instanceof ArrayBuffer) {
    return new Uint8Array(buf3, 0, buf3.byteLength);
  }
  return buf3;
}
function cidEncoder4(obj) {
  if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
    return null;
  }
  const cid = CID2.asCID(obj);
  if (!cid) {
    return null;
  }
  const cidString = cid.toString();
  return [
    new Token2(Type2.map, Infinity, 1),
    new Token2(Type2.string, "/", 1),
    // key
    new Token2(Type2.string, cidString, cidString.length),
    // value
    new Token2(Type2.break, void 0, 1)
  ];
}
function bytesEncoder2(bytes2) {
  const bytesString = base643.encode(bytes2).slice(1);
  return [
    new Token2(Type2.map, Infinity, 1),
    new Token2(Type2.string, "/", 1),
    // key
    new Token2(Type2.map, Infinity, 1),
    // value
    new Token2(Type2.string, "bytes", 5),
    // inner key
    new Token2(Type2.string, bytesString, bytesString.length),
    // inner value
    new Token2(Type2.break, void 0, 1),
    new Token2(Type2.break, void 0, 1)
  ];
}
function taBytesEncoder(obj) {
  return bytesEncoder2(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
}
function abBytesEncoder(ab) {
  return bytesEncoder2(new Uint8Array(ab));
}
function undefinedEncoder4() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder4(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions4, DagJsonTokenizer2, decodeOptions4, encode23, decode27, utf8Decoder, utf8Encoder;
var init_src8 = __esm({
  "../../node_modules/.pnpm/@ipld+dag-json@10.2.2/node_modules/@ipld/dag-json/src/index.js"() {
    init_cborg2();
    init_json3();
    init_src7();
    init_base643();
    encodeOptions4 = {
      typeEncoders: {
        Object: cidEncoder4,
        Buffer: bytesEncoder2,
        Uint8Array: bytesEncoder2,
        Int8Array: taBytesEncoder,
        Uint16Array: taBytesEncoder,
        Int16Array: taBytesEncoder,
        Uint32Array: taBytesEncoder,
        Int32Array: taBytesEncoder,
        Float32Array: taBytesEncoder,
        Float64Array: taBytesEncoder,
        Uint8ClampedArray: taBytesEncoder,
        BigInt64Array: taBytesEncoder,
        BigUint64Array: taBytesEncoder,
        DataView: taBytesEncoder,
        ArrayBuffer: abBytesEncoder,
        undefined: undefinedEncoder4,
        number: numberEncoder4
      }
    };
    DagJsonTokenizer2 = class extends Tokenizer2 {
      /**
       * @param {Uint8Array} data
       * @param {object} [options]
       */
      constructor(data, options) {
        super(data, options);
        this.tokenBuffer = [];
      }
      /**
       * @returns {boolean}
       */
      done() {
        return this.tokenBuffer.length === 0 && super.done();
      }
      /**
       * @returns {Token}
       */
      _next() {
        if (this.tokenBuffer.length > 0) {
          return this.tokenBuffer.pop();
        }
        return super.next();
      }
      /**
       * Implements rules outlined in https://github.com/ipld/specs/pull/356
       *
       * @returns {Token}
       */
      next() {
        const token = this._next();
        if (token.type === Type2.map) {
          const keyToken = this._next();
          if (keyToken.type === Type2.string && keyToken.value === "/") {
            const valueToken = this._next();
            if (valueToken.type === Type2.string) {
              const breakToken = this._next();
              if (breakToken.type !== Type2.break) {
                throw new Error("Invalid encoded CID form");
              }
              this.tokenBuffer.push(valueToken);
              return new Token2(Type2.tag, 42, 0);
            }
            if (valueToken.type === Type2.map) {
              const innerKeyToken = this._next();
              if (innerKeyToken.type === Type2.string && innerKeyToken.value === "bytes") {
                const innerValueToken = this._next();
                if (innerValueToken.type === Type2.string) {
                  for (let i = 0; i < 2; i++) {
                    const breakToken = this._next();
                    if (breakToken.type !== Type2.break) {
                      throw new Error("Invalid encoded Bytes form");
                    }
                  }
                  const bytes2 = base643.decode(`m${innerValueToken.value}`);
                  return new Token2(Type2.bytes, bytes2, innerValueToken.value.length);
                }
                this.tokenBuffer.push(innerValueToken);
              }
              this.tokenBuffer.push(innerKeyToken);
            }
            this.tokenBuffer.push(valueToken);
          }
          this.tokenBuffer.push(keyToken);
        }
        return token;
      }
    };
    decodeOptions4 = {
      allowIndefinite: false,
      allowUndefined: false,
      allowNaN: false,
      allowInfinity: false,
      allowBigInt: true,
      // this will lead to BigInt for ints outside of
      // safe-integer range, which may surprise users
      strict: true,
      useMaps: false,
      rejectDuplicateMapKeys: true,
      /** @type {import('cborg').TagDecoder[]} */
      tags: []
    };
    decodeOptions4.tags[42] = CID2.parse;
    encode23 = (node) => encode22(node, encodeOptions4);
    decode27 = (data) => {
      const buf3 = toByteView2(data);
      const options = Object.assign(decodeOptions4, { tokenizer: new DagJsonTokenizer2(buf3, decodeOptions4) });
      return decode26(buf3, options);
    };
    utf8Decoder = new TextDecoder();
    utf8Encoder = new TextEncoder();
  }
});

// ../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/formatter.js
var format5, formatSignPayload, formatHeader, formatPayload, formatSignature, encodeHeader, encodePayload, encodeProof;
var init_formatter = __esm({
  "../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/formatter.js"() {
    init_did();
    init_src8();
    init_base642();
    init_signature();
    format5 = (model) => {
      const header = formatHeader(model.v, model.s.algorithm);
      const payload = formatPayload(model);
      const signature = formatSignature(model.s);
      return (
        /** @type {UCAN.JWT<C>} */
        `${header}.${payload}.${signature}`
      );
    };
    formatSignPayload = (payload, version3, alg) => `${formatHeader(version3, alg)}.${formatPayload(payload)}`;
    formatHeader = (version3, alg) => base64url2.baseEncode(encodeHeader(version3, alg));
    formatPayload = (data) => base64url2.baseEncode(encodePayload(data));
    formatSignature = (signature) => base64url2.baseEncode(signature.raw);
    encodeHeader = (v, alg) => encode23({
      alg,
      ucv: v,
      typ: "JWT"
    });
    encodePayload = (data) => encode23({
      iss: format3(data.iss),
      aud: format3(data.aud),
      att: data.att,
      exp: data.exp,
      prf: data.prf.map(encodeProof),
      // leave out optionals and empty fields
      ...data.fct.length > 0 && { fct: data.fct },
      ...data.nnc && { nnc: data.nnc },
      ...data.nbf && { nbf: data.nbf }
    });
    encodeProof = (proof) => (
      /** @type {UCAN.ToString<UCAN.Link>} */
      proof.toString()
    );
  }
});

// ../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/view.js
var toJSON3, View;
var init_view = __esm({
  "../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/view.js"() {
    init_did();
    init_src8();
    init_utf8();
    toJSON3 = (data) => JSON.parse(decode23(encode23(data)));
    View = class {
      /**
       * @param {UCAN.UCAN<C>} model
       */
      constructor(model) {
        this.model = model;
      }
      get version() {
        return this.model.v;
      }
      get issuer() {
        return from7(this.model.iss);
      }
      get audience() {
        return from7(this.model.aud);
      }
      /**
       * @returns {C}
       */
      get capabilities() {
        return this.model.att;
      }
      /**
       * @returns {number}
       */
      get expiration() {
        const { exp } = this.model;
        return exp === null ? Infinity : exp;
      }
      /**
       * @returns {undefined|number}
       */
      get notBefore() {
        return this.model.nbf;
      }
      /**
       * @returns {undefined|string}
       */
      get nonce() {
        return this.model.nnc;
      }
      /**
       * @returns {UCAN.Fact[]}
       */
      get facts() {
        return this.model.fct;
      }
      /**
       * @returns {UCAN.Link[]}
       */
      get proofs() {
        return this.model.prf;
      }
      get signature() {
        return this.model.s;
      }
      // compatibility with UCAN.UCAN
      get jwt() {
        return this.model.jwt;
      }
      get s() {
        return this.model.s;
      }
      get v() {
        return this.model.v;
      }
      get iss() {
        return this.model.iss;
      }
      get aud() {
        return this.model.aud;
      }
      get att() {
        return this.model.att;
      }
      get exp() {
        return this.model.exp;
      }
      get nbf() {
        return this.model.nbf;
      }
      get nnc() {
        return this.model.nnc;
      }
      get fct() {
        return this.model.fct;
      }
      get prf() {
        return this.model.prf;
      }
      /**
       * @returns {UCAN.ToJSON<UCAN.UCAN<C>, UCAN.UCANJSON<this>>}
       */
      toJSON() {
        const { v, iss, aud, s, att, prf, exp, fct, nnc, nbf } = this.model;
        return {
          iss,
          aud,
          v,
          s,
          exp,
          ...toJSON3({
            att,
            prf,
            ...fct.length > 0 && { fct }
          }),
          ...nnc != null && { nnc },
          ...nbf && { nbf }
        };
      }
    };
  }
});

// ../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/codec/cbor.js
var code14, from9, encode24, encodeSignature, decode28, CBORView;
var init_cbor2 = __esm({
  "../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/codec/cbor.js"() {
    init_src5();
    init_schema();
    init_formatter();
    init_signature();
    init_view();
    code14 = code9;
    from9 = (model) => new CBORView(model);
    encode24 = (model) => {
      const { fct, nnc, nbf, ...payload } = readPayload(model);
      return (
        /** @type {Uint8Array} */
        encode15({
          // leave out optionals unless they are set
          ...fct.length > 0 && { fct },
          ...nnc != null && { nnc },
          ...nbf && { nbf },
          ...payload,
          // add version and signature
          v: readVersion(model.v, "v"),
          s: encodeSignature(model.s, "s")
        })
      );
    };
    encodeSignature = (signature, context2) => {
      try {
        return encode21(signature);
      } catch (cause) {
        throw new Error(
          `Expected signature ${context2}, instead got ${JSON.stringify(signature)}`,
          // @ts-expect-error - types don't know about second arg
          { cause }
        );
      }
    };
    decode28 = (bytes2) => {
      const model = decode18(bytes2);
      return new CBORView({
        ...readPayload(model),
        v: readVersion(model.v, "v"),
        s: readSignature(model.s)
      });
    };
    CBORView = class extends View {
      get code() {
        return code14;
      }
      format() {
        return format5(this.model);
      }
      encode() {
        return encode24(this.model);
      }
    };
  }
});

// ../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/parser.js
var parse5, parseHeader, parsePayload;
var init_parser = __esm({
  "../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/parser.js"() {
    init_src8();
    init_schema();
    init_base642();
    init_signature();
    parse5 = (jwt) => {
      const segments = jwt.split(".");
      const [header, payload, signature] = segments.length === 3 ? segments : fail(
        `Can't parse UCAN: ${jwt}: Expected JWT format: 3 dot-separated base64url-encoded values.`
      );
      const { ucv, alg } = parseHeader(header);
      return {
        ...parsePayload(payload),
        v: ucv,
        s: createNamed(alg, base64url2.baseDecode(signature))
      };
    };
    parseHeader = (header) => {
      const { ucv, alg, typ } = decode27(base64url2.baseDecode(header));
      return {
        typ: readLiteral(typ, "JWT", "typ"),
        ucv: readVersion(ucv, "ucv"),
        alg: readString(alg, "alg")
      };
    };
    parsePayload = (source) => {
      const payload = decode27(base64url2.baseDecode(source));
      return readJWTPayload(payload);
    };
  }
});

// ../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/codec/jwt.js
var decode29, encode25, format6, JWTView;
var init_jwt = __esm({
  "../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/codec/jwt.js"() {
    init_utf8();
    init_parser();
    init_raw2();
    init_view();
    decode29 = (bytes2) => {
      const jwt = (
        /** @type {UCAN.JWT<C>} */
        decode23(bytes2)
      );
      return new JWTView({ ...parse5(jwt), jwt });
    };
    encode25 = ({ jwt }) => encode18(jwt);
    format6 = ({ jwt }) => jwt;
    JWTView = class extends View {
      /**
       * @param {UCAN.FromJWT<C>} model
       */
      constructor(model) {
        super(model);
        this.model = model;
      }
      get code() {
        return code13;
      }
      format() {
        return format6(this.model);
      }
      encode() {
        return encode25(this.model);
      }
    };
  }
});

// ../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/sha2.js
var import_crypto3, sha2562, sha5122;
var init_sha22 = __esm({
  "../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/sha2.js"() {
    import_crypto3 = __toESM(require("crypto"), 1);
    init_hasher2();
    init_bytes3();
    sha2562 = from6({
      name: "sha2-256",
      code: 18,
      encode: (input10) => coerce2(import_crypto3.default.createHash("sha256").update(input10).digest())
    });
    sha5122 = from6({
      name: "sha2-512",
      code: 19,
      encode: (input10) => coerce2(import_crypto3.default.createHash("sha512").update(input10).digest())
    });
  }
});

// ../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/lib.js
var VERSION, defaultHasher, decode30, write, issue, encodeSignaturePayload, now;
var init_lib2 = __esm({
  "../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/lib.js"() {
    init_cbor2();
    init_jwt();
    init_utf8();
    init_schema();
    init_did();
    init_parser();
    init_formatter();
    init_sha22();
    init_link();
    init_did();
    init_ucan();
    VERSION = "0.9.1";
    defaultHasher = sha2562;
    decode30 = (bytes2) => {
      try {
        return decode28(bytes2);
      } catch (_) {
        return decode29(
          /** @type {UCAN.ByteView<UCAN.FromJWT<C>>} */
          bytes2
        );
      }
    };
    write = async (ucan2, { hasher = defaultHasher } = {}) => {
      const [code25, bytes2] = ucan2.jwt ? [code13, encode25(ucan2)] : [code14, encode24(ucan2)];
      const digest6 = await hasher.digest(bytes2);
      return {
        bytes: bytes2,
        cid: create5(code25, digest6),
        data: ucan2
      };
    };
    issue = async ({
      issuer,
      audience,
      capabilities,
      lifetimeInSeconds = 30,
      expiration = now() + lifetimeInSeconds,
      notBefore,
      facts = [],
      proofs: proofs2 = [],
      nonce
    }) => {
      const v = VERSION;
      const data = readPayload({
        iss: parse3(issuer.did()),
        aud: parse3(audience.did()),
        att: capabilities,
        fct: facts,
        exp: expiration,
        nbf: notBefore,
        prf: proofs2,
        nnc: nonce
      });
      const payload = encodeSignaturePayload(data, v, issuer.signatureAlgorithm);
      return from9({
        ...data,
        v,
        s: await issuer.sign(payload)
      });
    };
    encodeSignaturePayload = (payload, version3, algorithm2) => encode18(formatSignPayload(payload, version3, algorithm2));
    now = () => Math.floor(Date.now() / 1e3);
  }
});

// ../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/link.js
var init_link2 = __esm({
  "../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/link.js"() {
    init_link();
    init_base323();
    init_base583();
  }
});

// ../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/cbor.js
var cbor_exports3 = {};
__export(cbor_exports3, {
  code: () => code9,
  contentType: () => contentType,
  decode: () => decode18,
  encode: () => encode26,
  link: () => link,
  name: () => name8,
  write: () => write2
});
var contentType, prepare2, encode26, link, write2;
var init_cbor3 = __esm({
  "../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/cbor.js"() {
    init_src5();
    init_src5();
    init_sha22();
    init_link();
    contentType = "application/vnd.ipld.dag-cbor";
    prepare2 = (data, seen) => {
      if (seen.has(data)) {
        throw new TypeError("Can not encode circular structure");
      }
      if (data === void 0 && seen.size === 0) {
        return null;
      }
      if (data === null) {
        return null;
      }
      if (typeof data === "symbol" && seen.size === 0) {
        return null;
      }
      if (isLink(data)) {
        return data;
      }
      if (ArrayBuffer.isView(data)) {
        return data;
      }
      if (Array.isArray(data)) {
        seen.add(data);
        const items = [];
        for (const item of data) {
          items.push(
            item === void 0 || typeof item === "symbol" ? null : prepare2(item, seen)
          );
        }
        return items;
      }
      if (typeof /** @type {{toJSON?:unknown}} */
      data.toJSON === "function") {
        seen.add(data);
        const json = (
          /** @type {{toJSON():unknown}} */
          data.toJSON()
        );
        return prepare2(json, seen);
      }
      if (typeof data === "object") {
        seen.add(data);
        const object = {};
        for (const [key, value] of Object.entries(data)) {
          if (value !== void 0 && typeof value !== "symbol") {
            object[key] = prepare2(value, new Set(seen));
          }
        }
        return object;
      }
      return data;
    };
    encode26 = (data) => (
      /** @type {CBOR.ByteView<T>} */
      encode15(prepare2(data, /* @__PURE__ */ new Set()))
    );
    link = async (bytes2, { hasher = sha2562 } = {}) => {
      return (
        /** @type {API.Link<T, typeof CBOR.code>} */
        create5(code9, await hasher.digest(bytes2))
      );
    };
    write2 = async (data, options) => {
      const bytes2 = encode26(data);
      const cid = await link(bytes2, options);
      return { cid, bytes: bytes2 };
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/dag.js
var iterate, createStore, EMBED_CODE, get, notFound, writeInto, addInto, addEveryInto;
var init_dag2 = __esm({
  "../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/dag.js"() {
    init_link2();
    init_sha22();
    init_cbor3();
    init_identity3();
    iterate = function* (value) {
      if (value && typeof value === "object" && "iterateIPLDBlocks" in value && typeof value.iterateIPLDBlocks === "function") {
        yield* value.iterateIPLDBlocks();
      }
    };
    createStore = (blocks = []) => {
      const store2 = /* @__PURE__ */ new Map();
      addEveryInto(blocks, store2);
      return store2;
    };
    EMBED_CODE = identity3.code;
    get = (cid, store2, fallback) => {
      if (cid.multihash.code === EMBED_CODE) {
        return { cid, bytes: cid.multihash.digest };
      }
      const block = (
        /** @type {API.Block<U, Format, Alg, V>|undefined} */
        store2.get(`${cid}`)
      );
      return block ? block : fallback === void 0 ? notFound(cid) : fallback;
    };
    notFound = (link5) => {
      throw new Error(`Block for the ${link5} is not found`);
    };
    writeInto = async (source, store2, options = {}) => {
      const codec = (
        /** @type {MF.BlockEncoder<C, U>} */
        options.codec || cbor_exports3
      );
      const hasher = (
        /** @type {MF.MultihashHasher<A>} */
        options.hasher || sha2562
      );
      const bytes2 = codec.encode(source);
      const digest6 = await hasher.digest(bytes2);
      const link5 = create5(codec.code, digest6);
      store2.set(
        /** @type {API.ToString<typeof link>} */
        link5.toString(),
        {
          bytes: bytes2,
          cid: link5
        }
      );
      return { bytes: bytes2, cid: link5, data: source };
    };
    addInto = ({ cid, bytes: bytes2 }, store2) => {
      store2.set(
        /** @type {API.ToString<typeof cid>} */
        cid.toString(),
        {
          bytes: bytes2,
          cid
        }
      );
      return { bytes: bytes2, cid };
    };
    addEveryInto = (source, store2) => {
      for (const block of source) {
        addInto(block, store2);
      }
    };
  }
});

// ../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/decoder-common.js
function decodeVarint2(bytes2, seeker) {
  if (!bytes2.length) {
    throw new Error("Unexpected end of data");
  }
  const i = import_varint4.default.decode(bytes2);
  seeker.seek(
    /** @type {number} */
    import_varint4.default.decode.bytes
  );
  return i;
}
function decodeV2Header(bytes2) {
  const dv = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
  let offset2 = 0;
  const header = {
    version: 2,
    /** @type {[bigint, bigint]} */
    characteristics: [
      dv.getBigUint64(offset2, true),
      dv.getBigUint64(offset2 += 8, true)
    ],
    dataOffset: Number(dv.getBigUint64(offset2 += 8, true)),
    dataSize: Number(dv.getBigUint64(offset2 += 8, true)),
    indexOffset: Number(dv.getBigUint64(offset2 += 8, true))
  };
  return header;
}
function getMultihashLength(bytes2) {
  import_varint4.default.decode(bytes2);
  const codeLength = (
    /** @type {number} */
    import_varint4.default.decode.bytes
  );
  const length5 = import_varint4.default.decode(bytes2.subarray(import_varint4.default.decode.bytes));
  const lengthLength = (
    /** @type {number} */
    import_varint4.default.decode.bytes
  );
  const mhLength = codeLength + lengthLength + length5;
  return mhLength;
}
var import_varint4, CIDV0_BYTES, V2_HEADER_LENGTH;
var init_decoder_common = __esm({
  "../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/decoder-common.js"() {
    import_varint4 = __toESM(require_varint3(), 1);
    CIDV0_BYTES = {
      SHA2_256: 18,
      LENGTH: 32,
      DAG_PB: 112
    };
    V2_HEADER_LENGTH = /* characteristics */
    16 + 8 + 8 + 8;
  }
});

// ../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/header-validator.js
var Kinds, Types, Reprs, CarV1HeaderOrV2Pragma;
var init_header_validator = __esm({
  "../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/header-validator.js"() {
    Kinds = {
      Null: (
        /** @returns {undefined|null} */
        (obj) => obj === null ? obj : void 0
      ),
      Int: (
        /** @returns {undefined|number} */
        (obj) => Number.isInteger(obj) ? obj : void 0
      ),
      Float: (
        /** @returns {undefined|number} */
        (obj) => typeof obj === "number" && Number.isFinite(obj) ? obj : void 0
      ),
      String: (
        /** @returns {undefined|string} */
        (obj) => typeof obj === "string" ? obj : void 0
      ),
      Bool: (
        /** @returns {undefined|boolean} */
        (obj) => typeof obj === "boolean" ? obj : void 0
      ),
      Bytes: (
        /** @returns {undefined|Uint8Array} */
        (obj) => obj instanceof Uint8Array ? obj : void 0
      ),
      Link: (
        /** @returns {undefined|object} */
        (obj) => obj !== null && typeof obj === "object" && obj.asCID === obj ? obj : void 0
      ),
      List: (
        /** @returns {undefined|Array<any>} */
        (obj) => Array.isArray(obj) ? obj : void 0
      ),
      Map: (
        /** @returns {undefined|object} */
        (obj) => obj !== null && typeof obj === "object" && obj.asCID !== obj && !Array.isArray(obj) && !(obj instanceof Uint8Array) ? obj : void 0
      )
    };
    Types = {
      "CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)": Kinds.Link,
      "CarV1HeaderOrV2Pragma > roots (anon)": (
        /** @returns {undefined|any} */
        (obj) => {
          if (Kinds.List(obj) === void 0) {
            return void 0;
          }
          for (let i = 0; i < obj.length; i++) {
            let v = obj[i];
            v = Types["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v);
            if (v === void 0) {
              return void 0;
            }
            if (v !== obj[i]) {
              const ret = obj.slice(0, i);
              for (let j = i; j < obj.length; j++) {
                let v2 = obj[j];
                v2 = Types["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v2);
                if (v2 === void 0) {
                  return void 0;
                }
                ret.push(v2);
              }
              return ret;
            }
          }
          return obj;
        }
      ),
      Int: Kinds.Int,
      CarV1HeaderOrV2Pragma: (
        /** @returns {undefined|any} */
        (obj) => {
          if (Kinds.Map(obj) === void 0) {
            return void 0;
          }
          const entries3 = Object.entries(obj);
          let ret = obj;
          let requiredCount = 1;
          for (let i = 0; i < entries3.length; i++) {
            const [key, value] = entries3[i];
            switch (key) {
              case "roots":
                {
                  const v = Types["CarV1HeaderOrV2Pragma > roots (anon)"](obj[key]);
                  if (v === void 0) {
                    return void 0;
                  }
                  if (v !== value || ret !== obj) {
                    if (ret === obj) {
                      ret = {};
                      for (let j = 0; j < i; j++) {
                        ret[entries3[j][0]] = entries3[j][1];
                      }
                    }
                    ret.roots = v;
                  }
                }
                break;
              case "version":
                {
                  requiredCount--;
                  const v = Types.Int(obj[key]);
                  if (v === void 0) {
                    return void 0;
                  }
                  if (v !== value || ret !== obj) {
                    if (ret === obj) {
                      ret = {};
                      for (let j = 0; j < i; j++) {
                        ret[entries3[j][0]] = entries3[j][1];
                      }
                    }
                    ret.version = v;
                  }
                }
                break;
              default:
                return void 0;
            }
          }
          if (requiredCount > 0) {
            return void 0;
          }
          return ret;
        }
      )
    };
    Reprs = {
      "CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)": Kinds.Link,
      "CarV1HeaderOrV2Pragma > roots (anon)": (
        /** @returns {undefined|any} */
        (obj) => {
          if (Kinds.List(obj) === void 0) {
            return void 0;
          }
          for (let i = 0; i < obj.length; i++) {
            let v = obj[i];
            v = Reprs["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v);
            if (v === void 0) {
              return void 0;
            }
            if (v !== obj[i]) {
              const ret = obj.slice(0, i);
              for (let j = i; j < obj.length; j++) {
                let v2 = obj[j];
                v2 = Reprs["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v2);
                if (v2 === void 0) {
                  return void 0;
                }
                ret.push(v2);
              }
              return ret;
            }
          }
          return obj;
        }
      ),
      Int: Kinds.Int,
      CarV1HeaderOrV2Pragma: (
        /** @returns {undefined|any} */
        (obj) => {
          if (Kinds.Map(obj) === void 0) {
            return void 0;
          }
          const entries3 = Object.entries(obj);
          let ret = obj;
          let requiredCount = 1;
          for (let i = 0; i < entries3.length; i++) {
            const [key, value] = entries3[i];
            switch (key) {
              case "roots":
                {
                  const v = Reprs["CarV1HeaderOrV2Pragma > roots (anon)"](value);
                  if (v === void 0) {
                    return void 0;
                  }
                  if (v !== value || ret !== obj) {
                    if (ret === obj) {
                      ret = {};
                      for (let j = 0; j < i; j++) {
                        ret[entries3[j][0]] = entries3[j][1];
                      }
                    }
                    ret.roots = v;
                  }
                }
                break;
              case "version":
                {
                  requiredCount--;
                  const v = Reprs.Int(value);
                  if (v === void 0) {
                    return void 0;
                  }
                  if (v !== value || ret !== obj) {
                    if (ret === obj) {
                      ret = {};
                      for (let j = 0; j < i; j++) {
                        ret[entries3[j][0]] = entries3[j][1];
                      }
                    }
                    ret.version = v;
                  }
                }
                break;
              default:
                return void 0;
            }
          }
          if (requiredCount > 0) {
            return void 0;
          }
          return ret;
        }
      )
    };
    CarV1HeaderOrV2Pragma = {
      toTyped: Types.CarV1HeaderOrV2Pragma,
      toRepresentation: Reprs.CarV1HeaderOrV2Pragma
    };
  }
});

// ../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/buffer-decoder.js
function readHeader(reader, strictVersion) {
  const length5 = decodeVarint2(reader.upTo(8), reader);
  if (length5 === 0) {
    throw new Error("Invalid CAR header (zero length)");
  }
  const header = reader.exactly(length5, true);
  const block = decode18(header);
  if (CarV1HeaderOrV2Pragma.toTyped(block) === void 0) {
    throw new Error("Invalid CAR header format");
  }
  if (block.version !== 1 && block.version !== 2 || strictVersion !== void 0 && block.version !== strictVersion) {
    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== void 0 ? ` (expected ${strictVersion})` : ""}`);
  }
  if (block.version === 1) {
    if (!Array.isArray(block.roots)) {
      throw new Error("Invalid CAR header format");
    }
    return block;
  }
  if (block.roots !== void 0) {
    throw new Error("Invalid CAR header format");
  }
  const v2Header = decodeV2Header(reader.exactly(V2_HEADER_LENGTH, true));
  reader.seek(v2Header.dataOffset - reader.pos);
  const v1Header = readHeader(reader, 1);
  return Object.assign(v1Header, v2Header);
}
function readCid(reader) {
  const first2 = reader.exactly(2, false);
  if (first2[0] === CIDV0_BYTES.SHA2_256 && first2[1] === CIDV0_BYTES.LENGTH) {
    const bytes3 = reader.exactly(34, true);
    const multihash2 = decode17(bytes3);
    return CID2.create(0, CIDV0_BYTES.DAG_PB, multihash2);
  }
  const version3 = decodeVarint2(reader.upTo(8), reader);
  if (version3 !== 1) {
    throw new Error(`Unexpected CID version (${version3})`);
  }
  const codec = decodeVarint2(reader.upTo(8), reader);
  const bytes2 = reader.exactly(getMultihashLength(reader.upTo(8)), true);
  const multihash = decode17(bytes2);
  return CID2.create(version3, codec, multihash);
}
function readBlockHead(reader) {
  const start = reader.pos;
  let length5 = decodeVarint2(reader.upTo(8), reader);
  if (length5 === 0) {
    throw new Error("Invalid CAR section (zero length)");
  }
  length5 += reader.pos - start;
  const cid = readCid(reader);
  const blockLength2 = length5 - Number(reader.pos - start);
  return { cid, length: length5, blockLength: blockLength2 };
}
function fromBytes2(bytes2) {
  let reader = bytesReader(bytes2);
  const header = readHeader(reader);
  if (header.version === 2) {
    const v1length = reader.pos - header.dataOffset;
    reader = limitReader(reader, header.dataSize - v1length);
  }
  const blocks = [];
  while (reader.upTo(8).length > 0) {
    const { cid, blockLength: blockLength2 } = readBlockHead(reader);
    blocks.push({ cid, bytes: reader.exactly(blockLength2, true) });
  }
  return {
    header,
    blocks
  };
}
function bytesReader(bytes2) {
  let pos = 0;
  return {
    upTo(length5) {
      return bytes2.subarray(pos, pos + Math.min(length5, bytes2.length - pos));
    },
    exactly(length5, seek = false) {
      if (length5 > bytes2.length - pos) {
        throw new Error("Unexpected end of data");
      }
      const out = bytes2.subarray(pos, pos + length5);
      if (seek) {
        pos += length5;
      }
      return out;
    },
    seek(length5) {
      pos += length5;
    },
    get pos() {
      return pos;
    }
  };
}
function limitReader(reader, byteLimit) {
  let bytesRead = 0;
  return {
    upTo(length5) {
      let bytes2 = reader.upTo(length5);
      if (bytes2.length + bytesRead > byteLimit) {
        bytes2 = bytes2.subarray(0, byteLimit - bytesRead);
      }
      return bytes2;
    },
    exactly(length5, seek = false) {
      const bytes2 = reader.exactly(length5, seek);
      if (bytes2.length + bytesRead > byteLimit) {
        throw new Error("Unexpected end of data");
      }
      if (seek) {
        bytesRead += length5;
      }
      return bytes2;
    },
    seek(length5) {
      bytesRead += length5;
      reader.seek(length5);
    },
    get pos() {
      return reader.pos;
    }
  };
}
var init_buffer_decoder = __esm({
  "../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/buffer-decoder.js"() {
    init_src5();
    init_cid2();
    init_digest3();
    init_decoder_common();
    init_header_validator();
  }
});

// ../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/buffer-reader-browser.js
var CarBufferReader;
var init_buffer_reader_browser = __esm({
  "../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/buffer-reader-browser.js"() {
    init_buffer_decoder();
    CarBufferReader = class _CarBufferReader {
      /**
       * @constructs CarBufferReader
       * @param {CarHeader|CarV2Header} header
       * @param {Block[]} blocks
       */
      constructor(header, blocks) {
        this._header = header;
        this._blocks = blocks;
        this._cids = void 0;
      }
      /**
       * @property version
       * @memberof CarBufferReader
       * @instance
       */
      get version() {
        return this._header.version;
      }
      /**
       * Get the list of roots defined by the CAR referenced by this reader. May be
       * zero or more `CID`s.
       *
       * @function
       * @memberof CarBufferReader
       * @instance
       * @returns {CID[]}
       */
      getRoots() {
        return this._header.roots;
      }
      /**
       * Check whether a given `CID` exists within the CAR referenced by this
       * reader.
       *
       * @function
       * @memberof CarBufferReader
       * @instance
       * @param {CID} key
       * @returns {boolean}
       */
      has(key) {
        return this._blocks.some((b) => b.cid.equals(key));
      }
      /**
       * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR
       * referenced by this reader matching the provided `CID`. In the case where
       * the provided `CID` doesn't exist within the CAR, `undefined` will be
       * returned.
       *
       * @function
       * @memberof CarBufferReader
       * @instance
       * @param {CID} key
       * @returns {Block | undefined}
       */
      get(key) {
        return this._blocks.find((b) => b.cid.equals(key));
      }
      /**
       * Returns a `Block[]` of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within
       * the CAR referenced by this reader.
       *
       * @function
       * @memberof CarBufferReader
       * @instance
       * @returns {Block[]}
       */
      blocks() {
        return this._blocks;
      }
      /**
       * Returns a `CID[]` of the `CID`s contained within the CAR referenced by this reader.
       *
       * @function
       * @memberof CarBufferReader
       * @instance
       * @returns {CID[]}
       */
      cids() {
        if (!this._cids) {
          this._cids = this._blocks.map((b) => b.cid);
        }
        return this._cids;
      }
      /**
       * Instantiate a {@link CarBufferReader} from a `Uint8Array` blob. This performs a
       * decode fully in memory and maintains the decoded state in memory for full
       * access to the data via the `CarReader` API.
       *
       * @static
       * @memberof CarBufferReader
       * @param {Uint8Array} bytes
       * @returns {CarBufferReader}
       */
      static fromBytes(bytes2) {
        if (!(bytes2 instanceof Uint8Array)) {
          throw new TypeError("fromBytes() requires a Uint8Array");
        }
        const { header, blocks } = fromBytes2(bytes2);
        return new _CarBufferReader(header, blocks);
      }
    };
  }
});

// ../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/buffer-reader.js
var import_fs, fsread, CarBufferReader2;
var init_buffer_reader = __esm({
  "../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/buffer-reader.js"() {
    import_fs = __toESM(require("fs"), 1);
    init_buffer_reader_browser();
    fsread = import_fs.default.readSync;
    CarBufferReader2 = class extends CarBufferReader {
      /**
       * Reads a block directly from a file descriptor for an open CAR file. This
       * function is **only available in Node.js** and not a browser environment.
       *
       * This function can be used in connection with {@link CarIndexer} which emits
       * the `BlockIndex` objects that are required by this function.
       *
       * The user is responsible for opening and closing the file used in this call.
       *
       * @static
       * @memberof CarBufferReader
       * @param {number} fd - A file descriptor from the
       * Node.js `fs` module. An integer, from `fs.open()`.
       * @param {BlockIndex} blockIndex - An index pointing to the location of the
       * Block required. This `BlockIndex` should take the form:
       * `{cid:CID, blockLength:number, blockOffset:number}`.
       * @returns {Block} A `{ cid:CID, bytes:Uint8Array }` pair.
       */
      static readRaw(fd, blockIndex) {
        const { cid, blockLength: blockLength2, blockOffset } = blockIndex;
        const bytes2 = new Uint8Array(blockLength2);
        let read10;
        if (typeof fd === "number") {
          read10 = fsread(fd, bytes2, 0, blockLength2, blockOffset);
        } else {
          throw new TypeError("Bad fd");
        }
        if (read10 !== blockLength2) {
          throw new Error(`Failed to read entire block (${read10} instead of ${blockLength2})`);
        }
        return { cid, bytes: bytes2 };
      }
    };
  }
});

// ../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/length.js
function tokensToLength(tokens, encoders = cborEncoders3, options = defaultEncodeOptions5) {
  if (Array.isArray(tokens)) {
    let len = 0;
    for (const token of tokens) {
      len += tokensToLength(token, encoders, options);
    }
    return len;
  } else {
    const encoder3 = encoders[tokens.type.major];
    if (encoder3.encodedSize === void 0 || typeof encoder3.encodedSize !== "function") {
      throw new Error(`Encoder for ${tokens.type.name} does not have an encodedSize()`);
    }
    return encoder3.encodedSize(tokens, options);
  }
}
var cborEncoders3, defaultEncodeOptions5;
var init_length = __esm({
  "../../node_modules/.pnpm/cborg@4.2.3/node_modules/cborg/lib/length.js"() {
    init_encode3();
    init_jump2();
    cborEncoders3 = makeCborEncoders2();
    defaultEncodeOptions5 = {
      float64: false,
      quickEncodeToken: quickEncodeToken2
    };
  }
});

// ../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/buffer-writer.js
var import_varint5, CarBufferWriter, addRoot, blockLength, addBlock, close, resizeHeader, writeBytes, writeHeader, headerPreludeTokens, CID_TAG, calculateHeaderLength, headerLength, createWriter;
var init_buffer_writer = __esm({
  "../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/buffer-writer.js"() {
    init_src5();
    init_cborg2();
    init_length();
    import_varint5 = __toESM(require_varint3(), 1);
    CarBufferWriter = class {
      /**
       * @param {Uint8Array} bytes
       * @param {number} headerSize
       */
      constructor(bytes2, headerSize) {
        this.bytes = bytes2;
        this.byteOffset = headerSize;
        this.roots = [];
        this.headerSize = headerSize;
      }
      /**
       * Add a root to this writer, to be used to create a header when the CAR is
       * finalized with {@link CarBufferWriter.close `close()`}
       *
       * @param {CID} root
       * @param {{resize?:boolean}} [options]
       * @returns {CarBufferWriter}
       */
      addRoot(root2, options) {
        addRoot(this, root2, options);
        return this;
      }
      /**
       * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.
       * Throws if there is not enough capacity.
       *
       * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.
       * @returns {CarBufferWriter}
       */
      write(block) {
        addBlock(this, block);
        return this;
      }
      /**
       * Finalize the CAR and return it as a `Uint8Array`.
       *
       * @param {object} [options]
       * @param {boolean} [options.resize]
       * @returns {Uint8Array}
       */
      close(options) {
        return close(this, options);
      }
    };
    addRoot = (writer, root2, options = {}) => {
      const { resize = false } = options;
      const { bytes: bytes2, headerSize, byteOffset, roots } = writer;
      writer.roots.push(root2);
      const size5 = headerLength(writer);
      if (size5 > headerSize) {
        if (size5 - headerSize + byteOffset < bytes2.byteLength) {
          if (resize) {
            resizeHeader(writer, size5);
          } else {
            roots.pop();
            throw new RangeError(`Header of size ${headerSize} has no capacity for new root ${root2}.
  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`);
          }
        } else {
          roots.pop();
          throw new RangeError(`Buffer has no capacity for a new root ${root2}`);
        }
      }
    };
    blockLength = ({ cid, bytes: bytes2 }) => {
      const size5 = cid.bytes.byteLength + bytes2.byteLength;
      return import_varint5.default.encodingLength(size5) + size5;
    };
    addBlock = (writer, { cid, bytes: bytes2 }) => {
      const byteLength = cid.bytes.byteLength + bytes2.byteLength;
      const size5 = import_varint5.default.encode(byteLength);
      if (writer.byteOffset + size5.length + byteLength > writer.bytes.byteLength) {
        throw new RangeError("Buffer has no capacity for this block");
      } else {
        writeBytes(writer, size5);
        writeBytes(writer, cid.bytes);
        writeBytes(writer, bytes2);
      }
    };
    close = (writer, options = {}) => {
      const { resize = false } = options;
      const { roots, bytes: bytes2, byteOffset, headerSize } = writer;
      const headerBytes = encode15({ version: 1, roots });
      const varintBytes = import_varint5.default.encode(headerBytes.length);
      const size5 = varintBytes.length + headerBytes.byteLength;
      const offset2 = headerSize - size5;
      if (offset2 === 0) {
        writeHeader(writer, varintBytes, headerBytes);
        return bytes2.subarray(0, byteOffset);
      } else if (resize) {
        resizeHeader(writer, size5);
        writeHeader(writer, varintBytes, headerBytes);
        return bytes2.subarray(0, writer.byteOffset);
      } else {
        throw new RangeError(`Header size was overestimated.
You can use close({ resize: true }) to resize header`);
      }
    };
    resizeHeader = (writer, byteLength) => {
      const { bytes: bytes2, headerSize } = writer;
      bytes2.set(bytes2.subarray(headerSize, writer.byteOffset), byteLength);
      writer.byteOffset += byteLength - headerSize;
      writer.headerSize = byteLength;
    };
    writeBytes = (writer, bytes2) => {
      writer.bytes.set(bytes2, writer.byteOffset);
      writer.byteOffset += bytes2.length;
    };
    writeHeader = ({ bytes: bytes2 }, varint9, header) => {
      bytes2.set(varint9);
      bytes2.set(header, varint9.length);
    };
    headerPreludeTokens = [
      new Token2(Type2.map, 2),
      new Token2(Type2.string, "version"),
      new Token2(Type2.uint, 1),
      new Token2(Type2.string, "roots")
    ];
    CID_TAG = new Token2(Type2.tag, 42);
    calculateHeaderLength = (rootLengths) => {
      const tokens = [...headerPreludeTokens];
      tokens.push(new Token2(Type2.array, rootLengths.length));
      for (const rootLength of rootLengths) {
        tokens.push(CID_TAG);
        tokens.push(new Token2(Type2.bytes, { length: rootLength + 1 }));
      }
      const length5 = tokensToLength(tokens);
      return import_varint5.default.encodingLength(length5) + length5;
    };
    headerLength = ({ roots }) => calculateHeaderLength(roots.map((cid) => cid.bytes.byteLength));
    createWriter = (buffer3, options = {}) => {
      const {
        roots = [],
        byteOffset = 0,
        byteLength = buffer3.byteLength,
        headerSize = headerLength({ roots })
      } = options;
      const bytes2 = new Uint8Array(buffer3, byteOffset, byteLength);
      const writer = new CarBufferWriter(bytes2, headerSize);
      for (const root2 of roots) {
        writer.addRoot(root2);
      }
      return writer;
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/car.js
var car_exports = {};
__export(car_exports, {
  code: () => code15,
  contentType: () => contentType2,
  createWriter: () => createWriter2,
  decode: () => decode31,
  encode: () => encode27,
  link: () => link2,
  name: () => name12,
  write: () => write3
});
var contentType2, name12, code15, Writer, createWriter2, encode27, decode31, link2, write3;
var init_car = __esm({
  "../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/car.js"() {
    init_buffer_reader();
    init_buffer_writer();
    init_base323();
    init_link2();
    init_sha22();
    contentType2 = "application/vnd.ipld.car";
    name12 = "CAR";
    code15 = 514;
    Writer = class {
      /**
       * @param {API.IPLDBlock[]} blocks
       * @param {number} byteLength
       */
      constructor(blocks = [], byteLength = 0) {
        this.written = /* @__PURE__ */ new Set();
        this.blocks = blocks;
        this.byteLength = byteLength;
      }
      /**
       * @param {API.IPLDBlock[]} blocks
       */
      write(...blocks) {
        for (const block of blocks) {
          const id = block.cid.toString(base323);
          if (!this.written.has(id)) {
            this.blocks.push(block);
            this.byteLength += blockLength(
              /** @type {any} */
              block
            );
            this.written.add(id);
          }
        }
        return this;
      }
      /**
       * @param {API.IPLDBlock[]} rootBlocks
       */
      flush(...rootBlocks) {
        const roots = [];
        for (const block of rootBlocks.reverse()) {
          const id = block.cid.toString(base323);
          if (!this.written.has(id)) {
            this.blocks.unshift(block);
            this.byteLength += blockLength({
              cid: (
                /** @type {CarBufferWriter.CID} */
                block.cid
              ),
              bytes: block.bytes
            });
            this.written.add(id);
          }
          roots.unshift(
            /** @type {CarBufferWriter.CID} */
            block.cid
          );
        }
        this.byteLength += headerLength({ roots });
        const buffer3 = new ArrayBuffer(this.byteLength);
        const writer = createWriter(buffer3, { roots });
        for (
          const block of
          /** @type {CarBufferWriter.Block[]} */
          this.blocks
        ) {
          writer.write(block);
        }
        return writer.close();
      }
    };
    createWriter2 = () => new Writer();
    encode27 = ({ roots = [], blocks }) => {
      const writer = new Writer();
      if (blocks) {
        writer.write(...blocks.values());
      }
      return writer.flush(...roots);
    };
    decode31 = (bytes2) => {
      const reader = CarBufferReader2.fromBytes(bytes2);
      const roots = [];
      const blocks = /* @__PURE__ */ new Map();
      for (const root2 of reader.getRoots()) {
        const block = (
          /** @type {API.IPLDBlock} */
          reader.get(root2)
        );
        if (block) {
          roots.push(block);
        }
      }
      for (const block of reader.blocks()) {
        blocks.set(block.cid.toString(), block);
      }
      return { roots, blocks };
    };
    link2 = async (bytes2, { hasher = sha2562 } = {}) => {
      return (
        /** @type {API.Link<T, typeof code, typeof hasher.code>} */
        create5(code15, await hasher.digest(bytes2))
      );
    };
    write3 = async (data, options) => {
      const bytes2 = encode27(data);
      const cid = await link2(bytes2, options);
      return { bytes: bytes2, cid };
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema/type.js
var init_type = __esm({
  "../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema/type.js"() {
  }
});

// ../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/result.js
var ok, error, panic, fail2, Failure;
var init_result = __esm({
  "../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/result.js"() {
    ok = (value) => {
      if (value == null) {
        throw new TypeError(`ok(${value}) is not allowed, consider ok({}) instead`);
      } else {
        return { ok: value };
      }
    };
    error = (cause) => {
      if (cause == null) {
        throw new TypeError(
          `error(${cause}) is not allowed, consider passing an error instead`
        );
      } else {
        return { error: cause };
      }
    };
    panic = (message) => {
      throw new Failure(message);
    };
    fail2 = (message) => ({ error: new Failure(message) });
    Failure = class extends Error {
      describe() {
        return this.toString();
      }
      get message() {
        return this.describe();
      }
      toJSON() {
        const { name: name20, message, stack } = this;
        return { name: name20, message, stack };
      }
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema/schema.js
var API, Never, never, Unknown, unknown, Nullable, nullable, Optional, Default, optional, ArrayOf, array, Tuple, tuple, Dictionary, dictionary, Enum, createEnum, Union, union, or4, Intersection, intersection, and, Boolean2, anyBoolean, boolean, UnknownNumber, AnyNumber, anyNumber, number, RefinedNumber, LessThan, lessThan, GreaterThan, greaterThan, Integer, anyInteger, integer, MAX_UINT64, Uint64Schema, Uint64, uint64, Float, anyFloat, float, UnknownString, RefinedString, AnyString, anyString, string2, BytesSchema, Bytes, bytes, StartsWith, startsWith, EndsWith, endsWith, Refine, refine, Literal, literal, Struct, struct, Variant, variant, error2, SchemaError, TypeError2, typeError, toString6, LiteralError, ElementError, FieldError, memberError, UnionError, IntersectionError, indent, li;
var init_schema2 = __esm({
  "../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema/schema.js"() {
    init_result();
    init_type();
    API = class {
      /**
       * @param {Settings} settings
       */
      constructor(settings) {
        this.settings = settings;
      }
      toString() {
        return `new ${this.constructor.name}()`;
      }
      /**
       * @abstract
       * @param {I} input
       * @param {Settings} settings
       * @returns {Schema.ReadResult<T>}
       */
      /* c8 ignore next 3 */
      readWith(input10, settings) {
        throw new Error(`Abstract method readWith must be implemented by subclass`);
      }
      /**
       * @param {I} input
       * @returns {Schema.ReadResult<T>}
       */
      read(input10) {
        return this.readWith(input10, this.settings);
      }
      /**
       * @param {unknown} value
       * @returns {value is T}
       */
      is(value) {
        return !this.read(
          /** @type {I} */
          value
        )?.error;
      }
      /**
       * @param {unknown} value
       * @return {T}
       */
      from(value) {
        const result = this.read(
          /** @type {I} */
          value
        );
        if (result.error) {
          throw result.error;
        } else {
          return result.ok;
        }
      }
      /**
       * @returns {Schema.Schema<T|undefined, I>}
       */
      optional() {
        return optional(this);
      }
      /**
       * @returns {Schema.Schema<T|null, I>}
       */
      nullable() {
        return nullable(this);
      }
      /**
       * @returns {Schema.Schema<T[], I>}
       */
      array() {
        return array(this);
      }
      /**
       * @template U
       * @param {Schema.Reader<U, I>} schema
       * @returns {Schema.Schema<T | U, I>}
       */
      or(schema5) {
        return or4(this, schema5);
      }
      /**
       * @template U
       * @param {Schema.Reader<U, I>} schema
       * @returns {Schema.Schema<T & U, I>}
       */
      and(schema5) {
        return and(this, schema5);
      }
      /**
       * @template {T} U
       * @param {Schema.Reader<U, T>} schema
       * @returns {Schema.Schema<U, I>}
       */
      refine(schema5) {
        return refine(this, schema5);
      }
      /**
       * @template {string} Kind
       * @param {Kind} [kind]
       * @returns {Schema.Schema<Schema.Branded<T, Kind>, I>}
       */
      brand(kind) {
        return (
          /** @type {Schema.Schema<Schema.Branded<T, Kind>, I>} */
          this
        );
      }
      /**
       * @param {Schema.NotUndefined<T>} value
       * @returns {Schema.DefaultSchema<Schema.NotUndefined<T>, I>}
       */
      default(value) {
        const fallback = this.from(value);
        if (fallback === void 0) {
          throw new Error(`Value of type undefined is not a valid default`);
        }
        const schema5 = new Default({
          reader: (
            /** @type {Schema.Reader<T, I>} */
            this
          ),
          value: (
            /** @type {Schema.NotUndefined<T>} */
            fallback
          )
        });
        return (
          /** @type {Schema.DefaultSchema<Schema.NotUndefined<T>, I>} */
          schema5
        );
      }
    };
    Never = class extends API {
      toString() {
        return "never()";
      }
      /**
       * @param {I} input
       * @returns {Schema.ReadResult<never>}
       */
      read(input10) {
        return typeError({ expect: "never", actual: input10 });
      }
    };
    never = () => new Never();
    Unknown = class extends API {
      /**
       * @param {I} input
       */
      read(input10) {
        return (
          /** @type {Schema.ReadResult<unknown>}*/
          { ok: input10 }
        );
      }
      toString() {
        return "unknown()";
      }
    };
    unknown = () => new Unknown();
    Nullable = class extends API {
      /**
       * @param {I} input
       * @param {Schema.Reader<O, I>} reader
       */
      readWith(input10, reader) {
        const result = reader.read(input10);
        if (result.error) {
          return input10 === null ? { ok: null } : {
            error: new UnionError({
              causes: [
                result.error,
                typeError({ expect: "null", actual: input10 }).error
              ]
            })
          };
        } else {
          return result;
        }
      }
      toString() {
        return `${this.settings}.nullable()`;
      }
    };
    nullable = (schema5) => new Nullable(schema5);
    Optional = class extends API {
      optional() {
        return this;
      }
      /**
       * @param {I} input
       * @param {Schema.Reader<O, I>} reader
       * @returns {Schema.ReadResult<O|undefined>}
       */
      readWith(input10, reader) {
        const result = reader.read(input10);
        return result.error && input10 === void 0 ? { ok: void 0 } : result;
      }
      toString() {
        return `${this.settings}.optional()`;
      }
    };
    Default = class extends API {
      /**
       * @returns {Schema.DefaultSchema<O & Schema.NotUndefined<O>, I>}
       */
      optional() {
        return (
          /** @type {Schema.DefaultSchema<O & Schema.NotUndefined<O>, I>} */
          this
        );
      }
      /**
       * @param {I} input
       * @param {object} options
       * @param {Schema.Reader<O|undefined, I>} options.reader
       * @param {O} options.value
       * @returns {Schema.ReadResult<O>}
       */
      readWith(input10, { reader, value }) {
        if (input10 === void 0) {
          return (
            /** @type {Schema.ReadResult<O>} */
            { ok: value }
          );
        } else {
          const result = reader.read(input10);
          return result.error ? result : result.ok !== void 0 ? (
            // We just checked that result.ok is not undefined but still needs
            // reassurance
            /** @type {Schema.ReadResult<O>} */
            result
          ) : { ok: value };
        }
      }
      toString() {
        return `${this.settings.reader}.default(${JSON.stringify(
          this.settings.value
        )})`;
      }
      get value() {
        return this.settings.value;
      }
    };
    optional = (schema5) => new Optional(schema5);
    ArrayOf = class extends API {
      /**
       * @param {I} input
       * @param {Schema.Reader<O, I>} schema
       */
      readWith(input10, schema5) {
        if (!Array.isArray(input10)) {
          return typeError({ expect: "array", actual: input10 });
        }
        const results = [];
        for (const [index2, value] of input10.entries()) {
          const result = schema5.read(value);
          if (result.error) {
            return memberError({ at: index2, cause: result.error });
          } else {
            results.push(result.ok);
          }
        }
        return { ok: results };
      }
      get element() {
        return this.settings;
      }
      toString() {
        return `array(${this.element})`;
      }
    };
    array = (schema5) => new ArrayOf(schema5);
    Tuple = class extends API {
      /**
       * @param {I} input
       * @param {U} shape
       * @returns {Schema.ReadResult<Schema.InferTuple<U>>}
       */
      readWith(input10, shape) {
        if (!Array.isArray(input10)) {
          return typeError({ expect: "array", actual: input10 });
        }
        if (input10.length !== this.shape.length) {
          return error2(`Array must contain exactly ${this.shape.length} elements`);
        }
        const results = [];
        for (const [index2, reader] of shape.entries()) {
          const result = reader.read(input10[index2]);
          if (result.error) {
            return memberError({ at: index2, cause: result.error });
          } else {
            results[index2] = result.ok;
          }
        }
        return { ok: (
          /** @type {Schema.InferTuple<U>} */
          results
        ) };
      }
      /** @type {U} */
      get shape() {
        return this.settings;
      }
      toString() {
        return `tuple([${this.shape.map((reader) => reader.toString()).join(", ")}])`;
      }
    };
    tuple = (shape) => new Tuple(shape);
    Dictionary = class _Dictionary extends API {
      /**
       * @param {I} input
       * @param {object} schema
       * @param {Schema.Reader<K, string>} schema.key
       * @param {Schema.Reader<V, I>} schema.value
       */
      readWith(input10, { key, value }) {
        if (typeof input10 != "object" || input10 === null || Array.isArray(input10)) {
          return typeError({
            expect: "dictionary",
            actual: input10
          });
        }
        const dict = (
          /** @type {Schema.Dictionary<K, V>} */
          {}
        );
        for (const [k, v] of Object.entries(input10)) {
          const keyResult = key.read(k);
          if (keyResult.error) {
            return memberError({ at: k, cause: keyResult.error });
          }
          const valueResult = value.read(v);
          if (valueResult.error) {
            return memberError({ at: k, cause: valueResult.error });
          }
          if (valueResult.ok !== void 0) {
            dict[keyResult.ok] = valueResult.ok;
          }
        }
        return { ok: dict };
      }
      get key() {
        return this.settings.key;
      }
      get value() {
        return this.settings.value;
      }
      partial() {
        const { key, value } = this.settings;
        return new _Dictionary({
          key,
          value: optional(value)
        });
      }
      toString() {
        return `dictionary(${this.settings})`;
      }
    };
    dictionary = ({ value, key }) => new Dictionary({
      value,
      key: key || /** @type {Schema.Reader<K, string>} */
      string2()
    });
    Enum = class extends API {
      /**
       * @param {I} input
       * @param {{type:string, variants:Set<T[number]>}} settings
       * @returns {Schema.ReadResult<T[number]>}
       */
      readWith(input10, { variants, type: type2 }) {
        if (variants.has(input10)) {
          return (
            /** @type {Schema.ReadResult<T[number]>} */
            { ok: input10 }
          );
        } else {
          return typeError({ expect: type2, actual: input10 });
        }
      }
      toString() {
        return this.settings.type;
      }
    };
    createEnum = (variants) => new Enum({
      type: variants.join("|"),
      variants: new Set(variants)
    });
    Union = class extends API {
      /**
       * @param {I} input
       * @param {U} variants
       */
      readWith(input10, variants) {
        const causes = [];
        for (const reader of variants) {
          const result = reader.read(input10);
          if (result.error) {
            causes.push(result.error);
          } else {
            return (
              /** @type {Schema.ReadResult<Schema.InferUnion<U>>} */
              result
            );
          }
        }
        return { error: new UnionError({ causes }) };
      }
      get variants() {
        return this.settings;
      }
      toString() {
        return `union([${this.variants.map((type2) => type2.toString()).join(", ")}])`;
      }
    };
    union = (variants) => new Union(variants);
    or4 = (left, right) => union([left, right]);
    Intersection = class extends API {
      /**
       * @param {I} input
       * @param {U} schemas
       * @returns {Schema.ReadResult<Schema.InferIntersection<U>>}
       */
      readWith(input10, schemas) {
        const causes = [];
        for (const schema5 of schemas) {
          const result = schema5.read(input10);
          if (result.error) {
            causes.push(result.error);
          }
        }
        return causes.length > 0 ? { error: new IntersectionError({ causes }) } : (
          /** @type {Schema.ReadResult<Schema.InferIntersection<U>>} */
          {
            ok: input10
          }
        );
      }
      toString() {
        return `intersection([${this.settings.map((type2) => type2.toString()).join(",")}])`;
      }
    };
    intersection = (variants) => new Intersection(variants);
    and = (left, right) => intersection([left, right]);
    Boolean2 = class extends API {
      /**
       * @param {I} input
       */
      readWith(input10) {
        switch (input10) {
          case true:
          case false:
            return { ok: (
              /** @type {boolean} */
              input10
            ) };
          default:
            return typeError({
              expect: "boolean",
              actual: input10
            });
        }
      }
      toString() {
        return `boolean()`;
      }
    };
    anyBoolean = new Boolean2();
    boolean = () => anyBoolean;
    UnknownNumber = class extends API {
      /**
       * @param {number} n
       */
      greaterThan(n) {
        return this.refine(greaterThan(n));
      }
      /**
       * @param {number} n
       */
      lessThan(n) {
        return this.refine(lessThan(n));
      }
      /**
       * @template {O} U
       * @param {Schema.Reader<U, O>} schema
       * @returns {Schema.NumberSchema<U, I>}
       */
      refine(schema5) {
        return new RefinedNumber({ base: this, schema: schema5 });
      }
    };
    AnyNumber = class extends UnknownNumber {
      /**
       * @param {I} input
       * @returns {Schema.ReadResult<number>}
       */
      readWith(input10) {
        return typeof input10 === "number" ? { ok: input10 } : typeError({ expect: "number", actual: input10 });
      }
      toString() {
        return `number()`;
      }
    };
    anyNumber = new AnyNumber();
    number = () => anyNumber;
    RefinedNumber = class extends UnknownNumber {
      /**
       * @param {I} input
       * @param {{base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}} settings
       * @returns {Schema.ReadResult<O>}
       */
      readWith(input10, { base: base6, schema: schema5 }) {
        const result = base6.read(input10);
        return result.error ? result : schema5.read(result.ok);
      }
      toString() {
        return `${this.settings.base}.refine(${this.settings.schema})`;
      }
    };
    LessThan = class extends API {
      /**
       * @param {T} input
       * @param {number} number
       * @returns {Schema.ReadResult<T>}
       */
      readWith(input10, number2) {
        if (input10 < number2) {
          return { ok: input10 };
        } else {
          return error2(`Expected ${input10} < ${number2}`);
        }
      }
      toString() {
        return `lessThan(${this.settings})`;
      }
    };
    lessThan = (n) => new LessThan(n);
    GreaterThan = class extends API {
      /**
       * @param {T} input
       * @param {number} number
       * @returns {Schema.ReadResult<T>}
       */
      readWith(input10, number2) {
        if (input10 > number2) {
          return { ok: input10 };
        } else {
          return error2(`Expected ${input10} > ${number2}`);
        }
      }
      toString() {
        return `greaterThan(${this.settings})`;
      }
    };
    greaterThan = (n) => new GreaterThan(n);
    Integer = {
      /**
       * @param {number} input
       * @returns {Schema.ReadResult<Schema.Integer>}
       */
      read(input10) {
        return Number.isInteger(input10) ? { ok: (
          /** @type {Schema.Integer} */
          input10
        ) } : typeError({
          expect: "integer",
          actual: input10
        });
      },
      toString() {
        return `Integer`;
      }
    };
    anyInteger = anyNumber.refine(Integer);
    integer = () => anyInteger;
    MAX_UINT64 = 2n ** 64n - 1n;
    Uint64Schema = class extends API {
      /**
       * @param {I} input
       * @returns {Schema.ReadResult<O>}
       */
      read(input10) {
        switch (typeof input10) {
          case "bigint":
            return input10 > MAX_UINT64 ? error2(`Integer is too big for uint64, ${input10} > ${MAX_UINT64}`) : input10 < 0 ? error2(
              `Negative integer can not be represented as uint64, ${input10} < ${0}`
            ) : { ok: (
              /** @type {I & O} */
              input10
            ) };
          case "number":
            return !Number.isInteger(input10) ? typeError({
              expect: "uint64",
              actual: input10
            }) : input10 < 0 ? error2(
              `Negative integer can not be represented as uint64, ${input10} < ${0}`
            ) : { ok: (
              /** @type {O} */
              BigInt(input10)
            ) };
          default:
            return typeError({
              expect: "uint64",
              actual: input10
            });
        }
      }
      toString() {
        return `uint64`;
      }
    };
    Uint64 = new Uint64Schema();
    uint64 = () => Uint64;
    Float = {
      /**
       * @param {number} number
       * @returns {Schema.ReadResult<Schema.Float>}
       */
      read(number2) {
        return Number.isFinite(number2) ? { ok: (
          /** @type {Schema.Float} */
          number2
        ) } : typeError({
          expect: "Float",
          actual: number2
        });
      },
      toString() {
        return "Float";
      }
    };
    anyFloat = anyNumber.refine(Float);
    float = () => anyFloat;
    UnknownString = class extends API {
      /**
       * @template {O|unknown} U
       * @param {Schema.Reader<U, O>} schema
       * @returns {Schema.StringSchema<O & U, I>}
       */
      refine(schema5) {
        const other = (
          /** @type {Schema.Reader<U, O>} */
          schema5
        );
        const rest = new RefinedString({
          base: this,
          schema: other
        });
        return (
          /** @type {Schema.StringSchema<O & U, I>} */
          rest
        );
      }
      /**
       * @template {string} Prefix
       * @param {Prefix} prefix
       */
      startsWith(prefix2) {
        return this.refine(startsWith(prefix2));
      }
      /**
       * @template {string} Suffix
       * @param {Suffix} suffix
       */
      endsWith(suffix) {
        return this.refine(endsWith(suffix));
      }
      toString() {
        return `string()`;
      }
    };
    RefinedString = class extends UnknownString {
      /**
       * @param {I} input
       * @param {{base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}} settings
       * @returns {Schema.ReadResult<T & O>}
       */
      readWith(input10, { base: base6, schema: schema5 }) {
        const result = base6.read(input10);
        return result.error ? result : (
          /** @type {Schema.ReadResult<T & O>} */
          schema5.read(result.ok)
        );
      }
      toString() {
        return `${this.settings.base}.refine(${this.settings.schema})`;
      }
    };
    AnyString = class extends UnknownString {
      /**
       * @param {I} input
       * @returns {Schema.ReadResult<string>}
       */
      readWith(input10) {
        return typeof input10 === "string" ? { ok: input10 } : typeError({ expect: "string", actual: input10 });
      }
    };
    anyString = new AnyString();
    string2 = () => anyString;
    BytesSchema = class extends API {
      /**
       * @param {I} input
       * @returns {Schema.ReadResult<Uint8Array>}
       */
      readWith(input10) {
        if (input10 instanceof Uint8Array) {
          return { ok: input10 };
        } else {
          return typeError({ expect: "Uint8Array", actual: input10 });
        }
      }
    };
    Bytes = new BytesSchema();
    bytes = () => Bytes;
    StartsWith = class extends API {
      /**
       * @param {Body} input
       * @param {Prefix} prefix
       */
      readWith(input10, prefix2) {
        const result = input10.startsWith(prefix2) ? (
          /** @type {Schema.ReadResult<Body & `${Prefix}${Body}`>} */
          {
            ok: input10
          }
        ) : error2(`Expect string to start with "${prefix2}" instead got "${input10}"`);
        return result;
      }
      get prefix() {
        return this.settings;
      }
      toString() {
        return `startsWith("${this.prefix}")`;
      }
    };
    startsWith = (prefix2) => new StartsWith(prefix2);
    EndsWith = class extends API {
      /**
       * @param {Body} input
       * @param {Suffix} suffix
       */
      readWith(input10, suffix) {
        return input10.endsWith(suffix) ? (
          /** @type {Schema.ReadResult<Body & `${Body}${Suffix}`>} */
          {
            ok: input10
          }
        ) : error2(`Expect string to end with "${suffix}" instead got "${input10}"`);
      }
      get suffix() {
        return this.settings;
      }
      toString() {
        return `endsWith("${this.suffix}")`;
      }
    };
    endsWith = (suffix) => new EndsWith(suffix);
    Refine = class extends API {
      /**
       * @param {I} input
       * @param {{ base: Schema.Reader<T, I>, schema: Schema.Reader<U, T> }} settings
       */
      readWith(input10, { base: base6, schema: schema5 }) {
        const result = base6.read(input10);
        return result.error ? result : schema5.read(result.ok);
      }
      toString() {
        return `${this.settings.base}.refine(${this.settings.schema})`;
      }
    };
    refine = (base6, schema5) => new Refine({ base: base6, schema: schema5 });
    Literal = class extends API {
      /**
       * @param {I} input
       * @param {T} expect
       * @returns {Schema.ReadResult<T>}
       */
      readWith(input10, expect) {
        return input10 !== /** @type {unknown} */
        expect ? { error: new LiteralError({ expect, actual: input10 }) } : { ok: expect };
      }
      get value() {
        return (
          /** @type {Exclude<T, undefined>} */
          this.settings
        );
      }
      /**
       * @template {Schema.NotUndefined<T>} U
       * @param {U} value
       */
      default(value = (
        /** @type {U} */
        this.value
      )) {
        return super.default(value);
      }
      toString() {
        return `literal(${toString6(this.value)})`;
      }
    };
    literal = (value) => new Literal(value);
    Struct = class _Struct extends API {
      /**
       * @param {I} input
       * @param {U} shape
       * @returns {Schema.ReadResult<Schema.InferStruct<U>>}
       */
      readWith(input10, shape) {
        if (typeof input10 != "object" || input10 === null || Array.isArray(input10)) {
          return typeError({
            expect: "object",
            actual: input10
          });
        }
        const source = (
          /** @type {{[K in keyof U]: unknown}} */
          input10
        );
        const struct2 = (
          /** @type {{[K in keyof U]: Schema.Infer<U[K]>}} */
          {}
        );
        const entries3 = (
          /** @type {{[K in keyof U]: [K & string, U[K]]}[keyof U][]} */
          Object.entries(shape)
        );
        for (const [at2, reader] of entries3) {
          const result = reader.read(source[at2]);
          if (result.error) {
            return memberError({ at: at2, cause: result.error });
          } else if (result.ok !== void 0) {
            struct2[at2] = /** @type {Schema.Infer<U[typeof at]>} */
            result.ok;
          }
        }
        return { ok: struct2 };
      }
      /**
       * @returns {Schema.MapRepresentation<Partial<Schema.InferStruct<U>>> & Schema.StructSchema}
       */
      partial() {
        return new _Struct(
          Object.fromEntries(
            Object.entries(this.shape).map(([key, value]) => [key, optional(value)])
          )
        );
      }
      /** @type {U} */
      get shape() {
        return this.settings;
      }
      toString() {
        return [
          `struct({ `,
          ...Object.entries(this.shape).map(([key, schema5]) => `${key}: ${schema5}`).join(", "),
          ` })`
        ].join("");
      }
      /**
       * @param {Schema.InferStructSource<U>} data
       */
      create(data) {
        return this.from(data || {});
      }
      /**
       * @template {{[key:string]: Schema.Reader}} E
       * @param {E} extension
       * @returns {Schema.StructSchema<U & E, I>}
       */
      extend(extension) {
        return new _Struct({ ...this.shape, ...extension });
      }
    };
    struct = (fields) => {
      const shape = (
        /** @type {{[K in keyof U]: Schema.Reader<unknown, unknown>}} */
        {}
      );
      const entries3 = Object.entries(fields);
      for (const [key, field] of entries3) {
        switch (typeof field) {
          case "number":
          case "string":
          case "boolean":
            shape[key] = literal(field);
            break;
          case "object":
            shape[key] = field === null ? literal(null) : field;
            break;
          default:
            throw new Error(
              `Invalid struct field "${key}", expected schema or literal, instead got ${typeof field}`
            );
        }
      }
      return new Struct(
        /** @type {V} */
        shape
      );
    };
    Variant = class extends API {
      /**
       * @param {I} input
       * @param {U} variants
       * @returns {Schema.ReadResult<Schema.InferVariant<U>>}
       */
      readWith(input10, variants) {
        if (typeof input10 != "object" || input10 === null || Array.isArray(input10)) {
          return typeError({
            expect: "object",
            actual: input10
          });
        }
        const keys2 = (
          /** @type {Array<keyof input & keyof variants & string>} */
          Object.keys(input10)
        );
        const [key] = keys2.length === 1 ? keys2 : [];
        const reader = key ? variants[key] : void 0;
        if (reader) {
          const result = reader.read(input10[key]);
          return result.error ? memberError({ at: key, cause: result.error }) : { ok: (
            /** @type {Schema.InferVariant<U>} */
            { [key]: result.ok }
          ) };
        } else if (variants._) {
          const result = variants._.read(input10);
          return result.error ? result : { ok: (
            /** @type {Schema.InferVariant<U>} */
            { _: result.ok }
          ) };
        } else if (key) {
          return error2(
            `Expected an object with one of the these keys: ${Object.keys(variants).sort().join(", ")} instead got object with key ${key}`
          );
        } else {
          return error2(
            "Expected an object with a single key instead got object with keys " + keys2.sort().join(", ")
          );
        }
      }
      /**
       * @template [E=never]
       * @param {I} input
       * @param {E} [fallback]
       */
      match(input10, fallback) {
        const result = this.read(input10);
        if (result.error) {
          if (fallback !== void 0) {
            return [null, fallback];
          } else {
            throw result.error;
          }
        } else {
          const [key] = Object.keys(result.ok);
          const value = result.ok[key];
          return (
            /** @type {any} */
            [key, value]
          );
        }
      }
      /**
       * @template {Schema.InferVariant<U>} O
       * @param {O} source
       * @returns {O}
       */
      create(source) {
        return (
          /** @type {O} */
          this.from(source)
        );
      }
    };
    variant = (variants) => new Variant(variants);
    error2 = (message) => ({ error: new SchemaError(message) });
    SchemaError = class extends Failure {
      get name() {
        return "SchemaError";
      }
      /* c8 ignore next 3 */
      describe() {
        return this.name;
      }
    };
    TypeError2 = class extends SchemaError {
      /**
       * @param {{expect:string, actual:unknown}} data
       */
      constructor({ expect, actual }) {
        super();
        this.expect = expect;
        this.actual = actual;
      }
      get name() {
        return "TypeError";
      }
      describe() {
        return `Expected value of type ${this.expect} instead got ${toString6(
          this.actual
        )}`;
      }
    };
    typeError = (data) => ({ error: new TypeError2(data) });
    toString6 = (value) => {
      const type2 = typeof value;
      switch (type2) {
        case "boolean":
        case "string":
          return JSON.stringify(value);
        case "bigint":
          return `${value}n`;
        case "number":
        case "symbol":
        case "undefined":
          return String(value);
        case "object":
          return value === null ? "null" : Array.isArray(value) ? "array" : Symbol.toStringTag in /** @type {object} */
          value ? value[Symbol.toStringTag] : "object";
        default:
          return type2;
      }
    };
    LiteralError = class extends SchemaError {
      /**
       * @param {{
       * expect:string|number|boolean|null
       * actual:unknown
       * }} data
       */
      constructor({ expect, actual }) {
        super();
        this.expect = expect;
        this.actual = actual;
      }
      get name() {
        return "LiteralError";
      }
      describe() {
        return `Expected literal ${toString6(this.expect)} instead got ${toString6(
          this.actual
        )}`;
      }
    };
    ElementError = class extends SchemaError {
      /**
       * @param {{at:number, cause:Schema.Error}} data
       */
      constructor({ at: at2, cause }) {
        super();
        this.at = at2;
        this.cause = cause;
      }
      get name() {
        return "ElementError";
      }
      describe() {
        return [
          `Array contains invalid element at ${this.at}:`,
          li(this.cause.message)
        ].join("\n");
      }
    };
    FieldError = class extends SchemaError {
      /**
       * @param {{at:string, cause:Schema.Error}} data
       */
      constructor({ at: at2, cause }) {
        super();
        this.at = at2;
        this.cause = cause;
      }
      get name() {
        return "FieldError";
      }
      describe() {
        return [
          `Object contains invalid field "${this.at}":`,
          li(this.cause.message)
        ].join("\n");
      }
    };
    memberError = ({ at: at2, cause }) => typeof at2 === "string" ? { error: new FieldError({ at: at2, cause }) } : { error: new ElementError({ at: at2, cause }) };
    UnionError = class extends SchemaError {
      /**
       * @param {{causes: Schema.Error[]}} data
       */
      constructor({ causes }) {
        super();
        this.causes = causes;
      }
      get name() {
        return "UnionError";
      }
      describe() {
        const { causes } = this;
        return [
          `Value does not match any type of the union:`,
          ...causes.map((cause) => li(cause.message))
        ].join("\n");
      }
    };
    IntersectionError = class extends SchemaError {
      /**
       * @param {{causes: Schema.Error[]}} data
       */
      constructor({ causes }) {
        super();
        this.causes = causes;
      }
      get name() {
        return "IntersectionError";
      }
      describe() {
        const { causes } = this;
        return [
          `Value does not match following types of the intersection:`,
          ...causes.map((cause) => li(cause.message))
        ].join("\n");
      }
    };
    indent = (message, indent3 = "  ") => `${indent3}${message.split("\n").join(`
${indent3}`)}`;
    li = (message) => indent(`- ${message}`);
  }
});

// ../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema/uri.js
var uri_exports = {};
__export(uri_exports, {
  from: () => from11,
  match: () => match,
  read: () => read4,
  uri: () => uri
});
var URISchema, schema, uri, read4, match, from11;
var init_uri = __esm({
  "../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema/uri.js"() {
    init_schema2();
    URISchema = class extends API {
      /**
       * @param {unknown} input
       * @param {Partial<O>} options
       * @returns {Schema.ReadResult<API.URI<O['protocol']>>}
       */
      readWith(input10, { protocol } = {}) {
        if (typeof input10 !== "string" && !(input10 instanceof URL)) {
          return error2(
            `Expected URI but got ${input10 === null ? "null" : typeof input10}`
          );
        }
        try {
          const url = new URL(String(input10));
          if (protocol != null && url.protocol !== protocol) {
            return error2(`Expected ${protocol} URI instead got ${url.href}`);
          } else {
            return { ok: (
              /** @type {API.URI<O['protocol']>} */
              url.href
            ) };
          }
        } catch (_) {
          return error2(`Invalid URI`);
        }
      }
    };
    schema = new URISchema({});
    uri = () => schema;
    read4 = (input10) => schema.read(input10);
    match = (options) => new URISchema(options);
    from11 = (input10) => (
      /** @type {API.URI<`${Scheme}:`>} */
      schema.from(input10)
    );
  }
});

// ../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema/link.js
var link_exports2 = {};
__export(link_exports2, {
  create: () => create5,
  createLegacy: () => createLegacy,
  isLink: () => isLink,
  link: () => link3,
  match: () => match2,
  optional: () => optional2,
  parse: () => parse2,
  read: () => read5,
  schema: () => schema2
});
var LinkSchema, schema2, link3, match2, read5, optional2;
var init_link3 = __esm({
  "../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema/link.js"() {
    init_link2();
    init_schema2();
    LinkSchema = class extends API {
      /**
       *
       * @param {unknown} cid
       * @param {Settings<Code, Alg, Version>} settings
       * @returns {Schema.ReadResult<API.Link<unknown, Code, Alg, Version>>}
       */
      readWith(cid, { code: code25, multihash = {}, version: version3 }) {
        if (cid == null) {
          return error2(`Expected link but got ${cid} instead`);
        } else {
          if (!isLink(cid)) {
            return error2(`Expected link to be a CID instead of ${cid}`);
          } else {
            if (code25 != null && cid.code !== code25) {
              return error2(
                `Expected link to be CID with 0x${code25.toString(16)} codec`
              );
            }
            if (multihash.code != null && cid.multihash.code !== multihash.code)
              return error2(
                `Expected link to be CID with 0x${multihash.code.toString(
                  16
                )} hashing algorithm`
              );
            if (version3 != null && cid.version !== version3) {
              return error2(
                `Expected link to be CID version ${version3} instead of ${cid.version}`
              );
            }
            const [expectDigest, actualDigest] = multihash.digest != null ? [
              base323.baseEncode(multihash.digest),
              base323.baseEncode(cid.multihash.digest)
            ] : ["", ""];
            if (expectDigest !== actualDigest) {
              return error2(
                `Expected link with "${expectDigest}" hash digest instead of "${actualDigest}"`
              );
            }
            return {
              ok: (
                /** @type {API.Link<unknown, any, any, any>} */
                cid
              )
            };
          }
        }
      }
    };
    schema2 = new LinkSchema({});
    link3 = () => schema2;
    match2 = (options = {}) => new LinkSchema(options);
    read5 = (input10) => schema2.read(input10);
    optional2 = () => schema2.optional();
  }
});

// ../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema/did.js
var did_exports2 = {};
__export(did_exports2, {
  did: () => did,
  from: () => from12,
  match: () => match3,
  read: () => read6
});
var DIDSchema, schema3, did, read6, match3, from12;
var init_did2 = __esm({
  "../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema/did.js"() {
    init_schema2();
    DIDSchema = class extends API {
      /**
       * @param {string} source
       * @param {void|Method} method
       */
      readWith(source, method) {
        const prefix2 = method ? `did:${method}:` : `did:`;
        if (!source.startsWith(prefix2)) {
          return error2(`Expected a ${prefix2} but got "${source}" instead`);
        } else {
          return { ok: (
            /** @type {API.DID<Method>} */
            source
          ) };
        }
      }
    };
    schema3 = string2().refine(new DIDSchema());
    did = () => schema3;
    read6 = (input10) => schema3.read(input10);
    match3 = (options = {}) => (
      /** @type {Schema.Schema<API.DID<Method> & API.URI<"did:">>} */
      string2().refine(new DIDSchema(options.method))
    );
    from12 = (input10) => match3({}).from(input10);
  }
});

// ../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema/text.js
var text_exports = {};
__export(text_exports, {
  match: () => match4,
  read: () => read7,
  text: () => text
});
var schema4, match4, text, read7, Match;
var init_text = __esm({
  "../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema/text.js"() {
    init_schema2();
    schema4 = string2();
    match4 = (options) => options ? schema4.refine(new Match(options.pattern)) : schema4;
    text = match4;
    read7 = (input10) => schema4.read(input10);
    Match = class extends API {
      /**
       * @param {string} source
       * @param {RegExp} pattern
       */
      readWith(source, pattern) {
        if (!pattern.test(source)) {
          return error2(
            `Expected to match ${pattern} but got "${source}" instead`
          );
        } else {
          return { ok: source };
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema.js
var schema_exports3 = {};
__export(schema_exports3, {
  API: () => API,
  Bytes: () => Bytes,
  DID: () => did_exports2,
  Link: () => link_exports2,
  Text: () => text_exports,
  URI: () => uri_exports,
  and: () => and,
  array: () => array,
  boolean: () => boolean,
  bytes: () => bytes,
  dictionary: () => dictionary,
  did: () => match3,
  endsWith: () => endsWith,
  enum: () => createEnum,
  error: () => error2,
  float: () => float,
  greaterThan: () => greaterThan,
  integer: () => integer,
  intersection: () => intersection,
  lessThan: () => lessThan,
  link: () => match2,
  literal: () => literal,
  memberError: () => memberError,
  never: () => never,
  nullable: () => nullable,
  number: () => number,
  ok: () => ok,
  optional: () => optional,
  or: () => or4,
  refine: () => refine,
  startsWith: () => startsWith,
  string: () => string2,
  struct: () => struct,
  text: () => match4,
  toString: () => toString6,
  tuple: () => tuple,
  typeError: () => typeError,
  uint64: () => uint64,
  unknown: () => unknown,
  uri: () => match,
  variant: () => variant
});
var init_schema3 = __esm({
  "../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema.js"() {
    init_uri();
    init_link3();
    init_did2();
    init_text();
    init_schema2();
    init_link3();
    init_did2();
    init_uri();
    init_text();
  }
});

// ../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/delegation.js
var delegation_exports = {};
__export(delegation_exports, {
  ArchiveSchema: () => ArchiveSchema,
  Delegation: () => Delegation,
  View: () => Delegation,
  allows: () => allows,
  archive: () => archive,
  create: () => create8,
  delegate: () => delegate,
  exportDAG: () => exportDAG,
  extract: () => extract,
  importDAG: () => importDAG,
  isDelegation: () => isDelegation,
  isLink: () => isLink2,
  view: () => view2
});
function getLinksFromObject(obj) {
  const links3 = [];
  function recurse(obj2) {
    for (const key in obj2) {
      const value = obj2[key];
      if (isLink(value)) {
        links3.push(value);
      } else if (value && typeof value === "object") {
        recurse(value);
      }
    }
  }
  recurse(obj);
  return links3;
}
var isLink2, isDelegation, allows, iterateCapabilities, matchAbility, Delegation, archive, ArchiveSchema, extract, it, decodeCache, decode32, delegate, exportDAG, exportSubDAG, importDAG, create8, view2, proofs;
var init_delegation = __esm({
  "../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/delegation.js"() {
    init_lib2();
    init_link2();
    init_dag2();
    init_car();
    init_cbor3();
    init_schema3();
    init_result();
    isLink2 = isLink;
    isDelegation = (proof) => !isLink(proof);
    allows = (...delegations) => {
      let allow = {};
      for (const delegation of delegations) {
        for (const { with: uri2, can, nb } of iterateCapabilities(delegation)) {
          const resource = allow[uri2] || (allow[uri2] = {});
          const abilities = resource[can] || (resource[can] = []);
          abilities.push({ ...nb });
        }
      }
      return (
        /** @type {API.InferAllowedFromDelegations<T>} */
        allow
      );
    };
    iterateCapabilities = function* ({ issuer, capabilities, proofs: proofs2 }) {
      for (const own of capabilities) {
        if (own.with === "ucan:*") {
          yield {
            ...own,
            with: issuer.did()
          };
          for (const proof of proofs2) {
            if (isDelegation(proof)) {
              for (const capability2 of iterateCapabilities(proof)) {
                const can = matchAbility(capability2.can, own.can);
                if (can) {
                  yield {
                    ...capability2,
                    can,
                    // We do not know capability semantics so it is impossible
                    // for us to eliminate capabilities that do not satisfy imposed
                    // caveats (`own.nb`). Therefore we optimistically assume that
                    // `own.nb` further constraints `capability.nb` and do a shallow
                    // merge of the two. As a result we may include capabilities
                    // that during validation will be considered invalid due to
                    // constraint violations. While that is not ideal validator
                    // will treat them as if they were omitted and therefore it
                    // is a reasonable compromise.
                    nb: { ...capability2.nb, ...Object(own.nb) }
                  };
                }
              }
            }
          }
        } else {
          yield own;
        }
      }
    };
    matchAbility = (provided, claimed) => {
      if (provided === "*") {
        return claimed;
      }
      if (claimed === "*") {
        return provided;
      }
      if (claimed.endsWith("/*") && provided.startsWith(claimed.slice(0, -1))) {
        return provided;
      }
      if (provided.endsWith("/*") && claimed.startsWith(provided.slice(0, -1))) {
        return claimed;
      }
      if (provided === claimed) {
        return provided;
      }
      return null;
    };
    Delegation = class {
      /**
       * @param {API.UCANBlock<C>} root
       * @param {DAG.BlockStore} [blocks]
       */
      constructor(root2, blocks = /* @__PURE__ */ new Map()) {
        this.root = root2;
        this.blocks = blocks;
        Object.defineProperties(this, {
          blocks: {
            enumerable: false
          }
        });
      }
      /**
       * @returns {API.AttachedLinkSet}
       */
      get attachedLinks() {
        const _attachedLinks = /* @__PURE__ */ new Set();
        const ucanView = this.data;
        for (const capability2 of ucanView.capabilities) {
          const links3 = getLinksFromObject(capability2);
          for (const link5 of links3) {
            _attachedLinks.add(`${link5}`);
          }
        }
        for (const fact of ucanView.facts) {
          if (isLink(fact)) {
            _attachedLinks.add(`${fact}`);
          } else {
            const links3 = Object.values(fact).filter((e) => isLink(e));
            for (const link5 of links3) {
              _attachedLinks.add(`${link5}`);
            }
          }
        }
        return _attachedLinks;
      }
      get version() {
        return this.data.version;
      }
      get signature() {
        return this.data.signature;
      }
      get cid() {
        return this.root.cid;
      }
      link() {
        return this.root.cid;
      }
      get asCID() {
        return this.cid;
      }
      get bytes() {
        return this.root.bytes;
      }
      get data() {
        const data = decode32(this.root);
        Object.defineProperties(this, { data: { value: data, enumerable: false } });
        return data;
      }
      /**
       * Attach a block to the delegation DAG so it would be included in the
       * block iterator.
       *  You can only attach blocks that are referenced from the `capabilities`
       * or `facts`.
       *
       * @param {API.Block} block
       */
      attach(block) {
        if (!this.attachedLinks.has(`${block.cid.link()}`)) {
          throw new Error(`given block with ${block.cid} is not an attached link`);
        }
        this.blocks.set(`${block.cid}`, block);
      }
      export() {
        return exportDAG(this.root, this.blocks, this.attachedLinks);
      }
      /**
       * @returns {API.Await<API.Result<Uint8Array, Error>>}
       */
      archive() {
        return archive(this);
      }
      iterateIPLDBlocks() {
        return exportDAG(this.root, this.blocks, this.attachedLinks);
      }
      /**
       * @type {API.Proof[]}
       */
      get proofs() {
        return proofs(this);
      }
      /**
       * @type {API.Principal}
       */
      get issuer() {
        return this.data.issuer;
      }
      /**
       * @type {API.Principal}
       */
      get audience() {
        return this.data.audience;
      }
      /**
       * @returns {C}
       */
      get capabilities() {
        return (
          /** @type {C} */
          this.data.capabilities
        );
      }
      /**
       * @returns {number}
       */
      get expiration() {
        return this.data.expiration;
      }
      /**
       * @returns {undefined|number}
       */
      get notBefore() {
        return this.data.notBefore;
      }
      /**
       * @returns {undefined|string}
       */
      get nonce() {
        return this.data.nonce;
      }
      /**
       * @returns {API.Fact[]}
       */
      get facts() {
        return this.data.facts;
      }
      /**
       * Iterate over the proofs
       *
       * @returns {IterableIterator<API.Delegation>}
       */
      iterate() {
        return it(this);
      }
      delegate() {
        return this;
      }
      buildIPLDView() {
        return this;
      }
      /**
       * @returns {API.DelegationJSON<this>}
       */
      toJSON() {
        return (
          /** @type {any} */
          {
            ...this.data.toJSON(),
            "/": this.cid.toString(),
            prf: this.proofs.map(
              (proof) => isDelegation(proof) ? proof : { "/": proof.toString() }
            )
          }
        );
      }
    };
    archive = async (delegation) => {
      try {
        const store2 = /* @__PURE__ */ new Map();
        for (const block of delegation.iterateIPLDBlocks()) {
          store2.set(`${block.cid}`, block);
        }
        const variant2 = await write2({
          [`ucan@${delegation.version}`]: delegation.root.cid
        });
        store2.set(`${variant2.cid}`, variant2);
        const bytes2 = encode27({
          roots: [variant2],
          blocks: store2
        });
        return ok(bytes2);
      } catch (cause) {
        return error(
          /** @type {Error} */
          cause
        );
      }
    };
    ArchiveSchema = variant({
      "ucan@0.9.1": (
        /** @type {Schema.Schema<API.UCANLink>} */
        match2({ version: 1 })
      )
    });
    extract = async (archive3) => {
      try {
        const { roots, blocks } = decode31(archive3);
        const [root2] = roots;
        if (root2 == null) {
          return error2("CAR archive does not contain a root block");
        }
        const { bytes: bytes2 } = root2;
        const variant2 = decode18(bytes2);
        const [, link5] = ArchiveSchema.match(variant2);
        return ok(view2({ root: link5, blocks }));
      } catch (cause) {
        return error(
          /** @type {Error} */
          cause
        );
      }
    };
    it = function* (delegation) {
      for (const proof of delegation.proofs) {
        if (isDelegation(proof)) {
          yield* it(proof);
          yield proof;
        }
      }
    };
    decodeCache = /* @__PURE__ */ new WeakMap();
    decode32 = ({ bytes: bytes2 }) => {
      const data = decodeCache.get(bytes2);
      if (!data) {
        const data2 = decode30(bytes2);
        decodeCache.set(bytes2, data2);
        return data2;
      }
      return data;
    };
    delegate = async ({ issuer, audience, proofs: proofs2 = [], attachedBlocks = /* @__PURE__ */ new Map(), ...input10 }, options) => {
      const links3 = [];
      const blocks = /* @__PURE__ */ new Map();
      for (const proof of proofs2) {
        if (!isDelegation(proof)) {
          links3.push(proof);
        } else {
          links3.push(proof.cid);
          for (const block of proof.export()) {
            blocks.set(block.cid.toString(), block);
          }
        }
      }
      const data = await issue({
        ...input10,
        issuer,
        audience,
        proofs: links3
      });
      const { cid, bytes: bytes2 } = await write(data, options);
      decodeCache.set(cid, data);
      const delegation = new Delegation({ cid, bytes: bytes2 }, blocks);
      Object.defineProperties(delegation, { proofs: { value: proofs2 } });
      for (const block of attachedBlocks.values()) {
        delegation.attach(block);
      }
      return delegation;
    };
    exportDAG = function* (root2, blocks, attachedLinks) {
      for (const link5 of decode32(root2).proofs) {
        const root3 = (
          /** @type {UCAN.Block} */
          blocks.get(`${link5}`)
        );
        if (root3) {
          yield* exportSubDAG(root3, blocks);
        }
      }
      for (const link5 of attachedLinks.values()) {
        const block = blocks.get(link5);
        if (block) {
          yield block;
        }
      }
      yield root2;
    };
    exportSubDAG = function* (root2, blocks) {
      for (const link5 of decode32(root2).proofs) {
        const root3 = (
          /** @type {UCAN.Block} */
          blocks.get(`${link5}`)
        );
        if (root3) {
          yield* exportSubDAG(root3, blocks);
        }
      }
      yield root2;
    };
    importDAG = (dag) => {
      let entries3 = [];
      for (const block of dag) {
        entries3.push([block.cid.toString(), block]);
      }
      const last5 = entries3.pop();
      if (!last5) {
        throw new RangeError("Empty DAG can not be turned into a delegation");
      } else {
        const [, root2] = last5;
        return new Delegation(
          /** @type {API.UCANBlock<C>} */
          root2,
          new Map(entries3)
        );
      }
    };
    create8 = ({ root: root2, blocks }) => new Delegation(root2, blocks);
    view2 = ({ root: root2, blocks }, fallback) => {
      const block = get(root2, blocks, null);
      if (block == null) {
        return fallback !== void 0 ? fallback : notFound(root2);
      }
      return create8({ root: block, blocks });
    };
    proofs = (delegation) => {
      const proofs2 = [];
      const { root: root2, blocks } = delegation;
      for (const link5 of decode32(root2).proofs) {
        const root3 = (
          /** @type {UCAN.Block} */
          blocks.get(link5.toString())
        );
        proofs2.push(root3 ? create8({ root: root3, blocks }) : link5);
      }
      Object.defineProperty(delegation, "proofs", { value: proofs2 });
      return proofs2;
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/invocation.js
var invocation_exports = {};
__export(invocation_exports, {
  Invocation: () => Invocation,
  create: () => create9,
  invoke: () => invoke,
  isInvocation: () => isInvocation,
  view: () => view3
});
var isInvocation, invoke, create9, view3, IssuedInvocation, Invocation;
var init_invocation = __esm({
  "../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/invocation.js"() {
    init_delegation();
    init_dag2();
    isInvocation = (value) => isDelegation(value);
    invoke = (options) => new IssuedInvocation(options);
    create9 = ({ root: root2, blocks }) => new Invocation(root2, blocks);
    view3 = ({ root: root2, blocks }, fallback) => {
      const block = get(root2, blocks, null);
      if (block == null) {
        return fallback !== void 0 ? fallback : notFound(root2);
      }
      return (
        /** @type {API.Invocation<C>} */
        create9({ root: block, blocks })
      );
    };
    IssuedInvocation = class {
      /**
       * @param {API.InvocationOptions<Capability>} data
       */
      constructor({
        issuer,
        audience,
        capability: capability2,
        proofs: proofs2 = [],
        expiration,
        lifetimeInSeconds,
        notBefore,
        nonce,
        facts = []
      }) {
        this.issuer = issuer;
        this.audience = audience;
        this.proofs = proofs2;
        this.capabilities = [capability2];
        this.expiration = expiration;
        this.lifetimeInSeconds = lifetimeInSeconds;
        this.notBefore = notBefore;
        this.nonce = nonce;
        this.facts = facts;
        this.attachedBlocks = /* @__PURE__ */ new Map();
      }
      /**
       * @param {API.Block} block
       */
      attach(block) {
        this.attachedBlocks.set(`${block.cid}`, block);
      }
      delegate() {
        return delegate(this);
      }
      buildIPLDView() {
        return delegate(this);
      }
      /**
       * @template {API.InvocationService<Capability>} Service
       * @param {API.ConnectionView<Service>} connection
       * @returns {Promise<API.InferReceipt<Capability, Service>>}
       */
      async execute(connection6) {
        const invocation = this;
        const [result] = await connection6.execute(invocation);
        return result;
      }
    };
    Invocation = class extends Delegation {
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/receipt.js
var receipt_exports = {};
__export(receipt_exports, {
  issue: () => issue2,
  view: () => view4
});
var view4, Receipt, ReceptBuilder, NOFX, issue2;
var init_receipt = __esm({
  "../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/receipt.js"() {
    init_did();
    init_invocation();
    init_delegation();
    init_signature();
    init_dag2();
    init_cbor3();
    init_sha22();
    view4 = ({ root: root2, blocks }, fallback) => {
      const block = get(root2, blocks, null);
      if (block == null) {
        return fallback !== void 0 ? fallback : notFound(root2);
      }
      const data = decode18(block.bytes);
      return new Receipt({ root: { ...block, data }, store: blocks });
    };
    Receipt = class {
      /**
       * @param {object} input
       * @param {Required<API.Block<API.ReceiptModel<Ok, Error, Ran>>>} input.root
       * @param {DAG.BlockStore} input.store
       * @param {API.Meta} [input.meta]
       * @param {Ran|ReturnType<Ran['link']>} [input.ran]
       * @param {API.EffectsModel} [input.fx]
       * @param {API.SignatureView<API.OutcomeModel<Ok, Error, Ran>, SigAlg>} [input.signature]
       * @param {API.UCAN.Principal} [input.issuer]
       * @param {API.Proof[]} [input.proofs]
       */
      constructor({ root: root2, store: store2, ran, issuer, signature, proofs: proofs2 }) {
        this.store = store2;
        this.root = root2;
        this._ran = ran;
        this._fx = void 0;
        this._signature = signature;
        this._proofs = proofs2;
        this._issuer = issuer;
      }
      /**
       * @returns {Ran|ReturnType<Ran['link']>}
       */
      get ran() {
        const ran = this._ran;
        if (!ran) {
          const ran2 = (
            /** @type {Ran} */
            view3(
              {
                root: this.root.data.ocm.ran,
                blocks: this.store
              },
              this.root.data.ocm.ran
            )
          );
          this._ran = ran2;
          return ran2;
        } else {
          return ran;
        }
      }
      get proofs() {
        const proofs2 = this._proofs;
        if (proofs2) {
          return proofs2;
        } else {
          const { store: store2, root: root2 } = this;
          const { prf } = root2.data.ocm;
          const proofs3 = [];
          if (prf) {
            for (const link5 of prf) {
              const proof = view2({ root: link5, blocks: store2 }, link5);
              proofs3.push(proof);
            }
          }
          this._proofs = proofs3;
          return proofs3;
        }
      }
      link() {
        return this.root.cid;
      }
      get meta() {
        return this.root.data.ocm.meta;
      }
      get issuer() {
        const issuer = this._issuer;
        if (issuer) {
          return issuer;
        } else {
          const { iss } = this.root.data.ocm;
          if (iss) {
            const issuer2 = parse3(iss);
            this._issuer = issuer2;
            return issuer2;
          }
        }
      }
      get out() {
        return this.root.data.ocm.out;
      }
      get fx() {
        let fx = this._fx;
        if (!fx) {
          const { store: blocks } = this;
          const { fork: fork5, join: join2 } = this.root.data.ocm.fx;
          fx = {
            fork: fork5.map((root2) => view3({ root: root2, blocks }, root2))
          };
          if (join2) {
            fx.join = view3({ root: join2, blocks }, join2);
          }
          this._fx = fx;
        }
        return fx;
      }
      get signature() {
        const signature = this._signature;
        if (signature) {
          return signature;
        } else {
          const signature2 = (
            /** @type {API.SignatureView<API.OutcomeModel<Ok, Error, Ran>, SigAlg>} */
            view(this.root.data.sig)
          );
          this._signature = signature2;
          return signature2;
        }
      }
      /**
       * @param {API.Crypto.Verifier} signingPrincipal
       */
      verifySignature(signingPrincipal) {
        return this.signature.verify(
          signingPrincipal,
          encode26(this.root.data.ocm)
        );
      }
      buildIPLDView() {
        return this;
      }
      *iterateIPLDBlocks() {
        const { ran, fx, proofs: proofs2, root: root2 } = this;
        yield* iterate(ran);
        for (const fork5 of fx.fork) {
          yield* iterate(fork5);
        }
        if (fx.join) {
          yield* iterate(fx.join);
        }
        for (const proof of proofs2) {
          yield* iterate(proof);
        }
        yield root2;
      }
    };
    ReceptBuilder = class {
      /**
       * @param {object} options
       * @param {API.Signer<API.DID, SigAlg>} options.issuer
       * @param {Ran|ReturnType<Ran['link']>} options.ran
       * @param {API.Result<Ok, Error>} options.result
       * @param {API.Effects} [options.fx]
       * @param {API.Proof[]} [options.proofs]
       * @param {Record<string, unknown>} [options.meta]
       */
      constructor({ issuer, result, ran, fx = NOFX, proofs: proofs2 = [], meta = {} }) {
        this.issuer = issuer;
        this.result = result;
        this.ran = ran;
        this.fx = fx;
        this.proofs = proofs2;
        this.meta = meta;
      }
      async buildIPLDView({ hasher = sha2562, codec = cbor_exports3 } = {}) {
        const store2 = createStore();
        addEveryInto(iterate(this.ran), store2);
        const prf = [];
        for (const proof of this.proofs) {
          addEveryInto(iterate(proof), store2);
          prf.push(proof.link());
        }
        const fx = { fork: [] };
        for (const fork5 of this.fx.fork) {
          addEveryInto(iterate(fork5), store2);
          fx.fork.push(fork5.link());
        }
        if (this.fx.join) {
          addEveryInto(iterate(this.fx.join), store2);
          fx.join = this.fx.join.link();
        }
        const outcome = {
          ran: (
            /** @type {ReturnType<Ran['link']>} */
            this.ran.link()
          ),
          out: this.result,
          fx,
          meta: this.meta,
          iss: this.issuer.did(),
          prf
        };
        const signature = await this.issuer.sign(encode26(outcome));
        const model = {
          ocm: outcome,
          sig: signature
        };
        const root2 = await writeInto(model, store2, {
          hasher,
          codec
        });
        return new Receipt({
          root: root2,
          store: store2,
          signature,
          proofs: this.proofs,
          ran: this.ran
        });
      }
    };
    NOFX = Object.freeze({ fork: Object.freeze([]) });
    issue2 = (options) => new ReceptBuilder(options).buildIPLDView();
  }
});

// ../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/message.js
var message_exports = {};
__export(message_exports, {
  MessageSchema: () => MessageSchema,
  build: () => build2,
  view: () => view5
});
var MessageSchema, build2, view5, MessageBuilder, writeInvocations, writeReceipts, Message;
var init_message = __esm({
  "../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/message.js"() {
    init_dag2();
    init_lib3();
    init_receipt();
    init_schema3();
    MessageSchema = variant({
      "ucanto/message@7.0.0": struct({
        execute: match2().array().optional(),
        delegate: dictionary({
          key: string2(),
          value: (
            /** @type {API.Reader<API.Link<API.ReceiptModel>>} */
            match2()
          )
        }).array().optional()
      })
    });
    build2 = ({ invocations, receipts }) => new MessageBuilder({ invocations, receipts }).buildIPLDView();
    view5 = ({ root: root2, store: store2 }, fallback) => {
      const block = get(root2, store2, null);
      if (block === null) {
        return fallback !== void 0 ? fallback : notFound(root2);
      }
      const data = cbor_exports3.decode(block.bytes);
      const [branch, value] = MessageSchema.match(data, fallback);
      switch (branch) {
        case "ucanto/message@7.0.0":
          return new Message({ root: { ...block, data }, store: store2 });
        default:
          return value;
      }
    };
    MessageBuilder = class {
      /**
       * @param {object} source
       * @param {I} [source.invocations]
       * @param {R} [source.receipts]
       */
      constructor({ invocations, receipts }) {
        this.invocations = invocations;
        this.receipts = receipts;
      }
      /**
       *
       * @param {API.BuildOptions} [options]
       * @returns {Promise<Message<{ In: API.InferInvocations<I>, Out: R }>>}
       */
      async buildIPLDView(options) {
        const store2 = /* @__PURE__ */ new Map();
        const { invocations, ...executeField } = await writeInvocations(
          this.invocations || [],
          store2
        );
        const { receipts, ...receiptsField } = await writeReceipts(
          this.receipts || [],
          store2
        );
        const root2 = await writeInto(
          /** @type {API.AgentMessageModel<{ In: API.InferInvocations<I>, Out: R }>} */
          {
            "ucanto/message@7.0.0": {
              ...executeField,
              ...receiptsField
            }
          },
          store2,
          options
        );
        return new Message({ root: root2, store: store2 }, { receipts, invocations });
      }
    };
    writeInvocations = async (run, store2) => {
      const invocations = [];
      const execute2 = [];
      for (const invocation of run) {
        const view6 = await invocation.buildIPLDView();
        execute2.push(view6.link());
        invocations.push(view6);
        for (const block of view6.iterateIPLDBlocks()) {
          store2.set(`${block.cid}`, block);
        }
      }
      return { invocations, ...execute2.length > 0 ? { execute: execute2 } : {} };
    };
    writeReceipts = async (source, store2) => {
      if (source.length === 0) {
        return {};
      }
      const receipts = /* @__PURE__ */ new Map();
      const report = {};
      for (const [n, receipt] of source.entries()) {
        const view6 = await receipt.buildIPLDView();
        for (const block of view6.iterateIPLDBlocks()) {
          store2.set(`${block.cid}`, block);
        }
        const key = `${view6.ran.link()}`;
        if (!(key in report)) {
          report[key] = view6.root.cid;
          receipts.set(key, view6);
        } else {
          receipts.set(`${key}@${n}`, view6);
        }
      }
      return { receipts, report };
    };
    Message = class {
      /**
       * @param {object} source
       * @param {Required<API.Block<API.AgentMessageModel<T>>>} source.root
       * @param {DAG.BlockStore} source.store
       * @param {object} build
       * @param {API.Invocation[]} [build.invocations]
       * @param {Map<string, API.Receipt>} [build.receipts]
       */
      constructor({ root: root2, store: store2 }, { invocations, receipts } = {}) {
        this.root = root2;
        this.store = store2;
        this._invocations = invocations;
        this._receipts = receipts;
      }
      *iterateIPLDBlocks() {
        for (const invocation of this.invocations) {
          yield* invocation.iterateIPLDBlocks();
        }
        for (const receipt of this.receipts.values()) {
          yield* receipt.iterateIPLDBlocks();
        }
        yield this.root;
      }
      /**
       * @template [E=never]
       * @param {API.Link} link
       * @param {E} [fallback]
       * @returns {API.Receipt|E}
       */
      get(link5, fallback) {
        const receipts = this.root.data["ucanto/message@7.0.0"].report || {};
        const receipt = receipts[`${link5}`];
        if (receipt) {
          return view4({ root: receipt, blocks: this.store });
        } else {
          return fallback !== void 0 ? fallback : panic(`Message does not include receipt for ${link5}`);
        }
      }
      get invocationLinks() {
        return this.root.data["ucanto/message@7.0.0"].execute || [];
      }
      get invocations() {
        let invocations = this._invocations;
        if (!invocations) {
          invocations = this.invocationLinks.map((link5) => {
            return invocation_exports.view({ root: link5, blocks: this.store });
          });
        }
        return invocations;
      }
      get receipts() {
        let receipts = this._receipts;
        if (!receipts) {
          receipts = /* @__PURE__ */ new Map();
          const report = this.root.data["ucanto/message@7.0.0"].report || {};
          for (const [key, link5] of Object.entries(report)) {
            const receipt = view4({ root: link5, blocks: this.store });
            receipts.set(`${receipt.ran.link()}`, receipt);
          }
        }
        return receipts;
      }
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/lib.js
var init_lib3 = __esm({
  "../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/lib.js"() {
    init_lib();
    init_delegation();
    init_invocation();
    init_message();
    init_receipt();
    init_dag2();
    init_cbor3();
    init_car();
    init_delegation();
    init_invocation();
    init_link2();
    init_sha22();
    init_base583();
    init_lib2();
    init_did();
    init_signature();
    init_result();
    init_schema3();
  }
});

// ../../node_modules/.pnpm/@ucanto+client@9.0.1/node_modules/@ucanto/client/src/connection.js
var connect, Connection, execute;
var init_connection = __esm({
  "../../node_modules/.pnpm/@ucanto+client@9.0.1/node_modules/@ucanto/client/src/connection.js"() {
    init_lib3();
    connect = (options) => new Connection(options);
    Connection = class {
      /**
       * @param {API.ConnectionOptions<T>} options
       */
      constructor(options) {
        this.id = options.id;
        this.options = options;
        this.codec = options.codec;
        this.channel = options.channel;
        this.hasher = options.hasher || sha2562;
      }
      /**
       * Execute invocations.
       *
       * @template {API.Capability} C
       * @template {API.Tuple<API.ServiceInvocation<C, T>>} I
       * @param {I} invocations
       * @returns {Promise<API.InferReceipts<I, T>>}
       */
      async execute(...invocations) {
        return execute(invocations, this);
      }
    };
    execute = async (invocations, connection6) => {
      const input10 = await message_exports.build({ invocations });
      const request = await connection6.codec.encode(input10, connection6);
      const response = await connection6.channel.request(request);
      try {
        const output = await connection6.codec.decode(response);
        const receipts = input10.invocationLinks.map((link5) => output.get(link5));
        return (
          /** @type {API.InferReceipts<I, T>} */
          receipts
        );
      } catch (error3) {
        const { message, name: name20 = "Error", ...cause } = (
          /** @type {Error} */
          error3
        );
        const receipts = [];
        for await (const ran of input10.invocationLinks) {
          const receipt = await receipt_exports.issue({
            ran,
            result: { error: { ...cause, name: name20, message } },
            // @ts-expect-error - we can not really sign a receipt without having
            // an access to a signer which client does not have. In the future
            // we will change client API requiring a signer to be passed in but
            // for now we just use a dummy signer.
            issuer: {
              did() {
                return connection6.id.did();
              },
              sign() {
                return signature_exports.createNonStandard("", new Uint8Array());
              }
            }
          });
          receipts.push(receipt);
        }
        return (
          /** @type {API.InferReceipts<I, T>} */
          receipts
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+client@9.0.1/node_modules/@ucanto/client/src/lib.js
var delegate2;
var init_lib4 = __esm({
  "../../node_modules/.pnpm/@ucanto+client@9.0.1/node_modules/@ucanto/client/src/lib.js"() {
    init_connection();
    init_lib();
    init_lib3();
    delegate2 = delegation_exports.delegate;
  }
});

// ../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/car/request.js
var request_exports = {};
__export(request_exports, {
  codec: () => car_exports,
  contentType: () => contentType3,
  decode: () => decode34,
  encode: () => encode28
});
var contentType3, HEADERS, encode28, decode34;
var init_request = __esm({
  "../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/car/request.js"() {
    init_lib3();
    contentType3 = car_exports.contentType;
    HEADERS = Object.freeze({
      "content-type": contentType3,
      // We will signal that we want to receive a CAR file in the response
      accept: contentType3
    });
    encode28 = (message, options) => {
      const blocks = /* @__PURE__ */ new Map();
      for (const block of message.iterateIPLDBlocks()) {
        blocks.set(`${block.cid}`, block);
      }
      const body = car_exports.encode({
        roots: [message.root],
        blocks
      });
      return {
        headers: options?.headers || { ...HEADERS },
        body
      };
    };
    decode34 = async ({ headers, body }) => {
      const { roots, blocks } = car_exports.decode(
        /** @type {Uint8Array} */
        body
      );
      const message = message_exports.view({ root: roots[0].cid, store: blocks });
      return (
        /** @type {Message} */
        message
      );
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/car/response.js
var response_exports = {};
__export(response_exports, {
  codec: () => car_exports,
  contentType: () => contentType4,
  decode: () => decode35,
  encode: () => encode29
});
var contentType4, HEADERS2, encode29, decode35;
var init_response = __esm({
  "../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/car/response.js"() {
    init_lib3();
    contentType4 = car_exports.contentType;
    HEADERS2 = Object.freeze({
      "content-type": contentType4
    });
    encode29 = (message, options) => {
      const blocks = /* @__PURE__ */ new Map();
      for (const block of message.iterateIPLDBlocks()) {
        blocks.set(`${block.cid}`, block);
      }
      const body = car_exports.encode({
        roots: [message.root],
        blocks
      });
      return {
        headers: { ...HEADERS2 },
        body
      };
    };
    decode35 = async ({ headers, body }) => {
      const { roots, blocks } = car_exports.decode(
        /** @type {Uint8Array} */
        body
      );
      const message = message_exports.view({ root: roots[0].cid, store: blocks });
      return (
        /** @type {Message} */
        message
      );
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/codec.js
var inbound, Inbound, outbound, Outbound, parseMediaType, formatMediaType, parseAcceptHeader, formatAcceptHeader;
var init_codec = __esm({
  "../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/codec.js"() {
    inbound = (source) => new Inbound(source);
    Inbound = class {
      /**
       * @param {API.HTTPRequest} request
       * @returns {API.Result<API.InboundAcceptCodec, API.HTTPError>} transport
       */
      accept({ headers }) {
        const contentType9 = headers["content-type"] || headers["Content-Type"];
        const decoder3 = this.decoders[contentType9];
        if (!decoder3) {
          return {
            error: {
              status: 415,
              message: `The server cannot process the request because the payload format is not supported. Please check the content-type header and try again with a supported media type.`,
              headers: {
                accept: Object.keys(this.decoders).join(", ")
              }
            }
          };
        }
        const accept2 = parseAcceptHeader(headers.accept || headers.Accept || "*/*");
        for (const { category, type: type2 } of accept2) {
          for (const encoder3 of this.encoders) {
            const select2 = (category === "*" || category === encoder3.category) && (type2 === "*" || type2 === encoder3.type);
            if (select2) {
              return { ok: { ...encoder3, decoder: decoder3 } };
            }
          }
        }
        return {
          error: {
            status: 406,
            message: `The requested resource cannot be served in the requested content type. Please specify a supported content type using the Accept header.`,
            headers: {
              accept: formatAcceptHeader(Object.values(this.encoders))
            }
          }
        };
      }
      /**
       * @param {object} source
       * @param {Record<string, API.Transport.RequestDecoder>} source.decoders
       * @param {Record<string, API.Transport.ResponseEncoder>} source.encoders
       */
      constructor({ decoders = {}, encoders = {} }) {
        this.decoders = decoders;
        if (Object.keys(decoders).length === 0) {
          throw new Error("At least one decoder MUST be provided");
        }
        this.encoders = Object.entries(encoders).map(([mediaType, encoder3]) => {
          return { ...parseMediaType(mediaType), encoder: encoder3 };
        }).sort((a, b) => b.preference - a.preference);
        if (this.encoders.length === 0) {
          throw new Error("At least one encoder MUST be provided");
        }
      }
    };
    outbound = (source) => new Outbound(source);
    Outbound = class {
      /**
       * @param {object} source
       * @param {Record<string, API.Transport.RequestEncoder>} source.encoders
       * @param {Record<string, API.Transport.ResponseDecoder>} source.decoders
       */
      constructor({ decoders = {}, encoders = {} }) {
        this.decoders = decoders;
        if (Object.keys(decoders).length === 0) {
          throw new Error("At least one decoder MUST be provided");
        }
        this.encoders = Object.entries(encoders).map(([mediaType, encoder3]) => {
          return { ...parseMediaType(mediaType), encoder: encoder3 };
        }).sort((a, b) => b.preference - a.preference);
        this.acceptType = formatAcceptHeader(this.encoders);
        if (this.encoders.length === 0) {
          throw new Error("At least one encoder MUST be provided");
        }
        this.encoder = this.encoders[0].encoder;
      }
      /**
       * @template {API.AgentMessage} Message
       * @param {Message} message
       */
      encode(message) {
        return this.encoder.encode(message, {
          accept: this.acceptType
        });
      }
      /**
       * @template {API.AgentMessage} Message
       * @param {API.HTTPResponse<Message>} response
       * @returns {API.Await<Message>}
       */
      decode(response) {
        const { headers } = response;
        const contentType9 = headers["content-type"] || headers["Content-Type"];
        const decoder3 = this.decoders[contentType9] || this.decoders["*/*"];
        switch (response.status) {
          case 415:
          case 406:
            throw Object.assign(
              new RangeError(new TextDecoder().decode(response.body)),
              {
                status: response.status,
                headers: response.headers
              }
            );
        }
        if (!decoder3) {
          throw Object.assign(
            TypeError(
              `Can not decode response with content-type '${contentType9}' because no matching transport decoder is configured.`
            ),
            {
              error: true
            }
          );
        }
        return decoder3.decode(response);
      }
    };
    parseMediaType = (source) => {
      const [mediaType = "*/*", mediaRange = ""] = source.trim().split(";");
      const [category = "*", type2 = "*"] = mediaType.split("/");
      const params = new URLSearchParams(mediaRange);
      const preference = parseFloat(params.get("q") || "0");
      return {
        category,
        type: type2,
        /* c8 ignore next */
        preference: isNaN(preference) ? 0 : preference
      };
    };
    formatMediaType = ({ category, type: type2, preference }) => (
      /** @type {MediaType}  */
      `${category}/${type2}${preference ? `;q=${preference}` : ""}`
    );
    parseAcceptHeader = (source) => source.split(",").map(parseMediaType).sort((a, b) => b.preference - a.preference);
    formatAcceptHeader = (source) => source.map(formatMediaType).join(", ");
  }
});

// ../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/car.js
var car_exports2 = {};
__export(car_exports2, {
  codec: () => car_exports,
  contentType: () => contentType5,
  inbound: () => inbound2,
  outbound: () => outbound2,
  request: () => request_exports,
  response: () => response_exports
});
var contentType5, inbound2, outbound2;
var init_car2 = __esm({
  "../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/car.js"() {
    init_lib3();
    init_request();
    init_response();
    init_codec();
    contentType5 = car_exports.contentType;
    inbound2 = inbound({
      decoders: {
        [contentType3]: request_exports
      },
      encoders: {
        [contentType4]: response_exports
      }
    });
    outbound2 = outbound({
      encoders: {
        [contentType3]: request_exports
      },
      decoders: {
        [contentType4]: response_exports
      }
    });
  }
});

// ../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/http.js
var http_exports = {};
__export(http_exports, {
  open: () => open
});
var open, Channel, HTTPError2;
var init_http = __esm({
  "../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/http.js"() {
    open = ({ url, method = "POST", fetch: fetch3 }) => {
      if (!fetch3) {
        if (typeof globalThis.fetch !== "undefined") {
          fetch3 = globalThis.fetch.bind(globalThis);
        } else {
          throw new TypeError(
            `ucanto HTTP transport got undefined \`fetch\`. Try passing in a \`fetch\` implementation explicitly.`
          );
        }
      }
      return new Channel({ url, method, fetch: fetch3 });
    };
    Channel = class {
      /**
       * @param {object} options
       * @param {URL} options.url
       * @param {Fetcher} options.fetch
       * @param {string} [options.method]
       */
      constructor({ url, fetch: fetch3, method }) {
        this.fetch = fetch3;
        this.method = method;
        this.url = url;
      }
      /**
       * @template {API.Tuple<API.ServiceInvocation<API.Capability, S>>} I
       * @param {API.HTTPRequest<API.AgentMessage<{ In: API.InferInvocations<I>, Out: API.Tuple<API.Receipt> }>>} request
       * @returns {Promise<API.HTTPResponse<API.AgentMessage<{ Out: API.InferReceipts<I, S>, In: API.Tuple<API.Invocation> }>>>}
       */
      async request({ headers, body }) {
        const response = await this.fetch(this.url.href, {
          headers,
          body,
          method: this.method
        });
        const buffer3 = response.ok ? await response.arrayBuffer() : HTTPError2.throw(`HTTP Request failed. ${this.method} ${this.url.href} \u2192 ${response.status}`, response);
        return {
          headers: response.headers.entries ? Object.fromEntries(response.headers.entries()) : (
            /* c8 ignore next */
            {}
          ),
          body: new Uint8Array(buffer3)
        };
      }
    };
    HTTPError2 = class extends Error {
      /**
       * @param {string} message
       * @param {Options} options
       * @returns {never}
       */
      static throw(message, options) {
        throw new this(message, options);
      }
      /**
       * @param {string} message
       * @param {Options} options
       */
      constructor(message, { url, status = 500, statusText = "Server error" }) {
        super(message);
        this.name = "HTTPError";
        this.url = url;
        this.status = status;
        this.statusText = statusText;
      }
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/utf8.js
var encoder2, decoder2;
var init_utf82 = __esm({
  "../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/utf8.js"() {
    encoder2 = new TextEncoder();
    decoder2 = new TextDecoder();
  }
});

// ../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/legacy/response.js
var response_exports2 = {};
__export(response_exports2, {
  contentType: () => contentType6,
  encode: () => encode30
});
var contentType6, HEADERS3, encode30;
var init_response2 = __esm({
  "../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/legacy/response.js"() {
    init_cbor3();
    contentType6 = "application/cbor";
    HEADERS3 = Object.freeze({
      "content-type": contentType6
    });
    encode30 = (message, options) => {
      const legacyResults = [];
      for (const receipt of message.receipts.values()) {
        const result = receipt.out;
        if (result.ok) {
          legacyResults.push(result.ok);
        } else {
          legacyResults.push({
            ...result.error,
            error: true
          });
        }
      }
      const body = encode26(legacyResults);
      return (
        /** @type {API.HTTPResponse<Message>} */
        {
          headers: HEADERS3,
          body
        }
      );
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/legacy/request.js
var request_exports2 = {};
__export(request_exports2, {
  contentType: () => contentType7,
  decode: () => decode36
});
var contentType7, decode36;
var init_request2 = __esm({
  "../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/legacy/request.js"() {
    init_car();
    init_lib3();
    contentType7 = "application/car";
    decode36 = async ({ body }) => {
      const { roots, blocks } = decode31(
        /** @type {Uint8Array} */
        body
      );
      const run = [];
      for (const { cid } of roots) {
        const invocation = invocation_exports.view({
          root: (
            /** @type {API.Link} */
            cid
          ),
          blocks
        });
        run.push(invocation);
      }
      const message = await message_exports.build({
        invocations: (
          /** @type {API.Tuple<API.IssuedInvocation>} */
          run
        )
      });
      return (
        /** @type {Message} */
        message
      );
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/legacy.js
var contentType8, inbound3;
var init_legacy = __esm({
  "../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/legacy.js"() {
    init_codec();
    init_car2();
    init_response2();
    init_request2();
    ({ contentType: contentType8 } = request_exports2);
    inbound3 = inbound({
      decoders: {
        [contentType8]: request_exports2,
        [contentType5]: request_exports
      },
      encoders: {
        // Here we configure encoders such that if accept header is `*/*` (which is
        // the default if omitted) we will encode the response in CBOR. If
        // `application/vnd.ipld.car` is set we will encode the response in current
        // format.
        // Here we exploit the fact that legacy clients do not send an accept header
        // and therefore will get response in legacy format. New clients on the other
        // hand will send `application/vnd.ipld.car` and consequently get response
        // in current format.
        "*/*;q=0.1": response_exports2,
        [contentType5]: response_exports
      }
    });
  }
});

// ../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/lib.js
var init_lib5 = __esm({
  "../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/lib.js"() {
    init_car2();
    init_http();
    init_utf82();
    init_legacy();
    init_codec();
    init_codec();
  }
});

// ../../node_modules/.pnpm/@ucanto+validator@9.0.2/node_modules/@ucanto/validator/src/util.js
var the, entries, combine, intersection2;
var init_util2 = __esm({
  "../../node_modules/.pnpm/@ucanto+validator@9.0.2/node_modules/@ucanto/validator/src/util.js"() {
    the = (value) => value;
    entries = (object) => (
      /** @type {any} */
      Object.entries(object)
    );
    combine = ([first2, ...rest]) => {
      const results = first2.map((value) => [value]);
      for (const values2 of rest) {
        const tuples = results.splice(0);
        for (const value of values2) {
          for (const tuple2 of tuples) {
            results.push([...tuple2, value]);
          }
        }
      }
      return results;
    };
    intersection2 = (left, right) => {
      const [result, other] = left.length < right.length ? [new Set(left), new Set(right)] : [new Set(right), new Set(left)];
      for (const item of result) {
        if (!other.has(item)) {
          result.delete(item);
        }
      }
      return [...result];
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+validator@9.0.2/node_modules/@ucanto/validator/src/error.js
var EscalatedCapability, DelegationError, MalformedCapability, UnknownCapability, format7, indent2, li2;
var init_error = __esm({
  "../../node_modules/.pnpm/@ucanto+validator@9.0.2/node_modules/@ucanto/validator/src/error.js"() {
    init_util2();
    init_link2();
    init_result();
    EscalatedCapability = class extends Failure {
      /**
       * @param {API.ParsedCapability} claimed
       * @param {object} delegated
       * @param {API.Failure} cause
       */
      constructor(claimed, delegated, cause) {
        super();
        this.claimed = claimed;
        this.delegated = delegated;
        this.cause = cause;
        this.name = the("EscalatedCapability");
      }
      describe() {
        return `Constraint violation: ${this.cause.message}`;
      }
    };
    DelegationError = class extends Failure {
      /**
       * @param {(API.InvalidCapability | API.EscalatedDelegation | API.DelegationError)[]} causes
       * @param {object} context
       */
      constructor(causes, context2) {
        super();
        this.name = the("InvalidClaim");
        this.causes = causes;
        this.context = context2;
      }
      describe() {
        return [
          `Can not derive ${this.context} from delegated capabilities:`,
          ...this.causes.map((cause) => li2(cause.message))
        ].join("\n");
      }
      /**
       * @type {API.InvalidCapability | API.EscalatedDelegation | API.DelegationError}
       */
      get cause() {
        if (this.causes.length !== 1) {
          return this;
        } else {
          const [cause] = this.causes;
          const value = cause.name === "InvalidClaim" ? cause.cause : cause;
          Object.defineProperties(this, { cause: { value } });
          return value;
        }
      }
    };
    MalformedCapability = class extends Failure {
      /**
       * @param {API.Capability} capability
       * @param {API.Failure} cause
       */
      constructor(capability2, cause) {
        super();
        this.name = the("MalformedCapability");
        this.capability = capability2;
        this.cause = cause;
      }
      describe() {
        return [
          `Encountered malformed '${this.capability.can}' capability: ${format7(
            this.capability
          )}`,
          li2(this.cause.message)
        ].join("\n");
      }
    };
    UnknownCapability = class extends Failure {
      /**
       * @param {API.Capability} capability
       */
      constructor(capability2) {
        super();
        this.name = the("UnknownCapability");
        this.capability = capability2;
      }
      /* c8 ignore next 3 */
      describe() {
        return `Encountered unknown capability: ${format7(this.capability)}`;
      }
    };
    format7 = (capability2, space) => JSON.stringify(
      capability2,
      (_key, value) => {
        if (isLink(value)) {
          return value.toString();
        } else {
          return value;
        }
      },
      space
    );
    indent2 = (message, indent3 = "  ") => `${indent3}${message.split("\n").join(`
${indent3}`)}`;
    li2 = (message) => indent2(`- ${message}`);
  }
});

// ../../node_modules/.pnpm/@ucanto+validator@9.0.2/node_modules/@ucanto/validator/src/capability.js
var capability, defaultNBSchema, or5, and2, derive, View2, Unit, Capability, createCapability, isEmpty, Or, And, Derive, Match2, DerivedMatch, AndMatch, resolveAbility, resolveResource, parseCapability, resolveCapability, CapabilityView, select, selectGroup, defaultDerives;
var init_capability = __esm({
  "../../node_modules/.pnpm/@ucanto+validator@9.0.2/node_modules/@ucanto/validator/src/capability.js"() {
    init_util2();
    init_error();
    init_lib3();
    capability = ({
      derives = defaultDerives,
      nb = defaultNBSchema,
      ...etc
    }) => new Capability({ derives, nb, ...etc });
    defaultNBSchema = /** @type {Schema.MapRepresentation<any>} */
    schema_exports3.struct({});
    or5 = (left, right) => new Or(left, right);
    and2 = (...selectors) => new And(selectors);
    derive = ({ from: from21, to, derives }) => new Derive(from21, to, derives);
    View2 = class {
      /**
       * @param {API.Source} source
       * @returns {API.MatchResult<M>}
       */
      /* c8 ignore next 3 */
      match(source) {
        return { error: new UnknownCapability(source.capability) };
      }
      /**
       * @param {API.Source[]} capabilities
       * @returns {API.Select<M>}
       */
      select(capabilities) {
        return select(this, capabilities);
      }
      /**
       * @template {API.ParsedCapability} U
       * @param {object} source
       * @param {API.TheCapabilityParser<API.DirectMatch<U>>} source.to
       * @param {API.Derives<U, API.InferDeriveProof<M['value']>>} source.derives
       * @returns {API.TheCapabilityParser<API.DerivedMatch<U, M>>}
       */
      derive({ derives, to }) {
        return derive({ derives, to, from: this });
      }
    };
    Unit = class extends View2 {
      /**
       * @template {API.Match} W
       * @param {API.MatchSelector<W>} other
       * @returns {API.CapabilityParser<M | W>}
       */
      or(other) {
        return or5(this, other);
      }
      /**
       * @template {API.Match} W
       * @param {API.CapabilityParser<W>} other
       * @returns {API.CapabilitiesParser<[M, W]>}
       */
      and(other) {
        return and2(
          /** @type {API.CapabilityParser<M>} */
          this,
          other
        );
      }
    };
    Capability = class extends Unit {
      /**
       * @param {Required<Descriptor<A, R, C>>} descriptor
       */
      constructor(descriptor) {
        super();
        this.descriptor = descriptor;
        this.schema = schema_exports3.struct({
          can: schema_exports3.literal(descriptor.can),
          with: descriptor.with,
          nb: descriptor.nb
        });
      }
      /**
       * @param {API.InferCreateOptions<R, C>} options
       */
      create(options) {
        const { descriptor, can } = this;
        const decoders = descriptor.nb;
        const data = (
          /** @type {C} */
          options.nb || {}
        );
        const resource = descriptor.with.read(options.with);
        if (resource.error) {
          throw Object.assign(
            new Error(`Invalid 'with' - ${resource.error.message}`),
            {
              cause: resource
            }
          );
        }
        const nb = descriptor.nb.read(data);
        if (nb.error) {
          throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {
            cause: nb
          });
        }
        return createCapability({ can, with: resource.ok, nb: nb.ok });
      }
      /**
       * @param {API.InferInvokeOptions<R, C>} options
       */
      invoke({ with: with_, nb, ...options }) {
        return invoke({
          ...options,
          capability: this.create(
            /** @type {API.InferCreateOptions<R, C>} */
            { with: with_, nb }
          )
        });
      }
      /**
       * @param {API.InferDelegationOptions<R, C>} options
       * @returns {Promise<API.Delegation<[API.InferDelegatedCapability<API.ParsedCapability<A, R, C>>]>>}
       */
      async delegate({ nb: input10 = {}, with: with_, ...options }) {
        const { descriptor, can } = this;
        const readers = descriptor.nb;
        const resource = descriptor.with.read(with_);
        if (resource.error) {
          throw Object.assign(
            new Error(`Invalid 'with' - ${resource.error.message}`),
            {
              cause: resource
            }
          );
        }
        const nb = descriptor.nb.partial().read(input10);
        if (nb.error) {
          throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {
            cause: nb
          });
        }
        return delegate({
          capabilities: [createCapability({ can, with: resource.ok, nb: nb.ok })],
          ...options
        });
      }
      get can() {
        return this.descriptor.can;
      }
      /**
       * @param {API.Source} source
       * @returns {API.MatchResult<API.DirectMatch<API.ParsedCapability<A, R, C>>>}
       */
      match(source) {
        const result = parseCapability(this.descriptor, source);
        return result.error ? result : { ok: new Match2(source, result.ok, this.descriptor) };
      }
      toString() {
        return JSON.stringify({ can: this.descriptor.can });
      }
    };
    createCapability = ({ can, with: with_, nb }) => (
      /** @type {API.InferCapability<T>} */
      {
        can,
        with: with_,
        ...isEmpty(nb) ? {} : { nb }
      }
    );
    isEmpty = (object) => {
      for (const _ in object) {
        return false;
      }
      return true;
    };
    Or = class extends Unit {
      /**
       * @param {API.Matcher<M>} left
       * @param {API.Matcher<W>} right
       */
      constructor(left, right) {
        super();
        this.left = left;
        this.right = right;
      }
      /**
       * @param {API.Source} capability
       * @return {API.MatchResult<M|W>}
       */
      match(capability2) {
        const left = this.left.match(capability2);
        if (left.error) {
          const right = this.right.match(capability2);
          if (right.error) {
            return right.error.name === "MalformedCapability" ? (
              //
              right
            ) : (
              //
              left
            );
          } else {
            return right;
          }
        } else {
          return left;
        }
      }
      toString() {
        return `${this.left.toString()}|${this.right.toString()}`;
      }
    };
    And = class _And extends View2 {
      /**
       * @param {Selectors} selectors
       */
      constructor(selectors) {
        super();
        this.selectors = selectors;
      }
      /**
       * @param {API.Source} capability
       * @returns {API.MatchResult<API.Amplify<API.InferMembers<Selectors>>>}
       */
      match(capability2) {
        const group2 = [];
        for (const selector of this.selectors) {
          const result = selector.match(capability2);
          if (result.error) {
            return result;
          } else {
            group2.push(result.ok);
          }
        }
        return {
          ok: new AndMatch(
            /** @type {API.InferMembers<Selectors>} */
            group2
          )
        };
      }
      /**
       * @param {API.Source[]} capabilities
       */
      select(capabilities) {
        return selectGroup(this, capabilities);
      }
      /**
       * @template E
       * @template {API.Match} X
       * @param {API.MatchSelector<API.Match<E, X>>} other
       * @returns {API.CapabilitiesParser<[...API.InferMembers<Selectors>, API.Match<E, X>]>}
       */
      and(other) {
        return new _And([...this.selectors, other]);
      }
      toString() {
        return `[${this.selectors.map(String).join(", ")}]`;
      }
    };
    Derive = class extends Unit {
      /**
       * @param {API.MatchSelector<M>} from
       * @param {API.TheCapabilityParser<API.DirectMatch<T>>} to
       * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives
       */
      constructor(from21, to, derives) {
        super();
        this.from = from21;
        this.to = to;
        this.derives = derives;
      }
      /**
       * @type {typeof this.to['create']}
       */
      create(options) {
        return this.to.create(options);
      }
      /**
       * @type {typeof this.to['invoke']}
       */
      invoke(options) {
        return this.to.invoke(options);
      }
      /**
       * @type {typeof this.to['delegate']}
       */
      delegate(options) {
        return this.to.delegate(options);
      }
      get can() {
        return this.to.can;
      }
      /**
       * @param {API.Source} capability
       * @returns {API.MatchResult<API.DerivedMatch<T, M>>}
       */
      match(capability2) {
        const match5 = this.to.match(capability2);
        if (match5.error) {
          return match5;
        } else {
          return { ok: new DerivedMatch(match5.ok, this.from, this.derives) };
        }
      }
      toString() {
        return this.to.toString();
      }
    };
    Match2 = class _Match {
      /**
       * @param {API.Source} source
       * @param {API.ParsedCapability<A, R, C>} value
       * @param {Required<Descriptor<A, R, C>>} descriptor
       */
      constructor(source, value, descriptor) {
        this.source = [source];
        this.value = value;
        this.descriptor = descriptor;
      }
      get can() {
        return this.value.can;
      }
      get proofs() {
        const proofs2 = [this.source[0].delegation];
        Object.defineProperties(this, {
          proofs: { value: proofs2 }
        });
        return proofs2;
      }
      /**
       * @param {API.CanIssue} context
       * @returns {API.DirectMatch<API.ParsedCapability<A, R, C>>|null}
       */
      prune(context2) {
        if (context2.canIssue(this.value, this.source[0].delegation.issuer.did())) {
          return null;
        } else {
          return this;
        }
      }
      /**
       * @param {API.Source[]} capabilities
       * @returns {API.Select<API.DirectMatch<API.ParsedCapability<A, R, C>>>}
       */
      select(capabilities) {
        const unknown2 = [];
        const errors2 = [];
        const matches = [];
        for (const capability2 of capabilities) {
          const result = resolveCapability(this.descriptor, this.value, capability2);
          if (result.ok) {
            const claim = this.descriptor.derives(this.value, result.ok);
            if (claim.error) {
              errors2.push(
                new DelegationError(
                  [new EscalatedCapability(this.value, result.ok, claim.error)],
                  this
                )
              );
            } else {
              matches.push(new _Match(capability2, result.ok, this.descriptor));
            }
          } else {
            switch (result.error.name) {
              case "UnknownCapability":
                unknown2.push(result.error.capability);
                break;
              case "MalformedCapability":
              default:
                errors2.push(new DelegationError([result.error], this));
            }
          }
        }
        return { matches, unknown: unknown2, errors: errors2 };
      }
      toString() {
        const { nb } = this.value;
        return JSON.stringify({
          can: this.descriptor.can,
          with: this.value.with,
          nb: nb && Object.keys(nb).length > 0 ? nb : void 0
        });
      }
    };
    DerivedMatch = class _DerivedMatch {
      /**
       * @param {API.DirectMatch<T>} selected
       * @param {API.MatchSelector<M>} from
       * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives
       */
      constructor(selected, from21, derives) {
        this.selected = selected;
        this.from = from21;
        this.derives = derives;
      }
      get can() {
        return this.value.can;
      }
      get source() {
        return this.selected.source;
      }
      get proofs() {
        const proofs2 = [];
        for (const { delegation } of this.selected.source) {
          proofs2.push(delegation);
        }
        Object.defineProperties(this, { proofs: { value: proofs2 } });
        return proofs2;
      }
      get value() {
        return this.selected.value;
      }
      /**
       * @param {API.CanIssue} context
       */
      prune(context2) {
        const selected = (
          /** @type {API.DirectMatch<T>|null} */
          this.selected.prune(context2)
        );
        return selected ? new _DerivedMatch(selected, this.from, this.derives) : null;
      }
      /**
       * @param {API.Source[]} capabilities
       */
      select(capabilities) {
        const { derives, selected, from: from21 } = this;
        const { value } = selected;
        const direct = selected.select(capabilities);
        const derived = from21.select(capabilities);
        const matches = [];
        const errors2 = [];
        for (const match5 of derived.matches) {
          const result = derives(value, match5.value);
          if (result.error) {
            errors2.push(
              new DelegationError(
                [new EscalatedCapability(value, match5.value, result.error)],
                this
              )
            );
          } else {
            matches.push(match5);
          }
        }
        return {
          unknown: intersection2(direct.unknown, derived.unknown),
          errors: [
            ...errors2,
            ...direct.errors,
            ...derived.errors.map((error3) => new DelegationError([error3], this))
          ],
          matches: [
            ...direct.matches.map((match5) => new _DerivedMatch(match5, from21, derives)),
            ...matches
          ]
        };
      }
      toString() {
        return this.selected.toString();
      }
    };
    AndMatch = class _AndMatch {
      /**
       * @param {API.Match[]} matches
       */
      constructor(matches) {
        this.matches = matches;
      }
      get selectors() {
        return this.matches;
      }
      /**
       * @returns {API.Source[]}
       */
      get source() {
        const source = [];
        for (const match5 of this.matches) {
          source.push(...match5.source);
        }
        Object.defineProperties(this, { source: { value: source } });
        return source;
      }
      /**
       * @param {API.CanIssue} context
       */
      prune(context2) {
        const matches = [];
        for (const match5 of this.matches) {
          const pruned = match5.prune(context2);
          if (pruned) {
            matches.push(pruned);
          }
        }
        return matches.length === 0 ? null : new _AndMatch(matches);
      }
      get proofs() {
        const proofs2 = [];
        for (const { delegation } of this.source) {
          proofs2.push(delegation);
        }
        Object.defineProperties(this, { proofs: { value: proofs2 } });
        return proofs2;
      }
      /**
       * @type {API.InferValue<API.InferMembers<Selectors>>}
       */
      get value() {
        const value = [];
        for (const match5 of this.matches) {
          value.push(match5.value);
        }
        Object.defineProperties(this, { value: { value } });
        return (
          /** @type {any} */
          value
        );
      }
      /**
       * @param {API.Source[]} capabilities
       */
      select(capabilities) {
        return selectGroup(this, capabilities);
      }
      toString() {
        return `[${this.matches.map((match5) => match5.toString()).join(", ")}]`;
      }
    };
    resolveAbility = (pattern, can, fallback) => {
      switch (pattern) {
        case can:
        case "*":
          return can;
        default:
          return pattern.endsWith("/*") && can.startsWith(pattern.slice(0, -1)) ? can : fallback;
      }
    };
    resolveResource = (source, uri2, fallback) => {
      switch (source) {
        case uri2:
        case "ucan:*":
          return uri2;
        default:
          return fallback;
      }
    };
    parseCapability = (descriptor, source) => {
      const { delegation } = source;
      const capability2 = (
        /** @type {API.Capability<A, R, C>} */
        source.capability
      );
      if (descriptor.can !== capability2.can) {
        return { error: new UnknownCapability(capability2) };
      }
      const uri2 = descriptor.with.read(capability2.with);
      if (uri2.error) {
        return { error: new MalformedCapability(capability2, uri2.error) };
      }
      const nb = descriptor.nb.read(capability2.nb || {});
      if (nb.error) {
        return { error: new MalformedCapability(capability2, nb.error) };
      }
      return { ok: new CapabilityView(descriptor.can, uri2.ok, nb.ok, delegation) };
    };
    resolveCapability = (descriptor, claimed, { capability: capability2, delegation }) => {
      const can = resolveAbility(capability2.can, claimed.can, null);
      if (can == null) {
        return { error: new UnknownCapability(capability2) };
      }
      const resource = resolveResource(
        capability2.with,
        claimed.with,
        capability2.with
      );
      const uri2 = descriptor.with.read(resource);
      if (uri2.error) {
        return { error: new MalformedCapability(capability2, uri2.error) };
      }
      const nb = descriptor.nb.read({
        ...claimed.nb,
        ...capability2.nb
      });
      if (nb.error) {
        return { error: new MalformedCapability(capability2, nb.error) };
      }
      return { ok: new CapabilityView(can, uri2.ok, nb.ok, delegation) };
    };
    CapabilityView = class {
      /**
       * @param {A} can
       * @param {R} with_
       * @param {C} nb
       * @param {API.Delegation} delegation
       */
      constructor(can, with_, nb, delegation) {
        this.can = can;
        this.with = with_;
        this.delegation = delegation;
        this.nb = nb;
      }
    };
    select = (matcher, capabilities) => {
      const unknown2 = [];
      const matches = [];
      const errors2 = [];
      for (const capability2 of capabilities) {
        const result = matcher.match(capability2);
        if (result.error) {
          switch (result.error.name) {
            case "UnknownCapability":
              unknown2.push(result.error.capability);
              break;
            case "MalformedCapability":
            default:
              errors2.push(new DelegationError([result.error], result.error.capability));
          }
        } else {
          matches.push(result.ok);
        }
      }
      return { matches, errors: errors2, unknown: unknown2 };
    };
    selectGroup = (self2, capabilities) => {
      let unknown2;
      const data = [];
      const errors2 = [];
      for (const selector of self2.selectors) {
        const selected = selector.select(capabilities);
        unknown2 = unknown2 ? intersection2(unknown2, selected.unknown) : selected.unknown;
        for (const error3 of selected.errors) {
          errors2.push(new DelegationError([error3], self2));
        }
        data.push(selected.matches);
      }
      const matches = combine(data).map((group2) => new AndMatch(group2));
      return {
        unknown: (
          /* c8 ignore next */
          unknown2 || []
        ),
        errors: errors2,
        matches
      };
    };
    defaultDerives = (claimed, delegated) => {
      if (delegated.with.endsWith("*")) {
        if (!claimed.with.startsWith(delegated.with.slice(0, -1))) {
          return schema_exports3.error(
            `Resource ${claimed.with} does not match delegated ${delegated.with} `
          );
        }
      } else if (delegated.with !== claimed.with) {
        return schema_exports3.error(
          `Resource ${claimed.with} is not contained by ${delegated.with}`
        );
      }
      const caveats = delegated.nb || {};
      const nb = claimed.nb || {};
      const kv = entries(caveats);
      for (const [name20, value] of kv) {
        if (nb[name20] != value) {
          return schema_exports3.error(`${String(name20)}: ${nb[name20]} violates ${value}`);
        }
      }
      return { ok: true };
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+validator@9.0.2/node_modules/@ucanto/validator/src/authorization.js
var init_authorization = __esm({
  "../../node_modules/.pnpm/@ucanto+validator@9.0.2/node_modules/@ucanto/validator/src/authorization.js"() {
  }
});

// ../../node_modules/.pnpm/@ucanto+validator@9.0.2/node_modules/@ucanto/validator/src/lib.js
var init_lib6 = __esm({
  "../../node_modules/.pnpm/@ucanto+validator@9.0.2/node_modules/@ucanto/validator/src/lib.js"() {
    init_lib3();
    init_capability();
    init_schema3();
    init_authorization();
    init_error();
    init_capability();
    init_schema3();
  }
});

// ../../node_modules/.pnpm/@web3-storage+capabilities@16.0.0/node_modules/@web3-storage/capabilities/src/filecoin/lib.js
var FR32_SHA2_256_TRUNC254_PADDED_BINARY_TREE, RAW_CODE, PieceLink;
var init_lib7 = __esm({
  "../../node_modules/.pnpm/@web3-storage+capabilities@16.0.0/node_modules/@web3-storage/capabilities/src/filecoin/lib.js"() {
    init_lib6();
    FR32_SHA2_256_TRUNC254_PADDED_BINARY_TREE = /** @type {const} */
    4113;
    RAW_CODE = /** @type {const} */
    85;
    PieceLink = /** @type {import('../types.js').PieceLinkSchema} */
    schema_exports3.link({
      code: RAW_CODE,
      version: 1,
      multihash: {
        code: FR32_SHA2_256_TRUNC254_PADDED_BINARY_TREE
      }
    });
  }
});

// ../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/equals.js
function equals7(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
var init_equals = __esm({
  "../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/equals.js"() {
  }
});

// ../../node_modules/.pnpm/@web3-storage+capabilities@16.0.0/node_modules/@web3-storage/capabilities/src/utils.js
function equalWith(child, parent) {
  return child.with === parent.with ? ok({}) : fail2(`Can not derive ${child.can} with ${child.with} from ${parent.with}`);
}
function equal(child, parent, constraint) {
  if (parent === void 0 || parent === "*") {
    return ok({});
  } else if (String(child) === String(parent)) {
    return ok({});
  } else {
    return fail2(
      `Constrain violation: ${child} violates imposed ${constraint} constraint ${parent}`
    );
  }
}
var ProviderDID, SpaceDID, AccountDID, Await, checkLink, and3;
var init_utils4 = __esm({
  "../../node_modules/.pnpm/@web3-storage+capabilities@16.0.0/node_modules/@web3-storage/capabilities/src/utils.js"() {
    init_lib6();
    init_equals();
    ProviderDID = did_exports2.match({ method: "web" });
    SpaceDID = did_exports2.match({ method: "key" });
    AccountDID = did_exports2.match({ method: "mailto" });
    Await = schema_exports3.struct({
      "ucan/await": schema_exports3.tuple([schema_exports3.string(), schema_exports3.link()])
    });
    checkLink = (claimed, imposed, at2) => {
      return equal(
        String(claimed),
        imposed === void 0 ? void 0 : String(imposed),
        at2
      );
    };
    and3 = (result) => result.error ? result : void 0;
  }
});

// ../../node_modules/.pnpm/@web3-storage+capabilities@16.0.0/node_modules/@web3-storage/capabilities/src/filecoin/storefront.js
var filecoinOffer, filecoinSubmit, filecoinAccept, filecoinInfo;
var init_storefront = __esm({
  "../../node_modules/.pnpm/@web3-storage+capabilities@16.0.0/node_modules/@web3-storage/capabilities/src/filecoin/storefront.js"() {
    init_lib6();
    init_lib7();
    init_utils4();
    filecoinOffer = capability({
      can: "filecoin/offer",
      /**
       * DID of the space the content is stored in.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * CID of the content that resulted in Filecoin piece.
         */
        content: schema_exports3.link(),
        /**
         * CID of the piece.
         */
        piece: PieceLink
      }),
      derives: (claim, from21) => {
        return and3(equalWith(claim, from21)) || and3(checkLink(claim.nb.content, from21.nb.content, "nb.content")) || and3(checkLink(claim.nb.piece, from21.nb.piece, "nb.piece")) || ok({});
      }
    });
    filecoinSubmit = capability({
      can: "filecoin/submit",
      /**
       * DID of the Storefront.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * CID of the content that resulted in Filecoin piece.
         */
        content: schema_exports3.link(),
        /**
         * CID of the piece.
         *
         * @see https://github.com/filecoin-project/FIPs/pull/758/files
         */
        piece: PieceLink
      }),
      derives: (claim, from21) => {
        return and3(equalWith(claim, from21)) || and3(checkLink(claim.nb.content, from21.nb.content, "nb.content")) || and3(checkLink(claim.nb.piece, from21.nb.piece, "nb.piece")) || ok({});
      }
    });
    filecoinAccept = capability({
      can: "filecoin/accept",
      /**
       * DID of the Storefront.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * CID of the content that resulted in Filecoin piece.
         */
        content: schema_exports3.link(),
        /**
         * CID of the piece.
         *
         * @see https://github.com/filecoin-project/FIPs/pull/758/files
         */
        piece: PieceLink
      }),
      derives: (claim, from21) => {
        return and3(equalWith(claim, from21)) || and3(checkLink(claim.nb.content, from21.nb.content, "nb.content")) || and3(checkLink(claim.nb.piece, from21.nb.piece, "nb.piece")) || ok({});
      }
    });
    filecoinInfo = capability({
      can: "filecoin/info",
      /**
       * DID of the space the content is stored in.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * CID of the piece.
         *
         * @see https://github.com/filecoin-project/FIPs/pull/758/files
         */
        piece: PieceLink
      }),
      derives: (claim, from21) => {
        return and3(equalWith(claim, from21)) || and3(checkLink(claim.nb.piece, from21.nb.piece, "nb.piece")) || ok({});
      }
    });
  }
});

// ../../node_modules/.pnpm/@web3-storage+filecoin-client@3.3.3/node_modules/@web3-storage/filecoin-client/dist/src/service.js
var services;
var init_service2 = __esm({
  "../../node_modules/.pnpm/@web3-storage+filecoin-client@3.3.3/node_modules/@web3-storage/filecoin-client/dist/src/service.js"() {
    init_did();
    services = {
      STOREFRONT: {
        url: new URL("https://up.web3.storage"),
        principal: parse3("did:web:web3.storage")
      },
      AGGREGATOR: {
        url: new URL("https://aggregator.web3.storage"),
        principal: parse3("did:web:web3.storage")
      },
      DEALER: {
        url: new URL("https://dealer.web3.storage"),
        principal: parse3("did:web:web3.storage")
      },
      DEAL_TRACKER: {
        url: new URL("https://tracker.web3.storage"),
        principal: parse3("did:web:web3.storage")
      }
    };
  }
});

// ../../node_modules/.pnpm/@web3-storage+filecoin-client@3.3.3/node_modules/@web3-storage/filecoin-client/dist/src/storefront.js
var storefront_exports = {};
__export(storefront_exports, {
  connection: () => connection,
  filecoinAccept: () => filecoinAccept2,
  filecoinInfo: () => filecoinInfo2,
  filecoinOffer: () => filecoinOffer2,
  filecoinSubmit: () => filecoinSubmit2
});
async function filecoinOffer2({ issuer, with: resource, proofs: proofs2, audience }, content2, piece, options = {}) {
  const conn = options.connection ?? connection;
  const invocation = filecoinOffer.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? services.STOREFRONT.principal,
    with: resource,
    nb: {
      content: content2,
      piece
    },
    proofs: proofs2,
    expiration: Infinity
  });
  return await invocation.execute(conn);
}
async function filecoinSubmit2({ issuer, with: resource, proofs: proofs2, audience }, content2, piece, options = {}) {
  const conn = options.connection ?? connection;
  const invocation = filecoinSubmit.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? services.STOREFRONT.principal,
    with: resource,
    nb: {
      content: content2,
      piece
    },
    proofs: proofs2,
    expiration: Infinity
  });
  return await invocation.execute(conn);
}
async function filecoinAccept2({ issuer, with: resource, proofs: proofs2, audience }, content2, piece, options = {}) {
  const conn = options.connection ?? connection;
  const invocation = filecoinAccept.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? services.STOREFRONT.principal,
    with: resource,
    nb: {
      content: content2,
      piece
    },
    proofs: proofs2,
    expiration: Infinity
  });
  return await invocation.execute(conn);
}
async function filecoinInfo2({ issuer, with: resource, proofs: proofs2, audience }, piece, options = {}) {
  const conn = options.connection ?? connection;
  const invocation = filecoinInfo.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? services.STOREFRONT.principal,
    with: resource,
    nb: {
      piece
    },
    proofs: proofs2
  });
  return await invocation.execute(conn);
}
var connection;
var init_storefront2 = __esm({
  "../../node_modules/.pnpm/@web3-storage+filecoin-client@3.3.3/node_modules/@web3-storage/filecoin-client/dist/src/storefront.js"() {
    init_lib4();
    init_lib5();
    init_storefront();
    init_service2();
    connection = connect({
      id: services.STOREFRONT.principal,
      codec: car_exports2.outbound,
      channel: http_exports.open({
        url: services.STOREFRONT.url,
        method: "POST"
      })
    });
  }
});

// ../../node_modules/.pnpm/@web3-storage+capabilities@16.0.0/node_modules/@web3-storage/capabilities/src/filecoin/aggregator.js
var pieceOffer, pieceAccept;
var init_aggregator = __esm({
  "../../node_modules/.pnpm/@web3-storage+capabilities@16.0.0/node_modules/@web3-storage/capabilities/src/filecoin/aggregator.js"() {
    init_lib6();
    init_lib7();
    init_utils4();
    pieceOffer = capability({
      can: "piece/offer",
      /**
       * DID of an authorized Storefront.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * CID of the piece.
         */
        piece: PieceLink,
        /**
         * Grouping of joining segments into an aggregate.
         */
        group: schema_exports3.text()
      }),
      derives: (claim, from21) => {
        return and3(equalWith(claim, from21)) || and3(checkLink(claim.nb.piece, from21.nb.piece, "nb.piece")) || and3(equal(claim.nb.group, from21.nb.group, "nb.group")) || ok({});
      }
    });
    pieceAccept = capability({
      can: "piece/accept",
      /**
       * DID of the Aggregator.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * CID of the piece.
         *
         * @see https://github.com/filecoin-project/FIPs/pull/758/files
         */
        piece: PieceLink,
        /**
         * Grouping of joining segments into an aggregate.
         */
        group: schema_exports3.text()
      }),
      derives: (claim, from21) => {
        return and3(equalWith(claim, from21)) || and3(checkLink(claim.nb.piece, from21.nb.piece, "nb.piece")) || and3(equal(claim.nb.group, from21.nb.group, "nb.group")) || ok({});
      }
    });
  }
});

// ../../node_modules/.pnpm/@web3-storage+filecoin-client@3.3.3/node_modules/@web3-storage/filecoin-client/dist/src/aggregator.js
var connection2;
var init_aggregator2 = __esm({
  "../../node_modules/.pnpm/@web3-storage+filecoin-client@3.3.3/node_modules/@web3-storage/filecoin-client/dist/src/aggregator.js"() {
    init_lib4();
    init_lib5();
    init_aggregator();
    init_service2();
    connection2 = connect({
      id: services.AGGREGATOR.principal,
      codec: car_exports2.outbound,
      channel: http_exports.open({
        url: services.AGGREGATOR.url,
        method: "POST"
      })
    });
  }
});

// ../../node_modules/.pnpm/@web3-storage+capabilities@16.0.0/node_modules/@web3-storage/capabilities/src/filecoin/dealer.js
var aggregateOffer, aggregateAccept;
var init_dealer = __esm({
  "../../node_modules/.pnpm/@web3-storage+capabilities@16.0.0/node_modules/@web3-storage/capabilities/src/filecoin/dealer.js"() {
    init_lib6();
    init_lib7();
    init_utils4();
    aggregateOffer = capability({
      can: "aggregate/offer",
      /**
       * DID of an authorized Storefront.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * Commitment proof for the aggregate being offered.
         */
        aggregate: PieceLink,
        /**
         * CID of the DAG-CBOR encoded block with offer details.
         * Service will queue given offer to be validated and handled.
         */
        pieces: schema_exports3.link({ version: 1 })
      }),
      derives: (claim, from21) => {
        return and3(equalWith(claim, from21)) || and3(checkLink(claim.nb.aggregate, from21.nb.aggregate, "nb.aggregate")) || and3(checkLink(claim.nb.pieces, from21.nb.pieces, "nb.pieces")) || ok({});
      }
    });
    aggregateAccept = capability({
      can: "aggregate/accept",
      /**
       * did:key identifier of the broker authority where offer is made available.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * Commitment proof for the aggregate being offered.
         */
        aggregate: PieceLink,
        /**
         * CID of the DAG-CBOR encoded block with offer details.
         * Service will queue given offer to be validated and handled.
         */
        pieces: schema_exports3.link()
      }),
      derives: (claim, from21) => {
        return and3(equalWith(claim, from21)) || and3(checkLink(claim.nb.aggregate, from21.nb.aggregate, "nb.aggregate")) || and3(checkLink(claim.nb.pieces, from21.nb.pieces, "nb.pieces")) || ok({});
      }
    });
  }
});

// ../../node_modules/.pnpm/@web3-storage+filecoin-client@3.3.3/node_modules/@web3-storage/filecoin-client/dist/src/dealer.js
var connection3;
var init_dealer2 = __esm({
  "../../node_modules/.pnpm/@web3-storage+filecoin-client@3.3.3/node_modules/@web3-storage/filecoin-client/dist/src/dealer.js"() {
    init_lib4();
    init_lib5();
    init_lib3();
    init_dealer();
    init_service2();
    connection3 = connect({
      id: services.DEALER.principal,
      codec: car_exports2.outbound,
      channel: http_exports.open({
        url: services.DEALER.url,
        method: "POST"
      })
    });
  }
});

// ../../node_modules/.pnpm/@web3-storage+capabilities@16.0.0/node_modules/@web3-storage/capabilities/src/filecoin/deal-tracker.js
var dealInfo;
var init_deal_tracker = __esm({
  "../../node_modules/.pnpm/@web3-storage+capabilities@16.0.0/node_modules/@web3-storage/capabilities/src/filecoin/deal-tracker.js"() {
    init_lib6();
    init_lib7();
    init_utils4();
    dealInfo = capability({
      can: "deal/info",
      /**
       * DID of the Storefront.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * CID of the piece.
         *
         * @see https://github.com/filecoin-project/FIPs/pull/758/files
         */
        piece: PieceLink
      }),
      derives: (claim, from21) => {
        return and3(equalWith(claim, from21)) || and3(checkLink(claim.nb.piece, from21.nb.piece, "nb.piece")) || ok({});
      }
    });
  }
});

// ../../node_modules/.pnpm/@web3-storage+filecoin-client@3.3.3/node_modules/@web3-storage/filecoin-client/dist/src/deal-tracker.js
var connection4;
var init_deal_tracker2 = __esm({
  "../../node_modules/.pnpm/@web3-storage+filecoin-client@3.3.3/node_modules/@web3-storage/filecoin-client/dist/src/deal-tracker.js"() {
    init_lib4();
    init_lib5();
    init_deal_tracker();
    init_service2();
    connection4 = connect({
      id: services.DEAL_TRACKER.principal,
      codec: car_exports2.outbound,
      channel: http_exports.open({
        url: services.DEAL_TRACKER.url,
        method: "POST"
      })
    });
  }
});

// ../../node_modules/.pnpm/@web3-storage+filecoin-client@3.3.3/node_modules/@web3-storage/filecoin-client/dist/src/index.js
var init_src9 = __esm({
  "../../node_modules/.pnpm/@web3-storage+filecoin-client@3.3.3/node_modules/@web3-storage/filecoin-client/dist/src/index.js"() {
    init_storefront2();
    init_aggregator2();
    init_dealer2();
    init_deal_tracker2();
  }
});

// ../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/vendor/base-x.js
function base5(ALPHABET, name20) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode45(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length5 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size5 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size5);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size5 - 1; (carry !== 0 || i2 < length5) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i2;
      pbegin++;
    }
    var it2 = size5 - length5;
    while (it2 !== size5 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size5; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length5 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size5 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size5);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size5 - 1; (carry !== 0 || i2 < length5) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size5 - length5;
    while (it4 !== size5 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size5 - it4));
    var j2 = zeroes;
    while (it4 !== size5) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode53(string4) {
    var buffer3 = decodeUnsafe(string4);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name20} character`);
  }
  return {
    encode: encode45,
    decodeUnsafe,
    decode: decode53
  };
}
var src4, _brrp__multiformats_scope_baseX4, base_x_default4;
var init_base_x4 = __esm({
  "../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/vendor/base-x.js"() {
    src4 = base5;
    _brrp__multiformats_scope_baseX4 = src4;
    base_x_default4 = _brrp__multiformats_scope_baseX4;
  }
});

// ../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bytes.js
var empty5, equals8, coerce4;
var init_bytes6 = __esm({
  "../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bytes.js"() {
    empty5 = new Uint8Array(0);
    equals8 = (aa, bb) => {
      if (aa === bb) return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    coerce4 = (o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") return o;
      if (o instanceof ArrayBuffer) return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
  }
});

// ../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base.js
var Encoder4, Decoder4, ComposedDecoder4, or6, Codec4, from13, baseX4, decode37, encode31, rfc46484;
var init_base5 = __esm({
  "../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base.js"() {
    init_base_x4();
    init_bytes6();
    Encoder4 = class {
      /**
       * @param {Base} name
       * @param {Prefix} prefix
       * @param {(bytes:Uint8Array) => string} baseEncode
       */
      constructor(name20, prefix2, baseEncode) {
        this.name = name20;
        this.prefix = prefix2;
        this.baseEncode = baseEncode;
      }
      /**
       * @param {Uint8Array} bytes
       * @returns {API.Multibase<Prefix>}
       */
      encode(bytes2) {
        if (bytes2 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes2)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder4 = class {
      /**
       * @param {Base} name
       * @param {Prefix} prefix
       * @param {(text:string) => Uint8Array} baseDecode
       */
      constructor(name20, prefix2, baseDecode) {
        this.name = name20;
        this.prefix = prefix2;
        if (prefix2.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = /** @type {number} */
        prefix2.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      /**
       * @param {string} text
       */
      decode(text2) {
        if (typeof text2 === "string") {
          if (text2.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text2.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      /**
       * @template {string} OtherPrefix
       * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
       * @returns {ComposedDecoder<Prefix|OtherPrefix>}
       */
      or(decoder3) {
        return or6(this, decoder3);
      }
    };
    ComposedDecoder4 = class {
      /**
       * @param {Decoders<Prefix>} decoders
       */
      constructor(decoders) {
        this.decoders = decoders;
      }
      /**
       * @template {string} OtherPrefix
       * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
       * @returns {ComposedDecoder<Prefix|OtherPrefix>}
       */
      or(decoder3) {
        return or6(this, decoder3);
      }
      /**
       * @param {string} input
       * @returns {Uint8Array}
       */
      decode(input10) {
        const prefix2 = (
          /** @type {Prefix} */
          input10[0]
        );
        const decoder3 = this.decoders[prefix2];
        if (decoder3) {
          return decoder3.decode(input10);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input10)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    or6 = (left, right) => new ComposedDecoder4(
      /** @type {Decoders<L|R>} */
      {
        ...left.decoders || { [
          /** @type API.UnibaseDecoder<L> */
          left.prefix
        ]: left },
        ...right.decoders || { [
          /** @type API.UnibaseDecoder<R> */
          right.prefix
        ]: right }
      }
    );
    Codec4 = class {
      /**
       * @param {Base} name
       * @param {Prefix} prefix
       * @param {(bytes:Uint8Array) => string} baseEncode
       * @param {(text:string) => Uint8Array} baseDecode
       */
      constructor(name20, prefix2, baseEncode, baseDecode) {
        this.name = name20;
        this.prefix = prefix2;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder4(name20, prefix2, baseEncode);
        this.decoder = new Decoder4(name20, prefix2, baseDecode);
      }
      /**
       * @param {Uint8Array} input
       */
      encode(input10) {
        return this.encoder.encode(input10);
      }
      /**
       * @param {string} input
       */
      decode(input10) {
        return this.decoder.decode(input10);
      }
    };
    from13 = ({ name: name20, prefix: prefix2, encode: encode45, decode: decode53 }) => new Codec4(name20, prefix2, encode45, decode53);
    baseX4 = ({ prefix: prefix2, name: name20, alphabet: alphabet3 }) => {
      const { encode: encode45, decode: decode53 } = base_x_default4(alphabet3, name20);
      return from13({
        prefix: prefix2,
        name: name20,
        encode: encode45,
        /**
         * @param {string} text
         */
        decode: (text2) => coerce4(decode53(text2))
      });
    };
    decode37 = (string4, alphabet3, bitsPerChar, name20) => {
      const codes = {};
      for (let i = 0; i < alphabet3.length; ++i) {
        codes[alphabet3[i]] = i;
      }
      let end = string4.length;
      while (string4[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer3 = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string4[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name20} character`);
        }
        buffer3 = buffer3 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer3 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer3 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    encode31 = (data, alphabet3, bitsPerChar) => {
      const pad2 = alphabet3[alphabet3.length - 1] === "=";
      const mask2 = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer3 = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer3 = buffer3 << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet3[mask2 & buffer3 >> bits];
        }
      }
      if (bits) {
        out += alphabet3[mask2 & buffer3 << bitsPerChar - bits];
      }
      if (pad2) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    rfc46484 = ({ name: name20, prefix: prefix2, bitsPerChar, alphabet: alphabet3 }) => {
      return from13({
        prefix: prefix2,
        name: name20,
        encode(input10) {
          return encode31(input10, alphabet3, bitsPerChar);
        },
        decode(input10) {
          return decode37(input10, alphabet3, bitsPerChar, name20);
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base32.js
var base324, base32upper4, base32pad4, base32padupper4, base32hex4, base32hexupper4, base32hexpad4, base32hexpadupper4, base32z4;
var init_base324 = __esm({
  "../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base32.js"() {
    init_base5();
    base324 = rfc46484({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper4 = rfc46484({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad4 = rfc46484({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper4 = rfc46484({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex4 = rfc46484({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper4 = rfc46484({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad4 = rfc46484({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper4 = rfc46484({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z4 = rfc46484({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});

// ../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base58.js
var base58btc4, base58flickr4;
var init_base584 = __esm({
  "../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base58.js"() {
    init_base5();
    base58btc4 = baseX4({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr4 = baseX4({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});

// ../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/vendor/varint.js
function encode32(num, out, offset2) {
  out = out || [];
  offset2 = offset2 || 0;
  var oldOffset = offset2;
  while (num >= INT4) {
    out[offset2++] = num & 255 | MSB4;
    num /= 128;
  }
  while (num & MSBALL4) {
    out[offset2++] = num & 255 | MSB4;
    num >>>= 7;
  }
  out[offset2] = num | 0;
  encode32.bytes = offset2 - oldOffset + 1;
  return out;
}
function read8(buf3, offset2) {
  var res = 0, offset2 = offset2 || 0, shift = 0, counter = offset2, b, l = buf3.length;
  do {
    if (counter >= l) {
      read8.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$14) << shift : (b & REST$14) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$14);
  read8.bytes = counter - offset2;
  return res;
}
var encode_14, MSB4, REST4, MSBALL4, INT4, decode38, MSB$14, REST$14, N14, N24, N34, N44, N54, N64, N74, N84, N94, length4, varint6, _brrp_varint4, varint_default4;
var init_varint7 = __esm({
  "../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/vendor/varint.js"() {
    encode_14 = encode32;
    MSB4 = 128;
    REST4 = 127;
    MSBALL4 = ~REST4;
    INT4 = Math.pow(2, 31);
    decode38 = read8;
    MSB$14 = 128;
    REST$14 = 127;
    N14 = Math.pow(2, 7);
    N24 = Math.pow(2, 14);
    N34 = Math.pow(2, 21);
    N44 = Math.pow(2, 28);
    N54 = Math.pow(2, 35);
    N64 = Math.pow(2, 42);
    N74 = Math.pow(2, 49);
    N84 = Math.pow(2, 56);
    N94 = Math.pow(2, 63);
    length4 = function(value) {
      return value < N14 ? 1 : value < N24 ? 2 : value < N34 ? 3 : value < N44 ? 4 : value < N54 ? 5 : value < N64 ? 6 : value < N74 ? 7 : value < N84 ? 8 : value < N94 ? 9 : 10;
    };
    varint6 = {
      encode: encode_14,
      decode: decode38,
      encodingLength: length4
    };
    _brrp_varint4 = varint6;
    varint_default4 = _brrp_varint4;
  }
});

// ../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/varint.js
var decode39, encodeTo4, encodingLength4;
var init_varint8 = __esm({
  "../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/varint.js"() {
    init_varint7();
    decode39 = (data, offset2 = 0) => {
      const code25 = varint_default4.decode(data, offset2);
      return [code25, varint_default4.decode.bytes];
    };
    encodeTo4 = (int, target, offset2 = 0) => {
      varint_default4.encode(int, target, offset2);
      return target;
    };
    encodingLength4 = (int) => {
      return varint_default4.encodingLength(int);
    };
  }
});

// ../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/hashes/digest.js
var create11, decode40, equals9, Digest6;
var init_digest6 = __esm({
  "../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/hashes/digest.js"() {
    init_bytes6();
    init_varint8();
    create11 = (code25, digest6) => {
      const size5 = digest6.byteLength;
      const sizeOffset = encodingLength4(code25);
      const digestOffset = sizeOffset + encodingLength4(size5);
      const bytes2 = new Uint8Array(digestOffset + size5);
      encodeTo4(code25, bytes2, 0);
      encodeTo4(size5, bytes2, sizeOffset);
      bytes2.set(digest6, digestOffset);
      return new Digest6(code25, size5, digest6, bytes2);
    };
    decode40 = (multihash) => {
      const bytes2 = coerce4(multihash);
      const [code25, sizeOffset] = decode39(bytes2);
      const [size5, digestOffset] = decode39(bytes2.subarray(sizeOffset));
      const digest6 = bytes2.subarray(sizeOffset + digestOffset);
      if (digest6.byteLength !== size5) {
        throw new Error("Incorrect length");
      }
      return new Digest6(code25, size5, digest6, bytes2);
    };
    equals9 = (a, b) => {
      if (a === b) {
        return true;
      } else {
        const data = (
          /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
          b
        );
        return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals8(a.bytes, data.bytes);
      }
    };
    Digest6 = class {
      /**
       * Creates a multihash digest.
       *
       * @param {Code} code
       * @param {Size} size
       * @param {Uint8Array} digest
       * @param {Uint8Array} bytes
       */
      constructor(code25, size5, digest6, bytes2) {
        this.code = code25;
        this.size = size5;
        this.digest = digest6;
        this.bytes = bytes2;
      }
    };
  }
});

// ../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/link/interface.js
var init_interface9 = __esm({
  "../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/link/interface.js"() {
  }
});

// ../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/cid.js
var format8, cache3, baseCache3, CID4, parseCIDtoBytes4, toStringV04, toStringV14, DAG_PB_CODE5, SHA_256_CODE4, encodeCID5, cidSymbol4;
var init_cid4 = __esm({
  "../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/cid.js"() {
    init_base324();
    init_base584();
    init_bytes6();
    init_digest6();
    init_varint8();
    init_interface9();
    format8 = (link5, base6) => {
      const { bytes: bytes2, version: version3 } = link5;
      switch (version3) {
        case 0:
          return toStringV04(
            bytes2,
            baseCache3(link5),
            /** @type {API.MultibaseEncoder<"z">} */
            base6 || base58btc4.encoder
          );
        default:
          return toStringV14(
            bytes2,
            baseCache3(link5),
            /** @type {API.MultibaseEncoder<Prefix>} */
            base6 || base324.encoder
          );
      }
    };
    cache3 = /* @__PURE__ */ new WeakMap();
    baseCache3 = (cid) => {
      const baseCache4 = cache3.get(cid);
      if (baseCache4 == null) {
        const baseCache5 = /* @__PURE__ */ new Map();
        cache3.set(cid, baseCache5);
        return baseCache5;
      }
      return baseCache4;
    };
    CID4 = class _CID {
      /**
       * @param {Version} version - Version of the CID
       * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
       * @param {Uint8Array} bytes
       */
      constructor(version3, code25, multihash, bytes2) {
        this.code = code25;
        this.version = version3;
        this.multihash = multihash;
        this.bytes = bytes2;
        this["/"] = bytes2;
      }
      /**
       * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
       * please either use `CID.asCID(cid)` or switch to new signalling mechanism
       *
       * @deprecated
       */
      get asCID() {
        return this;
      }
      // ArrayBufferView
      get byteOffset() {
        return this.bytes.byteOffset;
      }
      // ArrayBufferView
      get byteLength() {
        return this.bytes.byteLength;
      }
      /**
       * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
       */
      toV0() {
        switch (this.version) {
          case 0: {
            return (
              /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
              this
            );
          }
          case 1: {
            const { code: code25, multihash } = this;
            if (code25 !== DAG_PB_CODE5) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE4) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return (
              /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
              _CID.createV0(
                /** @type {API.MultihashDigest<API.SHA_256>} */
                multihash
              )
            );
          }
          default: {
            throw Error(
              `Can not convert CID version ${this.version} to version 0. This is a bug please report`
            );
          }
        }
      }
      /**
       * @returns {CID<Data, Format, Alg, 1>}
       */
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code25, digest: digest6 } = this.multihash;
            const multihash = create11(code25, digest6);
            return (
              /** @type {CID<Data, Format, Alg, 1>} */
              _CID.createV1(this.code, multihash)
            );
          }
          case 1: {
            return (
              /** @type {CID<Data, Format, Alg, 1>} */
              this
            );
          }
          default: {
            throw Error(
              `Can not convert CID version ${this.version} to version 1. This is a bug please report`
            );
          }
        }
      }
      /**
       * @param {unknown} other
       * @returns {other is CID<Data, Format, Alg, Version>}
       */
      equals(other) {
        return _CID.equals(this, other);
      }
      /**
       * @template {unknown} Data
       * @template {number} Format
       * @template {number} Alg
       * @template {API.Version} Version
       * @param {API.Link<Data, Format, Alg, Version>} self
       * @param {unknown} other
       * @returns {other is CID}
       */
      static equals(self2, other) {
        const unknown2 = (
          /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
          other
        );
        return unknown2 && self2.code === unknown2.code && self2.version === unknown2.version && equals9(self2.multihash, unknown2.multihash);
      }
      /**
       * @param {API.MultibaseEncoder<string>} [base]
       * @returns {string}
       */
      toString(base6) {
        return format8(this, base6);
      }
      /**
       * @returns {API.LinkJSON<this>}
       */
      toJSON() {
        return { "/": format8(this) };
      }
      link() {
        return this;
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      // Legacy
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return `CID(${this.toString()})`;
      }
      /**
       * Takes any input `value` and returns a `CID` instance if it was
       * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
       * it will return value back. If `value` is not instance of this CID
       * class, but is compatible CID it will return new instance of this
       * `CID` class. Otherwise returns null.
       *
       * This allows two different incompatible versions of CID library to
       * co-exist and interop as long as binary interface is compatible.
       *
       * @template {unknown} Data
       * @template {number} Format
       * @template {number} Alg
       * @template {API.Version} Version
       * @template {unknown} U
       * @param {API.Link<Data, Format, Alg, Version>|U} input
       * @returns {CID<Data, Format, Alg, Version>|null}
       */
      static asCID(input10) {
        if (input10 == null) {
          return null;
        }
        const value = (
          /** @type {any} */
          input10
        );
        if (value instanceof _CID) {
          return value;
        } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
          const { version: version3, code: code25, multihash, bytes: bytes2 } = value;
          return new _CID(
            version3,
            code25,
            /** @type {API.MultihashDigest<Alg>} */
            multihash,
            bytes2 || encodeCID5(version3, code25, multihash.bytes)
          );
        } else if (value[cidSymbol4] === true) {
          const { version: version3, multihash, code: code25 } = value;
          const digest6 = (
            /** @type {API.MultihashDigest<Alg>} */
            decode40(multihash)
          );
          return _CID.create(version3, code25, digest6);
        } else {
          return null;
        }
      }
      /**
       *
       * @template {unknown} Data
       * @template {number} Format
       * @template {number} Alg
       * @template {API.Version} Version
       * @param {Version} version - Version of the CID
       * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
       * @returns {CID<Data, Format, Alg, Version>}
       */
      static create(version3, code25, digest6) {
        if (typeof code25 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        if (!(digest6.bytes instanceof Uint8Array)) {
          throw new Error("Invalid digest");
        }
        switch (version3) {
          case 0: {
            if (code25 !== DAG_PB_CODE5) {
              throw new Error(
                `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE5}) block encoding`
              );
            } else {
              return new _CID(version3, code25, digest6, digest6.bytes);
            }
          }
          case 1: {
            const bytes2 = encodeCID5(version3, code25, digest6.bytes);
            return new _CID(version3, code25, digest6, bytes2);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      /**
       * Simplified version of `create` for CIDv0.
       *
       * @template {unknown} [T=unknown]
       * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
       * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
       */
      static createV0(digest6) {
        return _CID.create(0, DAG_PB_CODE5, digest6);
      }
      /**
       * Simplified version of `create` for CIDv1.
       *
       * @template {unknown} Data
       * @template {number} Code
       * @template {number} Alg
       * @param {Code} code - Content encoding format code.
       * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
       * @returns {CID<Data, Code, Alg, 1>}
       */
      static createV1(code25, digest6) {
        return _CID.create(1, code25, digest6);
      }
      /**
       * Decoded a CID from its binary representation. The byte array must contain
       * only the CID with no additional bytes.
       *
       * An error will be thrown if the bytes provided do not contain a valid
       * binary representation of a CID.
       *
       * @template {unknown} Data
       * @template {number} Code
       * @template {number} Alg
       * @template {API.Version} Ver
       * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
       * @returns {CID<Data, Code, Alg, Ver>}
       */
      static decode(bytes2) {
        const [cid, remainder] = _CID.decodeFirst(bytes2);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      /**
       * Decoded a CID from its binary representation at the beginning of a byte
       * array.
       *
       * Returns an array with the first element containing the CID and the second
       * element containing the remainder of the original byte array. The remainder
       * will be a zero-length byte array if the provided bytes only contained a
       * binary CID representation.
       *
       * @template {unknown} T
       * @template {number} C
       * @template {number} A
       * @template {API.Version} V
       * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
       * @returns {[CID<T, C, A, V>, Uint8Array]}
       */
      static decodeFirst(bytes2) {
        const specs = _CID.inspectBytes(bytes2);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce4(
          bytes2.subarray(prefixSize, prefixSize + specs.multihashSize)
        );
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(
          specs.multihashSize - specs.digestSize
        );
        const digest6 = new Digest6(
          specs.multihashCode,
          specs.digestSize,
          digestBytes,
          multihashBytes
        );
        const cid = specs.version === 0 ? _CID.createV0(
          /** @type {API.MultihashDigest<API.SHA_256>} */
          digest6
        ) : _CID.createV1(specs.codec, digest6);
        return [
          /** @type {CID<T, C, A, V>} */
          cid,
          bytes2.subarray(specs.size)
        ];
      }
      /**
       * Inspect the initial bytes of a CID to determine its properties.
       *
       * Involves decoding up to 4 varints. Typically this will require only 4 to 6
       * bytes but for larger multicodec code values and larger multihash digest
       * lengths these varints can be quite large. It is recommended that at least
       * 10 bytes be made available in the `initialBytes` argument for a complete
       * inspection.
       *
       * @template {unknown} T
       * @template {number} C
       * @template {number} A
       * @template {API.Version} V
       * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
       * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
       */
      static inspectBytes(initialBytes) {
        let offset2 = 0;
        const next = () => {
          const [i, length5] = decode39(initialBytes.subarray(offset2));
          offset2 += length5;
          return i;
        };
        let version3 = (
          /** @type {V} */
          next()
        );
        let codec = (
          /** @type {C} */
          DAG_PB_CODE5
        );
        if (
          /** @type {number} */
          version3 === 18
        ) {
          version3 = /** @type {V} */
          0;
          offset2 = 0;
        } else {
          codec = /** @type {C} */
          next();
        }
        if (version3 !== 0 && version3 !== 1) {
          throw new RangeError(`Invalid CID version ${version3}`);
        }
        const prefixSize = offset2;
        const multihashCode = (
          /** @type {A} */
          next()
        );
        const digestSize = next();
        const size5 = offset2 + digestSize;
        const multihashSize = size5 - prefixSize;
        return { version: version3, codec, multihashCode, digestSize, multihashSize, size: size5 };
      }
      /**
       * Takes cid in a string representation and creates an instance. If `base`
       * decoder is not provided will use a default from the configuration. It will
       * throw an error if encoding of the CID is not compatible with supplied (or
       * a default decoder).
       *
       * @template {string} Prefix
       * @template {unknown} Data
       * @template {number} Code
       * @template {number} Alg
       * @template {API.Version} Ver
       * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
       * @param {API.MultibaseDecoder<Prefix>} [base]
       * @returns {CID<Data, Code, Alg, Ver>}
       */
      static parse(source, base6) {
        const [prefix2, bytes2] = parseCIDtoBytes4(source, base6);
        const cid = _CID.decode(bytes2);
        if (cid.version === 0 && source[0] !== "Q") {
          throw Error("Version 0 CID string must not include multibase prefix");
        }
        baseCache3(cid).set(prefix2, source);
        return cid;
      }
    };
    parseCIDtoBytes4 = (source, base6) => {
      switch (source[0]) {
        case "Q": {
          const decoder3 = base6 || base58btc4;
          return [
            /** @type {Prefix} */
            base58btc4.prefix,
            decoder3.decode(`${base58btc4.prefix}${source}`)
          ];
        }
        case base58btc4.prefix: {
          const decoder3 = base6 || base58btc4;
          return [
            /** @type {Prefix} */
            base58btc4.prefix,
            decoder3.decode(source)
          ];
        }
        case base324.prefix: {
          const decoder3 = base6 || base324;
          return [
            /** @type {Prefix} */
            base324.prefix,
            decoder3.decode(source)
          ];
        }
        default: {
          if (base6 == null) {
            throw Error(
              "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
            );
          }
          return [
            /** @type {Prefix} */
            source[0],
            base6.decode(source)
          ];
        }
      }
    };
    toStringV04 = (bytes2, cache5, base6) => {
      const { prefix: prefix2 } = base6;
      if (prefix2 !== base58btc4.prefix) {
        throw Error(`Cannot string encode V0 in ${base6.name} encoding`);
      }
      const cid = cache5.get(prefix2);
      if (cid == null) {
        const cid2 = base6.encode(bytes2).slice(1);
        cache5.set(prefix2, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    toStringV14 = (bytes2, cache5, base6) => {
      const { prefix: prefix2 } = base6;
      const cid = cache5.get(prefix2);
      if (cid == null) {
        const cid2 = base6.encode(bytes2);
        cache5.set(prefix2, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    DAG_PB_CODE5 = 112;
    SHA_256_CODE4 = 18;
    encodeCID5 = (version3, code25, multihash) => {
      const codeOffset = encodingLength4(version3);
      const hashOffset = codeOffset + encodingLength4(code25);
      const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo4(version3, bytes2, 0);
      encodeTo4(code25, bytes2, codeOffset);
      bytes2.set(multihash, hashOffset);
      return bytes2;
    };
    cidSymbol4 = Symbol.for("@ipld/js-cid/CID");
  }
});

// ../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/link.js
var create12;
var init_link4 = __esm({
  "../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/link.js"() {
    init_cid4();
    init_interface9();
    create12 = (code25, digest6) => CID4.create(1, code25, digest6);
  }
});

// ../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/codecs/raw.js
var raw_exports3 = {};
__export(raw_exports3, {
  code: () => code16,
  decode: () => decode41,
  encode: () => encode33,
  name: () => name13
});
var name13, code16, encode33, decode41;
var init_raw3 = __esm({
  "../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/codecs/raw.js"() {
    init_bytes6();
    name13 = "raw";
    code16 = 85;
    encode33 = (node) => coerce4(node);
    decode41 = (data) => coerce4(data);
  }
});

// ../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/hashes/hasher.js
var from14, Hasher5;
var init_hasher4 = __esm({
  "../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/hashes/hasher.js"() {
    init_digest6();
    from14 = ({ name: name20, code: code25, encode: encode45 }) => new Hasher5(name20, code25, encode45);
    Hasher5 = class {
      /**
       *
       * @param {Name} name
       * @param {Code} code
       * @param {(input: Uint8Array) => Await<Uint8Array>} encode
       */
      constructor(name20, code25, encode45) {
        this.name = name20;
        this.code = code25;
        this.encode = encode45;
      }
      /**
       * @param {Uint8Array} input
       * @returns {Await<Digest.Digest<Code, number>>}
       */
      digest(input10) {
        if (input10 instanceof Uint8Array) {
          const result = this.encode(input10);
          return result instanceof Uint8Array ? create11(this.code, result) : result.then((digest6) => create11(this.code, digest6));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/hashes/sha2.js
var import_crypto4, sha2563, sha5123;
var init_sha23 = __esm({
  "../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/hashes/sha2.js"() {
    import_crypto4 = __toESM(require("crypto"), 1);
    init_bytes6();
    init_hasher4();
    sha2563 = from14({
      name: "sha2-256",
      code: 18,
      encode: (input10) => coerce4(import_crypto4.default.createHash("sha256").update(input10).digest())
    });
    sha5123 = from14({
      name: "sha2-512",
      code: 19,
      encode: (input10) => coerce4(import_crypto4.default.createHash("sha512").update(input10).digest())
    });
  }
});

// ../../node_modules/.pnpm/@web3-storage+capabilities@17.2.0/node_modules/@web3-storage/capabilities/src/utils.js
function equalWith2(child, parent) {
  return child.with === parent.with ? ok({}) : fail2(`Can not derive ${child.can} with ${child.with} from ${parent.with}`);
}
function equal2(child, parent, constraint) {
  if (parent === void 0 || parent === "*") {
    return ok({});
  } else if (String(child) === String(parent)) {
    return ok({});
  } else {
    return fail2(
      `Constrain violation: ${child} violates imposed ${constraint} constraint ${parent}`
    );
  }
}
var ProviderDID2, SpaceDID2, AccountDID2, Await2, equalLink, equalBlob, equalBody, checkLink2, and4;
var init_utils5 = __esm({
  "../../node_modules/.pnpm/@web3-storage+capabilities@17.2.0/node_modules/@web3-storage/capabilities/src/utils.js"() {
    init_lib6();
    init_equals();
    ProviderDID2 = did_exports2.match({ method: "web" });
    SpaceDID2 = did_exports2.match({ method: "key" });
    AccountDID2 = did_exports2.match({ method: "mailto" });
    Await2 = schema_exports3.struct({
      "ucan/await": schema_exports3.tuple([schema_exports3.string(), schema_exports3.link()])
    });
    equalLink = (claimed, delegated) => {
      if (claimed.with !== delegated.with) {
        return fail2(
          `Expected 'with: "${delegated.with}"' instead got '${claimed.with}'`
        );
      } else if (delegated.nb.link && `${delegated.nb.link}` !== `${claimed.nb.link}`) {
        return fail2(
          `Link ${claimed.nb.link ? `${claimed.nb.link}` : ""} violates imposed ${delegated.nb.link} constraint.`
        );
      } else {
        return ok({});
      }
    };
    equalBlob = (claimed, delegated) => {
      if (claimed.with !== delegated.with) {
        return fail2(
          `Expected 'with: "${delegated.with}"' instead got '${claimed.with}'`
        );
      } else if (delegated.nb.blob.digest && !equals7(delegated.nb.blob.digest, claimed.nb.blob.digest)) {
        return fail2(
          `Link ${claimed.nb.blob.digest ? `${claimed.nb.blob.digest}` : ""} violates imposed ${delegated.nb.blob.digest} constraint.`
        );
      } else if (claimed.nb.blob.size !== void 0 && delegated.nb.blob.size !== void 0) {
        return claimed.nb.blob.size > delegated.nb.blob.size ? fail2(
          `Size constraint violation: ${claimed.nb.blob.size} > ${delegated.nb.blob.size}`
        ) : ok({});
      } else {
        return ok({});
      }
    };
    equalBody = (claimed, delegated) => {
      if (claimed.with !== delegated.with) {
        return fail2(
          `Expected 'with: "${delegated.with}"' instead got '${claimed.with}'`
        );
      } else if (delegated.nb.body.digest && !equals7(delegated.nb.body.digest, claimed.nb.body.digest)) {
        return fail2(
          `Link ${claimed.nb.body.digest ? `${claimed.nb.body.digest}` : ""} violates imposed ${delegated.nb.body.digest} constraint.`
        );
      } else if (claimed.nb.body.size !== void 0 && delegated.nb.body.size !== void 0) {
        return claimed.nb.body.size > delegated.nb.body.size ? fail2(
          `Size constraint violation: ${claimed.nb.body.size} > ${delegated.nb.body.size}`
        ) : ok({});
      } else {
        return ok({});
      }
    };
    checkLink2 = (claimed, imposed, at2) => {
      return equal2(
        String(claimed),
        imposed === void 0 ? void 0 : String(imposed),
        at2
      );
    };
    and4 = (result) => result.error ? result : void 0;
  }
});

// ../../node_modules/.pnpm/@web3-storage+capabilities@17.2.0/node_modules/@web3-storage/capabilities/src/store.js
var code17, CARLink, store, add, get2, remove, list, all3;
var init_store = __esm({
  "../../node_modules/.pnpm/@web3-storage+capabilities@17.2.0/node_modules/@web3-storage/capabilities/src/store.js"() {
    init_lib6();
    init_utils5();
    code17 = 514;
    CARLink = schema_exports3.link({ code: code17, version: 1 });
    store = capability({
      can: "store/*",
      /**
       * DID of the (memory) space where CAR is intended to
       * be stored.
       */
      with: SpaceDID2,
      derives: equalWith2
    });
    add = capability({
      can: "store/add",
      /**
       * DID of the (memory) space where CAR is intended to
       * be stored.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * CID of the CAR file to be stored. Service will provision write target
         * for this exact CAR file for agent to PUT or POST it. Attempt to write
         * any other content will fail.
         */
        link: CARLink,
        /**
         * Size of the CAR file to be stored. Service will provision write target
         * for this exact size. Attempt to write a larger CAR file will fail.
         */
        size: schema_exports3.integer(),
        /**
         * Agent may optionally provide a link to a related CAR file using `origin`
         * field. This is useful when storing large DAGs, agent could shard it
         * across multiple CAR files and then link each shard with a previous one.
         *
         * Providing this relation tells service that given CAR is shard of the
         * larger DAG as opposed to it being intentionally partial DAG. When DAG is
         * not sharded, there will be only one `store/add` with `origin` left out.
         */
        origin: link_exports2.optional()
      }),
      derives: (claim, from21) => {
        const result = equalLink(claim, from21);
        if (result.error) {
          return result;
        } else if (claim.nb.size !== void 0 && from21.nb.size !== void 0) {
          return claim.nb.size > from21.nb.size ? fail2(`Size constraint violation: ${claim.nb.size} > ${from21.nb.size}`) : ok({});
        } else {
          return ok({});
        }
      }
    });
    get2 = capability({
      can: "store/get",
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * shard CID to fetch info about.
         */
        link: CARLink.optional()
      }),
      derives: equalLink
    });
    remove = capability({
      can: "store/remove",
      /**
       * DID of the (memory) space where CAR is intended to
       * be stored.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * CID of the CAR file to be removed from the store.
         */
        link: CARLink
      }),
      derives: equalLink
    });
    list = capability({
      can: "store/list",
      /**
       * DID of the (memory) space where CAR is intended to
       * be stored.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * A pointer that can be moved back and forth on the list.
         * It can be used to paginate a list for instance.
         */
        cursor: schema_exports3.string().optional(),
        /**
         * Maximum number of items per page.
         */
        size: schema_exports3.integer().optional(),
        /**
         * If true, return page of results preceding cursor. Defaults to false.
         */
        pre: schema_exports3.boolean().optional()
      }),
      derives: (claimed, delegated) => {
        if (claimed.with !== delegated.with) {
          return fail2(
            `Expected 'with: "${delegated.with}"' instead got '${claimed.with}'`
          );
        }
        return ok({});
      }
    });
    all3 = add.or(remove).or(list);
  }
});

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error3 = this._errors[i];
        var message = error3.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error3;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js"(exports2) {
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js
var require_retry2 = __commonJS({
  "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js"(exports2, module2) {
    module2.exports = require_retry();
  }
});

// ../../node_modules/.pnpm/p-retry@5.1.2/node_modules/p-retry/index.js
async function pRetry(input10, options) {
  return new Promise((resolve2, reject) => {
    options = {
      onFailedAttempt() {
      },
      retries: 10,
      ...options
    };
    const operation = import_retry.default.operation(options);
    operation.attempt(async (attemptNumber) => {
      try {
        resolve2(await input10(attemptNumber));
      } catch (error3) {
        if (!(error3 instanceof Error)) {
          reject(new TypeError(`Non-error was thrown: "${error3}". You should only throw errors.`));
          return;
        }
        if (error3 instanceof AbortError) {
          operation.stop();
          reject(error3.originalError);
        } else if (error3 instanceof TypeError && !isNetworkError(error3.message)) {
          operation.stop();
          reject(error3);
        } else {
          decorateErrorWithCounts(error3, attemptNumber, options);
          try {
            await options.onFailedAttempt(error3);
          } catch (error4) {
            reject(error4);
            return;
          }
          if (!operation.retry(error3)) {
            reject(operation.mainError());
          }
        }
      }
    });
    if (options.signal && !options.signal.aborted) {
      options.signal.addEventListener("abort", () => {
        operation.stop();
        const reason = options.signal.reason === void 0 ? getDOMException("The operation was aborted.") : options.signal.reason;
        reject(reason instanceof Error ? reason : getDOMException(reason));
      }, {
        once: true
      });
    }
  });
}
var import_retry, networkErrorMsgs, AbortError, decorateErrorWithCounts, isNetworkError, getDOMException;
var init_p_retry = __esm({
  "../../node_modules/.pnpm/p-retry@5.1.2/node_modules/p-retry/index.js"() {
    import_retry = __toESM(require_retry2(), 1);
    networkErrorMsgs = /* @__PURE__ */ new Set([
      "Failed to fetch",
      // Chrome
      "NetworkError when attempting to fetch resource.",
      // Firefox
      "The Internet connection appears to be offline.",
      // Safari
      "Network request failed",
      // `cross-fetch`
      "fetch failed"
      // Undici (Node.js)
    ]);
    AbortError = class extends Error {
      constructor(message) {
        super();
        if (message instanceof Error) {
          this.originalError = message;
          ({ message } = message);
        } else {
          this.originalError = new Error(message);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message;
      }
    };
    decorateErrorWithCounts = (error3, attemptNumber, options) => {
      const retriesLeft = options.retries - (attemptNumber - 1);
      error3.attemptNumber = attemptNumber;
      error3.retriesLeft = retriesLeft;
      return error3;
    };
    isNetworkError = (errorMessage) => networkErrorMsgs.has(errorMessage);
    getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new Error(errorMessage) : new DOMException(errorMessage);
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/service.js
var serviceURL, servicePrincipal, receiptsEndpoint, connection5;
var init_service3 = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/service.js"() {
    init_lib4();
    init_lib5();
    init_did();
    serviceURL = new URL("https://up.web3.storage");
    servicePrincipal = parse3("did:web:web3.storage");
    receiptsEndpoint = "https://up.web3.storage/receipt/";
    connection5 = connect({
      id: servicePrincipal,
      codec: car_exports2.outbound,
      channel: http_exports.open({
        url: serviceURL,
        method: "POST"
      })
    });
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/constants.js
var REQUEST_RETRIES;
var init_constants = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/constants.js"() {
    REQUEST_RETRIES = 3;
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/store.js
var store_exports = {};
__export(store_exports, {
  add: () => add2,
  get: () => get3,
  list: () => list2,
  remove: () => remove2
});
function createUploadProgressHandler(url, handler) {
  function onUploadProgress({ total, loaded, lengthComputable }) {
    return handler({ total, loaded, lengthComputable, url });
  }
  return onUploadProgress;
}
async function add2({ issuer, with: resource, proofs: proofs2, audience }, car, options = {}) {
  const bytes2 = car instanceof Uint8Array ? car : new Uint8Array(await car.arrayBuffer());
  const link5 = await car_exports2.codec.link(bytes2);
  const conn = options.connection ?? connection5;
  const result = await pRetry(async () => {
    return await add.invoke({
      issuer,
      /* c8 ignore next */
      audience: audience ?? servicePrincipal,
      with: SpaceDID2.from(resource),
      nb: { link: link5, size: bytes2.length },
      proofs: proofs2,
      nonce: options.nonce
    }).execute(conn);
  }, {
    onFailedAttempt: console.warn,
    retries: options.retries ?? REQUEST_RETRIES
  });
  if (!result.out.ok) {
    throw new Error(`failed ${add.can} invocation`, {
      cause: result.out.error
    });
  }
  if (result.out.ok.status === "done") {
    return link5;
  }
  const responseAddUpload = result.out.ok;
  const fetchWithUploadProgress = options.fetchWithUploadProgress || options.fetch || globalThis.fetch.bind(globalThis);
  let fetchDidCallUploadProgressCb = false;
  const res = await pRetry(async () => {
    try {
      const res2 = await fetchWithUploadProgress(responseAddUpload.url, {
        method: "PUT",
        body: car,
        headers: responseAddUpload.headers,
        signal: options.signal,
        onUploadProgress: (status) => {
          fetchDidCallUploadProgressCb = true;
          if (options.onUploadProgress)
            createUploadProgressHandler(responseAddUpload.url, options.onUploadProgress)(status);
        },
        // @ts-expect-error - this is needed by recent versions of node - see https://github.com/bluesky-social/atproto/pull/470 for more info
        duplex: "half"
      });
      if (res2.status >= 400 && res2.status < 500) {
        throw new AbortError(`upload failed: ${res2.status}`);
      }
      return res2;
    } catch (err) {
      if (options.signal?.aborted === true) {
        throw new AbortError("upload aborted");
      }
      throw err;
    }
  }, {
    retries: options.retries ?? REQUEST_RETRIES
  });
  if (!fetchDidCallUploadProgressCb && options.onUploadProgress) {
    const carBlob = new Blob([car]);
    options.onUploadProgress({
      total: carBlob.size,
      loaded: carBlob.size,
      lengthComputable: false
    });
  }
  if (!res.ok) {
    throw new Error(`upload failed: ${res.status}`);
  }
  return link5;
}
async function get3({ issuer, with: resource, proofs: proofs2, audience }, link5, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await pRetry(async () => {
    return await get2.invoke({
      issuer,
      /* c8 ignore next */
      audience: audience ?? servicePrincipal,
      with: SpaceDID2.from(resource),
      nb: { link: link5 },
      proofs: proofs2,
      nonce: options.nonce
    }).execute(conn);
  }, {
    onFailedAttempt: console.warn,
    retries: options.retries ?? REQUEST_RETRIES
  });
  if (!result.out.ok) {
    throw new Error(`failed ${get2.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out.ok;
}
async function list2({ issuer, with: resource, proofs: proofs2, audience }, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await list.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? servicePrincipal,
    with: SpaceDID2.from(resource),
    proofs: proofs2,
    nb: {
      cursor: options.cursor,
      size: options.size,
      pre: options.pre
    },
    nonce: options.nonce
  }).execute(conn);
  if (!result.out.ok) {
    throw new Error(`failed ${list.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out.ok;
}
async function remove2({ issuer, with: resource, proofs: proofs2, audience }, link5, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await remove.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? servicePrincipal,
    with: SpaceDID2.from(resource),
    nb: { link: link5 },
    proofs: proofs2,
    nonce: options.nonce
  }).execute(conn);
  if (!result.out.ok) {
    throw new Error(`failed ${remove.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out;
}
var init_store2 = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/store.js"() {
    init_lib5();
    init_store();
    init_utils5();
    init_p_retry();
    init_service3();
    init_constants();
  }
});

// ../../node_modules/.pnpm/@noble+ed25519@1.7.3/node_modules/@noble/ed25519/lib/esm/index.js
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function assertExtPoint(other) {
  if (!(other instanceof ExtendedPoint))
    throw new TypeError("ExtendedPoint expected");
}
function assertRstPoint(other) {
  if (!(other instanceof RistrettoPoint))
    throw new TypeError("RistrettoPoint expected");
}
function legacyRist() {
  throw new Error("Legacy method: switch to RistrettoPoint");
}
function concatBytes(...arrays) {
  if (!arrays.every((a) => a instanceof Uint8Array))
    throw new Error("Expected Uint8Array list");
  if (arrays.length === 1)
    return arrays[0];
  const length5 = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length5);
  for (let i = 0, pad2 = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad2);
    pad2 += arr.length;
  }
  return result;
}
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex += hexes[uint8a[i]];
  }
  return hex;
}
function hexToBytes(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array2 = new Uint8Array(hex.length / 2);
  for (let i = 0; i < array2.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array2[i] = byte;
  }
  return array2;
}
function numberTo32BytesBE(num) {
  const length5 = 32;
  const hex = num.toString(16).padStart(length5 * 2, "0");
  return hexToBytes(hex);
}
function numberTo32BytesLE(num) {
  return numberTo32BytesBE(num).reverse();
}
function edIsNegative(num) {
  return (mod2(num) & _1n) === _1n;
}
function bytesToNumberLE(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  return BigInt("0x" + bytesToHex(Uint8Array.from(uint8a).reverse()));
}
function bytes255ToNumberLE(bytes2) {
  return mod2(bytesToNumberLE(bytes2) & MAX_255B);
}
function mod2(a, b = CURVE.P) {
  const res = a % b;
  return res >= _0n ? res : b + res;
}
function invert(number2, modulo = CURVE.P) {
  if (number2 === _0n || modulo <= _0n) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a = mod2(number2, modulo);
  let b = modulo;
  let x = _0n, y = _1n, u = _1n, v = _0n;
  while (a !== _0n) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (num === _0n)
      return acc;
    tmp[i] = acc;
    return mod2(acc * num, p);
  }, _1n);
  const inverted = invert(lastMultiplied, p);
  nums.reduceRight((acc, num, i) => {
    if (num === _0n)
      return acc;
    tmp[i] = mod2(acc * tmp[i], p);
    return mod2(acc * num, p);
  }, inverted);
  return tmp;
}
function pow2(x, power) {
  const { P } = CURVE;
  let res = x;
  while (power-- > _0n) {
    res *= res;
    res %= P;
  }
  return res;
}
function pow_2_252_3(x) {
  const { P } = CURVE;
  const _5n = BigInt(5);
  const _10n = BigInt(10);
  const _20n = BigInt(20);
  const _40n = BigInt(40);
  const _80n = BigInt(80);
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, _2n) * b2 % P;
  const b5 = pow2(b4, _1n) * x % P;
  const b10 = pow2(b5, _5n) * b5 % P;
  const b20 = pow2(b10, _10n) * b10 % P;
  const b40 = pow2(b20, _20n) * b20 % P;
  const b80 = pow2(b40, _40n) * b40 % P;
  const b160 = pow2(b80, _80n) * b80 % P;
  const b240 = pow2(b160, _80n) * b80 % P;
  const b250 = pow2(b240, _10n) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n) * x % P;
  return { pow_p_5_8, b2 };
}
function uvRatio(u, v) {
  const v3 = mod2(v * v * v);
  const v7 = mod2(v3 * v3 * v);
  const pow = pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod2(u * v3 * pow);
  const vx2 = mod2(v * x * x);
  const root1 = x;
  const root2 = mod2(x * SQRT_M1);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod2(-u);
  const noRoot = vx2 === mod2(-u * SQRT_M1);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (edIsNegative(x))
    x = mod2(-x);
  return { isValid: useRoot1 || useRoot2, value: x };
}
function invertSqrt(number2) {
  return uvRatio(_1n, number2);
}
function modlLE(hash) {
  return mod2(bytesToNumberLE(hash), CURVE.l);
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length) {
    return false;
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] !== b2[i]) {
      return false;
    }
  }
  return true;
}
function ensureBytes(hex, expectedLength) {
  const bytes2 = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
  if (typeof expectedLength === "number" && bytes2.length !== expectedLength)
    throw new Error(`Expected ${expectedLength} bytes`);
  return bytes2;
}
function normalizeScalar(num, max, strict = true) {
  if (!max)
    throw new TypeError("Specify max value");
  if (typeof num === "number" && Number.isSafeInteger(num))
    num = BigInt(num);
  if (typeof num === "bigint" && num < max) {
    if (strict) {
      if (_0n < num)
        return num;
    } else {
      if (_0n <= num)
        return num;
    }
  }
  throw new TypeError("Expected valid scalar: 0 < scalar < max");
}
function adjustBytes25519(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
function checkPrivateKey(key) {
  key = typeof key === "bigint" || typeof key === "number" ? numberTo32BytesBE(normalizeScalar(key, POW_2_256)) : ensureBytes(key);
  if (key.length !== 32)
    throw new Error(`Expected 32 bytes`);
  return key;
}
function getKeyFromHash(hashed) {
  const head = adjustBytes25519(hashed.slice(0, 32));
  const prefix2 = hashed.slice(32, 64);
  const scalar = modlLE(head);
  const point = Point.BASE.multiply(scalar);
  const pointBytes = point.toRawBytes();
  return { head, prefix: prefix2, scalar, point, pointBytes };
}
async function getExtendedPublicKey(key) {
  return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));
}
async function getPublicKey(privateKey) {
  return (await getExtendedPublicKey(privateKey)).pointBytes;
}
async function sign(message, privateKey) {
  message = ensureBytes(message);
  const { prefix: prefix2, scalar, pointBytes } = await getExtendedPublicKey(privateKey);
  const r = modlLE(await utils.sha512(prefix2, message));
  const R = Point.BASE.multiply(r);
  const k = modlLE(await utils.sha512(R.toRawBytes(), pointBytes, message));
  const s = mod2(r + k * scalar, CURVE.l);
  return new Signature2(R, s).toRawBytes();
}
function prepareVerification(sig, message, publicKey) {
  message = ensureBytes(message);
  if (!(publicKey instanceof Point))
    publicKey = Point.fromHex(publicKey, false);
  const { r, s } = sig instanceof Signature2 ? sig.assertValidity() : Signature2.fromHex(sig);
  const SB = ExtendedPoint.BASE.multiplyUnsafe(s);
  return { r, s, SB, pub: publicKey, msg: message };
}
function finishVerification(publicKey, r, SB, hashed) {
  const k = modlLE(hashed);
  const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);
  const RkA = ExtendedPoint.fromAffine(r).add(kA);
  return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
}
async function verify(sig, message, publicKey) {
  const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);
  const hashed = await utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);
  return finishVerification(pub, r, SB, hashed);
}
var nodeCrypto, _0n, _1n, _2n, _8n, CU_O, CURVE, POW_2_256, SQRT_M1, SQRT_D, SQRT_AD_MINUS_ONE, INVSQRT_A_MINUS_D, ONE_MINUS_D_SQ, D_MINUS_ONE_SQ, ExtendedPoint, RistrettoPoint, pointPrecomputes, Point, Signature2, hexes, MAX_255B, _sha512Sync, crypto6, utils;
var init_esm3 = __esm({
  "../../node_modules/.pnpm/@noble+ed25519@1.7.3/node_modules/@noble/ed25519/lib/esm/index.js"() {
    nodeCrypto = __toESM(require("crypto"), 1);
    _0n = BigInt(0);
    _1n = BigInt(1);
    _2n = BigInt(2);
    _8n = BigInt(8);
    CU_O = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989");
    CURVE = Object.freeze({
      a: BigInt(-1),
      d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
      P: BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
      l: CU_O,
      n: CU_O,
      h: BigInt(8),
      Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
      Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
    });
    POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
    SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
    SQRT_D = BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
    SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
    INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
    ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
    D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
    ExtendedPoint = class _ExtendedPoint {
      constructor(x, y, z, t) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.t = t;
      }
      static fromAffine(p) {
        if (!(p instanceof Point)) {
          throw new TypeError("ExtendedPoint#fromAffine: expected Point");
        }
        if (p.equals(Point.ZERO))
          return _ExtendedPoint.ZERO;
        return new _ExtendedPoint(p.x, p.y, _1n, mod2(p.x * p.y));
      }
      static toAffineBatch(points) {
        const toInv = invertBatch(points.map((p) => p.z));
        return points.map((p, i) => p.toAffine(toInv[i]));
      }
      static normalizeZ(points) {
        return this.toAffineBatch(points).map(this.fromAffine);
      }
      equals(other) {
        assertExtPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const X1Z2 = mod2(X1 * Z2);
        const X2Z1 = mod2(X2 * Z1);
        const Y1Z2 = mod2(Y1 * Z2);
        const Y2Z1 = mod2(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      negate() {
        return new _ExtendedPoint(mod2(-this.x), this.y, this.z, mod2(-this.t));
      }
      double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const { a } = CURVE;
        const A = mod2(X1 * X1);
        const B = mod2(Y1 * Y1);
        const C = mod2(_2n * mod2(Z1 * Z1));
        const D = mod2(a * A);
        const x1y1 = X1 + Y1;
        const E = mod2(mod2(x1y1 * x1y1) - A - B);
        const G = D + B;
        const F = G - C;
        const H = D - B;
        const X3 = mod2(E * F);
        const Y3 = mod2(G * H);
        const T3 = mod2(E * H);
        const Z3 = mod2(F * G);
        return new _ExtendedPoint(X3, Y3, Z3, T3);
      }
      add(other) {
        assertExtPoint(other);
        const { x: X1, y: Y1, z: Z1, t: T1 } = this;
        const { x: X2, y: Y2, z: Z2, t: T2 } = other;
        const A = mod2((Y1 - X1) * (Y2 + X2));
        const B = mod2((Y1 + X1) * (Y2 - X2));
        const F = mod2(B - A);
        if (F === _0n)
          return this.double();
        const C = mod2(Z1 * _2n * T2);
        const D = mod2(T1 * _2n * Z2);
        const E = D + C;
        const G = B + A;
        const H = D - C;
        const X3 = mod2(E * F);
        const Y3 = mod2(G * H);
        const T3 = mod2(E * H);
        const Z3 = mod2(F * G);
        return new _ExtendedPoint(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      precomputeWindow(W) {
        const windows = 1 + 256 / W;
        const points = [];
        let p = this;
        let base6 = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base6 = p;
          points.push(base6);
          for (let i = 1; i < 2 ** (W - 1); i++) {
            base6 = base6.add(p);
            points.push(base6);
          }
          p = base6.double();
        }
        return points;
      }
      wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(_ExtendedPoint.BASE))
          affinePoint = Point.BASE;
        const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
        if (256 % W) {
          throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
        }
        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
        if (!precomputes) {
          precomputes = this.precomputeWindow(W);
          if (affinePoint && W !== 1) {
            precomputes = _ExtendedPoint.normalizeZ(precomputes);
            pointPrecomputes.set(affinePoint, precomputes);
          }
        }
        let p = _ExtendedPoint.ZERO;
        let f = _ExtendedPoint.BASE;
        const windows = 1 + 256 / W;
        const windowSize = 2 ** (W - 1);
        const mask2 = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset2 = window2 * windowSize;
          let wbits = Number(n & mask2);
          n >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n;
          }
          const offset1 = offset2;
          const offset22 = offset2 + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f = f.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p = p.add(constTimeNegate(cond2, precomputes[offset22]));
          }
        }
        return _ExtendedPoint.normalizeZ([p, f])[0];
      }
      multiply(scalar, affinePoint) {
        return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);
      }
      multiplyUnsafe(scalar) {
        let n = normalizeScalar(scalar, CURVE.l, false);
        const G = _ExtendedPoint.BASE;
        const P0 = _ExtendedPoint.ZERO;
        if (n === _0n)
          return P0;
        if (this.equals(P0) || n === _1n)
          return this;
        if (this.equals(G))
          return this.wNAF(n);
        let p = P0;
        let d = this;
        while (n > _0n) {
          if (n & _1n)
            p = p.add(d);
          d = d.double();
          n >>= _1n;
        }
        return p;
      }
      isSmallOrder() {
        return this.multiplyUnsafe(CURVE.h).equals(_ExtendedPoint.ZERO);
      }
      isTorsionFree() {
        let p = this.multiplyUnsafe(CURVE.l / _2n).double();
        if (CURVE.l % _2n)
          p = p.add(this);
        return p.equals(_ExtendedPoint.ZERO);
      }
      toAffine(invZ) {
        const { x, y, z } = this;
        const is0 = this.equals(_ExtendedPoint.ZERO);
        if (invZ == null)
          invZ = is0 ? _8n : invert(z);
        const ax = mod2(x * invZ);
        const ay = mod2(y * invZ);
        const zz = mod2(z * invZ);
        if (is0)
          return Point.ZERO;
        if (zz !== _1n)
          throw new Error("invZ was invalid");
        return new Point(ax, ay);
      }
      fromRistrettoBytes() {
        legacyRist();
      }
      toRistrettoBytes() {
        legacyRist();
      }
      fromRistrettoHash() {
        legacyRist();
      }
    };
    ExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod2(CURVE.Gx * CURVE.Gy));
    ExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);
    RistrettoPoint = class _RistrettoPoint {
      constructor(ep) {
        this.ep = ep;
      }
      static calcElligatorRistrettoMap(r0) {
        const { d } = CURVE;
        const r = mod2(SQRT_M1 * r0 * r0);
        const Ns = mod2((r + _1n) * ONE_MINUS_D_SQ);
        let c = BigInt(-1);
        const D = mod2((c - d * r) * mod2(r + d));
        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
        let s_ = mod2(s * r0);
        if (!edIsNegative(s_))
          s_ = mod2(-s_);
        if (!Ns_D_is_sq)
          s = s_;
        if (!Ns_D_is_sq)
          c = r;
        const Nt = mod2(c * (r - _1n) * D_MINUS_ONE_SQ - D);
        const s2 = s * s;
        const W0 = mod2((s + s) * D);
        const W1 = mod2(Nt * SQRT_AD_MINUS_ONE);
        const W2 = mod2(_1n - s2);
        const W3 = mod2(_1n + s2);
        return new ExtendedPoint(mod2(W0 * W3), mod2(W2 * W1), mod2(W1 * W3), mod2(W0 * W2));
      }
      static hashToCurve(hex) {
        hex = ensureBytes(hex, 64);
        const r1 = bytes255ToNumberLE(hex.slice(0, 32));
        const R1 = this.calcElligatorRistrettoMap(r1);
        const r2 = bytes255ToNumberLE(hex.slice(32, 64));
        const R2 = this.calcElligatorRistrettoMap(r2);
        return new _RistrettoPoint(R1.add(R2));
      }
      static fromHex(hex) {
        hex = ensureBytes(hex, 32);
        const { a, d } = CURVE;
        const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
        const s = bytes255ToNumberLE(hex);
        if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))
          throw new Error(emsg);
        const s2 = mod2(s * s);
        const u1 = mod2(_1n + a * s2);
        const u2 = mod2(_1n - a * s2);
        const u1_2 = mod2(u1 * u1);
        const u2_2 = mod2(u2 * u2);
        const v = mod2(a * d * u1_2 - u2_2);
        const { isValid, value: I } = invertSqrt(mod2(v * u2_2));
        const Dx = mod2(I * u2);
        const Dy = mod2(I * Dx * v);
        let x = mod2((s + s) * Dx);
        if (edIsNegative(x))
          x = mod2(-x);
        const y = mod2(u1 * Dy);
        const t = mod2(x * y);
        if (!isValid || edIsNegative(t) || y === _0n)
          throw new Error(emsg);
        return new _RistrettoPoint(new ExtendedPoint(x, y, _1n, t));
      }
      toRawBytes() {
        let { x, y, z, t } = this.ep;
        const u1 = mod2(mod2(z + y) * mod2(z - y));
        const u2 = mod2(x * y);
        const u2sq = mod2(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod2(u1 * u2sq));
        const D1 = mod2(invsqrt * u1);
        const D2 = mod2(invsqrt * u2);
        const zInv = mod2(D1 * D2 * t);
        let D;
        if (edIsNegative(t * zInv)) {
          let _x = mod2(y * SQRT_M1);
          let _y = mod2(x * SQRT_M1);
          x = _x;
          y = _y;
          D = mod2(D1 * INVSQRT_A_MINUS_D);
        } else {
          D = D2;
        }
        if (edIsNegative(x * zInv))
          y = mod2(-y);
        let s = mod2((z - y) * D);
        if (edIsNegative(s))
          s = mod2(-s);
        return numberTo32BytesLE(s);
      }
      toHex() {
        return bytesToHex(this.toRawBytes());
      }
      toString() {
        return this.toHex();
      }
      equals(other) {
        assertRstPoint(other);
        const a = this.ep;
        const b = other.ep;
        const one = mod2(a.x * b.y) === mod2(a.y * b.x);
        const two = mod2(a.y * b.y) === mod2(a.x * b.x);
        return one || two;
      }
      add(other) {
        assertRstPoint(other);
        return new _RistrettoPoint(this.ep.add(other.ep));
      }
      subtract(other) {
        assertRstPoint(other);
        return new _RistrettoPoint(this.ep.subtract(other.ep));
      }
      multiply(scalar) {
        return new _RistrettoPoint(this.ep.multiply(scalar));
      }
      multiplyUnsafe(scalar) {
        return new _RistrettoPoint(this.ep.multiplyUnsafe(scalar));
      }
    };
    RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
    RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
    pointPrecomputes = /* @__PURE__ */ new WeakMap();
    Point = class _Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
      }
      static fromHex(hex, strict = true) {
        const { d, P } = CURVE;
        hex = ensureBytes(hex, 32);
        const normed = hex.slice();
        normed[31] = hex[31] & ~128;
        const y = bytesToNumberLE(normed);
        if (strict && y >= P)
          throw new Error("Expected 0 < hex < P");
        if (!strict && y >= POW_2_256)
          throw new Error("Expected 0 < hex < 2**256");
        const y2 = mod2(y * y);
        const u = mod2(y2 - _1n);
        const v = mod2(d * y2 + _1n);
        let { isValid, value: x } = uvRatio(u, v);
        if (!isValid)
          throw new Error("Point.fromHex: invalid y coordinate");
        const isXOdd = (x & _1n) === _1n;
        const isLastByteOdd = (hex[31] & 128) !== 0;
        if (isLastByteOdd !== isXOdd) {
          x = mod2(-x);
        }
        return new _Point(x, y);
      }
      static async fromPrivateKey(privateKey) {
        return (await getExtendedPublicKey(privateKey)).point;
      }
      toRawBytes() {
        const bytes2 = numberTo32BytesLE(this.y);
        bytes2[31] |= this.x & _1n ? 128 : 0;
        return bytes2;
      }
      toHex() {
        return bytesToHex(this.toRawBytes());
      }
      toX25519() {
        const { y } = this;
        const u = mod2((_1n + y) * invert(_1n - y));
        return numberTo32BytesLE(u);
      }
      isTorsionFree() {
        return ExtendedPoint.fromAffine(this).isTorsionFree();
      }
      equals(other) {
        return this.x === other.x && this.y === other.y;
      }
      negate() {
        return new _Point(mod2(-this.x), this.y);
      }
      add(other) {
        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiply(scalar) {
        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
      }
    };
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
    Point.ZERO = new Point(_0n, _1n);
    Signature2 = class _Signature {
      constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
      }
      static fromHex(hex) {
        const bytes2 = ensureBytes(hex, 64);
        const r = Point.fromHex(bytes2.slice(0, 32), false);
        const s = bytesToNumberLE(bytes2.slice(32, 64));
        return new _Signature(r, s);
      }
      assertValidity() {
        const { r, s } = this;
        if (!(r instanceof Point))
          throw new Error("Expected Point instance");
        normalizeScalar(s, CURVE.l, false);
        return this;
      }
      toRawBytes() {
        const u8 = new Uint8Array(64);
        u8.set(this.r.toRawBytes());
        u8.set(numberTo32BytesLE(this.s), 32);
        return u8;
      }
      toHex() {
        return bytesToHex(this.toRawBytes());
      }
    };
    hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    Point.BASE._setWindowSize(8);
    crypto6 = {
      node: nodeCrypto,
      web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
    };
    utils = {
      bytesToHex,
      hexToBytes,
      concatBytes,
      getExtendedPublicKey,
      mod: mod2,
      invert,
      TORSION_SUBGROUP: [
        "0100000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
        "0000000000000000000000000000000000000000000000000000000000000080",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
        "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
        "0000000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
      ],
      hashToPrivateScalar: (hash) => {
        hash = ensureBytes(hash);
        if (hash.length < 40 || hash.length > 1024)
          throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
        return mod2(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;
      },
      randomBytes: (bytesLength = 32) => {
        if (crypto6.web) {
          return crypto6.web.getRandomValues(new Uint8Array(bytesLength));
        } else if (crypto6.node) {
          const { randomBytes } = crypto6.node;
          return new Uint8Array(randomBytes(bytesLength).buffer);
        } else {
          throw new Error("The environment doesn't have randomBytes function");
        }
      },
      randomPrivateKey: () => {
        return utils.randomBytes(32);
      },
      sha512: async (...messages) => {
        const message = concatBytes(...messages);
        if (crypto6.web) {
          const buffer3 = await crypto6.web.subtle.digest("SHA-512", message.buffer);
          return new Uint8Array(buffer3);
        } else if (crypto6.node) {
          return Uint8Array.from(crypto6.node.createHash("sha512").update(message).digest());
        } else {
          throw new Error("The environment doesn't have sha512 function");
        }
      },
      precompute(windowSize = 8, point = Point.BASE) {
        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_2n);
        return cached;
      },
      sha512Sync: void 0
    };
    Object.defineProperties(utils, {
      sha512Sync: {
        configurable: false,
        get() {
          return _sha512Sync;
        },
        set(val) {
          if (!_sha512Sync)
            _sha512Sync = val;
        }
      }
    });
  }
});

// ../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/ed25519/type.js
var init_type2 = __esm({
  "../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/ed25519/type.js"() {
  }
});

// ../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/verifier.js
var parseWith, or7, Parser, withDID, VerifierWithDID;
var init_verifier = __esm({
  "../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/verifier.js"() {
    parseWith = (did2, parsers) => {
      if (did2.startsWith("did:")) {
        for (const parser of parsers) {
          try {
            return parser.parse(did2);
          } catch (_) {
          }
        }
        throw new Error(`Unsupported did ${did2}`);
      } else {
        throw new Error(`Expected did instead got ${did2}`);
      }
    };
    or7 = (left, right) => new Parser([left, right]);
    Parser = class _Parser {
      /**
       * @param {API.PrincipalParser[]} variants
       */
      constructor(variants) {
        this.variants = variants;
      }
      /**
       * @param {API.DID} did
       */
      parse(did2) {
        return parseWith(did2, this.variants);
      }
      /**
       * @param {API.PrincipalParser} parser
       */
      or(parser) {
        return new _Parser([...this.variants, parser]);
      }
    };
    withDID = (key, id) => new VerifierWithDID(id, key);
    VerifierWithDID = class {
      /**
       * @param {ID} id
       * @param {API.VerifierKey<SigAlg>} key
       */
      constructor(id, key) {
        this.id = id;
        this.key = key;
      }
      did() {
        return this.id;
      }
      toDIDKey() {
        return this.key.toDIDKey();
      }
      /**
       * @template T
       * @param {API.ByteView<T>} payload
       * @param {API.Signature<T, SigAlg>} signature
       * @returns {API.Await<boolean>}
       */
      verify(payload, signature) {
        return this.key.verify(payload, signature);
      }
      /**
       * @template {API.DID} ID
       * @param {ID} id
       */
      withDID(id) {
        return withDID(this.key, id);
      }
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/ed25519/verifier.js
var verifier_exports = {};
__export(verifier_exports, {
  code: () => code18,
  decode: () => decode42,
  encode: () => encode34,
  format: () => format9,
  name: () => name14,
  or: () => or8,
  parse: () => parse6,
  signatureAlgorithm: () => signatureAlgorithm,
  signatureCode: () => signatureCode
});
var code18, name14, signatureCode, signatureAlgorithm, PUBLIC_TAG_SIZE, SIZE, parse6, decode42, format9, encode34, Ed25519Verifier, or8;
var init_verifier2 = __esm({
  "../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/ed25519/verifier.js"() {
    init_did();
    init_esm3();
    init_src6();
    init_signature();
    init_base583();
    init_verifier();
    code18 = 237;
    name14 = "Ed25519";
    signatureCode = EdDSA;
    signatureAlgorithm = "EdDSA";
    PUBLIC_TAG_SIZE = varint_exports3.encodingLength(code18);
    SIZE = 32 + PUBLIC_TAG_SIZE;
    parse6 = (did2) => decode42(parse3(did2));
    decode42 = (bytes2) => {
      const [algorithm2] = varint_exports3.decode(bytes2);
      if (algorithm2 !== code18) {
        throw new RangeError(
          `Unsupported key algorithm with multicode 0x${code18.toString(16)}`
        );
      } else if (bytes2.byteLength !== SIZE) {
        throw new RangeError(
          `Expected Uint8Array with byteLength ${SIZE}, instead got Uint8Array with byteLength ${bytes2.byteLength}`
        );
      } else {
        return new Ed25519Verifier(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
      }
    };
    format9 = (principal) => format3(principal);
    encode34 = (principal) => encode20(principal);
    Ed25519Verifier = class extends Uint8Array {
      /** @type {typeof code} */
      get code() {
        return code18;
      }
      /** @type {typeof signatureCode} */
      get signatureCode() {
        return signatureCode;
      }
      /** @type {typeof signatureAlgorithm} */
      get signatureAlgorithm() {
        return signatureAlgorithm;
      }
      /**
       * Raw public key without a multiformat code.
       *
       * @readonly
       */
      get publicKey() {
        const key = new Uint8Array(this.buffer, this.byteOffset + PUBLIC_TAG_SIZE);
        Object.defineProperties(this, {
          publicKey: {
            value: key
          }
        });
        return key;
      }
      /**
       * DID of the Principal in `did:key` format.
       * @returns {API.DID<"key">}
       */
      did() {
        return `did:key:${base58btc3.encode(this)}`;
      }
      /**
       * @template T
       * @param {API.ByteView<T>} payload
       * @param {API.Signature<T, Signature.EdDSA>} signature
       * @returns {API.Await<boolean>}
       */
      verify(payload, signature) {
        return signature.code === signatureCode && verify(signature.raw, payload, this.publicKey);
      }
      /**
       * @template {API.DID} ID
       * @param {ID} id
       * @returns {API.Verifier<ID, typeof signatureCode>}
       */
      withDID(id) {
        return withDID(this, id);
      }
      toDIDKey() {
        return this.did();
      }
    };
    or8 = (other) => or7({ parse: parse6 }, other);
  }
});

// ../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/signer.js
var or9, Importer, create13, importWith, withDID2, SignerWithDID;
var init_signer = __esm({
  "../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/signer.js"() {
    or9 = (left, right) => new Importer([left, right]);
    Importer = class _Importer {
      /**
       * @param {Importers} variants
       */
      constructor(variants) {
        this.variants = variants;
        this.from = create13(variants);
      }
      /**
       * @template {API.SignerImporter} Other
       * @param {Other} other
       * @returns {API.CompositeImporter<[Other, ...Importers]>}
       */
      or(other) {
        return new _Importer([other, ...this.variants]);
      }
    };
    create13 = (importers) => {
      const from21 = (archive3) => {
        if (archive3.id.startsWith("did:key:")) {
          return (
            /** @type {API.Signer<ID, Alg>} */
            importWith(archive3, importers)
          );
        } else {
          for (const [name20, key] of Object.entries(archive3.keys)) {
            const id = (
              /** @type {API.DIDKey} */
              name20
            );
            const signer = (
              /** @type {API.Signer<API.DIDKey, Alg>} */
              importWith(
                {
                  id,
                  keys: { [id]: key }
                },
                importers
              )
            );
            return signer.withDID(archive3.id);
          }
          throw new Error(`Archive ${archive3.id} contains no keys`);
        }
      };
      return (
        /** @type {API.Intersection<Importers[number]['from']>} */
        from21
      );
    };
    importWith = (archive3, importers) => {
      for (const importer of importers) {
        try {
          return importer.from(archive3);
        } catch (_) {
        }
      }
      throw new Error(`Unsupported signer`);
    };
    withDID2 = ({ signer, verifier }, id) => new SignerWithDID(signer, verifier.withDID(id));
    SignerWithDID = class {
      /**
       * @param {API.Signer<API.DID<'key'>, Code>} key
       * @param {API.Verifier<ID, Code>} verifier
       */
      constructor(key, verifier) {
        this.key = key;
        this.verifier = verifier;
      }
      /** @type {API.Signer<ID, Code>} */
      get signer() {
        return this;
      }
      get signatureAlgorithm() {
        return this.key.signatureAlgorithm;
      }
      get signatureCode() {
        return this.key.signatureCode;
      }
      /**
       * @returns {ID}
       */
      did() {
        return this.verifier.did();
      }
      toDIDKey() {
        return this.verifier.toDIDKey();
      }
      /**
       * @template {API.DID} ID
       * @param {ID} id
       */
      withDID(id) {
        return withDID2(this.key, id);
      }
      /**
       * @template T
       * @param {API.ByteView<T>} payload
       */
      sign(payload) {
        return this.key.sign(payload);
      }
      /**
       * @template T
       * @param {API.ByteView<T>} payload
       * @param {API.Signature<T, Code>} signature
       */
      verify(payload, signature) {
        return this.verifier.verify(payload, signature);
      }
      toArchive() {
        const { keys: keys2 } = this.key.toArchive();
        return {
          id: this.did(),
          keys: keys2
        };
      }
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/ed25519/signer.js
var signer_exports = {};
__export(signer_exports, {
  PUB_KEY_OFFSET: () => PUB_KEY_OFFSET,
  code: () => code19,
  decode: () => decode43,
  derive: () => derive2,
  encode: () => encode35,
  format: () => format10,
  from: () => from15,
  generate: () => generate,
  name: () => name15,
  or: () => or10,
  parse: () => parse7,
  signatureAlgorithm: () => signatureAlgorithm2,
  signatureCode: () => signatureCode2
});
var code19, name15, signatureAlgorithm2, signatureCode2, PRIVATE_TAG_SIZE, PUBLIC_TAG_SIZE2, KEY_SIZE, SIZE2, PUB_KEY_OFFSET, generate, derive2, from15, or10, decode43, encode35, format10, parse7, Ed25519Signer;
var init_signer2 = __esm({
  "../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/ed25519/signer.js"() {
    init_esm3();
    init_src6();
    init_verifier2();
    init_base642();
    init_signature();
    init_signer();
    init_type2();
    code19 = 4864;
    name15 = name14;
    signatureAlgorithm2 = signatureAlgorithm;
    signatureCode2 = signatureCode;
    PRIVATE_TAG_SIZE = varint_exports3.encodingLength(code19);
    PUBLIC_TAG_SIZE2 = varint_exports3.encodingLength(code18);
    KEY_SIZE = 32;
    SIZE2 = PRIVATE_TAG_SIZE + KEY_SIZE + PUBLIC_TAG_SIZE2 + KEY_SIZE;
    PUB_KEY_OFFSET = PRIVATE_TAG_SIZE + KEY_SIZE;
    generate = () => derive2(utils.randomPrivateKey());
    derive2 = async (secret) => {
      if (secret.byteLength !== KEY_SIZE) {
        throw new Error(
          `Expected Uint8Array with byteLength of ${KEY_SIZE} instead not ${secret.byteLength}`
        );
      }
      const publicKey = await getPublicKey(secret);
      const signer = new Ed25519Signer(SIZE2);
      varint_exports3.encodeTo(code19, signer, 0);
      signer.set(secret, PRIVATE_TAG_SIZE);
      varint_exports3.encodeTo(code18, signer, PRIVATE_TAG_SIZE + KEY_SIZE);
      signer.set(publicKey, PRIVATE_TAG_SIZE + KEY_SIZE + PUBLIC_TAG_SIZE2);
      return signer;
    };
    from15 = ({ id, keys: keys2 }) => {
      if (id.startsWith("did:key:")) {
        const key = keys2[
          /** @type {API.DIDKey} */
          id
        ];
        if (key instanceof Uint8Array) {
          return decode43(key);
        }
      }
      throw new TypeError(`Unsupported archive format`);
    };
    or10 = (other) => or9({ from: from15 }, other);
    decode43 = (bytes2) => {
      if (bytes2.byteLength !== SIZE2) {
        throw new Error(
          `Expected Uint8Array with byteLength of ${SIZE2} instead not ${bytes2.byteLength}`
        );
      }
      {
        const [keyCode] = varint_exports3.decode(bytes2);
        if (keyCode !== code19) {
          throw new Error(`Given bytes must be a multiformat with ${code19} tag`);
        }
      }
      {
        const [code25] = varint_exports3.decode(bytes2.subarray(PUB_KEY_OFFSET));
        if (code25 !== code18) {
          throw new Error(
            `Given bytes must contain public key in multiformats with ${code18} tag`
          );
        }
      }
      return new Ed25519Signer(bytes2);
    };
    encode35 = (signer) => signer.encode();
    format10 = (signer, encoder3) => (encoder3 || base64pad2).encode(encode35(signer));
    parse7 = (principal, decoder3) => decode43((decoder3 || base64pad2).decode(principal));
    Ed25519Signer = class extends Uint8Array {
      /** @type {typeof code} */
      get code() {
        return code19;
      }
      get signer() {
        return this;
      }
      /** @type {API.EdVerifier} */
      get verifier() {
        const bytes2 = new Uint8Array(this.buffer, PRIVATE_TAG_SIZE + KEY_SIZE);
        const verifier = decode42(bytes2);
        Object.defineProperties(this, {
          verifier: {
            value: verifier
          }
        });
        return verifier;
      }
      /**
       * Raw public key without multiformat code.
       */
      get secret() {
        const secret = new Uint8Array(this.buffer, PRIVATE_TAG_SIZE, KEY_SIZE);
        Object.defineProperties(this, {
          secret: {
            value: secret
          }
        });
        return secret;
      }
      /**
       * DID of this principal in `did:key` format.
       */
      did() {
        return this.verifier.did();
      }
      toDIDKey() {
        return this.verifier.toDIDKey();
      }
      /**
       * @template {API.DID} ID
       * @param {ID} id
       * @returns {API.Signer<ID, typeof Signature.EdDSA>}
       */
      withDID(id) {
        return withDID2(this, id);
      }
      /**
       * @template T
       * @param {API.ByteView<T>} payload
       * @returns {Promise<API.SignatureView<T, typeof Signature.EdDSA>>}
       */
      async sign(payload) {
        const raw = await sign(payload, this.secret);
        return create7(this.signatureCode, raw);
      }
      /**
       * @template T
       * @param {API.ByteView<T>} payload
       * @param {API.Signature<T, typeof this.signatureCode>} signature
       */
      verify(payload, signature) {
        return this.verifier.verify(payload, signature);
      }
      get signatureAlgorithm() {
        return signatureAlgorithm2;
      }
      get signatureCode() {
        return EdDSA;
      }
      encode() {
        return this;
      }
      toArchive() {
        const id = this.did();
        return {
          id,
          keys: { [id]: this.encode() }
        };
      }
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/ed25519.js
var ed25519_exports = {};
__export(ed25519_exports, {
  PUB_KEY_OFFSET: () => PUB_KEY_OFFSET,
  Signer: () => signer_exports,
  Verifier: () => verifier_exports,
  code: () => code19,
  decode: () => decode43,
  derive: () => derive2,
  encode: () => encode35,
  format: () => format10,
  from: () => from15,
  generate: () => generate,
  name: () => name15,
  or: () => or10,
  parse: () => parse7,
  signatureAlgorithm: () => signatureAlgorithm2,
  signatureCode: () => signatureCode2
});
var init_ed25519 = __esm({
  "../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/ed25519.js"() {
    init_signer2();
    init_verifier2();
    init_signer2();
  }
});

// ../../node_modules/.pnpm/one-webcrypto@1.0.3/node_modules/one-webcrypto/node.mjs
var import_crypto5, webcrypto;
var init_node3 = __esm({
  "../../node_modules/.pnpm/one-webcrypto@1.0.3/node_modules/one-webcrypto/node.mjs"() {
    import_crypto5 = __toESM(require("crypto"), 1);
    webcrypto = import_crypto5.default.webcrypto;
  }
});

// ../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa/type.js
var init_type3 = __esm({
  "../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa/type.js"() {
  }
});

// ../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/multiformat.js
var tagWith, untagWith, encodingLength5, encodeTo5, decode44;
var init_multiformat = __esm({
  "../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/multiformat.js"() {
    init_src6();
    tagWith = (code25, bytes2) => {
      const offset2 = varint_exports3.encodingLength(code25);
      const multiformat = new Uint8Array(bytes2.byteLength + offset2);
      varint_exports3.encodeTo(code25, multiformat, 0);
      multiformat.set(bytes2, offset2);
      return multiformat;
    };
    untagWith = (code25, source, byteOffset = 0) => {
      const bytes2 = byteOffset !== 0 ? source.subarray(byteOffset) : source;
      const [tag2, size5] = varint_exports3.decode(bytes2);
      if (tag2 !== code25) {
        throw new Error(
          `Expected multiformat with 0x${code25.toString(
            16
          )} tag instead got 0x${tag2.toString(16)}`
        );
      } else {
        return new Uint8Array(bytes2.buffer, bytes2.byteOffset + size5);
      }
    };
    encodingLength5 = varint_exports3.encodingLength;
    encodeTo5 = varint_exports3.encodeTo;
    decode44 = varint_exports3.decode;
  }
});

// ../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa/asn1.js
var TAG_SIZE2, INT_TAG, BITSTRING_TAG, OCTET_STRING_TAG, SEQUENCE_TAG, UNUSED_BIT_PAD, encodeDERLength, readDERLength, skip, into, encodeBitString, encodeOctetString, encodeSequence, readSequence, encodeInt, enterSequence, skipSequence, skipInt, readBitString, readInt2, readOctetString, readSequenceWith;
var init_asn1 = __esm({
  "../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa/asn1.js"() {
    TAG_SIZE2 = 1;
    INT_TAG = 2;
    BITSTRING_TAG = 3;
    OCTET_STRING_TAG = 4;
    SEQUENCE_TAG = 48;
    UNUSED_BIT_PAD = 0;
    encodeDERLength = (length5) => {
      if (length5 <= 127) {
        return new Uint8Array([length5]);
      }
      const octets = [];
      while (length5 !== 0) {
        octets.push(length5 & 255);
        length5 = length5 >>> 8;
      }
      octets.reverse();
      return new Uint8Array([128 | octets.length & 255, ...octets]);
    };
    readDERLength = (bytes2, offset2 = 0) => {
      if ((bytes2[offset2] & 128) === 0) {
        return { number: bytes2[offset2], consumed: 1 };
      }
      const numberBytes = bytes2[offset2] & 127;
      if (bytes2.length < numberBytes + 1) {
        throw new Error(
          `ASN parsing error: Too few bytes. Expected encoded length's length to be at least ${numberBytes}`
        );
      }
      let length5 = 0;
      for (let i = 0; i < numberBytes; i++) {
        length5 = length5 << 8;
        length5 = length5 | bytes2[offset2 + i + 1];
      }
      return { number: length5, consumed: numberBytes + 1 };
    };
    skip = (input10, expectedTag, position) => {
      const parsed = into(input10, expectedTag, position);
      return parsed.position + parsed.length;
    };
    into = (input10, expectedTag, offset2) => {
      const actualTag = input10[offset2];
      if (actualTag !== expectedTag) {
        throw new Error(
          `ASN parsing error: Expected tag 0x${expectedTag.toString(
            16
          )} at position ${offset2}, but got 0x${actualTag.toString(16)}.`
        );
      }
      const length5 = readDERLength(input10, offset2 + TAG_SIZE2);
      const position = offset2 + TAG_SIZE2 + length5.consumed;
      return { position, length: length5.number };
    };
    encodeBitString = (input10) => {
      const length5 = encodeDERLength(input10.byteLength + 1);
      const bytes2 = new Uint8Array(
        TAG_SIZE2 + // ASN_BITSTRING_TAG
        length5.byteLength + 1 + // amount of unused bits at the end of our bitstring
        input10.byteLength
      );
      let byteOffset = 0;
      bytes2[byteOffset] = BITSTRING_TAG;
      byteOffset += TAG_SIZE2;
      bytes2.set(length5, byteOffset);
      byteOffset += length5.byteLength;
      bytes2[byteOffset] = UNUSED_BIT_PAD;
      byteOffset += 1;
      bytes2.set(input10, byteOffset);
      return bytes2;
    };
    encodeOctetString = (input10) => {
      const length5 = encodeDERLength(input10.byteLength);
      const bytes2 = new Uint8Array(TAG_SIZE2 + length5.byteLength + input10.byteLength);
      let byteOffset = 0;
      bytes2[byteOffset] = OCTET_STRING_TAG;
      byteOffset += TAG_SIZE2;
      bytes2.set(length5, byteOffset);
      byteOffset += length5.byteLength;
      bytes2.set(input10, byteOffset);
      return bytes2;
    };
    encodeSequence = (sequence) => {
      let byteLength = 0;
      for (const item of sequence) {
        byteLength += item.byteLength;
      }
      const length5 = encodeDERLength(byteLength);
      const bytes2 = new Uint8Array(TAG_SIZE2 + length5.byteLength + byteLength);
      let byteOffset = 0;
      bytes2[byteOffset] = SEQUENCE_TAG;
      byteOffset += TAG_SIZE2;
      bytes2.set(length5, byteOffset);
      byteOffset += length5.byteLength;
      for (const item of sequence) {
        bytes2.set(item, byteOffset);
        byteOffset += item.byteLength;
      }
      return bytes2;
    };
    readSequence = (bytes2, offset2 = 0) => {
      const { position, length: length5 } = into(bytes2, SEQUENCE_TAG, offset2);
      return new Uint8Array(bytes2.buffer, bytes2.byteOffset + position, length5);
    };
    encodeInt = (input10) => {
      const extra = input10.byteLength === 0 || input10[0] & 128 ? 1 : 0;
      const length5 = encodeDERLength(input10.byteLength + extra);
      const bytes2 = new Uint8Array(
        TAG_SIZE2 + // INT_TAG
        length5.byteLength + input10.byteLength + extra
      );
      let byteOffset = 0;
      bytes2[byteOffset] = INT_TAG;
      byteOffset += TAG_SIZE2;
      bytes2.set(length5, byteOffset);
      byteOffset += length5.byteLength;
      if (extra > 0) {
        bytes2[byteOffset] = UNUSED_BIT_PAD;
        byteOffset += extra;
      }
      bytes2.set(input10, byteOffset);
      return bytes2;
    };
    enterSequence = (bytes2, offset2 = 0) => into(bytes2, SEQUENCE_TAG, offset2).position;
    skipSequence = (bytes2, offset2 = 0) => skip(bytes2, SEQUENCE_TAG, offset2);
    skipInt = (bytes2, offset2 = 0) => skip(bytes2, INT_TAG, offset2);
    readBitString = (bytes2, offset2 = 0) => {
      const { position, length: length5 } = into(bytes2, BITSTRING_TAG, offset2);
      const tag2 = bytes2[position];
      if (tag2 !== UNUSED_BIT_PAD) {
        throw new Error(
          `Can not read bitstring, expected length to be multiple of 8, but got ${tag2} unused bits in last byte.`
        );
      }
      return new Uint8Array(
        bytes2.buffer,
        bytes2.byteOffset + position + 1,
        length5 - 1
      );
    };
    readInt2 = (bytes2, byteOffset = 0) => {
      const { position, length: length5 } = into(bytes2, INT_TAG, byteOffset);
      let delta = 0;
      while (bytes2[position + delta] === 0) {
        delta++;
      }
      return new Uint8Array(
        bytes2.buffer,
        bytes2.byteOffset + position + delta,
        length5 - delta
      );
    };
    readOctetString = (bytes2, offset2 = 0) => {
      const { position, length: length5 } = into(bytes2, OCTET_STRING_TAG, offset2);
      return new Uint8Array(bytes2.buffer, bytes2.byteOffset + position, length5);
    };
    readSequenceWith = (readers, source, byteOffset = 0) => {
      const results = [];
      const sequence = readSequence(source, byteOffset);
      let offset2 = 0;
      for (const read10 of readers) {
        const chunk = read10(sequence, offset2);
        results.push(chunk);
        offset2 = chunk.byteOffset + chunk.byteLength - sequence.byteOffset;
      }
      return results;
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa/spki.js
var SPKI_PARAMS_ENCODED, encode36, decode45;
var init_spki = __esm({
  "../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa/spki.js"() {
    init_asn1();
    SPKI_PARAMS_ENCODED = new Uint8Array([
      48,
      13,
      6,
      9,
      42,
      134,
      72,
      134,
      247,
      13,
      1,
      1,
      1,
      5,
      0
    ]);
    encode36 = (key) => encodeSequence([SPKI_PARAMS_ENCODED, encodeBitString(key)]);
    decode45 = (info) => {
      const offset2 = enterSequence(info, 0);
      const keyOffset = skipSequence(info, offset2);
      return readBitString(info, keyOffset);
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa/pkcs8.js
var PKSC8_HEADER, decode46, encode37;
var init_pkcs8 = __esm({
  "../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa/pkcs8.js"() {
    init_base642();
    init_asn1();
    PKSC8_HEADER = new Uint8Array([
      // version
      2,
      1,
      0,
      // privateKeyAlgorithm
      48,
      13,
      6,
      9,
      42,
      134,
      72,
      134,
      247,
      13,
      1,
      1,
      1,
      5,
      0
    ]);
    decode46 = (info) => {
      let offset2 = 0;
      offset2 = enterSequence(info, offset2);
      offset2 = skipInt(info, offset2);
      offset2 = skipSequence(info, offset2);
      return readOctetString(info, offset2);
    };
    encode37 = (key) => encodeSequence([PKSC8_HEADER, encodeOctetString(key)]);
  }
});

// ../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa/public-key.js
var encode38;
var init_public_key = __esm({
  "../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa/public-key.js"() {
    init_asn1();
    init_spki();
    init_base642();
    encode38 = ({ n, e }) => encodeSequence([encodeInt(n), encodeInt(e)]);
  }
});

// ../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa/private-key.js
var VERSION2, decode47;
var init_private_key = __esm({
  "../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa/private-key.js"() {
    init_asn1();
    init_base642();
    init_pkcs8();
    init_spki();
    init_public_key();
    VERSION2 = new Uint8Array();
    decode47 = (source, byteOffset = 0) => {
      const [v, n, e, d, p, q, dp, dq, qi] = readSequenceWith(
        [
          readInt2,
          readInt2,
          readInt2,
          readInt2,
          readInt2,
          readInt2,
          readInt2,
          readInt2,
          readInt2
        ],
        source,
        byteOffset
      );
      return { v, n, e, d, p, q, dp, dq, qi };
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa.js
var rsa_exports = {};
__export(rsa_exports, {
  Verifier: () => RSAVerifier,
  code: () => code20,
  decode: () => decode48,
  from: () => from16,
  generate: () => generate2,
  name: () => name16,
  or: () => or11,
  signatureAlgorithm: () => signatureAlgorithm3,
  signatureCode: () => signatureCode3
});
var name16, code20, verifierCode, signatureCode3, signatureAlgorithm3, ALG, HASH_ALG, KEY_SIZE2, SALT_LENGTH, IMPORT_PARAMS, generate2, from16, or11, decode48, RSAVerifier, RSASigner, ExtractableRSASigner, UnextractableRSASigner;
var init_rsa = __esm({
  "../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa.js"() {
    init_node3();
    init_base583();
    init_did();
    init_multiformat();
    init_signature();
    init_spki();
    init_pkcs8();
    init_private_key();
    init_public_key();
    init_verifier();
    init_signer();
    init_type3();
    name16 = "RSA";
    code20 = 4869;
    verifierCode = 4613;
    signatureCode3 = RS256;
    signatureAlgorithm3 = "RS256";
    ALG = "RSASSA-PKCS1-v1_5";
    HASH_ALG = "SHA-256";
    KEY_SIZE2 = 2048;
    SALT_LENGTH = 128;
    IMPORT_PARAMS = {
      name: ALG,
      hash: { name: HASH_ALG }
    };
    generate2 = async ({
      size: size5 = KEY_SIZE2,
      extractable = false
    } = {}) => {
      const { publicKey, privateKey } = await webcrypto.subtle.generateKey(
        {
          name: ALG,
          modulusLength: size5,
          publicExponent: new Uint8Array([1, 0, 1]),
          hash: { name: HASH_ALG }
        },
        extractable,
        ["sign", "verify"]
      );
      const spki = await webcrypto.subtle.exportKey("spki", publicKey);
      const publicBytes = tagWith(verifierCode, decode45(new Uint8Array(spki)));
      const verifier = new RSAVerifier({ bytes: publicBytes, publicKey });
      if (!extractable) {
        return new UnextractableRSASigner({
          privateKey,
          verifier
        });
      } else {
        const pkcs8 = await webcrypto.subtle.exportKey("pkcs8", privateKey);
        const bytes2 = tagWith(code20, decode46(new Uint8Array(pkcs8)));
        return new ExtractableRSASigner({
          privateKey,
          bytes: bytes2,
          verifier
        });
      }
    };
    from16 = ({ id, keys: keys2 }) => {
      if (id.startsWith("did:key:")) {
        const did2 = (
          /** @type {API.DIDKey} */
          id
        );
        const key = keys2[did2];
        if (key instanceof Uint8Array) {
          return decode48(key);
        } else {
          return new UnextractableRSASigner({
            privateKey: key,
            verifier: RSAVerifier.parse(did2)
          });
        }
      } else {
        throw new TypeError(
          `RSA can not import from ${id} archive, try generic Signer instead`
        );
      }
    };
    or11 = (other) => or9({ from: from16 }, other);
    decode48 = (bytes2) => {
      const rsa = decode47(untagWith(code20, bytes2));
      const publicBytes = tagWith(verifierCode, encode38(rsa));
      return new ExtractableRSASigner({
        bytes: bytes2,
        privateKey: webcrypto.subtle.importKey(
          "pkcs8",
          encode37(untagWith(code20, bytes2)),
          IMPORT_PARAMS,
          true,
          ["sign"]
        ),
        verifier: RSAVerifier.decode(publicBytes)
      });
    };
    RSAVerifier = class _RSAVerifier {
      /**
       * @param {object} options
       * @param {API.Await<CryptoKey>} options.publicKey
       * @param {API.ByteView<API.RSAVerifier>} options.bytes
       */
      constructor({ publicKey, bytes: bytes2 }) {
        this.publicKey = publicKey;
        this.bytes = bytes2;
      }
      /**
       * @template {API.DID} ID
       * @param {ID} id
       * @returns {API.Verifier<ID, typeof signatureCode>}
       */
      withDID(id) {
        return withDID(this, id);
      }
      toDIDKey() {
        return this.did();
      }
      /**
       * @param {API.ByteView<API.RSAVerifier>} bytes
       * @returns {API.RSAVerifier}
       */
      static decode(bytes2) {
        return new this({
          bytes: bytes2,
          publicKey: webcrypto.subtle.importKey(
            "spki",
            encode36(untagWith(verifierCode, bytes2)),
            IMPORT_PARAMS,
            true,
            ["verify"]
          )
        });
      }
      /**
       * @param {API.DIDKey} did
       * @returns {API.RSAVerifier}
       */
      static parse(did2) {
        return _RSAVerifier.decode(
          /** @type {Uint8Array} */
          parse3(did2)
        );
      }
      /**
       * @param {API.PrincipalParser} other
       */
      static or(other) {
        return or7(this, other);
      }
      /** @type {typeof verifierCode} */
      get code() {
        return verifierCode;
      }
      /**
       * @type {typeof signatureCode}
       */
      get signatureCode() {
        return signatureCode3;
      }
      /**
       * @type {typeof signatureAlgorithm}
       */
      get signatureAlgorithm() {
        return signatureAlgorithm3;
      }
      /**
       * DID of the Principal in `did:key` format.
       * @returns {API.DID<"key">}
       */
      did() {
        return `did:key:${base58btc3.encode(this.bytes)}`;
      }
      /**
       * @template T
       * @param {API.ByteView<T>} payload
       * @param {API.Signature<T, typeof this.signatureCode>} signature
       * @returns {Promise<boolean>}
       */
      async verify(payload, signature) {
        if (signature.code !== signatureCode3) {
          return false;
        }
        return webcrypto.subtle.verify(
          { name: ALG, hash: { name: HASH_ALG } },
          await this.publicKey,
          signature.raw,
          payload
        );
      }
    };
    RSASigner = class {
      /**
       * @param {object} options
       * @param {API.Await<CryptoKey>} options.privateKey
       * @param {API.RSAVerifier} options.verifier
       */
      constructor({ privateKey, verifier }) {
        this.verifier = verifier;
        this.privateKey = privateKey;
      }
      get signer() {
        return this;
      }
      /**
       * @type {typeof code}
       */
      get code() {
        return code20;
      }
      /**
       * @type {typeof signatureCode}
       */
      get signatureCode() {
        return signatureCode3;
      }
      /**
       * @type {typeof signatureAlgorithm}
       */
      get signatureAlgorithm() {
        return signatureAlgorithm3;
      }
      did() {
        return this.verifier.did();
      }
      toDIDKey() {
        return this.verifier.toDIDKey();
      }
      /**
       * @template T
       * @param {API.ByteView<T>} payload
       * @param {API.Signature<T, typeof this.signatureCode>} signature
       */
      verify(payload, signature) {
        return this.verifier.verify(payload, signature);
      }
      /**
       * @template T
       * @param {API.ByteView<T>} payload
       * @returns {Promise<API.SignatureView<T, typeof signatureCode>>}
       */
      async sign(payload) {
        const buffer3 = await webcrypto.subtle.sign(
          { name: ALG, saltLength: SALT_LENGTH },
          await this.privateKey,
          payload
        );
        return create7(signatureCode3, new Uint8Array(buffer3));
      }
    };
    ExtractableRSASigner = class extends RSASigner {
      /**
       * @param {object} options
       * @param {API.Await<CryptoKey>} options.privateKey
       * @param {EncodedSigner} options.bytes
       * @param {API.RSAVerifier} options.verifier
       */
      constructor(options) {
        super(options);
        this.bytes = options.bytes;
      }
      /**
       * @template {API.DID} ID
       * @param {ID} id
       * @returns {API.Signer<ID, typeof signatureCode>}
       */
      withDID(id) {
        return withDID2(this, id);
      }
      toArchive() {
        const id = this.did();
        return {
          id,
          keys: { [id]: this.bytes }
        };
      }
    };
    UnextractableRSASigner = class extends RSASigner {
      /**
       * @param {object} options
       * @param {CryptoKey} options.privateKey
       * @param {API.RSAVerifier} options.verifier
       */
      constructor(options) {
        super(options);
        this.privateKey = options.privateKey;
      }
      /**
       * @template {API.DID} ID
       * @param {ID} id
       * @returns {API.Signer<ID, typeof signatureCode>}
       */
      withDID(id) {
        return withDID2(this, id);
      }
      toArchive() {
        const id = this.did();
        return {
          id,
          keys: { [id]: this.privateKey }
        };
      }
    };
  }
});

// ../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/absentee.js
var init_absentee = __esm({
  "../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/absentee.js"() {
    init_signature();
    init_lib2();
  }
});

// ../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/lib.js
var Verifier, Signer;
var init_lib8 = __esm({
  "../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/lib.js"() {
    init_ed25519();
    init_rsa();
    init_absentee();
    init_multiformat();
    Verifier = verifier_exports.or(RSAVerifier);
    Signer = or10(rsa_exports);
  }
});

// ../../node_modules/.pnpm/@web3-storage+capabilities@17.2.0/node_modules/@web3-storage/capabilities/src/ucan.js
var UCANLink, ucan, revoke, conclude, attest;
var init_ucan2 = __esm({
  "../../node_modules/.pnpm/@web3-storage+capabilities@17.2.0/node_modules/@web3-storage/capabilities/src/ucan.js"() {
    init_lib6();
    init_utils5();
    UCANLink = /** @type {Schema.Schema<API.UCANLink, unknown>} */
    schema_exports3.link({ version: 1 });
    ucan = capability({
      can: "ucan/*",
      with: schema_exports3.did(),
      derives: equalWith2
    });
    revoke = capability({
      can: "ucan/revoke",
      /**
       * DID of the principal authorizing revocation.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * UCAN being revoked from all proof chains that lead to the UCAN that is
         * either issued (iss) by or delegated to (aud) the principal identified
         * by the `with` field.
         */
        ucan: UCANLink,
        /**
         * Proof chain illustrating the path from revoked UCAN to the one that is
         * either issued (iss) by or delegated to (aud) the principal identified
         * by the `with` field.
         *
         * If the UCAN being revoked is either issued (iss) by or delegated to (aud)
         * the principal identified by the `with` field no `proof` is required and
         * it can be omitted or set to an empty array.
         *
         * It is RECOMMENDED that `proof` is provided in all other cases otherwise
         * it MAY not be possible to verify that revoking principal is a participant
         * in the proof chain.
         */
        proof: UCANLink.array().optional()
      }),
      derives: (claim, from21) => (
        // With field MUST be the same
        and4(equalWith2(claim, from21)) ?? // UCAN being revoked MUST be the same
        and4(checkLink2(claim.nb.ucan, from21.nb.ucan, "nb.ucan")) ?? // And proof chain MUST be the same
        equal2(
          (claim.nb.proof ?? []).join("/"),
          (from21.nb.proof ?? []).join("/"),
          "nb.proof"
        )
      )
    });
    conclude = capability({
      can: "ucan/conclude",
      /**
       * DID of the principal representing the Conclusion Authority.
       * MUST be the DID of the audience of the ran invocation.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * CID of the content with the Receipt.
         */
        receipt: schema_exports3.link()
      }),
      derives: (claim, from21) => (
        // With field MUST be the same
        and4(equalWith2(claim, from21)) || and4(checkLink2(claim.nb.receipt, from21.nb.receipt, "nb.receipt")) || ok({})
      )
    });
    attest = capability({
      can: "ucan/attest",
      // Should be web3.storage DID
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        // UCAN delegation that is being attested.
        proof: schema_exports3.link({ version: 1 })
      }),
      derives: (claim, from21) => (
        // With field MUST be the same
        and4(equalWith2(claim, from21)) ?? // UCAN link MUST be the same
        checkLink2(claim.nb.proof, from21.nb.proof, "nb.proof")
      )
    });
  }
});

// ../../node_modules/.pnpm/@web3-storage+capabilities@17.2.0/node_modules/@web3-storage/capabilities/src/blob.js
var blob, content, add3, remove3, list3, get4;
var init_blob = __esm({
  "../../node_modules/.pnpm/@web3-storage+capabilities@17.2.0/node_modules/@web3-storage/capabilities/src/blob.js"() {
    init_equals();
    init_lib6();
    init_utils5();
    blob = capability({
      can: "space/blob/*",
      /**
       * DID of the (memory) space where Blob is intended to
       * be stored.
       */
      with: SpaceDID2,
      derives: equalWith2
    });
    content = schema_exports3.struct({
      /**
       * A multihash digest of the blob payload bytes, uniquely identifying blob.
       */
      digest: schema_exports3.bytes(),
      /**
       * Number of bytes contained by this blob. Service will provision write target
       * for this exact size. Attempt to write a larger Blob file will fail.
       */
      size: schema_exports3.integer()
    });
    add3 = capability({
      can: "space/blob/add",
      /**
       * DID of the (memory) space where Blob is intended to
       * be stored.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * Blob to be added on the space.
         */
        blob: content
      }),
      derives: equalBlob
    });
    remove3 = capability({
      can: "space/blob/remove",
      /**
       * DID of the (memory) space where Blob is stored.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * A multihash digest of the blob payload bytes, uniquely identifying blob.
         */
        digest: schema_exports3.bytes()
      }),
      derives: (claimed, delegated) => {
        if (claimed.with !== delegated.with) {
          return fail2(
            `Expected 'with: "${delegated.with}"' instead got '${claimed.with}'`
          );
        } else if (delegated.nb.digest && !equals7(delegated.nb.digest, claimed.nb.digest)) {
          return fail2(
            `Link ${claimed.nb.digest ? `${claimed.nb.digest}` : ""} violates imposed ${delegated.nb.digest} constraint.`
          );
        }
        return ok({});
      }
    });
    list3 = capability({
      can: "space/blob/list",
      /**
       * DID of the (memory) space where Blobs to be listed are stored.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * A pointer that can be moved back and forth on the list.
         * It can be used to paginate a list for instance.
         */
        cursor: schema_exports3.string().optional(),
        /**
         * Maximum number of items per page.
         */
        size: schema_exports3.integer().optional()
      }),
      derives: (claimed, delegated) => {
        if (claimed.with !== delegated.with) {
          return fail2(
            `Expected 'with: "${delegated.with}"' instead got '${claimed.with}'`
          );
        }
        return ok({});
      }
    });
    get4 = capability({
      can: "space/blob/get/0/1",
      /**
       * DID of the (memory) space where Blob is stored.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * A multihash digest of the blob payload bytes, uniquely identifying blob.
         */
        digest: schema_exports3.bytes()
      }),
      derives: (claimed, delegated) => {
        if (claimed.with !== delegated.with) {
          return fail2(
            `Expected 'with: "${delegated.with}"' instead got '${claimed.with}'`
          );
        } else if (delegated.nb.digest && !equals7(delegated.nb.digest, claimed.nb.digest)) {
          return fail2(
            `Link ${claimed.nb.digest ? `${claimed.nb.digest}` : ""} violates imposed ${delegated.nb.digest} constraint.`
          );
        }
        return ok({});
      }
    });
  }
});

// ../../node_modules/.pnpm/@web3-storage+capabilities@17.2.0/node_modules/@web3-storage/capabilities/src/web3.storage/blob.js
var blob2, allocate, accept;
var init_blob2 = __esm({
  "../../node_modules/.pnpm/@web3-storage+capabilities@17.2.0/node_modules/@web3-storage/capabilities/src/web3.storage/blob.js"() {
    init_lib6();
    init_blob();
    init_utils5();
    blob2 = capability({
      can: "web3.storage/blob/*",
      /**
       * DID of the (memory) space where Blob is intended to
       * be stored.
       */
      with: SpaceDID2,
      derives: equalWith2
    });
    allocate = capability({
      can: "web3.storage/blob/allocate",
      /**
       * Provider DID.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * Blob to allocate on the space.
         */
        blob: content,
        /**
         * The Link for an Add Blob task, that caused an allocation
         */
        cause: link_exports2,
        /**
         * DID of the user space where allocation takes place
         */
        space: SpaceDID2
      }),
      derives: (claim, from21) => {
        return and4(equalWith2(claim, from21)) || and4(equalBlob(claim, from21)) || and4(checkLink2(claim.nb.cause, from21.nb.cause, "cause")) || and4(equal2(claim.nb.space, from21.nb.space, "space")) || ok({});
      }
    });
    accept = capability({
      can: "web3.storage/blob/accept",
      /**
       * Provider DID.
       */
      with: schema_exports3.did(),
      nb: schema_exports3.struct({
        /**
         * Blob to accept.
         */
        blob: content,
        /**
         * Content location commitment time to live, which will be encoded as expiry of the issued location claim.
         */
        ttl: schema_exports3.integer().optional(),
        /**
         * DID of the user space where allocation took place
         */
        space: SpaceDID2,
        /**
         * This task is blocked on `http/put` receipt available
         */
        _put: Await2
      }),
      derives: (claim, from21) => {
        return and4(equalWith2(claim, from21)) || and4(equalBlob(claim, from21)) || and4(equal2(claim.nb.ttl, from21.nb.ttl, "ttl")) || and4(equal2(claim.nb.space, from21.nb.space, "space")) || ok({});
      }
    });
  }
});

// ../../node_modules/.pnpm/@web3-storage+capabilities@17.2.0/node_modules/@web3-storage/capabilities/src/http.js
var put;
var init_http2 = __esm({
  "../../node_modules/.pnpm/@web3-storage+capabilities@17.2.0/node_modules/@web3-storage/capabilities/src/http.js"() {
    init_lib6();
    init_blob();
    init_utils5();
    put = capability({
      can: "http/put",
      /**
       * DID of the (memory) space where Blob is intended to
       * be stored.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * Description of body to send (digest/size).
         */
        body: content,
        /**
         * HTTP(S) location that can receive blob content via HTTP PUT request.
         */
        url: schema_exports3.string().or(Await2),
        /**
         * HTTP headers.
         */
        headers: schema_exports3.dictionary({ value: schema_exports3.string() }).or(Await2)
      }),
      derives: (claim, from21) => {
        return and4(equalWith2(claim, from21)) || and4(equalBody(claim, from21)) || and4(equal2(claim.nb.url, from21.nb, "url")) || and4(equal2(claim.nb.headers, from21.nb, "headers")) || ok({});
      }
    });
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/receipts.js
var receipts_exports = {};
__export(receipts_exports, {
  ReceiptMissing: () => ReceiptMissing,
  ReceiptNotFound: () => ReceiptNotFound,
  poll: () => poll
});
async function poll(taskCid, options = {}) {
  return await pRetry(async () => {
    const res = await get5(taskCid, options);
    if (res.error) {
      if (res.error.name === "ReceiptNotFound") {
        throw res.error;
      } else {
        throw new AbortError(new Error("failed to fetch blob/accept receipt", {
          cause: res.error
        }));
      }
    }
    return res.ok;
  }, {
    onFailedAttempt: console.warn,
    /* c8 ignore next */
    retries: options.retries ?? REQUEST_RETRIES
  });
}
async function get5(taskCid, options = {}) {
  const url = new URL(taskCid.toString(), options.receiptsEndpoint ?? receiptsEndpoint);
  const fetchReceipt = options.fetch ?? globalThis.fetch.bind(globalThis);
  const workflowResponse = await fetchReceipt(url);
  if (workflowResponse.status === 404) {
    return {
      error: new ReceiptNotFound(taskCid)
    };
  }
  const agentMessageBytes = new Uint8Array(await workflowResponse.arrayBuffer());
  const agentMessage = await car_exports2.request.decode({
    body: agentMessageBytes,
    headers: {}
  });
  const receipt = agentMessage.receipts.get(taskCid.toString());
  if (!receipt) {
    return {
      error: new ReceiptMissing(taskCid)
    };
  }
  return {
    ok: receipt
  };
}
var ReceiptNotFound, ReceiptMissing;
var init_receipts = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/receipts.js"() {
    init_p_retry();
    init_lib5();
    init_service3();
    init_constants();
    ReceiptNotFound = class extends Error {
      /**
       * @param {import('multiformats').UnknownLink} taskCid
       */
      constructor(taskCid) {
        super();
        this.taskCid = taskCid;
      }
      /* c8 ignore start */
      get reason() {
        return `receipt not found for task ${this.taskCid} in the indexed workflow`;
      }
      /* c8 ignore end */
      get name() {
        return "ReceiptNotFound";
      }
    };
    ReceiptMissing = class extends Error {
      /**
       * @param {import('multiformats').UnknownLink} taskCid
       */
      constructor(taskCid) {
        super();
        this.taskCid = taskCid;
      }
      /* c8 ignore start */
      get reason() {
        return `receipt missing for task ${this.taskCid}`;
      }
      /* c8 ignore end */
      get name() {
        return "ReceiptMissing";
      }
    };
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/blob/add.js
function createUploadProgressHandler2(url, handler) {
  const onUploadProgress = ({ total, loaded, lengthComputable }) => {
    return handler({ total, loaded, lengthComputable, url });
  };
  return onUploadProgress;
}
function getConcludeReceipt(concludeFx) {
  const receiptBlocks = /* @__PURE__ */ new Map();
  for (const block of concludeFx.iterateIPLDBlocks()) {
    receiptBlocks.set(`${block.cid}`, block);
  }
  return receipt_exports.view({
    // @ts-expect-error object of type unknown
    root: concludeFx.capabilities[0].nb.receipt,
    blocks: receiptBlocks
  });
}
function parseBlobAddReceiptNext(receipt) {
  const forkInvocations = receipt.fx.fork;
  const allocateTask = forkInvocations.find((fork5) => fork5.capabilities[0].can === allocate.can);
  const concludefxs = forkInvocations.filter((fork5) => fork5.capabilities[0].can === conclude.can);
  const putTask = forkInvocations.find((fork5) => fork5.capabilities[0].can === put.can);
  const acceptTask = forkInvocations.find((fork5) => fork5.capabilities[0].can === accept.can);
  if (!allocateTask || !concludefxs.length || !putTask || !acceptTask) {
    throw new Error("mandatory effects not received");
  }
  const nextReceipts = concludefxs.map((fx) => getConcludeReceipt(fx));
  const allocateReceipt = nextReceipts.find((receipt2) => receipt2.ran.link().equals(allocateTask.cid));
  const putReceipt = nextReceipts.find((receipt2) => receipt2.ran.link().equals(putTask.cid));
  const acceptReceipt = nextReceipts.find((receipt2) => receipt2.ran.link().equals(acceptTask.cid));
  if (!allocateReceipt) {
    throw new Error("mandatory effects not received");
  }
  return {
    allocate: {
      task: allocateTask,
      receipt: allocateReceipt
    },
    put: {
      task: putTask,
      receipt: putReceipt
    },
    accept: {
      task: acceptTask,
      receipt: acceptReceipt
    }
  };
}
function createConcludeInvocation(id, serviceDid, receipt) {
  const receiptBlocks = [];
  const receiptCids = [];
  for (const block of receipt.iterateIPLDBlocks()) {
    receiptBlocks.push(block);
    receiptCids.push(block.cid);
  }
  const concludeAllocatefx = conclude.invoke({
    issuer: id,
    audience: serviceDid,
    with: id.toDIDKey(),
    nb: {
      receipt: receipt.link()
    },
    expiration: Infinity,
    facts: [
      {
        ...receiptCids
      }
    ]
  });
  for (const block of receiptBlocks) {
    concludeAllocatefx.attach(block);
  }
  return concludeAllocatefx;
}
async function add4({ issuer, with: resource, proofs: proofs2, audience }, digest6, data, options = {}) {
  const bytes2 = data instanceof Uint8Array ? data : new Uint8Array(await data.arrayBuffer());
  const size5 = bytes2.length;
  const conn = options.connection ?? connection5;
  const result = await pRetry(async () => {
    return await add3.invoke({
      issuer,
      /* c8 ignore next */
      audience: audience ?? servicePrincipal,
      with: SpaceDID2.from(resource),
      nb: input(digest6, size5),
      proofs: proofs2,
      nonce: options.nonce
    }).execute(conn);
  }, {
    onFailedAttempt: console.warn,
    retries: options.retries ?? REQUEST_RETRIES
  });
  if (!result.out.ok) {
    throw new Error(`failed ${add3.can} invocation`, {
      cause: result.out.error
    });
  }
  const nextTasks = parseBlobAddReceiptNext(result);
  const { receipt: allocateReceipt } = nextTasks.allocate;
  if (!allocateReceipt.out.ok) {
    throw new Error(`failed ${add3.can} invocation`, {
      cause: allocateReceipt.out.error
    });
  }
  const { address } = allocateReceipt.out.ok;
  if (address) {
    const fetchWithUploadProgress = options.fetchWithUploadProgress || options.fetch || globalThis.fetch.bind(globalThis);
    let fetchDidCallUploadProgressCb = false;
    const { status } = await pRetry(async () => {
      try {
        const res = await fetchWithUploadProgress(address.url, {
          method: "PUT",
          mode: "cors",
          body: bytes2,
          headers: address.headers,
          signal: options.signal,
          onUploadProgress: (status2) => {
            fetchDidCallUploadProgressCb = true;
            if (options.onUploadProgress)
              createUploadProgressHandler2(address.url, options.onUploadProgress)(status2);
          },
          // @ts-expect-error - this is needed by recent versions of node - see https://github.com/bluesky-social/atproto/pull/470 for more info
          duplex: "half"
        });
        if (res.status >= 400 && res.status < 500) {
          throw new AbortError(`upload failed: ${res.status}`);
        }
        return res;
      } catch (err) {
        if (options.signal?.aborted === true) {
          throw new AbortError("upload aborted");
        }
        throw err;
      }
    }, {
      retries: options.retries ?? REQUEST_RETRIES
    });
    if (status !== 200)
      throw new Error(`upload failed: ${status}`);
    if (!fetchDidCallUploadProgressCb && options.onUploadProgress) {
      const blob3 = new Blob([bytes2]);
      options.onUploadProgress({
        total: blob3.size,
        loaded: blob3.size,
        lengthComputable: false
      });
    }
  }
  let { receipt: httpPutReceipt } = nextTasks.put;
  if (!httpPutReceipt?.out.ok) {
    const derivedSigner = ed25519_exports.from(
      /** @type {import('@ucanto/interface').SignerArchive<import('@ucanto/interface').DID, typeof ed25519.signatureCode>} */
      nextTasks.put.task.facts[0]["keys"]
    );
    httpPutReceipt = await receipt_exports.issue({
      issuer: derivedSigner,
      ran: nextTasks.put.task.cid,
      result: { ok: {} }
    });
    const httpPutConcludeInvocation = createConcludeInvocation(
      issuer,
      /* c8 ignore next */
      audience ?? servicePrincipal,
      httpPutReceipt
    );
    const ucanConclude = await httpPutConcludeInvocation.execute(conn);
    if (!ucanConclude.out.ok) {
      throw new Error(`failed ${add3.can} invocation`, {
        cause: result.out.error
      });
    }
  }
  let { receipt: acceptReceipt } = nextTasks.accept;
  if (!acceptReceipt?.out.ok) {
    acceptReceipt = await poll(nextTasks.accept.task.link(), options);
  }
  const blocks = new Map([...acceptReceipt.iterateIPLDBlocks()].map((block) => [
    `${block.cid}`,
    block
  ]));
  const site = delegation_exports.view({
    root: (
      /** @type {import('@ucanto/interface').UCANLink} */
      acceptReceipt.out.ok?.site
    ),
    blocks
  });
  return { site };
}
var ability, input;
var init_add6 = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/blob/add.js"() {
    init_lib8();
    init_ucan2();
    init_ucan2();
    init_lib3();
    init_blob2();
    init_blob();
    init_http2();
    init_utils5();
    init_p_retry();
    init_service3();
    init_constants();
    init_receipts();
    ability = add3.can;
    input = (digest6, size5) => ({
      blob: {
        digest: digest6.bytes,
        size: size5
      }
    });
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/blob/get.js
async function get6({ issuer, with: resource, proofs: proofs2, audience }, multihash, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await get4.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? servicePrincipal,
    with: SpaceDID2.from(resource),
    nb: input2(multihash),
    proofs: proofs2,
    nonce: options.nonce
  }).execute(conn);
  if (!result.out.ok) {
    throw new Error(`failed ${get4.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out;
}
var ability2, input2;
var init_get7 = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/blob/get.js"() {
    init_blob();
    init_utils5();
    init_service3();
    ability2 = get4.can;
    input2 = (digest6) => ({ digest: digest6.bytes });
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/blob/list.js
async function list4({ issuer, with: resource, proofs: proofs2, audience }, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await list3.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? servicePrincipal,
    with: SpaceDID2.from(resource),
    proofs: proofs2,
    nb: input3(options.cursor, options.size),
    nonce: options.nonce
  }).execute(conn);
  if (!result.out.ok) {
    throw new Error(`failed ${list3.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out.ok;
}
var ability3, input3;
var init_list4 = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/blob/list.js"() {
    init_blob();
    init_utils5();
    init_service3();
    ability3 = list3.can;
    input3 = (cursor, size5) => ({ cursor, size: size5 });
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/blob/remove.js
async function remove4({ issuer, with: resource, proofs: proofs2, audience }, multihash, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await remove3.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? servicePrincipal,
    with: SpaceDID2.from(resource),
    nb: input4(multihash),
    proofs: proofs2,
    nonce: options.nonce
  }).execute(conn);
  if (!result.out.ok) {
    throw new Error(`failed ${remove3.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out;
}
var ability4, input4;
var init_remove = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/blob/remove.js"() {
    init_blob();
    init_utils5();
    init_service3();
    ability4 = remove3.can;
    input4 = (digest6) => ({ digest: digest6.bytes });
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/blob/index.js
var blob_exports3 = {};
__export(blob_exports3, {
  add: () => add4,
  get: () => get6,
  list: () => list4,
  remove: () => remove4
});
var init_blob3 = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/blob/index.js"() {
    init_add6();
    init_get7();
    init_list4();
    init_remove();
  }
});

// ../../node_modules/.pnpm/@web3-storage+capabilities@17.2.0/node_modules/@web3-storage/capabilities/src/index/index.js
var index, add5;
var init_index = __esm({
  "../../node_modules/.pnpm/@web3-storage+capabilities@17.2.0/node_modules/@web3-storage/capabilities/src/index/index.js"() {
    init_lib3();
    init_lib6();
    init_utils5();
    index = capability({
      can: "space/index/*",
      /** DID of the space where indexed data is stored. */
      with: SpaceDID2,
      derives: equalWith2
    });
    add5 = capability({
      can: "space/index/add",
      /** DID of the space where indexed data is stored. */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /** Content Archive (CAR) containing the `Index`. */
        index: schema_exports3.link({ code: car_exports.code })
      }),
      derives: (claimed, delegated) => and4(equalWith2(claimed, delegated)) || and4(equal2(claimed.nb.index, delegated.nb.index, "index")) || ok({})
    });
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/index/add.js
async function add6({ issuer, with: resource, proofs: proofs2, audience }, index2, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await pRetry(async () => {
    return await add5.invoke({
      issuer,
      /* c8 ignore next */
      audience: audience ?? servicePrincipal,
      with: SpaceDID2.from(resource),
      nb: input5(index2),
      proofs: proofs2
    }).execute(conn);
  }, {
    onFailedAttempt: console.warn,
    retries: options.retries ?? REQUEST_RETRIES
  });
  if (!result.out.ok) {
    throw new Error(`failed ${add5.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out.ok;
}
var ability5, input5;
var init_add7 = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/index/add.js"() {
    init_index();
    init_utils5();
    init_p_retry();
    init_service3();
    init_constants();
    ability5 = add5.can;
    input5 = (index2) => ({ index: index2 });
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/index/index.js
var index_exports2 = {};
__export(index_exports2, {
  add: () => add6
});
var init_index2 = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/index/index.js"() {
    init_add7();
  }
});

// ../../node_modules/.pnpm/@web3-storage+capabilities@17.2.0/node_modules/@web3-storage/capabilities/src/upload.js
var upload, CARLink2, add7, get7, remove5, list5, all4;
var init_upload = __esm({
  "../../node_modules/.pnpm/@web3-storage+capabilities@17.2.0/node_modules/@web3-storage/capabilities/src/upload.js"() {
    init_lib6();
    init_car2();
    init_utils5();
    upload = capability({
      can: "upload/*",
      /**
       * DID of the (memory) space where upload is add to the
       * upload list.
       */
      with: SpaceDID2,
      derives: equalWith2
    });
    CARLink2 = link_exports2.match({ code: car_exports.code, version: 1 });
    add7 = capability({
      can: "upload/add",
      /**
       * DID of the (memory) space where uploaded is added.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * Root CID of the DAG to be added to the upload list.
         */
        root: link_exports2,
        /**
         * CIDs to the CAR files that contain blocks of the DAG.
         */
        shards: CARLink2.array().optional()
      }),
      derives: (self2, from21) => {
        return and4(equalWith2(self2, from21)) || and4(equal2(self2.nb.root, from21.nb.root, "root")) || and4(equal2(self2.nb.shards, from21.nb.shards, "shards")) || ok({});
      }
    });
    get7 = capability({
      can: "upload/get",
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * Root CID of the DAG to fetch upload info about.
         */
        root: link_exports2.optional()
      }),
      derives: (self2, from21) => {
        const res = equalWith2(self2, from21);
        if (res.error) {
          return res;
        }
        if (!from21.nb.root) {
          return res;
        }
        return equal2(self2.nb.root, from21.nb.root, "root");
      }
    });
    remove5 = capability({
      can: "upload/remove",
      /**
       * DID of the (memory) space where uploaded is removed from.
       */
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * Root CID of the DAG to be removed from the upload list.
         */
        root: link_exports2
      }),
      derives: (self2, from21) => {
        return and4(equalWith2(self2, from21)) || and4(equal2(self2.nb.root, from21.nb.root, "root")) || ok({});
      }
    });
    list5 = capability({
      can: "upload/list",
      with: SpaceDID2,
      nb: schema_exports3.struct({
        /**
         * A pointer that can be moved back and forth on the list.
         * It can be used to paginate a list for instance.
         */
        cursor: schema_exports3.string().optional(),
        /**
         * Maximum number of items per page.
         */
        size: schema_exports3.integer().optional(),
        /**
         * If true, return page of results preceding cursor. Defaults to false.
         */
        pre: schema_exports3.boolean().optional()
      })
    });
    all4 = add7.or(remove5).or(list5);
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/upload/add.js
async function add8({ issuer, with: resource, proofs: proofs2, audience }, root2, shards, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await pRetry(async () => {
    return await add7.invoke({
      issuer,
      /* c8 ignore next */
      audience: audience ?? servicePrincipal,
      with: SpaceDID2.from(resource),
      nb: input6(root2, shards),
      proofs: proofs2,
      nonce: options.nonce
    }).execute(conn);
  }, {
    onFailedAttempt: console.warn,
    retries: options.retries ?? REQUEST_RETRIES
  });
  if (!result.out.ok) {
    throw new Error(`failed ${add7.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out.ok;
}
var ability6, input6;
var init_add8 = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/upload/add.js"() {
    init_upload();
    init_utils5();
    init_p_retry();
    init_service3();
    init_constants();
    ability6 = add7.can;
    input6 = (root2, shards) => ({ root: root2, shards });
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/upload/get.js
async function get8({ issuer, with: resource, proofs: proofs2, audience }, root2, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await pRetry(async () => {
    return await get7.invoke({
      issuer,
      /* c8 ignore next */
      audience: audience ?? servicePrincipal,
      with: SpaceDID2.from(resource),
      nb: input7(root2),
      proofs: proofs2,
      nonce: options.nonce
    }).execute(conn);
  }, {
    onFailedAttempt: console.warn,
    retries: options.retries ?? REQUEST_RETRIES
  });
  if (!result.out.ok) {
    throw new Error(`failed ${get7.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out.ok;
}
var ability7, input7;
var init_get8 = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/upload/get.js"() {
    init_upload();
    init_utils5();
    init_p_retry();
    init_service3();
    init_constants();
    ability7 = get7.can;
    input7 = (root2) => ({ root: root2 });
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/upload/list.js
async function list6({ issuer, with: resource, proofs: proofs2, audience }, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await list5.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? servicePrincipal,
    with: SpaceDID2.from(resource),
    proofs: proofs2,
    nb: input8(options.cursor, options.size, options.pre),
    nonce: options.nonce
  }).execute(conn);
  if (!result.out.ok) {
    throw new Error(`failed ${list5.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out.ok;
}
var ability8, input8;
var init_list5 = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/upload/list.js"() {
    init_upload();
    init_utils5();
    init_service3();
    ability8 = list5.can;
    input8 = (cursor, size5, pre) => ({ cursor, size: size5, pre });
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/upload/remove.js
async function remove6({ issuer, with: resource, proofs: proofs2, audience }, root2, options = {}) {
  const conn = options.connection ?? connection5;
  const result = await remove5.invoke({
    issuer,
    /* c8 ignore next */
    audience: audience ?? servicePrincipal,
    with: SpaceDID2.from(resource),
    nb: input9(root2),
    proofs: proofs2,
    nonce: options.nonce
  }).execute(conn);
  if (!result.out.ok) {
    throw new Error(`failed ${remove5.can} invocation`, {
      cause: result.out.error
    });
  }
  return result.out.ok;
}
var ability9, input9;
var init_remove2 = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/upload/remove.js"() {
    init_upload();
    init_utils5();
    init_service3();
    ability9 = remove5.can;
    input9 = (root2) => ({ root: root2 });
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/upload/index.js
var upload_exports2 = {};
__export(upload_exports2, {
  add: () => add8,
  get: () => get8,
  list: () => list6,
  remove: () => remove6
});
var init_upload2 = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/upload/index.js"() {
    init_add8();
    init_get8();
    init_list5();
    init_remove2();
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/api.js
var init_api2 = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/api.js"() {
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/api.js
var init_api3 = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/api.js"() {
  }
});

// ../../node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/pb-decode.js
function decodeVarint3(bytes2, offset2) {
  let v = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset2 >= bytes2.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b = bytes2[offset2++];
    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
    if (b < 128) {
      break;
    }
  }
  return [v, offset2];
}
function decodeBytes2(bytes2, offset2) {
  let byteLen;
  [byteLen, offset2] = decodeVarint3(bytes2, offset2);
  const postOffset = offset2 + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes2.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [bytes2.subarray(offset2, postOffset), postOffset];
}
function decodeKey2(bytes2, index2) {
  let wire;
  [wire, index2] = decodeVarint3(bytes2, index2);
  return [wire & 7, wire >> 3, index2];
}
function decodeLink2(bytes2) {
  const link5 = {};
  const l = bytes2.length;
  let index2 = 0;
  while (index2 < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index2] = decodeKey2(bytes2, index2);
    if (fieldNum === 1) {
      if (link5.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link5.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link5.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      [link5.Hash, index2] = decodeBytes2(bytes2, index2);
    } else if (fieldNum === 2) {
      if (link5.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link5.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index2] = decodeBytes2(bytes2, index2);
      link5.Name = textDecoder5.decode(byts);
    } else if (fieldNum === 3) {
      if (link5.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      [link5.Tsize, index2] = decodeVarint3(bytes2, index2);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index2 > l) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link5;
}
function decodeNode2(bytes2) {
  const l = bytes2.length;
  let index2 = 0;
  let links3 = void 0;
  let linksBeforeData = false;
  let data = void 0;
  while (index2 < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index2] = decodeKey2(bytes2, index2);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      [data, index2] = decodeBytes2(bytes2, index2);
      if (links3) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links3) {
        links3 = [];
      }
      let byts;
      [byts, index2] = decodeBytes2(bytes2, index2);
      links3.push(decodeLink2(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index2 > l) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links3 || [];
  return node;
}
var textDecoder5;
var init_pb_decode2 = __esm({
  "../../node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/pb-decode.js"() {
    textDecoder5 = new TextDecoder();
  }
});

// ../../node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/pb-encode.js
function encodeLink2(link5, bytes2) {
  let i = bytes2.length;
  if (typeof link5.Tsize === "number") {
    if (link5.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link5.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i = encodeVarint2(bytes2, i, link5.Tsize) - 1;
    bytes2[i] = 24;
  }
  if (typeof link5.Name === "string") {
    const nameBytes = textEncoder6.encode(link5.Name);
    i -= nameBytes.length;
    bytes2.set(nameBytes, i);
    i = encodeVarint2(bytes2, i, nameBytes.length) - 1;
    bytes2[i] = 18;
  }
  if (link5.Hash) {
    i -= link5.Hash.length;
    bytes2.set(link5.Hash, i);
    i = encodeVarint2(bytes2, i, link5.Hash.length) - 1;
    bytes2[i] = 10;
  }
  return bytes2.length - i;
}
function encodeNode2(node) {
  const size5 = sizeNode2(node);
  const bytes2 = new Uint8Array(size5);
  let i = size5;
  if (node.Data) {
    i -= node.Data.length;
    bytes2.set(node.Data, i);
    i = encodeVarint2(bytes2, i, node.Data.length) - 1;
    bytes2[i] = 10;
  }
  if (node.Links) {
    for (let index2 = node.Links.length - 1; index2 >= 0; index2--) {
      const size6 = encodeLink2(node.Links[index2], bytes2.subarray(0, i));
      i -= size6;
      i = encodeVarint2(bytes2, i, size6) - 1;
      bytes2[i] = 18;
    }
  }
  return bytes2;
}
function sizeLink2(link5) {
  let n = 0;
  if (link5.Hash) {
    const l = link5.Hash.length;
    n += 1 + l + sov2(l);
  }
  if (typeof link5.Name === "string") {
    const l = textEncoder6.encode(link5.Name).length;
    n += 1 + l + sov2(l);
  }
  if (typeof link5.Tsize === "number") {
    n += 1 + sov2(link5.Tsize);
  }
  return n;
}
function sizeNode2(node) {
  let n = 0;
  if (node.Data) {
    const l = node.Data.length;
    n += 1 + l + sov2(l);
  }
  if (node.Links) {
    for (const link5 of node.Links) {
      const l = sizeLink2(link5);
      n += 1 + l + sov2(l);
    }
  }
  return n;
}
function encodeVarint2(bytes2, offset2, v) {
  offset2 -= sov2(v);
  const base6 = offset2;
  while (v >= maxUInt322) {
    bytes2[offset2++] = v & 127 | 128;
    v /= 128;
  }
  while (v >= 128) {
    bytes2[offset2++] = v & 127 | 128;
    v >>>= 7;
  }
  bytes2[offset2] = v;
  return base6;
}
function sov2(x) {
  if (x % 2 === 0) {
    x++;
  }
  return Math.floor((len642(x) + 6) / 7);
}
function len642(x) {
  let n = 0;
  if (x >= maxInt322) {
    x = Math.floor(x / maxInt322);
    n = 32;
  }
  if (x >= 1 << 16) {
    x >>>= 16;
    n += 16;
  }
  if (x >= 1 << 8) {
    x >>>= 8;
    n += 8;
  }
  return n + len8tab2[x];
}
var textEncoder6, maxInt322, maxUInt322, len8tab2;
var init_pb_encode2 = __esm({
  "../../node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/pb-encode.js"() {
    textEncoder6 = new TextEncoder();
    maxInt322 = 2 ** 32;
    maxUInt322 = 2 ** 31;
    len8tab2 = [
      0,
      1,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ];
  }
});

// ../../node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/util.js
function linkComparator2(a, b) {
  if (a === b) {
    return 0;
  }
  const abuf = a.Name ? textEncoder7.encode(a.Name) : [];
  const bbuf = b.Name ? textEncoder7.encode(b.Name) : [];
  let x = abuf.length;
  let y = bbuf.length;
  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (abuf[i] !== bbuf[i]) {
      x = abuf[i];
      y = bbuf[i];
      break;
    }
  }
  return x < y ? -1 : y < x ? 1 : 0;
}
function hasOnlyProperties2(node, properties) {
  return !Object.keys(node).some((p) => !properties.includes(p));
}
function asLink2(link5) {
  if (typeof link5.asCID === "object") {
    const Hash = CID2.asCID(link5);
    if (!Hash) {
      throw new TypeError("Invalid DAG-PB form");
    }
    return { Hash };
  }
  if (typeof link5 !== "object" || Array.isArray(link5)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbl = {};
  if (link5.Hash) {
    let cid = CID2.asCID(link5.Hash);
    try {
      if (!cid) {
        if (typeof link5.Hash === "string") {
          cid = CID2.parse(link5.Hash);
        } else if (link5.Hash instanceof Uint8Array) {
          cid = CID2.decode(link5.Hash);
        }
      }
    } catch (e) {
      throw new TypeError(`Invalid DAG-PB form: ${e.message}`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (typeof link5.Name === "string") {
    pbl.Name = link5.Name;
  }
  if (typeof link5.Tsize === "number") {
    pbl.Tsize = link5.Tsize;
  }
  return pbl;
}
function prepare3(node) {
  if (node instanceof Uint8Array || typeof node === "string") {
    node = { Data: node };
  }
  if (typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbn = {};
  if (node.Data !== void 0) {
    if (typeof node.Data === "string") {
      pbn.Data = textEncoder7.encode(node.Data);
    } else if (node.Data instanceof Uint8Array) {
      pbn.Data = node.Data;
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  }
  if (node.Links !== void 0) {
    if (Array.isArray(node.Links)) {
      pbn.Links = node.Links.map(asLink2);
      pbn.Links.sort(linkComparator2);
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate2(node) {
  if (!node || typeof node !== "object" || Array.isArray(node) || node instanceof Uint8Array || node["/"] && node["/"] === node.bytes) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties2(node, pbNodeProperties2)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be bytes)");
  }
  if (!Array.isArray(node.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be a list)");
  }
  for (let i = 0; i < node.Links.length; i++) {
    const link5 = node.Links[i];
    if (!link5 || typeof link5 !== "object" || Array.isArray(link5) || link5 instanceof Uint8Array || link5["/"] && link5["/"] === link5.bytes) {
      throw new TypeError("Invalid DAG-PB form (bad link)");
    }
    if (!hasOnlyProperties2(link5, pbLinkProperties2)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link)");
    }
    if (link5.Hash === void 0) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link5.Hash == null || !link5.Hash["/"] || link5.Hash["/"] !== link5.Hash.bytes) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link5.Name !== void 0 && typeof link5.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link5.Tsize !== void 0) {
      if (typeof link5.Tsize !== "number" || link5.Tsize % 1 !== 0) {
        throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
      }
      if (link5.Tsize < 0) {
        throw new TypeError("Invalid DAG-PB form (link Tsize cannot be negative)");
      }
    }
    if (i > 0 && linkComparator2(link5, node.Links[i - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
function toByteView3(buf3) {
  if (buf3 instanceof ArrayBuffer) {
    return new Uint8Array(buf3, 0, buf3.byteLength);
  }
  return buf3;
}
var pbNodeProperties2, pbLinkProperties2, textEncoder7;
var init_util3 = __esm({
  "../../node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/util.js"() {
    init_cid2();
    pbNodeProperties2 = ["Data", "Links"];
    pbLinkProperties2 = ["Hash", "Name", "Tsize"];
    textEncoder7 = new TextEncoder();
  }
});

// ../../node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/index.js
function encode39(node) {
  validate2(node);
  const pbn = {};
  if (node.Links) {
    pbn.Links = node.Links.map((l) => {
      const link5 = {};
      if (l.Hash) {
        link5.Hash = l.Hash.bytes;
      }
      if (l.Name !== void 0) {
        link5.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link5.Tsize = l.Tsize;
      }
      return link5;
    });
  }
  if (node.Data) {
    pbn.Data = node.Data;
  }
  return encodeNode2(pbn);
}
function decode49(bytes2) {
  const buf3 = toByteView3(bytes2);
  const pbn = decodeNode2(buf3);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l) => {
      const link5 = {};
      try {
        link5.Hash = CID2.decode(l.Hash);
      } catch (e) {
      }
      if (!link5.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l.Name !== void 0) {
        link5.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link5.Tsize = l.Tsize;
      }
      return link5;
    });
  }
  return node;
}
var code21;
var init_src10 = __esm({
  "../../node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/index.js"() {
    init_cid2();
    init_pb_decode2();
    init_pb_encode2();
    init_util3();
    code21 = 112;
  }
});

// ../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/util/longbits.js
var require_longbits2 = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal3();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign2 = value < 0;
      if (sign2)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign2) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from21(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask2 = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask2) >>> 0;
      this.lo = (this.lo << 1 ^ mask2) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask2 = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask2) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask2) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length5() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/util/minimal.js
var require_minimal3 = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base642();
    util.EventEmitter = require_eventemitter();
    util.float = require_float2();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits2();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer5 = util.inquire("buffer").Buffer;
        return Buffer5.prototype.utf8Write ? Buffer5 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge3(dst, src5, ifNotSet) {
      for (var keys2 = Object.keys(src5), i = 0; i < keys2.length; ++i)
        if (dst[keys2[i]] === void 0 || !ifNotSet)
          dst[keys2[i]] = src5[keys2[i]];
      return dst;
    }
    util.merge = merge3;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name20) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge3(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get15() {
            return name20;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys2 = Object.keys(this), i2 = keys2.length - 1; i2 > -1; --i2)
          if (fieldMap[keys2[i2]] === 1 && this[keys2[i2]] !== void 0 && this[keys2[i2]] !== null)
            return keys2[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name20) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name20)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer5 = util.Buffer;
      if (!Buffer5) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer5.from !== Uint8Array.from && Buffer5.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer5(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer5.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size5) {
        return new Buffer5(size5);
      };
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/writer.js
var require_writer2 = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer2;
    var util = require_minimal3();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base644 = util.base64;
    var utf84 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop2() {
    }
    function State2(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer2() {
      this.len = 0;
      this.head = new Op(noop2, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create21 = function create22() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer2.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer2();
      };
    };
    Writer2.create = create21();
    Writer2.alloc = function alloc4(size5) {
      return new util.Array(size5);
    };
    if (util.Array !== Array)
      Writer2.alloc = util.pool(Writer2.alloc, util.Array.prototype.subarray);
    Writer2.prototype._push = function push2(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf3, pos) {
      buf3[pos] = val & 255;
    }
    function writeVarint32(val, buf3, pos) {
      while (val > 127) {
        buf3[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf3[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer2.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer2.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer2.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf3, pos) {
      while (val.hi) {
        buf3[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf3[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf3[pos++] = val.lo;
    }
    Writer2.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer2.prototype.int64 = Writer2.prototype.uint64;
    Writer2.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer2.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf3, pos) {
      buf3[pos] = val & 255;
      buf3[pos + 1] = val >>> 8 & 255;
      buf3[pos + 2] = val >>> 16 & 255;
      buf3[pos + 3] = val >>> 24;
    }
    Writer2.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer2.prototype.sfixed32 = Writer2.prototype.fixed32;
    Writer2.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer2.prototype.sfixed64 = Writer2.prototype.fixed64;
    Writer2.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer2.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes2 = util.Array.prototype.set ? function writeBytes_set(val, buf3, pos) {
      buf3.set(val, pos);
    } : function writeBytes_for(val, buf3, pos) {
      for (var i = 0; i < val.length; ++i)
        buf3[pos + i] = val[i];
    };
    Writer2.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf3 = Writer2.alloc(len = base644.length(value));
        base644.decode(value, buf3, 0);
        value = buf3;
      }
      return this.uint32(len)._push(writeBytes2, len, value);
    };
    Writer2.prototype.string = function write_string(value) {
      var len = utf84.length(value);
      return len ? this.uint32(len)._push(utf84.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer2.prototype.fork = function fork5() {
      this.states = new State2(this);
      this.head = this.tail = new Op(noop2, 0, 0);
      this.len = 0;
      return this;
    };
    Writer2.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop2, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer2.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer2.prototype.finish = function finish() {
      var head = this.head.next, buf3 = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf3, pos);
        pos += head.len;
        head = head.next;
      }
      return buf3;
    };
    Writer2._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer2.create = create21();
      BufferWriter._configure();
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer2 = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer2 = require_writer2();
    (BufferWriter.prototype = Object.create(Writer2.prototype)).constructor = BufferWriter;
    var util = require_minimal3();
    function BufferWriter() {
      Writer2.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf3, pos) {
        buf3.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf3, pos) {
        if (val.copy)
          val.copy(buf3, pos, 0, val.length);
        else for (var i = 0; i < val.length; )
          buf3[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf3, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf3, pos);
      else if (buf3.utf8Write)
        buf3.utf8Write(val, pos);
      else
        buf3.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// ../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/reader.js
var require_reader2 = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal3();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf84 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer3) {
      this.buf = buffer3;
      this.pos = 0;
      this.len = buffer3.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer3) {
      if (buffer3 instanceof Uint8Array || Array.isArray(buffer3))
        return new Reader(buffer3);
      throw Error("illegal buffer");
    } : function create_array2(buffer3) {
      if (Array.isArray(buffer3))
        return new Reader(buffer3);
      throw Error("illegal buffer");
    };
    var create21 = function create22() {
      return util.Buffer ? function create_buffer_setup(buffer3) {
        return (Reader.create = function create_buffer(buffer4) {
          return util.Buffer.isBuffer(buffer4) ? new BufferReader(buffer4) : create_array(buffer4);
        })(buffer3);
      } : create_array;
    };
    Reader.create = create21();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf3, end) {
      return (buf3[end - 4] | buf3[end - 3] << 8 | buf3[end - 2] << 16 | buf3[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length5 = this.uint32(), start = this.pos, end = this.pos + length5;
      if (end > this.len)
        throw indexOutOfRange(this, length5);
      this.pos += length5;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      if (start === end) {
        var nativeBuffer = util.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
      }
      return this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes2 = this.bytes();
      return utf84.read(bytes2, 0, bytes2.length);
    };
    Reader.prototype.skip = function skip2(length5) {
      if (typeof length5 === "number") {
        if (this.pos + length5 > this.len)
          throw indexOutOfRange(this, length5);
        this.pos += length5;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create21();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer2 = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader2();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal3();
    function BufferReader(buffer3) {
      Reader.call(this, buffer3);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// ../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/rpc/service.js
var require_service2 = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal3();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/rpc.js
var require_rpc2 = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service2();
  }
});

// ../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/roots.js
var require_roots2 = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// ../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/index-minimal.js
var require_index_minimal2 = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer2();
    protobuf.BufferWriter = require_writer_buffer2();
    protobuf.Reader = require_reader2();
    protobuf.BufferReader = require_reader_buffer2();
    protobuf.util = require_minimal3();
    protobuf.rpc = require_rpc2();
    protobuf.roots = require_roots2();
    protobuf.configure = configure7;
    function configure7() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure7();
  }
});

// ../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/minimal.js
var require_minimal4 = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal2();
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/gen/unixfs.js
var import_minimal2, $Reader2, $Writer2, $util2, $root2, Data2, UnixTime2, Metadata2;
var init_unixfs2 = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/gen/unixfs.js"() {
    import_minimal2 = __toESM(require_minimal4(), 1);
    $Reader2 = import_minimal2.default.Reader;
    $Writer2 = import_minimal2.default.Writer;
    $util2 = import_minimal2.default.util;
    $root2 = import_minimal2.default.roots.unixfs || (import_minimal2.default.roots.unixfs = {});
    Data2 = $root2.Data = (() => {
      function Data3(p) {
        this.blocksizes = [];
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Data3.prototype.Type = 0;
      Data3.prototype.Data = $util2.newBuffer([]);
      Data3.prototype.filesize = $util2.Long ? $util2.Long.fromBits(0, 0, true) : 0;
      Data3.prototype.blocksizes = $util2.emptyArray;
      Data3.prototype.hashType = $util2.Long ? $util2.Long.fromBits(0, 0, true) : 0;
      Data3.prototype.fanout = $util2.Long ? $util2.Long.fromBits(0, 0, true) : 0;
      Data3.prototype.mode = 0;
      Data3.prototype.mtime = null;
      Data3.encode = function encode45(m, w) {
        if (!w)
          w = $Writer2.create();
        w.uint32(8).int32(m.Type);
        if (m.Data != null && Object.hasOwnProperty.call(m, "Data"))
          w.uint32(18).bytes(m.Data);
        if (m.filesize != null && Object.hasOwnProperty.call(m, "filesize"))
          w.uint32(24).uint64(m.filesize);
        if (m.blocksizes != null && m.blocksizes.length) {
          for (var i = 0; i < m.blocksizes.length; ++i)
            w.uint32(32).uint64(m.blocksizes[i]);
        }
        if (m.hashType != null && Object.hasOwnProperty.call(m, "hashType"))
          w.uint32(40).uint64(m.hashType);
        if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
          w.uint32(48).uint64(m.fanout);
        if (m.mode != null && Object.hasOwnProperty.call(m, "mode"))
          w.uint32(56).uint32(m.mode);
        if (m.mtime != null && Object.hasOwnProperty.call(m, "mtime"))
          $root2.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
        return w;
      };
      Data3.decode = function decode53(r, l) {
        if (!(r instanceof $Reader2))
          r = $Reader2.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root2.Data();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.Type = r.int32();
              break;
            case 2:
              m.Data = r.bytes();
              break;
            case 3:
              m.filesize = r.uint64();
              break;
            case 4:
              if (!(m.blocksizes && m.blocksizes.length))
                m.blocksizes = [];
              if ((t & 7) === 2) {
                var c2 = r.uint32() + r.pos;
                while (r.pos < c2)
                  m.blocksizes.push(r.uint64());
              } else
                m.blocksizes.push(r.uint64());
              break;
            case 5:
              m.hashType = r.uint64();
              break;
            case 6:
              m.fanout = r.uint64();
              break;
            case 7:
              m.mode = r.uint32();
              break;
            case 8:
              m.mtime = $root2.UnixTime.decode(r, r.uint32());
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        if (!m.hasOwnProperty("Type"))
          throw $util2.ProtocolError("missing required 'Type'", { instance: m });
        return m;
      };
      Data3.fromObject = function fromObject(d) {
        if (d instanceof $root2.Data)
          return d;
        var m = new $root2.Data();
        switch (d.Type) {
          case "Raw":
          case 0:
            m.Type = 0;
            break;
          case "Directory":
          case 1:
            m.Type = 1;
            break;
          case "File":
          case 2:
            m.Type = 2;
            break;
          case "Metadata":
          case 3:
            m.Type = 3;
            break;
          case "Symlink":
          case 4:
            m.Type = 4;
            break;
          case "HAMTShard":
          case 5:
            m.Type = 5;
            break;
        }
        if (d.Data != null) {
          if (typeof d.Data === "string")
            $util2.base64.decode(d.Data, m.Data = $util2.newBuffer($util2.base64.length(d.Data)), 0);
          else if (d.Data.length)
            m.Data = d.Data;
        }
        if (d.filesize != null) {
          if ($util2.Long)
            (m.filesize = $util2.Long.fromValue(d.filesize)).unsigned = true;
          else if (typeof d.filesize === "string")
            m.filesize = parseInt(d.filesize, 10);
          else if (typeof d.filesize === "number")
            m.filesize = d.filesize;
          else if (typeof d.filesize === "object")
            m.filesize = new $util2.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
        }
        if (d.blocksizes) {
          if (!Array.isArray(d.blocksizes))
            throw TypeError(".Data.blocksizes: array expected");
          m.blocksizes = [];
          for (var i = 0; i < d.blocksizes.length; ++i) {
            if ($util2.Long)
              (m.blocksizes[i] = $util2.Long.fromValue(d.blocksizes[i])).unsigned = true;
            else if (typeof d.blocksizes[i] === "string")
              m.blocksizes[i] = parseInt(d.blocksizes[i], 10);
            else if (typeof d.blocksizes[i] === "number")
              m.blocksizes[i] = d.blocksizes[i];
            else if (typeof d.blocksizes[i] === "object")
              m.blocksizes[i] = new $util2.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);
          }
        }
        if (d.hashType != null) {
          if ($util2.Long)
            (m.hashType = $util2.Long.fromValue(d.hashType)).unsigned = true;
          else if (typeof d.hashType === "string")
            m.hashType = parseInt(d.hashType, 10);
          else if (typeof d.hashType === "number")
            m.hashType = d.hashType;
          else if (typeof d.hashType === "object")
            m.hashType = new $util2.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
        }
        if (d.fanout != null) {
          if ($util2.Long)
            (m.fanout = $util2.Long.fromValue(d.fanout)).unsigned = true;
          else if (typeof d.fanout === "string")
            m.fanout = parseInt(d.fanout, 10);
          else if (typeof d.fanout === "number")
            m.fanout = d.fanout;
          else if (typeof d.fanout === "object")
            m.fanout = new $util2.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
        }
        if (d.mode != null) {
          m.mode = d.mode >>> 0;
        }
        if (d.mtime != null) {
          if (typeof d.mtime !== "object")
            throw TypeError(".Data.mtime: object expected");
          m.mtime = $root2.UnixTime.fromObject(d.mtime);
        }
        return m;
      };
      Data3.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.arrays || o.defaults) {
          d.blocksizes = [];
        }
        if (o.defaults) {
          d.Type = o.enums === String ? "Raw" : 0;
          if (o.bytes === String)
            d.Data = "";
          else {
            d.Data = [];
            if (o.bytes !== Array)
              d.Data = $util2.newBuffer(d.Data);
          }
          if ($util2.Long) {
            var n = new $util2.Long(0, 0, true);
            d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.filesize = o.longs === String ? "0" : 0;
          if ($util2.Long) {
            var n = new $util2.Long(0, 0, true);
            d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.hashType = o.longs === String ? "0" : 0;
          if ($util2.Long) {
            var n = new $util2.Long(0, 0, true);
            d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.fanout = o.longs === String ? "0" : 0;
          d.mode = 0;
          d.mtime = null;
        }
        if (m.Type != null && m.hasOwnProperty("Type")) {
          d.Type = o.enums === String ? $root2.Data.DataType[m.Type] : m.Type;
        }
        if (m.Data != null && m.hasOwnProperty("Data")) {
          d.Data = o.bytes === String ? $util2.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
        }
        if (m.filesize != null && m.hasOwnProperty("filesize")) {
          if (typeof m.filesize === "number")
            d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
          else
            d.filesize = o.longs === String ? $util2.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util2.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
        }
        if (m.blocksizes && m.blocksizes.length) {
          d.blocksizes = [];
          for (var j = 0; j < m.blocksizes.length; ++j) {
            if (typeof m.blocksizes[j] === "number")
              d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
            else
              d.blocksizes[j] = o.longs === String ? $util2.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util2.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
          }
        }
        if (m.hashType != null && m.hasOwnProperty("hashType")) {
          if (typeof m.hashType === "number")
            d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
          else
            d.hashType = o.longs === String ? $util2.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util2.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
        }
        if (m.fanout != null && m.hasOwnProperty("fanout")) {
          if (typeof m.fanout === "number")
            d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
          else
            d.fanout = o.longs === String ? $util2.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util2.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
        }
        if (m.mode != null && m.hasOwnProperty("mode")) {
          d.mode = m.mode;
        }
        if (m.mtime != null && m.hasOwnProperty("mtime")) {
          d.mtime = $root2.UnixTime.toObject(m.mtime, o);
        }
        return d;
      };
      Data3.prototype.toJSON = function toJSON6() {
        return this.constructor.toObject(this, import_minimal2.default.util.toJSONOptions);
      };
      Data3.DataType = function() {
        const valuesById = {}, values2 = Object.create(valuesById);
        values2[valuesById[0] = "Raw"] = 0;
        values2[valuesById[1] = "Directory"] = 1;
        values2[valuesById[2] = "File"] = 2;
        values2[valuesById[3] = "Metadata"] = 3;
        values2[valuesById[4] = "Symlink"] = 4;
        values2[valuesById[5] = "HAMTShard"] = 5;
        return values2;
      }();
      return Data3;
    })();
    UnixTime2 = $root2.UnixTime = (() => {
      function UnixTime3(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      UnixTime3.prototype.Seconds = $util2.Long ? $util2.Long.fromBits(0, 0, false) : 0;
      UnixTime3.prototype.FractionalNanoseconds = 0;
      UnixTime3.encode = function encode45(m, w) {
        if (!w)
          w = $Writer2.create();
        w.uint32(8).int64(m.Seconds);
        if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, "FractionalNanoseconds"))
          w.uint32(21).fixed32(m.FractionalNanoseconds);
        return w;
      };
      UnixTime3.decode = function decode53(r, l) {
        if (!(r instanceof $Reader2))
          r = $Reader2.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root2.UnixTime();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.Seconds = r.int64();
              break;
            case 2:
              m.FractionalNanoseconds = r.fixed32();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        if (!m.hasOwnProperty("Seconds"))
          throw $util2.ProtocolError("missing required 'Seconds'", { instance: m });
        return m;
      };
      UnixTime3.fromObject = function fromObject(d) {
        if (d instanceof $root2.UnixTime)
          return d;
        var m = new $root2.UnixTime();
        if (d.Seconds != null) {
          if ($util2.Long)
            (m.Seconds = $util2.Long.fromValue(d.Seconds)).unsigned = false;
          else if (typeof d.Seconds === "string")
            m.Seconds = parseInt(d.Seconds, 10);
          else if (typeof d.Seconds === "number")
            m.Seconds = d.Seconds;
          else if (typeof d.Seconds === "object")
            m.Seconds = new $util2.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
        }
        if (d.FractionalNanoseconds != null) {
          m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
        }
        return m;
      };
      UnixTime3.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if ($util2.Long) {
            var n = new $util2.Long(0, 0, false);
            d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.Seconds = o.longs === String ? "0" : 0;
          d.FractionalNanoseconds = 0;
        }
        if (m.Seconds != null && m.hasOwnProperty("Seconds")) {
          if (typeof m.Seconds === "number")
            d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
          else
            d.Seconds = o.longs === String ? $util2.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util2.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
        }
        if (m.FractionalNanoseconds != null && m.hasOwnProperty("FractionalNanoseconds")) {
          d.FractionalNanoseconds = m.FractionalNanoseconds;
        }
        return d;
      };
      UnixTime3.prototype.toJSON = function toJSON6() {
        return this.constructor.toObject(this, import_minimal2.default.util.toJSONOptions);
      };
      return UnixTime3;
    })();
    Metadata2 = $root2.Metadata = (() => {
      function Metadata3(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Metadata3.prototype.MimeType = "";
      Metadata3.encode = function encode45(m, w) {
        if (!w)
          w = $Writer2.create();
        if (m.MimeType != null && Object.hasOwnProperty.call(m, "MimeType"))
          w.uint32(10).string(m.MimeType);
        return w;
      };
      Metadata3.decode = function decode53(r, l) {
        if (!(r instanceof $Reader2))
          r = $Reader2.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root2.Metadata();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.MimeType = r.string();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Metadata3.fromObject = function fromObject(d) {
        if (d instanceof $root2.Metadata)
          return d;
        var m = new $root2.Metadata();
        if (d.MimeType != null) {
          m.MimeType = String(d.MimeType);
        }
        return m;
      };
      Metadata3.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.MimeType = "";
        }
        if (m.MimeType != null && m.hasOwnProperty("MimeType")) {
          d.MimeType = m.MimeType;
        }
        return d;
      };
      Metadata3.prototype.toJSON = function toJSON6() {
        return this.constructor.toObject(this, import_minimal2.default.util.toJSONOptions);
      };
      return Metadata3;
    })();
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/unixfs.js
var NodeType;
var init_unixfs3 = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/unixfs.js"() {
    init_unixfs2();
    NodeType = Data2.DataType;
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/codec.js
var codec_exports2 = {};
__export(codec_exports2, {
  DEFAULT_DIRECTORY_MODE: () => DEFAULT_DIRECTORY_MODE2,
  DEFAULT_FILE_MODE: () => DEFAULT_FILE_MODE2,
  NodeType: () => NodeType,
  code: () => code22,
  createAdvancedFile: () => createAdvancedFile,
  createComplexFile: () => createComplexFile,
  createDirectoryShard: () => createDirectoryShard,
  createEmptyFile: () => createEmptyFile,
  createFileChunk: () => createFileChunk,
  createFileShard: () => createFileShard,
  createFlatDirectory: () => createFlatDirectory,
  createRaw: () => createRaw,
  createShardedDirectory: () => createShardedDirectory,
  createSimpleFile: () => createSimpleFile,
  createSymlink: () => createSymlink,
  cumulativeContentByteLength: () => cumulativeContentByteLength,
  cumulativeDagByteLength: () => cumulativeDagByteLength,
  decode: () => decode50,
  decodeMetadata: () => decodeMetadata,
  encode: () => encode40,
  encodeAdvancedFile: () => encodeAdvancedFile,
  encodeComplexFile: () => encodeComplexFile,
  encodeDirectory: () => encodeDirectory,
  encodeDirectoryMetadata: () => encodeDirectoryMetadata,
  encodeFile: () => encodeFile,
  encodeFileChunk: () => encodeFileChunk,
  encodeFileShard: () => encodeFileShard,
  encodeHAMTShard: () => encodeHAMTShard,
  encodeLink: () => encodeLink3,
  encodeMetadata: () => encodeMetadata,
  encodeMode: () => encodeMode,
  encodeRaw: () => encodeRaw,
  encodeSimpleFile: () => encodeSimpleFile,
  encodeSymlink: () => encodeSymlink,
  filesize: () => filesize,
  matchFile: () => matchFile,
  name: () => name17
});
var EMPTY2, EMPTY_BUFFER, BLANK, DEFAULT_FILE_MODE2, DEFAULT_DIRECTORY_MODE2, code22, name17, encodePB, createRaw, createEmptyFile, createSimpleFile, createFileChunk, createAdvancedFile, createFileShard, createComplexFile, createFlatDirectory, createShardedDirectory, createDirectoryShard, encodeRaw, encodeFile, encodeFileChunk, encodeFileShard, encodeAdvancedFile, encodeLink3, encodeSimpleFile, encodeComplexFile, encodeDirectory, encodeHAMTShard, readFanout, readInt3, createSymlink, encodeSymlink, encode40, decode50, decodeMtime, decodeFileLinks, decodeDirectoryLinks, cumulativeContentByteLength, cumulativeDagByteLength, contentByteLength, encodeNamedLink, encodeDirectoryMetadata, encodeMetadata, decodeMetadata, encodeMTime, encodeMode, decodeMode, matchFile, SimpleFileView, AdvancedFileView, ComplexFileView, filesize;
var init_codec2 = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/codec.js"() {
    init_src10();
    init_unixfs3();
    init_unixfs3();
    init_unixfs2();
    init_unixfs3();
    EMPTY2 = Object.freeze([]);
    EMPTY_BUFFER = new Uint8Array(0);
    BLANK = Object.freeze({});
    DEFAULT_FILE_MODE2 = parseInt("0644", 8);
    DEFAULT_DIRECTORY_MODE2 = parseInt("0755", 8);
    code22 = code21;
    name17 = "UnixFS";
    encodePB = (data, links3) => {
      Object(globalThis).debug && console.log({ data, links: links3 });
      return encode39(
        // We run through prepare as links need to be sorted by name which it will
        // do.
        prepare3({
          Data: Data2.encode(data).finish(),
          // We can cast to mutable array as we know no mutation occurs there
          Links: (
            /** @type {PB.PBLink[]} */
            links3
          )
        })
      );
    };
    createRaw = (content2) => ({
      type: NodeType.Raw,
      content: content2
    });
    createEmptyFile = (metadata) => createSimpleFile(EMPTY_BUFFER, metadata);
    createSimpleFile = (content2, metadata) => ({
      type: NodeType.File,
      layout: "simple",
      content: content2,
      metadata: decodeMetadata(metadata)
    });
    createFileChunk = (content2) => ({
      type: NodeType.File,
      layout: "simple",
      content: content2
    });
    createAdvancedFile = (parts, metadata) => ({
      type: NodeType.File,
      layout: "advanced",
      parts,
      metadata: decodeMetadata(metadata)
    });
    createFileShard = (parts) => ({
      type: NodeType.File,
      layout: "advanced",
      parts
    });
    createComplexFile = (content2, parts, metadata) => ({
      type: NodeType.File,
      layout: "complex",
      content: content2,
      parts,
      metadata: decodeMetadata(metadata)
    });
    createFlatDirectory = (entries3, metadata) => ({
      type: NodeType.Directory,
      metadata: decodeMetadata(metadata),
      entries: entries3
    });
    createShardedDirectory = (entries3, bitfield, fanout, hashType, metadata = BLANK) => ({
      type: NodeType.HAMTShard,
      bitfield,
      fanout: readFanout(fanout),
      hashType: readInt3(hashType),
      entries: entries3,
      metadata: decodeMetadata(metadata)
    });
    createDirectoryShard = (entries3, bitfield, fanout, hashType) => ({
      type: NodeType.HAMTShard,
      bitfield,
      fanout: readFanout(fanout),
      hashType: readInt3(hashType),
      entries: entries3
    });
    encodeRaw = (content2) => encodePB(
      {
        Type: NodeType.Raw,
        // TODO:
        Data: content2.byteLength > 0 ? content2 : void 0,
        filesize: content2.byteLength,
        // @ts-ignore
        blocksizes: EMPTY2
      },
      []
    );
    encodeFile = (node, ignoreMetadata = false) => {
      const metadata = ignoreMetadata ? BLANK : Object(node).metadata;
      switch (node.layout) {
        case "simple":
          return encodeSimpleFile(node.content, metadata);
        case "advanced":
          return encodeAdvancedFile(node.parts, metadata);
        case "complex":
          return encodeComplexFile(node.content, node.parts, metadata);
        default:
          throw new TypeError(
            `File with unknown layout "${Object(node).layout}" was passed`
          );
      }
    };
    encodeFileChunk = (content2) => encodeSimpleFile(content2, BLANK);
    encodeFileShard = (parts) => encodePB(
      {
        Type: NodeType.File,
        blocksizes: parts.map(contentByteLength),
        filesize: cumulativeContentByteLength(parts)
      },
      parts.map(encodeLink3)
    );
    encodeAdvancedFile = (parts, metadata = BLANK) => encodePB(
      {
        Type: NodeType.File,
        blocksizes: parts.map(contentByteLength),
        filesize: cumulativeContentByteLength(parts),
        ...encodeMetadata(metadata)
      },
      parts.map(encodeLink3)
    );
    encodeLink3 = (dag) => ({
      Name: "",
      Tsize: dag.dagByteLength,
      // @ts-ignore - @see https://github.com/multiformats/js-multiformats/pull/161
      Hash: dag.cid
    });
    encodeSimpleFile = (content2, metadata = BLANK) => encodePB(
      {
        Type: NodeType.File,
        // adding empty file to both go-ipfs and js-ipfs produces block in
        // which `Data` is omitted but filesize and blocksizes are present.
        // For the sake of hash consistency we do the same.
        Data: content2.byteLength > 0 ? content2 : void 0,
        filesize: content2.byteLength,
        blocksizes: [],
        ...encodeMetadata(metadata)
      },
      []
    );
    encodeComplexFile = (content2, parts, metadata = BLANK) => encodePB(
      {
        Type: NodeType.File,
        Data: content2,
        filesize: content2.byteLength + cumulativeContentByteLength(parts),
        blocksizes: parts.map(contentByteLength)
      },
      parts.map(encodeLink3)
    );
    encodeDirectory = (node) => encodePB(
      {
        Type: node.type,
        ...encodeDirectoryMetadata(node.metadata || BLANK)
      },
      node.entries.map(encodeNamedLink)
    );
    encodeHAMTShard = ({
      bitfield,
      fanout,
      hashType,
      entries: entries3,
      metadata = BLANK
    }) => encodePB(
      {
        Type: NodeType.HAMTShard,
        Data: bitfield.byteLength > 0 ? bitfield : void 0,
        fanout: readFanout(fanout),
        hashType: readInt3(hashType),
        ...encodeDirectoryMetadata(metadata)
      },
      entries3.map(encodeNamedLink)
    );
    readFanout = (n) => {
      if (Math.log2(n) % 1 === 0) {
        return n;
      } else {
        throw new TypeError(
          `Expected hamt size to be a power of two instead got ${n}`
        );
      }
    };
    readInt3 = (n) => {
      if (Number.isInteger(n)) {
        return n;
      } else {
        throw new TypeError(`Expected an integer value instead got ${n}`);
      }
    };
    createSymlink = (path, metadata = BLANK) => ({
      type: NodeType.Symlink,
      content: path,
      metadata: decodeMetadata(metadata)
    });
    encodeSymlink = (node, ignoreMetadata = false) => {
      const metadata = ignoreMetadata ? BLANK : Object(node).metadata;
      return encodePB(
        {
          Type: NodeType.Symlink,
          Data: node.content,
          ...encodeMetadata(metadata || BLANK)
        },
        []
      );
    };
    encode40 = (node, root2 = true) => {
      switch (node.type) {
        case NodeType.Raw:
          return encodeRaw(node.content);
        case NodeType.File:
          return encodeFile(node);
        case NodeType.Directory:
          return encodeDirectory(node);
        case NodeType.HAMTShard:
          return encodeHAMTShard(node);
        case NodeType.Symlink:
          return encodeSymlink(node);
        default:
          throw new Error(`Unknown node type ${Object(node).type}`);
      }
    };
    decode50 = (bytes2) => {
      const pb = decode49(bytes2);
      const message = Data2.decode(
        /** @type {Uint8Array} */
        pb.Data
      );
      const {
        Type: type2,
        Data: data,
        mtime,
        mode,
        blocksizes,
        ...rest
      } = Data2.toObject(message, {
        defaults: false,
        arrays: true,
        longs: Number,
        objects: false
      });
      const metadata = {
        ...mode && { mode },
        ...decodeMtime(mtime)
      };
      const links3 = pb.Links;
      switch (message.Type) {
        case NodeType.Raw:
          return createRaw(data);
        case NodeType.File:
          if (links3.length === 0) {
            return new SimpleFileView(data, metadata);
          } else if (data.byteLength === 0) {
            return new AdvancedFileView(
              decodeFileLinks(rest.blocksizes, links3),
              metadata
            );
          } else {
            return new ComplexFileView(
              data,
              decodeFileLinks(rest.blocksizes, links3),
              metadata
            );
          }
        case NodeType.Directory:
          return createFlatDirectory(decodeDirectoryLinks(links3), metadata);
        case NodeType.HAMTShard:
          return createShardedDirectory(
            decodeDirectoryLinks(links3),
            data || EMPTY_BUFFER,
            rest.fanout,
            rest.hashType,
            metadata
          );
        case NodeType.Symlink:
          return createSymlink(data, metadata);
        default:
          throw new TypeError(`Unsupported node type ${message.Type}`);
      }
    };
    decodeMtime = (mtime) => mtime == null ? void 0 : {
      mtime: { secs: mtime.Seconds, nsecs: mtime.FractionalNanoseconds || 0 }
    };
    decodeFileLinks = (blocksizes, links3) => {
      const parts = [];
      const length5 = blocksizes.length;
      let n = 0;
      while (n < length5) {
        parts.push(
          /** @type {UnixFS.FileLink} */
          {
            cid: links3[n].Hash,
            dagByteLength: links3[n].Tsize || 0,
            contentByteLength: blocksizes[n]
          }
        );
      }
      return parts;
    };
    decodeDirectoryLinks = (links3) => links3.map(
      (link5) => (
        /** @type {UnixFS.DirectoryEntryLink} */
        {
          cid: link5.Hash,
          name: link5.Name || "",
          dagByteLength: link5.Tsize || 0
        }
      )
    );
    cumulativeContentByteLength = (links3) => links3.reduce((size5, link5) => size5 + link5.contentByteLength, 0);
    cumulativeDagByteLength = (root2, links3) => links3.reduce((size5, link5) => size5 + link5.dagByteLength, root2.byteLength);
    contentByteLength = (link5) => link5.contentByteLength;
    encodeNamedLink = ({ name: name20, dagByteLength, cid }) => ({
      Name: name20,
      Tsize: dagByteLength,
      Hash: cid
    });
    encodeDirectoryMetadata = (metadata) => encodeMetadata(metadata, DEFAULT_DIRECTORY_MODE2);
    encodeMetadata = ({ mode, mtime }, defaultMode = DEFAULT_FILE_MODE2) => ({
      mode: mode != null ? encodeMode(mode, defaultMode) : void 0,
      mtime: mtime != null ? encodeMTime(mtime) : void 0
    });
    decodeMetadata = (data) => data == null ? BLANK : {
      ...data.mode == null ? void 0 : { mode: decodeMode(data.mode) },
      ...data.mtime == null ? void 0 : { mtime: data.mtime }
    };
    encodeMTime = (mtime) => {
      return mtime == null ? void 0 : mtime.nsecs !== 0 ? { Seconds: mtime.secs, FractionalNanoseconds: mtime.nsecs } : { Seconds: mtime.secs };
    };
    encodeMode = (specifiedMode, defaultMode) => {
      const mode = specifiedMode == null ? void 0 : decodeMode(specifiedMode);
      return mode === defaultMode || mode == null ? void 0 : mode;
    };
    decodeMode = (mode) => mode & 4095 | mode & 4294963200;
    matchFile = ({
      content: content2 = EMPTY_BUFFER,
      parts = EMPTY2,
      metadata = BLANK,
      ...rest
    }) => {
      if (parts.length === 0) {
        return new SimpleFileView(content2, metadata);
      } else if (content2.byteLength === 0) {
        return new AdvancedFileView(parts, metadata);
      } else {
        return new ComplexFileView(content2, parts, metadata);
      }
    };
    SimpleFileView = class {
      /**
       * @param {Uint8Array} content
       * @param {UnixFS.Metadata} metadata
       */
      constructor(content2, metadata) {
        this.content = content2;
        this.metadata = metadata;
        this.layout = "simple";
        this.type = NodeType.File;
      }
      get filesize() {
        return this.content.byteLength;
      }
      encode() {
        return encodeSimpleFile(this.content, this.metadata);
      }
    };
    AdvancedFileView = class {
      /**
       * @param {ReadonlyArray<UnixFS.FileLink>} parts
       * @param {UnixFS.Metadata} metadata
       */
      constructor(parts, metadata) {
        this.parts = parts;
        this.metadata = metadata;
      }
      /** @type {"advanced"} */
      get layout() {
        return "advanced";
      }
      /**
       * @returns {NodeType.File}
       */
      get type() {
        return NodeType.File;
      }
      get fileSize() {
        return cumulativeContentByteLength(this.parts);
      }
      get blockSizes() {
        return this.parts.map(contentByteLength);
      }
      encode() {
        return encodeAdvancedFile(this.parts, this.metadata);
      }
    };
    ComplexFileView = class {
      /**
       * @param {Uint8Array} content
       * @param {ReadonlyArray<UnixFS.FileLink>} parts
       * @param {UnixFS.Metadata} metadata
       */
      constructor(content2, parts, metadata) {
        this.content = content2;
        this.parts = parts;
        this.metadata = metadata;
      }
      /** @type {"complex"} */
      get layout() {
        return "complex";
      }
      /**
       * @returns {NodeType.File}
       */
      get type() {
        return NodeType.File;
      }
      get fileSize() {
        return this.content.byteLength + cumulativeContentByteLength(this.parts);
      }
      get blockSizes() {
        return this.parts.map(contentByteLength);
      }
      encode() {
        return encodeComplexFile(this.content, this.parts, this.metadata);
      }
    };
    filesize = (node) => {
      switch (node.type) {
        case NodeType.Raw:
        case NodeType.Symlink:
          return node.content.byteLength;
        case NodeType.File:
          switch (node.layout) {
            case "simple":
              return node.content.byteLength;
            case "advanced":
              return cumulativeContentByteLength(node.parts);
            case "complex":
              return node.content.byteLength + cumulativeContentByteLength(node.parts);
          }
        default:
          return 0;
      }
    };
  }
});

// ../../node_modules/.pnpm/actor@2.3.1/node_modules/actor/src/task.js
var init_task = __esm({
  "../../node_modules/.pnpm/actor@2.3.1/node_modules/actor/src/task.js"() {
    init_lib9();
  }
});

// ../../node_modules/.pnpm/actor@2.3.1/node_modules/actor/src/lib.js
function* current() {
  return (
    /** @type {Task.Controller<T, X, M>} */
    yield CURRENT
  );
}
function* wake(task) {
  enqueue(task);
}
function* batch(effects2) {
  const forks = [];
  for (const effect2 of effects2) {
    forks.push(yield* fork(effect2));
  }
  yield* group(forks);
}
function* conclude2(handle, result) {
  try {
    const task = handle;
    const state = result.ok ? task.return(result.value) : task.throw(result.error);
    if (!state.done) {
      if (state.value === SUSPEND) {
        const { idle } = Group.of(task).stack;
        idle.add(task);
      } else {
        enqueue(task);
      }
    }
  } catch (error3) {
  }
}
function* group(forks) {
  if (forks.length === 0) return;
  const self2 = yield* current();
  const group2 = new Group(self2);
  let failure = null;
  for (const fork5 of forks) {
    const { result } = fork5;
    if (result) {
      if (!result.ok && !failure) {
        failure = result;
      }
      continue;
    }
    move(fork5, group2);
  }
  try {
    if (failure) {
      throw failure.error;
    }
    while (true) {
      yield* step(group2);
      if (Stack.size(group2.stack) > 0) {
        yield* suspend();
      } else {
        break;
      }
    }
  } catch (error3) {
    for (const task of group2.stack.active) {
      yield* abort(task, error3);
    }
    for (const task of group2.stack.idle) {
      yield* abort(task, error3);
      enqueue(task);
    }
    throw error3;
  }
}
function* join(fork5) {
  if (fork5.status === IDLE) {
    yield* fork5;
  }
  if (!fork5.result) {
    yield* group([fork5]);
  }
  const result = (
    /** @type {Task.Result<T, X>} */
    fork5.result
  );
  if (result.ok) {
    return result.value;
  } else {
    throw result.error;
  }
}
var effect, suspend, wait, isAsync, send, listen, effects, tag, Tagger, none, withTag, CURRENT, SUSPEND, Group, Main, Stack, main, enqueue, resume, step, fork, exit, abort, move, Future, Fork, loop, ID, IDLE, ACTIVE, FINISHED, INIT, BLANK2, NONE, MAIN;
var init_lib9 = __esm({
  "../../node_modules/.pnpm/actor@2.3.1/node_modules/actor/src/lib.js"() {
    init_task();
    init_task();
    effect = function* (task) {
      const message = yield* task;
      yield* send(message);
    };
    suspend = function* () {
      yield SUSPEND;
    };
    wait = function* (input10) {
      const task = yield* current();
      if (isAsync(input10)) {
        let failed = false;
        let output = void 0;
        input10.then(
          (value) => {
            failed = false;
            output = value;
            enqueue(task);
          },
          (error3) => {
            failed = true;
            output = error3;
            enqueue(task);
          }
        );
        yield* suspend();
        if (failed) {
          throw output;
        } else {
          return (
            /** @type {T} */
            output
          );
        }
      } else {
        main(wake(task));
        yield* suspend();
        return input10;
      }
    };
    isAsync = (node) => node != null && typeof /** @type {{then?:unknown}} */
    node.then === "function";
    send = function* (message) {
      yield (
        /** @type {Task.Message<T>} */
        message
      );
    };
    listen = function* (source) {
      const forks = [];
      for (const entry of Object.entries(source)) {
        const [name20, effect2] = (
          /** @type {[Tag, Task.Effect<T>]} */
          entry
        );
        if (effect2 !== NONE) {
          forks.push(yield* fork(tag(effect2, name20)));
        }
      }
      yield* group(forks);
    };
    effects = (tasks) => tasks.length > 0 ? batch(tasks.map(effect)) : NONE;
    tag = (effect2, tag2) => (
      // @ts-ignore
      effect2 === NONE ? NONE : effect2 instanceof Tagger ? new Tagger([...effect2.tags, tag2], effect2.source) : new Tagger([tag2], effect2)
    );
    Tagger = class {
      /**
       * @param {Task.Task<Success, Failure, Message>} source
       * @param {string[]} tags
       */
      constructor(tags, source) {
        this.tags = tags;
        this.source = source;
        this.controller;
      }
      /* c8 ignore next 3 */
      [Symbol.iterator]() {
        if (!this.controller) {
          this.controller = this.source[Symbol.iterator]();
        }
        return this;
      }
      /**
       * @param {Task.TaskState<Success, Message>} state
       * @returns {Task.TaskState<Success, Tagged<Tag, Message>>}
       */
      box(state) {
        if (state.done) {
          return state;
        } else {
          switch (state.value) {
            case SUSPEND:
            case CURRENT:
              return (
                /** @type {Task.TaskState<Success, Tagged<Tag, Message>>} */
                state
              );
            default: {
              const tagged = (
                /** @type {{ done: false, value: any }} */
                state
              );
              let { value } = tagged;
              for (const tag2 of this.tags) {
                value = withTag(tag2, value);
              }
              tagged.value = value;
              return tagged;
            }
          }
        }
      }
      /**
       *
       * @param {Task.Instruction<Message>} instruction
       */
      next(instruction) {
        return this.box(this.controller.next(instruction));
      }
      /**
       *
       * @param {Failure} error
       */
      throw(error3) {
        return this.box(this.controller.throw(error3));
      }
      /**
       * @param {Success} value
       */
      return(value) {
        return this.box(this.controller.return(value));
      }
      get [Symbol.toStringTag]() {
        return "TaggedEffect";
      }
    };
    none = () => NONE;
    withTag = (tag2, value) => (
      /** @type {Tagged<Tag, T>} */
      { type: tag2, [tag2]: value }
    );
    CURRENT = Symbol("current");
    SUSPEND = Symbol("suspend");
    Group = class _Group {
      /**
       * @template T, X, M
       * @param {Task.Controller<T, X, M>|Task.Fork<T, X, M>} member
       * @returns {Task.Group<T, X, M>}
       */
      static of(member) {
        return (
          /** @type {{group?:Task.TaskGroup<T, X, M>}} */
          member.group || MAIN
        );
      }
      /**
       * @template T, X, M
       * @param {(Task.Controller<T, X, M>|Task.Fork<T, X, M>) & {group?:Task.TaskGroup<T, X, M>}} member
       * @param {Task.TaskGroup<T, X, M>} group
       */
      static enqueue(member, group2) {
        member.group = group2;
        group2.stack.active.push(member);
      }
      /**
       * @param {Task.Controller<T, X, M>} driver
       * @param {Task.Controller<T, X, M>[]} [active]
       * @param {Set<Task.Controller<T, X, M>>} [idle]
       * @param {Task.Stack<T, X, M>} [stack]
       */
      constructor(driver, active = [], idle = /* @__PURE__ */ new Set(), stack = new Stack(active, idle)) {
        this.driver = driver;
        this.parent = _Group.of(driver);
        this.stack = stack;
        this.id = ++ID;
      }
    };
    Main = class {
      constructor() {
        this.status = IDLE;
        this.stack = new Stack();
        this.id = /** @type {0} */
        0;
      }
    };
    Stack = class {
      /**
       * @param {Task.Controller<T, X, M>[]} [active]
       * @param {Set<Task.Controller<T, X, M>>} [idle]
       */
      constructor(active = [], idle = /* @__PURE__ */ new Set()) {
        this.active = active;
        this.idle = idle;
      }
      /**
       *
       * @param {Task.Stack<unknown, unknown, unknown>} stack
       * @returns
       */
      static size({ active, idle }) {
        return active.length + idle.size;
      }
    };
    main = (task) => enqueue(task[Symbol.iterator]());
    enqueue = (task) => {
      let group2 = Group.of(task);
      group2.stack.active.push(task);
      group2.stack.idle.delete(task);
      while (group2.parent) {
        const { idle, active } = group2.parent.stack;
        if (idle.has(group2.driver)) {
          idle.delete(group2.driver);
          active.push(group2.driver);
        } else {
          break;
        }
        group2 = group2.parent;
      }
      if (MAIN.status === IDLE) {
        MAIN.status = ACTIVE;
        while (true) {
          try {
            for (const _message of step(MAIN)) {
            }
            MAIN.status = IDLE;
            break;
          } catch (_error) {
            MAIN.stack.active.shift();
          }
        }
      }
    };
    resume = (task) => enqueue(task);
    step = function* (group2) {
      const { active } = group2.stack;
      let task = active[0];
      group2.stack.idle.delete(task);
      while (task) {
        let state = INIT;
        loop: while (!state.done && task === active[0]) {
          const instruction = state.value;
          switch (instruction) {
            case SUSPEND:
              group2.stack.idle.add(task);
              break loop;
            case CURRENT:
              state = task.next(task);
              break;
            default:
              state = task.next(
                yield (
                  /** @type {M & Task.Message<M>}*/
                  instruction
                )
              );
              break;
          }
        }
        active.shift();
        task = active[0];
        group2.stack.idle.delete(task);
      }
    };
    fork = (task, options) => new Fork(task, options);
    exit = (handle, value) => conclude2(handle, { ok: true, value });
    abort = (handle, error3) => conclude2(handle, { ok: false, error: error3 });
    move = (fork5, group2) => {
      const from21 = Group.of(fork5);
      if (from21 !== group2) {
        const { active, idle } = from21.stack;
        const target = group2.stack;
        fork5.group = group2;
        if (idle.has(fork5)) {
          idle.delete(fork5);
          target.idle.add(fork5);
        } else {
          const index2 = active.indexOf(fork5);
          if (index2 >= 0) {
            active.splice(index2, 1);
            target.active.push(fork5);
          }
        }
      }
    };
    Future = class {
      /**
       * @param {Task.StateHandler<T, X>} handler
       */
      constructor(handler) {
        this.handler = handler;
        this.result;
      }
      /**
       * @type {Promise<T>}
       */
      get promise() {
        const { result } = this;
        const promise = result == null ? new Promise((succeed, fail3) => {
          this.handler.onsuccess = succeed;
          this.handler.onfailure = fail3;
        }) : result.ok ? Promise.resolve(result.value) : Promise.reject(result.error);
        Object.defineProperty(this, "promise", { value: promise });
        return promise;
      }
      /**
       * @template U, [E=never]
       * @param {((value:T) => U | PromiseLike<U>)|undefined|null} [onresolve]
       * @param {((error:X) => E|PromiseLike<E>)|undefined|null} [onreject]
       * @returns {Promise<U|E>}
       */
      then(onresolve, onreject) {
        return this.activate().promise.then(onresolve, onreject);
      }
      /**
       * @template [U=never]
       * @param {(error:X) => U} onreject
       */
      catch(onreject) {
        return (
          /** @type {Task.Future<T|U, never>} */
          this.activate().promise.catch(onreject)
        );
      }
      /**
       * @param {() => void} onfinally
       * @returns {Task.Future<T, X>}
       */
      finally(onfinally) {
        return (
          /** @type {Task.Future<T, X>} */
          this.activate().promise.finally(onfinally)
        );
      }
      /**
       * @abstract
       */
      /* c8 ignore next 3 */
      activate() {
        return this;
      }
    };
    Fork = class extends Future {
      /**
       * @param {Task.Task<T, X, M>} task
       * @param {Task.ForkOptions} [options]
       * @param {Task.StateHandler<T, X>} [handler]
       * @param {Task.TaskState<T, M>} [state]
       */
      constructor(task, options = BLANK2, handler = {}, state = INIT) {
        super(handler);
        this.id = ++ID;
        this.name = options.name || "";
        this.task = task;
        this.state = state;
        this.status = IDLE;
        this.result;
        this.handler = handler;
        this.controller;
      }
      *resume() {
        resume(this);
      }
      /**
       * @returns {Task.Task<T, X, M>}
       */
      join() {
        return join(this);
      }
      /**
       * @param {X} error
       */
      abort(error3) {
        return abort(this, error3);
      }
      /**
       * @param {T} value
       */
      exit(value) {
        return exit(this, value);
      }
      get [Symbol.toStringTag]() {
        return "Fork";
      }
      /**
       * @returns {Task.Controller<Task.Fork<T, X, M>, never, never>}
       */
      *[Symbol.iterator]() {
        return this.activate();
      }
      activate() {
        this.controller = this.task[Symbol.iterator]();
        this.status = ACTIVE;
        enqueue(this);
        return this;
      }
      /**
       * @private
       * @param {any} error
       * @returns {never}
       */
      panic(error3) {
        this.result = { ok: false, error: error3 };
        this.status = FINISHED;
        const { handler } = this;
        if (handler.onfailure) {
          handler.onfailure(error3);
        }
        throw error3;
      }
      /**
       * @private
       * @param {Task.TaskState<T, M>} state
       */
      step(state) {
        this.state = state;
        if (state.done) {
          this.result = { ok: true, value: state.value };
          this.status = FINISHED;
          const { handler } = this;
          if (handler.onsuccess) {
            handler.onsuccess(state.value);
          }
        }
        return state;
      }
      /**
       * @param {unknown} value
       */
      next(value) {
        try {
          return this.step(this.controller.next(value));
        } catch (error3) {
          return this.panic(error3);
        }
      }
      /**
       * @param {T} value
       */
      return(value) {
        try {
          return this.step(this.controller.return(value));
        } catch (error3) {
          return this.panic(error3);
        }
      }
      /**
       * @param {X} error
       */
      throw(error3) {
        try {
          return this.step(this.controller.throw(error3));
        } catch (error4) {
          return this.panic(error4);
        }
      }
    };
    loop = function* (init2, next) {
      const controller = yield* current();
      const group2 = new Group(controller);
      Group.enqueue(init2[Symbol.iterator](), group2);
      while (true) {
        for (const message of step(group2)) {
          Group.enqueue(next(message)[Symbol.iterator](), group2);
        }
        if (Stack.size(group2.stack) > 0) {
          yield* suspend();
        } else {
          break;
        }
      }
    };
    ID = 0;
    IDLE = "idle";
    ACTIVE = "active";
    FINISHED = "finished";
    INIT = { done: false, value: CURRENT };
    BLANK2 = {};
    NONE = function* none2() {
    }();
    MAIN = new Main();
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/chunker/indexed.js
function Indexed() {
}
var init_indexed = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/chunker/indexed.js"() {
    Object.defineProperties(Indexed, {
      prototype: {
        value: new Proxy(Object.prototype, {
          /**
           * @param {object} target
           * @param {PropertyKey} property
           * @param {{get(key:PropertyKey): any}} receiver
           */
          get(target, property, receiver) {
            return typeof property === "symbol" ? Reflect.get(target, property, receiver) : receiver.get(property);
          }
        })
      }
    });
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/chunker/buffer.js
function* iterate2(buffer3) {
  for (const part of buffer3.segments) {
    yield* part;
  }
}
var empty6, slice3, push, get9, copyTo, BufferView;
var init_buffer = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/chunker/buffer.js"() {
    init_indexed();
    empty6 = () => new BufferView();
    slice3 = (buffer3, startOffset = 0, endOffset = buffer3.byteLength) => {
      const segments = [];
      const start = startOffset < 0 ? buffer3.byteLength - startOffset : startOffset;
      const end = endOffset < 0 ? buffer3.byteLength - endOffset : endOffset;
      if (start === 0 && end >= buffer3.byteLength) {
        return buffer3;
      }
      if (start > end || start > buffer3.byteLength || end <= 0) {
        return empty6();
      }
      let byteLength = 0;
      let offset2 = 0;
      for (const segment of buffer3.segments) {
        const nextOffset = offset2 + segment.byteLength;
        if (byteLength === 0) {
          if (end <= nextOffset) {
            const range = segment.subarray(start - offset2, end - offset2);
            segments.push(range);
            byteLength = range.byteLength;
            break;
          } else if (start < nextOffset) {
            const range = start === offset2 ? segment : segment.subarray(start - offset2);
            segments.push(range);
            byteLength = range.byteLength;
          }
        } else if (end <= nextOffset) {
          const range = end === nextOffset ? segment : segment.subarray(0, end - offset2);
          segments.push(range);
          byteLength += range.byteLength;
          break;
        } else {
          segments.push(segment);
          byteLength += segment.byteLength;
        }
        offset2 = nextOffset;
      }
      return new BufferView(segments, buffer3.byteOffset + start, byteLength);
    };
    push = (buffer3, part) => {
      if (part.byteLength > 0) {
        buffer3.segments.push(part);
        return new BufferView(
          buffer3.segments,
          buffer3.byteOffset,
          buffer3.byteLength + part.byteLength
        );
      } else {
        return buffer3;
      }
    };
    get9 = (buffer3, n) => {
      if (n < buffer3.byteLength) {
        let offset2 = 0;
        for (const segment of buffer3.segments) {
          if (n < offset2 + segment.byteLength) {
            return segment[n - offset2];
          } else {
            offset2 += segment.byteLength;
          }
        }
      }
      return void 0;
    };
    copyTo = (buffer3, target, byteOffset) => {
      let offset2 = byteOffset;
      for (const segment of buffer3.segments) {
        target.set(segment, offset2);
        offset2 += segment.byteLength;
      }
      return target;
    };
    BufferView = class extends Indexed {
      /**
       * @param {Uint8Array[]} segments
       * @param {number} byteOffset
       * @param {number} byteLength
       */
      constructor(segments = [], byteOffset = 0, byteLength = 0) {
        super();
        this.segments = segments;
        this.byteLength = byteLength;
        this.length = byteLength;
        this.byteOffset = byteOffset;
      }
      [Symbol.iterator]() {
        return iterate2(this);
      }
      /**
       * @param {number} [start]
       * @param {number} [end]
       */
      slice(start, end) {
        return (
          /** @type {BufferView} */
          slice3(this, start, end)
        );
      }
      /**
       * @param {number} [start]
       * @param {number} [end]
       */
      subarray(start, end) {
        return (
          /** @type {BufferView} */
          slice3(this, start, end)
        );
      }
      /**
       *
       * @param {Uint8Array} bytes
       */
      push(bytes2) {
        return (
          /** @type {BufferView} */
          push(this, bytes2)
        );
      }
      /**
       * @param {number} n
       */
      get(n) {
        return get9(this, n);
      }
      /**
       *
       * @param {Uint8Array} target
       * @param {number} offset
       */
      copyTo(target, offset2) {
        return copyTo(this, target, offset2);
      }
    };
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/chunker/api.js
var init_api4 = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/chunker/api.js"() {
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/writer/util.js
var panic2, unreachable, EMPTY_BUFFER2, EMPTY3;
var init_util4 = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/writer/util.js"() {
    panic2 = (reason) => {
      throw new Error(reason);
    };
    unreachable = (template, subject, ...substitutions) => panic2(String.raw(template, JSON.stringify(subject), ...substitutions));
    EMPTY_BUFFER2 = new Uint8Array(0);
    EMPTY3 = [];
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/chunker.js
var open2, write4, close2, split2;
var init_chunker = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/chunker.js"() {
    init_buffer();
    init_util4();
    init_api4();
    open2 = (config2) => ({
      config: config2,
      buffer: empty6()
    });
    write4 = (state, bytes2) => bytes2.byteLength > 0 ? split2(state.config, state.buffer.push(bytes2), false) : { ...state, chunks: EMPTY3 };
    close2 = (state) => split2(state.config, state.buffer, true);
    split2 = (config2, buffer3, end) => {
      const chunker = config2.chunker;
      const chunks = [];
      let offset2 = 0;
      for (const size5 of chunker.cut(chunker.context, buffer3, end)) {
        if (size5 > 0) {
          const chunk = buffer3.subarray(offset2, offset2 + size5);
          chunks.push(chunk);
          offset2 += size5;
        }
      }
      return { config: config2, chunks, buffer: buffer3.subarray(offset2) };
    };
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/layout/queue/api.js
var init_api5 = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/layout/queue/api.js"() {
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/layout/queue.js
var mutable, addNodes, addLink, patch, assign, patchDict, append, collect, EMPTY4, BLANK3;
var init_queue = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/layout/queue.js"() {
    init_api5();
    mutable = () => ({
      mutable: true,
      needs: {},
      nodes: {},
      links: {},
      linked: EMPTY4
    });
    addNodes = (newNodes, input10) => {
      let queue = patch(input10, {});
      for (const node of newNodes) {
        const { ready, has: has2, wants } = collect(node.children, queue.links);
        if (wants.length === 0) {
          queue = patch(queue, {
            links: assign(void 0, has2),
            linked: [{ id: node.id, links: ready }]
          });
        } else {
          queue = patch(queue, {
            needs: assign(node.id, wants),
            nodes: {
              [node.id]: {
                children: node.children,
                count: wants.length
              }
            }
          });
        }
      }
      return queue;
    };
    addLink = (id, link5, queue) => {
      const nodeID = queue.needs[id];
      const node = queue.nodes[nodeID];
      if (node != null) {
        if (node.count === 1) {
          const { ready, has: has2 } = collect(node.children, {
            ...queue.links,
            [id]: link5
          });
          return patch(queue, {
            needs: { [id]: void 0 },
            links: assign(void 0, has2),
            nodes: { [nodeID]: void 0 },
            linked: [{ id: nodeID, links: ready }]
          });
        } else {
          return patch(queue, {
            needs: { [id]: void 0 },
            links: { [id]: link5 },
            nodes: {
              [nodeID]: {
                ...node,
                count: node.count - 1
              }
            }
          });
        }
      } else {
        return patch(queue, {
          links: { [id]: link5 }
        });
      }
    };
    patch = (queue, { needs, nodes, links: links3, linked }) => {
      const result = queue.mutable ? queue : { ...queue };
      const original = queue.mutable ? BLANK3 : void 0;
      if (needs) {
        result.needs = patchDict(queue.needs, needs, original);
      }
      if (nodes) {
        result.nodes = patchDict(queue.nodes, nodes, original);
      }
      if (links3) {
        result.links = patchDict(queue.links, links3, original);
      }
      result.linked = linked ? append(queue.linked || EMPTY4, linked, EMPTY4) : queue.linked || [];
      return (
        /** @type {Queue.Result} */
        result
      );
    };
    assign = (value, keys2) => {
      const delta = (
        /** @type {Record<K, V>} */
        {}
      );
      for (const key of keys2) {
        delta[key] = value;
      }
      return delta;
    };
    patchDict = (target, delta, original = target) => {
      const result = target === original ? { ...target } : target;
      for (const entry of Object.entries(delta)) {
        const [id, value] = (
          /** @type {[K, V|void]} */
          entry
        );
        if (value == null) {
          delete result[id];
        } else {
          result[id] = value;
        }
      }
      return result;
    };
    append = (target, items, original = target) => {
      if (target === original) {
        return [...target, ...items];
      } else {
        for (const item of items) {
          target.push(item);
        }
        return target;
      }
    };
    collect = (children, source) => {
      const has2 = [];
      const wants = [];
      const ready = [];
      for (const child of children) {
        const link5 = source[child];
        if (link5) {
          has2.push(child);
          ready.push(link5);
        } else {
          wants.push(child);
        }
      }
      return { has: has2, wants, ready };
    };
    EMPTY4 = /** @type {never[]} */
    Object.freeze([]);
    BLANK3 = /** @type {Record<never, never>} */
    Object.freeze({});
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/writer.js
var update, init, write5, link4, close3, encodeLeaves, encodeLeaf, encodeBranches, encodeBranch, writeBlock, asUint8Array2, isLeafNode;
var init_writer = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/writer.js"() {
    init_lib9();
    init_codec2();
    init_chunker();
    init_util4();
    init_queue();
    update = (message, state) => {
      switch (message.type) {
        case "write":
          return write5(state, message.bytes);
        case "link":
          return link4(state, message.link);
        case "block":
          return { state, effect: none() };
        case "close":
          return close3(state);
        case "end":
          return { state, effect: none() };
        default:
          return unreachable`File Writer got unknown message ${message}`;
      }
    };
    init = (writer, metadata, config2) => {
      return {
        status: "open",
        metadata,
        config: config2,
        writer,
        chunker: open2({ chunker: config2.chunker }),
        layout: config2.fileLayout.open(),
        // Note: Writing in large slices e.g. 1GiB at a time creates large queues
        // with around `16353` items. Immutable version ends up copying it every
        // time state of the queue changes, which introduces significant overhead.
        // To avoid this overhead we use mutable implementation which is API
        // compatible but makes in place updates.
        // TODO: We should consider using Persistent bit-partitioned vector tries
        // instead of arrays which would provide immutable interface with neglegable
        // overhead.
        // @see https://github.com/Gozala/vectrie
        nodeQueue: mutable()
      };
    };
    write5 = (state, bytes2) => {
      if (state.status === "open") {
        const { chunks, ...chunker } = write4(state.chunker, bytes2);
        const { nodes, leaves, layout } = state.config.fileLayout.write(
          state.layout,
          chunks
        );
        const { linked, ...nodeQueue } = addNodes(nodes, state.nodeQueue);
        const tasks = [
          ...encodeLeaves(leaves, state.config),
          ...encodeBranches(linked, state.config)
        ];
        return {
          state: {
            ...state,
            chunker,
            layout,
            nodeQueue
          },
          effect: listen({
            link: effects(tasks)
          })
        };
      } else {
        return panic2("Unable to perform write on closed file");
      }
    };
    link4 = (state, { id, link: link5, block }) => {
      let { linked, ...nodeQueue } = addLink(id, link5, state.nodeQueue);
      const tasks = encodeBranches(linked, state.config);
      const newState = state.status === "closed" && id === state.rootID ? {
        ...state,
        status: "linked",
        link: link5,
        nodeQueue
      } : { ...state, nodeQueue };
      const end = state.status === "closed" && id === state.rootID && state.end ? state.end.resume() : none();
      return {
        state: newState,
        effect: listen({
          link: effects(tasks),
          block: writeBlock(state.writer, block),
          end
        })
      };
    };
    close3 = (state) => {
      if (state.status === "open") {
        const { chunks } = close2(state.chunker);
        const { layout, ...write8 } = state.config.fileLayout.write(
          state.layout,
          chunks
        );
        const { root: root2, ...close9 } = state.config.fileLayout.close(
          layout,
          state.metadata
        );
        const [nodes, leaves] = isLeafNode(root2) ? [
          [...write8.nodes, ...close9.nodes],
          [...write8.leaves, ...close9.leaves, root2]
        ] : [
          [...write8.nodes, ...close9.nodes, root2],
          [...write8.leaves, ...close9.leaves]
        ];
        const { linked, ...nodeQueue } = addNodes(nodes, state.nodeQueue);
        const tasks = [
          ...encodeLeaves(leaves, state.config),
          ...encodeBranches(linked, state.config)
        ];
        const fork5 = fork(suspend());
        return {
          state: {
            ...state,
            chunker: null,
            layout: null,
            rootID: root2.id,
            status: "closed",
            end: fork5,
            nodeQueue
          },
          effect: listen({
            link: effects(tasks),
            end: join(fork5)
          })
        };
      } else {
        return { state, effect: none() };
      }
    };
    encodeLeaves = (leaves, config2) => leaves.map((leaf) => encodeLeaf(config2, leaf, config2.fileChunkEncoder));
    encodeLeaf = function* ({ hasher, linker }, { id, content: content2 }, encoder3) {
      const bytes2 = encoder3.encode(content2 ? asUint8Array2(content2) : EMPTY_BUFFER2);
      const hash = yield* wait(hasher.digest(bytes2));
      const cid = linker.createLink(encoder3.code, hash);
      const block = { cid, bytes: bytes2 };
      const link5 = (
        /** @type {UnixFS.FileLink} */
        {
          cid,
          contentByteLength: content2 ? content2.byteLength : 0,
          dagByteLength: bytes2.byteLength
        }
      );
      return { id, block, link: link5 };
    };
    encodeBranches = (nodes, config2) => nodes.map((node) => encodeBranch(config2, node));
    encodeBranch = function* (config2, { id, links: links3 }, metadata) {
      const bytes2 = config2.fileEncoder.encode({
        type: NodeType.File,
        layout: "advanced",
        parts: links3,
        metadata
      });
      const hash = yield* wait(Promise.resolve(config2.hasher.digest(bytes2)));
      const cid = config2.linker.createLink(config2.fileEncoder.code, hash);
      const block = { bytes: bytes2, cid };
      const link5 = (
        /** @type {UnixFS.FileLink} */
        {
          cid,
          contentByteLength: cumulativeContentByteLength(links3),
          dagByteLength: cumulativeDagByteLength(bytes2, links3)
        }
      );
      return { id, block, link: link5 };
    };
    writeBlock = function* (writer, block) {
      if ((writer.desiredSize || 0) <= 0) {
        yield* wait(writer.ready);
      }
      writer.write(block);
    };
    asUint8Array2 = (buffer3) => buffer3 instanceof Uint8Array ? buffer3 : buffer3.copyTo(new Uint8Array(buffer3.byteLength), 0);
    isLeafNode = (node) => node.children == null;
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/chunker/fixed.js
var fixed_exports = {};
__export(fixed_exports, {
  context: () => context,
  cut: () => cut,
  name: () => name18,
  type: () => type,
  withMaxChunkSize: () => withMaxChunkSize
});
var name18, context, type, withMaxChunkSize, cut;
var init_fixed = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/chunker/fixed.js"() {
    name18 = "fixed";
    context = {
      maxChunkSize: 262144
    };
    type = "Stateless";
    withMaxChunkSize = (maxChunkSize) => ({
      type: "Stateless",
      context: { maxChunkSize },
      name: name18,
      cut
    });
    cut = ({ maxChunkSize }, { byteLength }, end) => {
      const n = byteLength / maxChunkSize | 0;
      const chunks = new Array(n).fill(maxChunkSize);
      const lastChunkSize = end ? byteLength - n * maxChunkSize : 0;
      if (lastChunkSize > 0) {
        chunks.push(lastChunkSize);
      }
      return chunks;
    };
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/layout/balanced.js
var Node, withWidth, defaults, open3, write6, flush2, close4, grow, EMPTY5;
var init_balanced = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/layout/balanced.js"() {
    Node = class {
      /**
       *
       * @param {number} id
       * @param {number[]} children
       * @param {Layout.Metadata} [metadata]
       */
      constructor(id, children, metadata) {
        this.id = id;
        this.children = children;
        this.metadata = metadata;
      }
    };
    withWidth = (width) => ({
      open: () => open3({ width }),
      write: write6,
      close: close4
    });
    defaults = { width: 174 };
    open3 = ({ width } = defaults) => ({
      width,
      head: null,
      leafIndex: [],
      nodeIndex: [],
      lastID: 0
    });
    write6 = (layout, chunks) => {
      if (chunks.length === 0) {
        return { layout, nodes: EMPTY5, leaves: EMPTY5 };
      } else {
        let { lastID } = layout;
        const [head, slices] = layout.head ? (
          // If we had a head we have more then two chunks (we already checked
          // chunks weren't empty) so we process head along with other chunks.
          [null, (chunks.unshift(layout.head), chunks)]
        ) : (
          // If we have no head no leaves and got only one chunk we have to save it
          // until we can decide what to do with it.
          chunks.length === 1 && layout.leafIndex.length === 0 ? [chunks[0], EMPTY5] : (
            // Otherwise we have no head but got enough chunks to know we'll have a
            // node.
            [null, chunks]
          )
        );
        if (slices.length === 0) {
          return { layout: { ...layout, head }, nodes: EMPTY5, leaves: EMPTY5 };
        } else {
          const leafIndex = [...layout.leafIndex];
          const leaves = [];
          for (const chunk of slices) {
            const leaf = { id: ++lastID, content: chunk };
            leaves.push(leaf);
            leafIndex.push(leaf.id);
          }
          if (leafIndex.length > layout.width) {
            return flush2({ ...layout, leafIndex, head, lastID }, leaves);
          } else {
            return {
              layout: { ...layout, head, leafIndex, lastID },
              leaves,
              nodes: EMPTY5
            };
          }
        }
      }
    };
    flush2 = (state, leaves = EMPTY5, nodes = [], close9 = false) => {
      let { lastID } = state;
      const nodeIndex = state.nodeIndex.map((row) => [...row]);
      const leafIndex = [...state.leafIndex];
      const { width } = state;
      while (leafIndex.length > width || leafIndex.length > 0 && close9) {
        grow(nodeIndex, 1);
        const node = new Node(++lastID, leafIndex.splice(0, width));
        nodeIndex[0].push(node.id);
        nodes.push(node);
      }
      let depth = 0;
      while (depth < nodeIndex.length) {
        const row = nodeIndex[depth];
        depth++;
        while (row.length > width || row.length > 0 && close9 && depth < nodeIndex.length) {
          const node = new Node(++lastID, row.splice(0, width));
          grow(nodeIndex, depth + 1);
          nodeIndex[depth].push(node.id);
          nodes.push(node);
        }
      }
      return { layout: { ...state, lastID, leafIndex, nodeIndex }, leaves, nodes };
    };
    close4 = (layout, metadata) => {
      const state = layout;
      if (layout.head) {
        return {
          root: { id: 1, content: layout.head, metadata },
          leaves: EMPTY5,
          nodes: EMPTY5
        };
      } else if (layout.leafIndex.length === 0) {
        return {
          root: { id: 1, metadata },
          leaves: EMPTY5,
          nodes: EMPTY5
        };
      } else {
        const { nodes, layout: layout2 } = flush2(state, EMPTY5, [], true);
        const { nodeIndex } = layout2;
        const height2 = nodeIndex.length - 1;
        const top = nodeIndex[height2];
        if (top.length === 1) {
          const root2 = nodes[nodes.length - 1];
          nodes.length = nodes.length - 1;
          return { root: root2, nodes, leaves: EMPTY5 };
        } else {
          const root2 = new Node(layout2.lastID + 1, top, metadata);
          return { root: root2, nodes, leaves: EMPTY5 };
        }
      }
    };
    grow = (index2, length5) => {
      while (index2.length < length5) {
        index2.push([]);
      }
      return index2;
    };
    EMPTY5 = [];
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file.js
var defaults2, configure2, UnixFSLeaf, create14, write7, close5, perform, FileWriterView;
var init_file = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file.js"() {
    init_codec2();
    init_writer();
    init_lib9();
    init_util4();
    init_fixed();
    init_sha22();
    init_cid3();
    init_balanced();
    init_api3();
    defaults2 = () => ({
      chunker: fixed_exports,
      fileChunkEncoder: UnixFSLeaf,
      smallFileEncoder: UnixFSLeaf,
      fileEncoder: codec_exports2,
      fileLayout: withWidth(174),
      hasher: sha2562,
      linker: { createLink: CID3.createV1 }
    });
    configure2 = (config2) => ({
      ...defaults2(),
      ...config2
    });
    UnixFSLeaf = {
      code: code22,
      name: name17,
      encode: encodeFileChunk
    };
    create14 = ({ writer, metadata = {}, settings = defaults2() }) => new FileWriterView(init(writer, metadata, configure2(settings)));
    write7 = async (view6, bytes2) => {
      await perform(view6, send({ type: "write", bytes: bytes2 }));
      return view6;
    };
    close5 = async (view6, { releaseLock = false, closeWriter = false } = {}) => {
      await perform(view6, send({ type: "close" }));
      const { state } = view6;
      if (state.status === "linked") {
        if (closeWriter) {
          await view6.state.writer.close();
        } else if (releaseLock) {
          view6.state.writer.releaseLock();
        }
        return state.link;
      } else {
        panic2(
          `Expected writer to be in 'linked' state after close, but it is in "${state.status}" instead`
        );
      }
    };
    perform = (view6, effect2) => fork(
      loop(effect2, (message) => {
        const { state, effect: effect3 } = update(message, view6.state);
        view6.state = state;
        return effect3;
      })
    );
    FileWriterView = class {
      /**
       * @param {Writer.State<Layout>} state
       */
      constructor(state) {
        this.state = state;
      }
      get writer() {
        return this.state.writer;
      }
      get settings() {
        return this.state.config;
      }
      /**
       * @param {Uint8Array} bytes
       * @returns {Promise<API.View<Layout>>}
       */
      write(bytes2) {
        return write7(this, bytes2);
      }
      /**
       * @param {API.CloseOptions} [options]
       * @returns {Promise<UnixFS.FileLink>}
       */
      close(options) {
        return close5(this, options);
      }
    };
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/directory/api.js
var init_api6 = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/directory/api.js"() {
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/directory.js
var defaults3, create15, set, remove7, asWritable, close6, links, fork2, DirectoryWriter;
var init_directory = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/directory.js"() {
    init_file();
    init_codec2();
    init_api6();
    defaults3 = defaults2;
    create15 = ({ writer, settings = defaults3(), metadata = {} }) => new DirectoryWriter({
      writer,
      metadata,
      settings,
      entries: /* @__PURE__ */ new Map(),
      closed: false
    });
    set = (view6, name20, link5, { overwrite = false } = {}) => {
      const writable = asWritable(view6.state);
      if (name20.includes("/")) {
        throw new Error(
          `Directory entry name "${name20}" contains forbidden "/" character`
        );
      }
      if (!overwrite && writable.entries.has(name20)) {
        throw new Error(`Directory already contains entry with name "${name20}"`);
      } else {
        writable.entries.set(name20, link5);
        return view6;
      }
    };
    remove7 = (view6, name20) => {
      const writer = asWritable(view6.state);
      writer.entries.delete(name20);
      return view6;
    };
    asWritable = (writer) => {
      if (!writer.closed) {
        return writer;
      } else {
        throw new Error(
          `Can not change written directory, but you can .fork() and make changes to it`
        );
      }
    };
    close6 = async (view6, { closeWriter = false, releaseLock = false } = {}) => {
      const { writer, settings, metadata } = asWritable(view6.state);
      view6.state.closed = true;
      const entries3 = [...links(view6)];
      const node = createFlatDirectory(entries3, metadata);
      const bytes2 = encodeDirectory(node);
      const digest6 = await settings.hasher.digest(bytes2);
      const cid = settings.linker.createLink(code22, digest6);
      if ((writer.desiredSize || 0) <= 0) {
        await writer.ready;
      }
      writer.write({ cid, bytes: bytes2 });
      if (closeWriter) {
        await writer.close();
      } else if (releaseLock) {
        writer.releaseLock();
      }
      return {
        cid,
        dagByteLength: cumulativeDagByteLength(bytes2, entries3)
      };
    };
    links = function* ({ state }) {
      for (const [name20, { dagByteLength, cid }] of state.entries) {
        yield (
          /** @type {UnixFS.DirectoryEntryLink} */
          {
            name: name20,
            dagByteLength,
            cid
          }
        );
      }
    };
    fork2 = ({ state }, {
      writer = state.writer,
      metadata = state.metadata,
      settings = state.settings
    } = {}) => new DirectoryWriter({
      writer,
      metadata,
      settings,
      entries: new Map(state.entries.entries()),
      closed: false
    });
    DirectoryWriter = class {
      /**
       * @param {API.State<Layout>} state
       */
      constructor(state) {
        this.state = state;
      }
      get writer() {
        return this.state.writer;
      }
      get settings() {
        return this.state.settings;
      }
      links() {
        return links(this);
      }
      /**
       * @param {string} name
       * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link
       * @param {API.WriteOptions} [options]
       */
      set(name20, link5, options) {
        return set(this, name20, link5, options);
      }
      /**
       * @param {string} name
       */
      remove(name20) {
        return remove7(this, name20);
      }
      /**
       * @template L
       * @param {Partial<API.Options<L>>} [options]
       * @returns {API.View<Layout|L>}
       */
      fork(options) {
        return fork2(this, options);
      }
      /**
       * @param {API.CloseOptions} [options]
       * @returns {Promise<UnixFS.DirectoryLink>}
       */
      close(options) {
        return close6(this, options);
      }
      entries() {
        return this.state.entries.entries();
      }
      /**
       * @param {string} name
       */
      has(name20) {
        return this.state.entries.has(name20);
      }
      get size() {
        return this.state.entries.size;
      }
    };
  }
});

// ../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/api.js
var init_api7 = __esm({
  "../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/api.js"() {
  }
});

// ../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/bitfield/api.js
var api_exports2 = {};
var init_api8 = __esm({
  "../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/bitfield/api.js"() {
  }
});

// ../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/bitfield/Uint32.js
var Uint32_exports = {};
__export(Uint32_exports, {
  API: () => api_exports2,
  and: () => and5,
  bitCount: () => bitCount,
  empty: () => empty7,
  from: () => from17,
  fromBytes: () => fromBytes3,
  get: () => get10,
  or: () => or12,
  popcount: () => popcount,
  set: () => set2,
  size: () => size3,
  toBytes: () => toBytes3,
  unset: () => unset
});
var empty7, from17, size3, mask, offset, popcount, set2, unset, get10, bitCount, and5, or12, toBytes3, fromBytes3;
var init_Uint32 = __esm({
  "../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/bitfield/Uint32.js"() {
    init_api8();
    empty7 = (size5 = 32) => {
      if (size5 !== 32) {
        throw new Error(`Uint32 BitField does not support size: ${size5}`);
      }
      return 0;
    };
    from17 = (bits, size5) => {
      let bitfield = empty7(size5);
      for (const bit of bits) {
        bitfield = set2(bitfield, bit);
      }
      return bitfield;
    };
    size3 = (_bitField) => 32;
    mask = (bitField2, index2) => bitField2 >>> index2 & 31;
    offset = (bitField2, index2) => 1 << mask(bitField2, index2);
    popcount = (bitField2, index2 = 31) => bitCount(bitField2 & offset(index2, 0) - 1);
    set2 = (bitField2, index2) => bitField2 | 1 << index2;
    unset = (bitField2, index2) => bitField2 & (255 ^ 1 << index2);
    get10 = (bitField2, index2) => (bitField2 >> index2 & 1) !== 0;
    bitCount = (bitField2) => {
      const n1 = bitField2 - (bitField2 >> 1 & 1431655765);
      const n2 = (n1 & 858993459) + (n1 >> 2 & 858993459);
      const n3 = (n2 + (n2 >> 4) & 252645135) * 16843009;
      return n3 >> 24;
    };
    and5 = (left, right) => left & right;
    or12 = (left, right) => left | right;
    toBytes3 = (bitField2) => Uint8Array.of(
      bitField2 >> 24 & 255,
      bitField2 >> 16 & 255,
      bitField2 >> 8 & 255,
      bitField2 & 255
    );
    fromBytes3 = (bytes2) => {
      if (bytes2.length !== 4) {
        throw new Error(`Expected 4 bytes instead got ${bytes2.length}`);
      }
      return (bytes2[0] << 24) + (bytes2[1] << 16) + (bytes2[2] << 8) + bytes2[3];
    };
  }
});

// ../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/api.js
var init_api9 = __esm({
  "../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/api.js"() {
  }
});

// ../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js
var require_murmurHash3js = __commonJS({
  "../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js"(exports2, module2) {
    (function(root2, undefined2) {
      "use strict";
      var library = {
        "version": "3.0.0",
        "x86": {},
        "x64": {},
        "inputValidation": true
      };
      function _validBytes(bytes2) {
        if (!Array.isArray(bytes2) && !ArrayBuffer.isView(bytes2)) {
          return false;
        }
        for (var i = 0; i < bytes2.length; i++) {
          if (!Number.isInteger(bytes2[i]) || bytes2[i] < 0 || bytes2[i] > 255) {
            return false;
          }
        }
        return true;
      }
      function _x86Multiply(m, n) {
        return (m & 65535) * n + (((m >>> 16) * n & 65535) << 16);
      }
      function _x86Rotl(m, n) {
        return m << n | m >>> 32 - n;
      }
      function _x86Fmix(h) {
        h ^= h >>> 16;
        h = _x86Multiply(h, 2246822507);
        h ^= h >>> 13;
        h = _x86Multiply(h, 3266489909);
        h ^= h >>> 16;
        return h;
      }
      function _x64Add(m, n) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m[3] + n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m[2] + n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m[1] + n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m[0] + n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Multiply(m, n) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m[3] * n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m[2] * n[3];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[2] += m[3] * n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m[1] * n[3];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m[2] * n[2];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m[3] * n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m[0] * n[3] + m[1] * n[2] + m[2] * n[1] + m[3] * n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Rotl(m, n) {
        n %= 64;
        if (n === 32) {
          return [m[1], m[0]];
        } else if (n < 32) {
          return [m[0] << n | m[1] >>> 32 - n, m[1] << n | m[0] >>> 32 - n];
        } else {
          n -= 32;
          return [m[1] << n | m[0] >>> 32 - n, m[0] << n | m[1] >>> 32 - n];
        }
      }
      function _x64LeftShift(m, n) {
        n %= 64;
        if (n === 0) {
          return m;
        } else if (n < 32) {
          return [m[0] << n | m[1] >>> 32 - n, m[1] << n];
        } else {
          return [m[1] << n - 32, 0];
        }
      }
      function _x64Xor(m, n) {
        return [m[0] ^ n[0], m[1] ^ n[1]];
      }
      function _x64Fmix(h) {
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [4283543511, 3981806797]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [3301882366, 444984403]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        return h;
      }
      library.x86.hash32 = function(bytes2, seed) {
        if (library.inputValidation && !_validBytes(bytes2)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes2.length % 4;
        var blocks = bytes2.length - remainder;
        var h1 = seed;
        var k1 = 0;
        var c1 = 3432918353;
        var c2 = 461845907;
        for (var i = 0; i < blocks; i = i + 4) {
          k1 = bytes2[i] | bytes2[i + 1] << 8 | bytes2[i + 2] << 16 | bytes2[i + 3] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 13);
          h1 = _x86Multiply(h1, 5) + 3864292196;
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= bytes2[i + 2] << 16;
          case 2:
            k1 ^= bytes2[i + 1] << 8;
          case 1:
            k1 ^= bytes2[i];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes2.length;
        h1 = _x86Fmix(h1);
        return h1 >>> 0;
      };
      library.x86.hash128 = function(bytes2, seed) {
        if (library.inputValidation && !_validBytes(bytes2)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes2.length % 16;
        var blocks = bytes2.length - remainder;
        var h1 = seed;
        var h2 = seed;
        var h3 = seed;
        var h4 = seed;
        var k1 = 0;
        var k2 = 0;
        var k3 = 0;
        var k4 = 0;
        var c1 = 597399067;
        var c2 = 2869860233;
        var c3 = 951274213;
        var c4 = 2716044179;
        for (var i = 0; i < blocks; i = i + 16) {
          k1 = bytes2[i] | bytes2[i + 1] << 8 | bytes2[i + 2] << 16 | bytes2[i + 3] << 24;
          k2 = bytes2[i + 4] | bytes2[i + 5] << 8 | bytes2[i + 6] << 16 | bytes2[i + 7] << 24;
          k3 = bytes2[i + 8] | bytes2[i + 9] << 8 | bytes2[i + 10] << 16 | bytes2[i + 11] << 24;
          k4 = bytes2[i + 12] | bytes2[i + 13] << 8 | bytes2[i + 14] << 16 | bytes2[i + 15] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 19);
          h1 += h2;
          h1 = _x86Multiply(h1, 5) + 1444728091;
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
          h2 = _x86Rotl(h2, 17);
          h2 += h3;
          h2 = _x86Multiply(h2, 5) + 197830471;
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
          h3 = _x86Rotl(h3, 15);
          h3 += h4;
          h3 = _x86Multiply(h3, 5) + 2530024501;
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
          h4 = _x86Rotl(h4, 13);
          h4 += h1;
          h4 = _x86Multiply(h4, 5) + 850148119;
        }
        k1 = 0;
        k2 = 0;
        k3 = 0;
        k4 = 0;
        switch (remainder) {
          case 15:
            k4 ^= bytes2[i + 14] << 16;
          case 14:
            k4 ^= bytes2[i + 13] << 8;
          case 13:
            k4 ^= bytes2[i + 12];
            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;
          case 12:
            k3 ^= bytes2[i + 11] << 24;
          case 11:
            k3 ^= bytes2[i + 10] << 16;
          case 10:
            k3 ^= bytes2[i + 9] << 8;
          case 9:
            k3 ^= bytes2[i + 8];
            k3 = _x86Multiply(k3, c3);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h3 ^= k3;
          case 8:
            k2 ^= bytes2[i + 7] << 24;
          case 7:
            k2 ^= bytes2[i + 6] << 16;
          case 6:
            k2 ^= bytes2[i + 5] << 8;
          case 5:
            k2 ^= bytes2[i + 4];
            k2 = _x86Multiply(k2, c2);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c3);
            h2 ^= k2;
          case 4:
            k1 ^= bytes2[i + 3] << 24;
          case 3:
            k1 ^= bytes2[i + 2] << 16;
          case 2:
            k1 ^= bytes2[i + 1] << 8;
          case 1:
            k1 ^= bytes2[i];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes2.length;
        h2 ^= bytes2.length;
        h3 ^= bytes2.length;
        h4 ^= bytes2.length;
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        h1 = _x86Fmix(h1);
        h2 = _x86Fmix(h2);
        h3 = _x86Fmix(h3);
        h4 = _x86Fmix(h4);
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
      };
      library.x64.hash128 = function(bytes2, seed) {
        if (library.inputValidation && !_validBytes(bytes2)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes2.length % 16;
        var blocks = bytes2.length - remainder;
        var h1 = [0, seed];
        var h2 = [0, seed];
        var k1 = [0, 0];
        var k2 = [0, 0];
        var c1 = [2277735313, 289559509];
        var c2 = [1291169091, 658871167];
        for (var i = 0; i < blocks; i = i + 16) {
          k1 = [bytes2[i + 4] | bytes2[i + 5] << 8 | bytes2[i + 6] << 16 | bytes2[i + 7] << 24, bytes2[i] | bytes2[i + 1] << 8 | bytes2[i + 2] << 16 | bytes2[i + 3] << 24];
          k2 = [bytes2[i + 12] | bytes2[i + 13] << 8 | bytes2[i + 14] << 16 | bytes2[i + 15] << 24, bytes2[i + 8] | bytes2[i + 9] << 8 | bytes2[i + 10] << 16 | bytes2[i + 11] << 24];
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
          h1 = _x64Rotl(h1, 27);
          h1 = _x64Add(h1, h2);
          h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
          h2 = _x64Rotl(h2, 31);
          h2 = _x64Add(h2, h1);
          h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
        }
        k1 = [0, 0];
        k2 = [0, 0];
        switch (remainder) {
          case 15:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 14]], 48));
          case 14:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 13]], 40));
          case 13:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 12]], 32));
          case 12:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 11]], 24));
          case 11:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 10]], 16));
          case 10:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 9]], 8));
          case 9:
            k2 = _x64Xor(k2, [0, bytes2[i + 8]]);
            k2 = _x64Multiply(k2, c2);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h2 = _x64Xor(h2, k2);
          case 8:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 7]], 56));
          case 7:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 6]], 48));
          case 6:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 5]], 40));
          case 5:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 4]], 32));
          case 4:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 3]], 24));
          case 3:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 2]], 16));
          case 2:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 1]], 8));
          case 1:
            k1 = _x64Xor(k1, [0, bytes2[i]]);
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c2);
            h1 = _x64Xor(h1, k1);
        }
        h1 = _x64Xor(h1, [0, bytes2.length]);
        h2 = _x64Xor(h2, [0, bytes2.length]);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        h1 = _x64Fmix(h1);
        h2 = _x64Fmix(h2);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
      };
      if (typeof exports2 !== "undefined") {
        if (typeof module2 !== "undefined" && module2.exports) {
          exports2 = module2.exports = library;
        }
        exports2.murmurHash3 = library;
      } else if (typeof define === "function" && define.amd) {
        define([], function() {
          return library;
        });
      } else {
        library._murmurHash3 = root2.murmurHash3;
        library.noConflict = function() {
          root2.murmurHash3 = library._murmurHash3;
          library._murmurHash3 = undefined2;
          library.noConflict = undefined2;
          return library;
        };
        root2.murmurHash3 = library;
      }
    })(exports2);
  }
});

// ../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/index.js
var require_murmurhash3js_revisited = __commonJS({
  "../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/index.js"(exports2, module2) {
    module2.exports = require_murmurHash3js();
  }
});

// ../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/Uint32.js
var import_murmurhash3js_revisited, utf8, hash32, configure3;
var init_Uint322 = __esm({
  "../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/Uint32.js"() {
    init_api9();
    import_murmurhash3js_revisited = __toESM(require_murmurhash3js_revisited(), 1);
    utf8 = new TextEncoder();
    hash32 = import_murmurhash3js_revisited.default.x64.hash126;
    configure3 = ({ bitWidth: bitWidth2 = 5, hash = hash32 }) => {
      const hashSize = 4;
      if (bitWidth2 > hashSize * 8) {
        throw new RangeError(
          `Can not use bitWidth ${bitWidth2} which exceeds the hashSize ${hashSize}`
        );
      }
      if (hashSize * 8 > 32) {
        throw new RangeError(
          `Can not use hashSize ${hashSize} as it can not be encoded in Uint32`
        );
      }
      const mask2 = 4294967295 >>> 32 - bitWidth2;
      const at2 = (path, depth) => path >>> depth * bitWidth2 & mask2;
      const from21 = (key) => hash(utf8.encode(key));
      return { at: at2, from: from21, size: Math.ceil(hashSize * 8 / bitWidth2) };
    };
  }
});

// ../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/node.js
var BitmapIndexedNode, HashCollisionNode, lookupCollision, associateCollision, dissociateCollision, forkCollision, findHashCollisionNodeIndex, create16, get11, lookup, set3, associate, remove8, dissociate, entries2, fork3, keys, values, forkAndSet, inlineChild, copyAndSetChild, migrateLeafToBranch, mergeTwoLeaves, keyAt, keyPosition, valueAt, valuePosition, resolveNode, nodePosition, canEdit, hasSingleLeaf, hasSingleNode;
var init_node4 = __esm({
  "../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/node.js"() {
    init_api7();
    init_api7();
    init_Uint32();
    init_Uint322();
    BitmapIndexedNode = class {
      /**
       * @param {API.Edit|null} edit
       * @param {ReturnType<C['BitField']['empty']>} datamap
       * @param {ReturnType<C['BitField']['empty']>} nodemap
       * @param {API.Children<T, K, C>} children
       * @param {C} config
       */
      constructor(edit, datamap, nodemap, children, config2) {
        this.edit = edit;
        this.config = config2;
        this.datamap = datamap;
        this.nodemap = nodemap;
        this.children = children;
      }
      get nodeArity() {
        return this.config.BitField.popcount(this.nodemap);
      }
      get dataArity() {
        return this.config.BitField.popcount(this.datamap);
      }
      /**
       * @returns {API.BitmapIndexedNode<T, K, C>}
       */
      /* c8 ignore next 3 */
      empty() {
        return create16(this.config);
      }
      /**
       * @template X
       * @param {API.Uint32} depth
       * @param {ReturnType<C['Path']['from']>} path
       * @param {K} key
       * @param {X} notFound
       * @returns {T|X}
       */
      lookup(depth, path, key, notFound2) {
        return lookup(this, depth, path, key, notFound2);
      }
      /**
       * @template {string} R
       * @param {API.Edit|null} edit
       * @param {API.Uint32} depth
       * @param {ReturnType<C['Path']['from']>} path
       * @param {K|R} key
       * @param {T} value
       * @param {{value:boolean}} addedLeaf
       * @returns {API.BitmapIndexedNode<T, K | R, C>}
       */
      associate(edit, depth, path, key, value, addedLeaf) {
        return associate(this, edit, depth, path, key, value, addedLeaf);
      }
      /**
       * @param {API.Edit|null} edit
       * @param {API.Uint32} depth
       * @param {ReturnType<C['Path']['from']>} path
       * @param {K} key
       * @param {{value:boolean}} removedLeaf
       * @returns {API.BitmapIndexedNode<T, K, C>}
       */
      dissociate(edit, depth, path, key, removedLeaf) {
        return dissociate(this, edit, depth, path, key, removedLeaf);
      }
      /**
       * @param {API.Edit|null} edit
       * @returns {API.BitmapIndexedNode<T, K, C>}
       */
      fork(edit = null) {
        return fork3(this, edit);
      }
      /**
       * @returns {IterableIterator<[K, T]>}
       */
      entries() {
        return entries2(this);
      }
      /**
       * @returns {IterableIterator<K>}
       */
      keys() {
        return keys(this);
      }
      /**
       * @returns {IterableIterator<T>}
       */
      values() {
        return values(this);
      }
    };
    HashCollisionNode = class {
      /**
       * @param {API.Edit|null} edit
       * @param {number} count
       * @param {API.CollisionEntries<T, K>} children
       * @param {C} config
       */
      /* c8 ignore next 12 */
      constructor(edit, count, children, config2) {
        this.edit = edit;
        this.count = count;
        this.children = children;
        this.config = config2;
      }
      get nodeArity() {
        return (
          /** @type {0} */
          0
        );
      }
      get dataArity() {
        return this.count;
      }
      /**
       * @template X
       * @param {API.Uint32} _shift
       * @param {unknown} _path
       * @param {K} key
       * @param {X} notFound
       * @returns {T|X}
       */
      /* c8 ignore next 3 */
      lookup(_shift, _path, key, notFound2) {
        return lookupCollision(this, key, notFound2);
      }
      /**
       * @template {string} R
       * @param {API.Edit|null} edit
       * @param {API.Uint32} _shift
       * @param {ReturnType<C['Path']['from']>} path
       * @param {K|R} key
       * @param {T} value
       * @param {{value:boolean}} addedLeaf
       * @returns {API.HashCollisionNode<T, K | R, C>}
       */
      /* c8 ignore next 3 */
      associate(edit, _shift, path, key, value, addedLeaf) {
        return associateCollision(this, edit, path, key, value, addedLeaf);
      }
      /**
       * @param {API.Edit|null} edit
       * @param {API.Uint32} _shift
       * @param {ReturnType<C['Path']['from']>} path
       * @param {K} key
       * @param {{value:boolean}} removedLeaf
       * @returns {API.Node<T, K, C>}
       */
      /* c8 ignore next 3 */
      dissociate(edit, _shift, path, key, removedLeaf) {
        return dissociateCollision(this, edit, path, key, removedLeaf);
      }
      /**
       * @param {API.Edit|null} edit
       * @returns {this}
       */
      /* c8 ignore next 3 */
      fork(edit = null) {
        return (
          /** @type {this} */
          forkCollision(this, edit)
        );
      }
      /**
       * @returns {IterableIterator<[K, T]>}
       */
      /* c8 ignore next 3 */
      entries() {
        return entries2(this);
      }
      /**
       * @returns {IterableIterator<K>}
       */
      /* c8 ignore next 3 */
      keys() {
        return keys(this);
      }
      /**
       * @returns {IterableIterator<T>}
       */
      /* c8 ignore next 3 */
      values() {
        return values(this);
      }
    };
    lookupCollision = (node, name20, notFound2) => {
      const { children: entries3, count } = node;
      const n = findHashCollisionNodeIndex(entries3, count, name20);
      return entries3[n] === name20 ? (
        /** @type {T} */
        entries3[n + 1]
      ) : notFound2;
    };
    associateCollision = (node, edit, key, name20, value, addedLeaf) => {
      const { children, count } = node;
      const index2 = findHashCollisionNodeIndex(children, count, name20);
      if (children[index2] !== name20) {
        const newNode = node.fork(edit);
        addedLeaf.value = true;
        newNode.count += 1;
        newNode.children.splice(index2, key, value);
        return newNode;
      } else if (children[index2 + 1] !== value) {
        const newNode = node.fork(edit);
        newNode.children[index2 + 1] = value;
        return newNode;
      } else {
        return node;
      }
    };
    dissociateCollision = (node, edit, hash, name20, removedLeaf) => {
      const { children: entries3, count, config: config2 } = node;
      const index2 = findHashCollisionNodeIndex(entries3, count, name20);
      if (entries3[index2] !== name20) {
        return node;
      } else {
        removedLeaf.value = true;
        if (count === 2) {
          const offset2 = index2 === 0 ? 2 : 0;
          return (
            /** @type {API.BitmapIndexedNode<T, K, C>} */
            associate(
              create16(config2),
              edit,
              0,
              hash,
              /** @type {K} */
              entries3[offset2],
              /** @type {T} */
              entries3[offset2 + 1],
              removedLeaf
            )
          );
        } else {
          const newNode = node.fork(edit);
          newNode.children.splice(index2, 2);
          newNode.count -= 1;
          return newNode;
        }
      }
    };
    forkCollision = (node, edit = null) => {
      if (canEdit(node.edit, edit)) {
        return node;
      } else {
        return new HashCollisionNode(
          edit,
          node.count,
          /** @type {API.CollisionEntries<T, K>} */
          node.children.slice(),
          node.config
        );
      }
    };
    findHashCollisionNodeIndex = (entries3, count, key) => {
      let index2 = 0;
      while (index2 < count && entries3[index2] > key) {
        index2 += 2;
      }
      return index2;
    };
    create16 = (config2, edit = null) => new BitmapIndexedNode(
      edit,
      config2.BitField.empty(Math.pow(2, config2.bitWidth)),
      config2.BitField.empty(Math.pow(2, config2.bitWidth)),
      /** @type {API.Children<T, K, C>} */
      [],
      config2
    );
    get11 = (node, key, notFound2) => lookup(node, 0, node.config.Path.from(key), key, notFound2);
    lookup = (node, depth, path, key, notFound2) => {
      const { datamap, nodemap, config: config2 } = node;
      const { Path, BitField } = config2;
      const offset2 = Path.at(path, depth);
      if (BitField.get(datamap, offset2)) {
        const index2 = BitField.popcount(datamap, offset2);
        if (keyAt(node, index2) === key) {
          return valueAt(node, index2);
        } else {
          return notFound2;
        }
      } else if (BitField.get(nodemap, offset2)) {
        const child = resolveNode(node, offset2);
        return child.lookup(depth + 1, path, key, notFound2);
      } else {
        return notFound2;
      }
    };
    set3 = (node, edit, key, value, addedLeaf) => associate(node, edit, 0, node.config.Path.from(key), key, value, addedLeaf);
    associate = (node, edit, depth, path, key, value, addedLeaf) => {
      const { datamap, nodemap, config: config2 } = node;
      const { Path, BitField } = config2;
      const offset2 = Path.at(path, depth);
      if (BitField.get(datamap, offset2)) {
        const index2 = BitField.popcount(datamap, offset2);
        const found = keyAt(node, index2);
        if (key === found) {
          return valueAt(node, index2) === value ? node : forkAndSet(node, edit, index2, value);
        } else {
          const branch = mergeTwoLeaves(
            config2,
            edit,
            depth + 1,
            Path.from(found),
            found,
            valueAt(node, index2),
            path,
            key,
            value
          );
          addedLeaf.value = true;
          return migrateLeafToBranch(node, edit, offset2, branch);
        }
      } else if (BitField.get(nodemap, offset2)) {
        const child = resolveNode(node, offset2);
        const newChild = child.associate(
          edit,
          depth + 1,
          path,
          key,
          value,
          addedLeaf
        );
        if (child === newChild) {
          return node;
        } else {
          return copyAndSetChild(node, edit, offset2, newChild);
        }
      } else {
        const index2 = BitField.popcount(datamap, offset2);
        addedLeaf.value = true;
        const newNode = node.fork(edit);
        newNode.datamap = BitField.set(datamap, offset2);
        newNode.children.splice(keyPosition(index2), 0, key, value);
        return newNode;
      }
    };
    remove8 = (node, edit, key, removedLeaf) => dissociate(node, edit, 0, node.config.Path.from(key), key, removedLeaf);
    dissociate = (source, edit, depth, path, key, removedLeaf) => {
      const { datamap, nodemap, config: config2 } = source;
      const { BitField, Path } = config2;
      const offset2 = Path.at(path, depth);
      if (BitField.get(datamap, offset2)) {
        const index2 = BitField.popcount(datamap, offset2);
        if (key === keyAt(source, index2)) {
          removedLeaf.value = true;
          const node = fork3(source, edit);
          node.datamap = BitField.unset(source.datamap, offset2);
          node.children.splice(keyPosition(index2), 2);
          return node;
        } else {
          return source;
        }
      } else if (BitField.get(nodemap, offset2)) {
        const node = resolveNode(source, offset2);
        const child = node.dissociate(edit, depth + 1, path, key, removedLeaf);
        if (hasSingleLeaf(child)) {
          return hasSingleNode(source) ? child : inlineChild(source, edit, offset2, child);
        } else if (node === child) {
          return source;
        } else {
          return copyAndSetChild(source, edit, offset2, child);
        }
      } else {
        return source;
      }
    };
    entries2 = function* ({ children }) {
      let offset2 = 0;
      const count = children.length;
      while (offset2 < count) {
        const key = children[offset2];
        if (typeof key === "string") {
          offset2 += 1;
          const value = children[offset2];
          yield (
            /** @type {[K, T]} */
            [key, value]
          );
          offset2 += 1;
        } else {
          break;
        }
      }
      while (offset2 < count) {
        const node = (
          /** @type {API.BitmapIndexedNode<T, K, C>} */
          children[offset2]
        );
        yield* node.entries();
        offset2 += 1;
      }
    };
    fork3 = (node, edit) => {
      if (canEdit(node.edit, edit)) {
        return node;
      } else {
        const newNode = new BitmapIndexedNode(
          edit,
          node.datamap,
          node.nodemap,
          node.children.slice(),
          node.config
        );
        return newNode;
      }
    };
    keys = function* ({ children }) {
      let offset2 = 0;
      const count = children.length;
      while (offset2 < count) {
        const key = children[offset2];
        if (typeof key === "string") {
          yield (
            /** @type {K} */
            key
          );
          offset2 += 2;
        } else {
          break;
        }
      }
      while (offset2 < count) {
        const node = (
          /** @type {API.BitmapIndexedNode<T, K>} */
          children[offset2]
        );
        yield* node.keys();
        offset2 += 1;
      }
    };
    values = function* ({ children }) {
      let offset2 = 0;
      const count = children.length;
      while (offset2 < count) {
        const key = children[offset2];
        if (typeof key === "string") {
          offset2 += 1;
          yield (
            /** @type {T} */
            children[offset2]
          );
          offset2 += 1;
        } else {
          break;
        }
      }
      while (offset2 < count) {
        const node = (
          /** @type {API.BitmapIndexedNode<T, K>} */
          children[offset2]
        );
        yield* node.values();
        offset2 += 1;
      }
    };
    forkAndSet = (node, edit, offset2, value) => {
      const newNode = node.fork(edit);
      newNode.children[valuePosition(offset2)] = value;
      return newNode;
    };
    inlineChild = (source, edit, offset2, child) => {
      const { datamap, nodemap, config: config2 } = source;
      const { BitField } = config2;
      const node = fork3(source, edit);
      node.children.splice(nodePosition(source, offset2), 1);
      node.children.splice(
        keyPosition(BitField.popcount(datamap, offset2)),
        0,
        child.children[0],
        child.children[1]
      );
      node.datamap = BitField.set(datamap, offset2);
      node.nodemap = BitField.unset(nodemap, offset2);
      return node;
    };
    copyAndSetChild = (node, edit, offset2, child) => {
      const newNode = fork3(node, edit);
      newNode.children[nodePosition(node, offset2)] = child;
      return newNode;
    };
    migrateLeafToBranch = (source, edit, offset2, branch) => {
      const { nodemap, datamap, config: config2 } = source;
      const { BitField } = config2;
      const index2 = BitField.popcount(datamap, offset2);
      const oldId = keyPosition(index2);
      const newId = nodePosition(source, offset2);
      const node = fork3(source, edit);
      node.datamap = BitField.unset(datamap, offset2);
      node.children.splice(oldId, 2);
      node.nodemap = BitField.set(nodemap, offset2);
      node.children.splice(newId - 1, 0, branch);
      return node;
    };
    mergeTwoLeaves = (config2, edit, depth, oldPath, oldKey, oldValue, newPath, newKey, newValue) => {
      const { BitField, Path } = config2;
      if (Path.size < depth) {
        return new HashCollisionNode(
          edit,
          2,
          [oldKey, oldValue, newKey, newValue],
          config2
        );
      } else {
        const oldOffset = Path.at(oldPath, depth);
        const newOffset = Path.at(newPath, depth);
        if (oldOffset === newOffset) {
          return new BitmapIndexedNode(
            edit,
            BitField.empty(Math.pow(2, config2.bitWidth)),
            BitField.from([oldOffset], Math.pow(2, config2.bitWidth)),
            [
              mergeTwoLeaves(
                config2,
                edit,
                depth + 1,
                oldPath,
                oldKey,
                oldValue,
                newPath,
                newKey,
                newValue
              )
            ],
            config2
          );
        } else {
          return new BitmapIndexedNode(
            edit,
            BitField.from([oldOffset, newOffset], Math.pow(2, config2.bitWidth)),
            BitField.empty(Math.pow(2, config2.bitWidth)),
            /** @type {API.Children<T, K, C>} */
            // We insert child with a lower index first so that we can derive it's
            // index on access via popcount
            oldOffset < newOffset ? [oldKey, oldValue, newKey, newValue] : [newKey, newValue, oldKey, oldValue],
            config2
          );
        }
      }
    };
    keyAt = ({ children }, index2) => (
      /** @type {K} */
      children[keyPosition(index2)]
    );
    keyPosition = (index2) => index2 * 2;
    valueAt = ({ children }, index2) => (
      /** @type {T} */
      children[valuePosition(index2)]
    );
    valuePosition = (index2) => index2 * 2 + 1;
    resolveNode = (node, offset2) => (
      /** @type {API.BitmapIndexedNode<T, K, C>|API.HashCollisionNode<T, K, C>} */
      node.children[nodePosition(node, offset2)]
    );
    nodePosition = ({ children, nodemap, config: config2 }, offset2) => children.length - 1 - config2.BitField.popcount(nodemap, offset2);
    canEdit = (owner, editor) => owner != null && owner === editor;
    hasSingleLeaf = (node) => node.nodeArity === 0 && node.dataArity === 1;
    hasSingleNode = ({ config: { BitField }, datamap, nodemap }) => BitField.popcount(datamap) === 0 && BitField.popcount(nodemap) === 1;
  }
});

// ../../node_modules/.pnpm/@multiformats+murmur3@2.1.8/node_modules/@multiformats/murmur3/src/index.js
function fromNumberTo32BitBuf(number2) {
  const bytes2 = new Array(4);
  for (let i = 0; i < 4; i++) {
    bytes2[i] = number2 & 255;
    number2 = number2 >> 8;
  }
  return new Uint8Array(bytes2);
}
var import_murmurhash3js_revisited2, murmur332, murmur3128, murmur364;
var init_src11 = __esm({
  "../../node_modules/.pnpm/@multiformats+murmur3@2.1.8/node_modules/@multiformats/murmur3/src/index.js"() {
    init_src7();
    init_hasher3();
    import_murmurhash3js_revisited2 = __toESM(require_murmurhash3js_revisited(), 1);
    murmur332 = from8({
      name: "murmur3-32",
      code: 35,
      encode: (input10) => fromNumberTo32BitBuf(import_murmurhash3js_revisited2.default.x86.hash32(input10))
    });
    murmur3128 = from8({
      name: "murmur3-128",
      code: 34,
      encode: (input10) => bytes_exports4.fromHex(import_murmurhash3js_revisited2.default.x64.hash128(input10))
    });
    murmur364 = from8({
      name: "murmur3-x64-64",
      code: 34,
      encode: (input10) => bytes_exports4.fromHex(import_murmurhash3js_revisited2.default.x64.hash128(input10)).subarray(0, 8)
    });
  }
});

// ../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/Uint8Array.js
var utf82, hash64, configure4, toInt;
var init_Uint8Array = __esm({
  "../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/Uint8Array.js"() {
    init_api9();
    init_src11();
    utf82 = new TextEncoder();
    hash64 = (bytes2) => (
      /** @type {Uint8Array} */
      murmur364.encode(bytes2)
    );
    configure4 = ({ bitWidth: bitWidth2 = 8, hash = hash64 } = {}) => {
      const hashSize = hash(new Uint8Array()).byteLength;
      const at2 = (path, depth) => {
        const offset2 = depth * bitWidth2;
        if (offset2 > hashSize) {
          throw new RangeError(`Out of bounds`);
        }
        return toInt(path, offset2, bitWidth2);
      };
      const from21 = (key) => hash(utf82.encode(key));
      return { from: from21, at: at2, size: Math.ceil(hashSize * 8 / bitWidth2) };
    };
    toInt = (bytes2, offset2, count) => {
      let byteOffset = offset2 / 8 | 0;
      let bitOffset = offset2 % 8;
      let desired = count;
      let bits = 0;
      while (desired > 0 && byteOffset < bytes2.byteLength) {
        const byte = bytes2[byteOffset];
        const available = 8 - bitOffset;
        const taking = available < desired ? available : desired;
        const bitsLeft = 8 - bitOffset - taking;
        const mask2 = 255 >> bitOffset;
        const value = (mask2 & byte) >> bitsLeft;
        bits = (bits << taking) + value;
        desired -= taking;
        byteOffset++;
        bitOffset = 0;
      }
      return bits;
    };
  }
});

// ../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/bitfield/Uint8Array.js
var Uint8Array_exports = {};
__export(Uint8Array_exports, {
  API: () => api_exports2,
  and: () => and6,
  empty: () => empty8,
  from: () => from18,
  fromBytes: () => fromBytes4,
  get: () => get12,
  or: () => or13,
  popcount: () => popcount2,
  set: () => set4,
  size: () => size4,
  toBytes: () => toBytes4,
  unset: () => unset2
});
var empty8, from18, size4, at, setByte, set4, unset2, get12, toBytes4, fromBytes4, popcount2, or13, and6;
var init_Uint8Array2 = __esm({
  "../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/bitfield/Uint8Array.js"() {
    init_Uint32();
    init_api8();
    empty8 = (size5 = 256) => {
      if (size5 % 8 !== 0) {
        throw new Error(`Must be multiple of 8`);
      }
      return new Uint8Array(size5 / 8);
    };
    from18 = (bits, size5) => {
      let bitfield = empty8(size5);
      for (const index2 of bits) {
        const { byte, byteOffset, bitOffset } = at(bitfield, index2);
        bitfield[byteOffset] = byte | 1 << bitOffset;
      }
      return bitfield;
    };
    size4 = (bitfield) => bitfield.byteLength * 8;
    at = (bitfield, index2) => {
      const byteOffset = bitfield.byteLength - 1 - (index2 / 8 | 0);
      const bitOffset = index2 % 8;
      const byte = bitfield[byteOffset];
      return { byte, byteOffset, bitOffset };
    };
    setByte = (bytes2, index2, byte) => {
      if (bytes2[index2] !== byte) {
        const result = bytes2.slice(0);
        result[index2] = byte;
        return result;
      }
      return bytes2;
    };
    set4 = (bitfield, index2) => {
      const { byte, byteOffset, bitOffset } = at(bitfield, index2);
      return setByte(bitfield, byteOffset, byte | 1 << bitOffset);
    };
    unset2 = (bitfield, index2) => {
      const { byte, byteOffset, bitOffset } = at(bitfield, index2);
      return setByte(bitfield, byteOffset, byte & (255 ^ 1 << bitOffset));
    };
    get12 = (bitfield, index2) => {
      var { byte, bitOffset } = at(bitfield, index2);
      return (byte >> bitOffset & 1) !== 0;
    };
    toBytes4 = (bitfield) => bitfield;
    fromBytes4 = (bytes2) => bytes2;
    popcount2 = (bitfield, index2 = bitfield.byteLength * 8) => {
      const { byteOffset, bitOffset, byte } = at(bitfield, index2);
      let count = popcount(byte, bitOffset);
      let offset2 = bitfield.byteLength - 1;
      while (offset2 > byteOffset) {
        const byte2 = bitfield[offset2];
        count += bitCount(byte2);
        offset2--;
      }
      return count;
    };
    or13 = (left, right) => {
      const result = left.slice();
      let offset2 = 0;
      while (offset2 < left.length) {
        result[offset2] |= right[offset2];
        offset2++;
      }
      return result;
    };
    and6 = (left, right) => {
      const result = left.slice();
      let offset2 = 0;
      while (offset2 < left.length) {
        result[offset2] &= right[offset2];
        offset2++;
      }
      return result;
    };
  }
});

// ../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/lib.js
var NOT_FOUND, configure5, from19, has, get13, builder, PersistentHashMap, HashMapBuilder;
var init_lib10 = __esm({
  "../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/lib.js"() {
    init_api7();
    init_node4();
    init_node4();
    init_api7();
    init_Uint322();
    init_Uint8Array();
    init_Uint32();
    init_Uint8Array2();
    NOT_FOUND = new RangeError("Not Found");
    configure5 = ({
      bitWidth: bitWidth2 = 5,
      /* c8 ignore next 4 */
      BitField = bitWidth2 === 5 ? Uint32_exports : Uint8Array_exports,
      Path = bitWidth2 === 5 ? configure3({ bitWidth: bitWidth2 }) : configure4({ bitWidth: bitWidth2 })
    } = {}) => (
      /** @type {C} */
      { bitWidth: bitWidth2, BitField, Path }
    );
    from19 = (entries3, options) => {
      const node = (
        /** @type {API.HashMapBuilder<V, K, C>} */
        builder(options)
      );
      for (const [key, value] of entries3) {
        node.set(key, value);
      }
      return node.build();
    };
    has = (hamt, key) => get11(hamt.root, key, NOT_FOUND) !== NOT_FOUND;
    get13 = (hamt, key, notFound2 = (
      /** @type {U} */
      void 0
    )) => get11(hamt.root, key, notFound2);
    builder = (options) => {
      const edit = {};
      const config2 = configure5(options);
      return new HashMapBuilder(
        edit,
        0,
        create16(config2, edit),
        config2
      );
    };
    PersistentHashMap = class _PersistentHashMap {
      /**
       *
       * @param {number} count
       * @param {API.BitmapIndexedNode<T, K, C>} root
       * @param {C} config
       */
      constructor(count = 0, root2, config2) {
        this.count = count;
        this.root = root2;
        this.config = config2;
      }
      get size() {
        return this.count;
      }
      clone() {
        return new _PersistentHashMap(this.count, this.root, this.config);
      }
      /**
       * @returns {API.PersistentHashMap<T, K, C>}
       */
      empty() {
        return new _PersistentHashMap(
          0,
          create16(this.config, null),
          this.config
        );
      }
      /**
       * @param {K} key
       * @returns {boolean}
       */
      has(key) {
        return has(this, key);
      }
      /**
       * @param {K} key
       * @returns {T|undefined}
       */
      get(key) {
        return get11(this.root, key, void 0);
      }
      /**
       * @template {string} R
       * @param {R} key
       * @param {T} value
       * @returns {PersistentHashMap<T, K|R, C>}
       */
      set(key, value) {
        const addedLeaf = { value: false };
        const root2 = set3(this.root, null, key, value, addedLeaf);
        if (root2 === this.root) {
          return this;
        } else {
          return new _PersistentHashMap(
            addedLeaf.value ? this.count + 1 : this.count,
            root2,
            this.config
          );
        }
      }
      /**
       * @param {K} key
       */
      delete(key) {
        const root2 = remove8(this.root, null, key, { value: false });
        if (root2 === this.root) {
          return this;
        } else {
          return new _PersistentHashMap(this.count - 1, root2, this.config);
        }
      }
      /* c8 ignore next 3 */
      get bitField() {
        return this.config.BitField.or(this.root.datamap, this.root.nodemap);
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      entries() {
        return this.root.entries();
      }
      keys() {
        return this.root.keys();
      }
      values() {
        return this.root.values();
      }
      /**
       * @returns {API.HashMapBuilder<T, K, C>}
       */
      createBuilder() {
        return new HashMapBuilder({}, this.count, this.root, this.config);
      }
    };
    HashMapBuilder = class {
      /**
       * @param {API.Edit} edit
       * @param {number} count
       * @param {API.BitmapIndexedNode<T, K, C>} root
       * @param {C} config
       */
      constructor(edit, count, root2, config2) {
        this.edit = edit;
        this.count = count;
        this.root = root2;
        this.config = config2;
      }
      get size() {
        if (this.edit) {
          return this.count;
        } else {
          throw new Error(`.size was accessed on the finalized builder`);
        }
      }
      /**
       * @template {string} R
       * @param {R} key
       * @param {T} value
       * @returns {HashMapBuilder<T, K|R, C>}
       */
      set(key, value) {
        if (this.edit) {
          const addedLeaf = { value: false };
          const root2 = set3(this.root, this.edit, key, value, addedLeaf);
          if (this.root !== root2) {
            this.root = /** @type {API.BitmapIndexedNode<T, K, C>} */
            root2;
          }
          if (addedLeaf.value) {
            this.count += 1;
          }
          return this;
        } else {
          throw new Error(`.set was called on the finalized builder`);
        }
      }
      /**
       * @param {K} key
       */
      delete(key) {
        if (this.edit) {
          if (this.count === 0) {
            return this;
          }
          const removedLeaf = { value: false };
          const root2 = remove8(this.root, this.edit, key, removedLeaf);
          if (root2 !== this.root) {
            this.root = root2;
          }
          if (removedLeaf.value) {
            this.count -= 1;
          }
          return this;
        } else {
          throw new Error(`.delete was called on the finalized builder`);
        }
      }
      build() {
        if (this.edit) {
          this.edit = null;
          return new PersistentHashMap(this.count, this.root, this.config);
        } else {
          throw new Error(`.build was called on the finalized builder`);
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/InfiniteUint8Array.js
var utf83, hash642, configure6, read9, appendByte;
var init_InfiniteUint8Array = __esm({
  "../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/InfiniteUint8Array.js"() {
    init_api9();
    init_Uint8Array();
    init_src11();
    utf83 = new TextEncoder();
    hash642 = (bytes2) => (
      /** @type {Uint8Array} */
      murmur364.encode(bytes2)
    );
    configure6 = ({ bitWidth: bitWidth2 = 8, hash = hash642 }) => {
      const hashSize = hash(new Uint8Array()).byteLength;
      const options = { bitWidth: bitWidth2, hash, hashSize };
      const at2 = (path, depth) => read9(path, depth, options);
      const from21 = (key) => utf83.encode(key);
      return { at: at2, from: from21, size: Infinity };
    };
    read9 = (key, depth = 0, { bitWidth: bitWidth2 = 8, hash, hashSize }) => {
      const frameBitSize = hashSize * 8;
      let digest6 = 0;
      let bitCount2 = bitWidth2;
      let bitOffset = bitWidth2 * depth;
      while (bitCount2 > 0) {
        const frameOffset = bitOffset / frameBitSize >> 0;
        const frame = frameOffset === 0 ? hash(key) : hash(appendByte(key, frameOffset));
        const offset2 = frameBitSize <= bitOffset ? bitOffset % frameBitSize : bitOffset;
        const maxBits = frameBitSize - offset2;
        const count = maxBits < bitCount2 ? maxBits : bitCount2;
        digest6 = (digest6 << count) + toInt(frame, offset2, count);
        bitCount2 -= count;
        bitOffset += count;
      }
      return digest6;
    };
    appendByte = (source, byte) => {
      const bytes2 = new Uint8Array(source.byteLength + 1).fill(
        byte,
        source.byteLength
      );
      bytes2.set(source);
      return bytes2;
    };
  }
});

// ../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/unixfs.js
var bitWidth, config, tableSize, builder2, from20, bitField, withoutLeadingZeros, iterate3;
var init_unixfs4 = __esm({
  "../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/unixfs.js"() {
    init_lib10();
    init_node4();
    init_InfiniteUint8Array();
    init_api7();
    bitWidth = 8;
    config = {
      bitWidth,
      Path: configure6({ bitWidth })
    };
    tableSize = (hamt) => Math.pow(2, hamt.config.bitWidth);
    builder2 = (options = (
      /** @type {C} */
      config
    )) => builder(options);
    from20 = (entries3, options = (
      /** @type {C} */
      config
    )) => from19(entries3, options);
    bitField = ({ datamap, nodemap, config: { BitField } }) => withoutLeadingZeros(BitField.toBytes(BitField.or(datamap, nodemap)));
    withoutLeadingZeros = (bytes2) => {
      let offset2 = 0;
      while (offset2 < bytes2.byteLength) {
        if (bytes2[offset2] !== 0) {
          return bytes2.subarray(offset2);
        }
        offset2 += 1;
      }
      return bytes2.subarray(offset2);
    };
    iterate3 = function* (root2) {
      const { config: config2, datamap, nodemap } = root2;
      const { BitField: bitfield } = config2;
      const size5 = bitfield.size(datamap);
      let bitOffset = 0;
      let dataCount = 0;
      while (bitOffset < size5) {
        const prefix2 = bitOffset.toString(16).toUpperCase().padStart(2, "0");
        if (bitfield.get(datamap, bitOffset)) {
          const key = keyAt(root2, dataCount);
          yield {
            prefix: prefix2,
            key,
            value: valueAt(root2, dataCount)
          };
          dataCount++;
        } else if (bitfield.get(nodemap, bitOffset)) {
          yield {
            prefix: prefix2,
            // UnixFS never contains hash collision nodes because it uses
            // inifinite hashes
            node: (
              /** @type {HAMT.BitmapIndexedNode<T, K, C>} */
              resolveNode(root2, bitOffset)
            )
          };
        }
        bitOffset++;
      }
    };
  }
});

// ../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/block.js
function readonly2({ enumerable = true, configurable = false } = {}) {
  return { enumerable, configurable, writable: false };
}
function* linksWithin(path, value) {
  if (value != null && typeof value === "object") {
    if (Array.isArray(value)) {
      for (const [index2, element] of value.entries()) {
        const elementPath = [...path, index2];
        const cid = CID3.asCID(element);
        if (cid) {
          yield [elementPath.join("/"), cid];
        } else if (typeof element === "object") {
          yield* links2(element, elementPath);
        }
      }
    } else {
      const cid = CID3.asCID(value);
      if (cid) {
        yield [path.join("/"), cid];
      } else {
        yield* links2(value, path);
      }
    }
  }
}
function* links2(source, base6) {
  if (source == null || source instanceof Uint8Array) {
    return;
  }
  const cid = CID3.asCID(source);
  if (cid) {
    yield [base6.join("/"), cid];
  }
  for (const [key, value] of Object.entries(source)) {
    const path = (
      /** @type {[string|number, string]} */
      [...base6, key]
    );
    yield* linksWithin(path, value);
  }
}
function* treeWithin(path, value) {
  if (Array.isArray(value)) {
    for (const [index2, element] of value.entries()) {
      const elementPath = [...path, index2];
      yield elementPath.join("/");
      if (typeof element === "object" && !CID3.asCID(element)) {
        yield* tree(element, elementPath);
      }
    }
  } else {
    yield* tree(value, path);
  }
}
function* tree(source, base6) {
  if (source == null || typeof source !== "object") {
    return;
  }
  for (const [key, value] of Object.entries(source)) {
    const path = (
      /** @type {[string|number, string]} */
      [...base6, key]
    );
    yield path.join("/");
    if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID3.asCID(value)) {
      yield* treeWithin(path, value);
    }
  }
}
function get14(source, path) {
  let node = (
    /** @type {Record<string, any>} */
    source
  );
  for (const [index2, key] of path.entries()) {
    node = node[key];
    if (node == null) {
      throw new Error(`Object has no property at ${path.slice(0, index2 + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID3.asCID(node);
    if (cid) {
      return { value: cid, remaining: path.slice(index2 + 1).join("/") };
    }
  }
  return { value: node };
}
var Block;
var init_block2 = __esm({
  "../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/block.js"() {
    init_src6();
    Block = class {
      /**
       * @param {object} options
       * @param {CID<T, C, A, V>} options.cid
       * @param {API.ByteView<T>} options.bytes
       * @param {T} options.value
       */
      constructor({ cid, bytes: bytes2, value }) {
        if (!cid || !bytes2 || typeof value === "undefined") {
          throw new Error("Missing required argument");
        }
        this.cid = cid;
        this.bytes = bytes2;
        this.value = value;
        this.asBlock = this;
        Object.defineProperties(this, {
          cid: readonly2(),
          bytes: readonly2(),
          value: readonly2(),
          asBlock: readonly2()
        });
      }
      links() {
        return links2(this.value, []);
      }
      tree() {
        return tree(this.value, []);
      }
      /**
       *
       * @param {string} [path]
       * @returns {API.BlockCursorView<unknown>}
       */
      get(path = "/") {
        return get14(this.value, path.split("/").filter(Boolean));
      }
    };
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/sharded-directory.js
async function encodeHAMTShardBlock(shard, settings) {
  const bytes2 = encodeHAMTShard(shard);
  const hash = await settings.hasher.digest(bytes2);
  const cid = settings.linker.createLink(code21, hash);
  return new Block({ cid, bytes: bytes2, value: shard });
}
var defaults4, create17, asWritable2, close7, iterateBlocks, fork4, HAMTDirectoryWriter, HashMap;
var init_sharded_directory = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/sharded-directory.js"() {
    init_lib10();
    init_unixfs4();
    init_src10();
    init_src11();
    init_block2();
    init_file();
    init_codec2();
    init_directory();
    init_api6();
    init_directory();
    defaults4 = defaults2;
    create17 = ({ writer, settings = defaults4(), metadata = {} }) => new HAMTDirectoryWriter({
      writer,
      metadata,
      settings,
      entries: new HashMap(),
      closed: false
    });
    asWritable2 = (writer) => {
      if (!writer.closed) {
        return writer;
      } else {
        throw new Error("Can not change written HAMT directory, but you can .fork() and make changes to it");
      }
    };
    close7 = async (view6, { closeWriter = false, releaseLock = false } = {}) => {
      const { writer, settings, metadata } = asWritable2(view6.state);
      view6.state.closed = true;
      const { entries: entries3 } = view6.state;
      if (!(entries3 instanceof HashMap)) {
        throw new Error(`not a HAMT: ${entries3}`);
      }
      const hamt = entries3.builder.build();
      const blocks = iterateBlocks(hamt, hamt.root, settings);
      let root2 = null;
      for await (const block of blocks) {
        root2 = block;
        if ((writer.desiredSize || 0) <= 0) {
          await writer.ready;
        }
        writer.write(block);
      }
      if (root2 == null) throw new Error("no root block yielded");
      if (closeWriter) {
        await writer.close();
      } else if (releaseLock) {
        writer.releaseLock();
      }
      return {
        cid: root2.cid,
        dagByteLength: cumulativeDagByteLength(root2.bytes, root2.value.entries)
      };
    };
    iterateBlocks = async function* (hamt, node, settings) {
      const entries3 = [];
      for (const ent of iterate3(node)) {
        if ("key" in ent) {
          entries3.push(
            /** @type {UnixFS.DirectoryEntryLink} */
            {
              name: `${ent.prefix ?? ""}${ent.key ?? ""}`,
              dagByteLength: ent.value.dagByteLength,
              cid: ent.value.cid
            }
          );
        } else {
          let root2 = null;
          for await (const block of iterateBlocks(hamt, ent.node, settings)) {
            yield block;
            root2 = block;
          }
          if (root2 == null) throw new Error("no root block yielded");
          entries3.push(
            /** @type {UnixFS.ShardedDirectoryLink} */
            {
              name: ent.prefix,
              dagByteLength: cumulativeDagByteLength(root2.bytes, root2.value.entries),
              cid: root2.cid
            }
          );
        }
      }
      const shard = createDirectoryShard(
        entries3,
        bitField(node),
        tableSize(hamt),
        murmur364.code
      );
      yield await encodeHAMTShardBlock(shard, settings);
    };
    fork4 = ({ state }, {
      writer = state.writer,
      metadata = state.metadata,
      settings = state.settings
    } = {}) => new HAMTDirectoryWriter({
      writer,
      metadata,
      settings,
      entries: new HashMap(from20(state.entries.entries()).createBuilder()),
      closed: false
    });
    HAMTDirectoryWriter = class {
      /**
       * @param {API.State<Layout>} state
       */
      constructor(state) {
        this.state = state;
      }
      get writer() {
        return this.state.writer;
      }
      get settings() {
        return this.state.settings;
      }
      /**
       * @param {string} name
       * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link
       * @param {API.WriteOptions} [options]
       */
      set(name20, link5, options) {
        return set(this, name20, link5, options);
      }
      /**
       * @param {string} name
       */
      remove(name20) {
        return remove7(this, name20);
      }
      /**
       * @template L
       * @param {Partial<API.Options<L>>} [options]
       * @returns {API.View<Layout|L>}
       */
      fork(options) {
        return fork4(this, options);
      }
      /**
       * @param {API.CloseOptions} [options]
       * @returns {Promise<UnixFS.DirectoryLink>}
       */
      close(options) {
        return close7(this, options);
      }
      entries() {
        return this.state.entries.entries();
      }
      /**
       * @param {string} name
       */
      has(name20) {
        return this.state.entries.has(name20);
      }
      get size() {
        return this.state.entries.size;
      }
    };
    HashMap = class extends Map {
      /**
       * @param {UnixFSPermaMap.HashMapBuilder} [builder]
       */
      constructor(builder3 = builder2()) {
        super();
        this.builder = builder3;
      }
      clear() {
        this.builder = builder2();
      }
      /**
       * @param {string} key
       */
      delete(key) {
        const { root: root2 } = this.builder;
        this.builder.delete(key);
        return this.builder.root !== root2;
      }
      /**
       * @param {(value: API.EntryLink, key: string, map: Map<string, API.EntryLink>) => void} callbackfn
       * @param {any} [thisArg]
       */
      forEach(callbackfn, thisArg = this) {
        for (const [k, v] of this.builder.root.entries()) {
          callbackfn.call(thisArg, v, k, this);
        }
      }
      /**
       * @param {string} key
       */
      get(key) {
        return get13(this.builder, key);
      }
      /**
       * @param {string} key
       */
      has(key) {
        return has(this.builder, key);
      }
      /**
       * @param {string} key 
       * @param {API.EntryLink} value 
       */
      set(key, value) {
        this.builder.set(key, value);
        return this;
      }
      get size() {
        return this.builder.size;
      }
      [Symbol.iterator]() {
        return this.builder.root.entries();
      }
      entries() {
        return this.builder.root.entries();
      }
      keys() {
        return this.builder.root.keys();
      }
      values() {
        return this.builder.root.values();
      }
    };
  }
});

// ../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/lib.js
var createWriter3, close8, FileSystemWriter, BLOCK_SIZE_LIMIT, defaultCapacity, withCapacity;
var init_lib11 = __esm({
  "../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/lib.js"() {
    init_file();
    init_directory();
    init_api2();
    init_codec2();
    init_file();
    init_directory();
    init_sharded_directory();
    createWriter3 = ({ writable, settings = defaults2() }) => new FileSystemWriter({
      writer: writable.getWriter(),
      settings
    });
    close8 = async (view6, { releaseLock = true, closeWriter = true } = {}) => {
      if (closeWriter) {
        await view6.writer.close();
      } else if (releaseLock) {
        view6.writer.releaseLock();
      }
      return view6;
    };
    FileSystemWriter = class {
      /**
       * @param {object} options
       * @param {API.BlockWriter} options.writer
       * @param {Partial<API.EncoderSettings<Layout>>} options.settings
       */
      constructor({ writer, settings }) {
        this.writer = writer;
        this.settings = configure2(settings);
      }
      /**
       * @template [L=unknown]
       * @param {API.WriterOptions<L|Layout>} config
       */
      createFileWriter({ settings = this.settings, metadata } = {}) {
        return create14({
          writer: this.writer,
          settings,
          metadata
        });
      }
      /**
       * @template [L=unknown]
       * @param {API.WriterOptions<L|Layout>} config
       */
      createDirectoryWriter({ settings = this.settings, metadata } = {}) {
        return create15({
          writer: this.writer,
          settings,
          metadata
        });
      }
      /**
       * @param {API.CloseOptions} [options]
       */
      close(options) {
        return close8(this, options);
      }
    };
    BLOCK_SIZE_LIMIT = 1048576;
    defaultCapacity = BLOCK_SIZE_LIMIT * 100;
    withCapacity = (byteLength = defaultCapacity) => ({
      highWaterMark: byteLength,
      size: (block) => block.bytes.length
    });
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/unixfs.js
var unixfs_exports4 = {};
__export(unixfs_exports4, {
  createDirectoryEncoderStream: () => createDirectoryEncoderStream,
  createFileEncoderStream: () => createFileEncoderStream,
  encodeDirectory: () => encodeDirectory2,
  encodeFile: () => encodeFile2
});
async function encodeFile2(blob3, options) {
  const readable = createFileEncoderStream(blob3, options);
  const blocks = await collect2(readable);
  return { cid: blocks.at(-1).cid, blocks };
}
function createFileEncoderStream(blob3, options) {
  const { readable, writable } = new TransformStream({}, queuingStrategy);
  const settings = options?.settings ?? defaultSettings;
  const unixfsWriter = createWriter3({ writable, settings });
  const fileBuilder = new UnixFSFileBuilder("", blob3);
  void (async () => {
    await fileBuilder.finalize(unixfsWriter);
    await unixfsWriter.close();
  })();
  return readable;
}
async function encodeDirectory2(files, options) {
  const readable = createDirectoryEncoderStream(files, options);
  const blocks = await collect2(readable);
  return { cid: blocks.at(-1).cid, blocks };
}
function createDirectoryEncoderStream(files, options) {
  const rootDir = new UnixFSDirectoryBuilder("", options);
  for (const file of files) {
    const path = file.name.split("/");
    if (path[0] === "" || path[0] === ".") {
      path.shift();
    }
    let dir = rootDir;
    for (const [i, name20] of path.entries()) {
      if (i === path.length - 1) {
        dir.entries.set(name20, new UnixFSFileBuilder(path.join("/"), file));
        break;
      }
      let dirBuilder = dir.entries.get(name20);
      if (dirBuilder == null) {
        const dirName = dir === rootDir ? name20 : `${dir.name}/${name20}`;
        dirBuilder = new UnixFSDirectoryBuilder(dirName, options);
        dir.entries.set(name20, dirBuilder);
      }
      if (!(dirBuilder instanceof UnixFSDirectoryBuilder)) {
        throw new Error(`"${file.name}" cannot be a file and a directory`);
      }
      dir = dirBuilder;
    }
  }
  const { readable, writable } = new TransformStream({}, queuingStrategy);
  const settings = options?.settings ?? defaultSettings;
  const unixfsWriter = createWriter3({ writable, settings });
  void (async () => {
    const link5 = await rootDir.finalize(unixfsWriter);
    if (options?.onDirectoryEntryLink) {
      options.onDirectoryEntryLink({ name: "", ...link5 });
    }
    await unixfsWriter.close();
  })();
  return readable;
}
async function collect2(collectable) {
  const chunks = [];
  await collectable.pipeTo(new WritableStream({
    write(chunk) {
      chunks.push(chunk);
    }
  }));
  return chunks;
}
var SHARD_THRESHOLD, queuingStrategy, defaultSettings, UnixFSFileBuilder, UnixFSDirectoryBuilder;
var init_unixfs5 = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/unixfs.js"() {
    init_lib11();
    init_raw3();
    init_fixed();
    init_balanced();
    SHARD_THRESHOLD = 1e3;
    queuingStrategy = withCapacity();
    defaultSettings = configure2({
      fileChunkEncoder: raw_exports3,
      smallFileEncoder: raw_exports3,
      chunker: withMaxChunkSize(1024 * 1024),
      fileLayout: withWidth(1024)
    });
    UnixFSFileBuilder = class {
      #file;
      /**
       * @param {string} name
       * @param {import('./types.js').BlobLike} file
       */
      constructor(name20, file) {
        this.name = name20;
        this.#file = file;
      }
      /** @param {import('@ipld/unixfs').View} writer */
      async finalize(writer) {
        const unixfsFileWriter = create14(writer);
        await this.#file.stream().pipeTo(new WritableStream({
          async write(chunk) {
            await unixfsFileWriter.write(chunk);
          }
        }));
        return await unixfsFileWriter.close();
      }
    };
    UnixFSDirectoryBuilder = class {
      #options;
      /** @type {Map<string, UnixFSFileBuilder | UnixFSDirectoryBuilder>} */
      entries = /* @__PURE__ */ new Map();
      /**
       * @param {string} name
       * @param {import('./types.js').UnixFSDirectoryEncoderOptions} [options]
       */
      constructor(name20, options) {
        this.name = name20;
        this.#options = options;
      }
      /** @param {import('@ipld/unixfs').View} writer */
      async finalize(writer) {
        const dirWriter = this.entries.size <= SHARD_THRESHOLD ? create15(writer) : create17(writer);
        for (const [name20, entry] of this.entries) {
          const link5 = await entry.finalize(writer);
          if (this.#options?.onDirectoryEntryLink) {
            this.#options.onDirectoryEntryLink({ name: entry.name, ...link5 });
          }
          dirWriter.set(name20, link5);
        }
        return await dirWriter.close();
      }
    };
  }
});

// ../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/decoder.js
async function readHeader2(reader, strictVersion) {
  const length5 = decodeVarint2(await reader.upTo(8), reader);
  if (length5 === 0) {
    throw new Error("Invalid CAR header (zero length)");
  }
  const header = await reader.exactly(length5, true);
  const block = decode18(header);
  if (CarV1HeaderOrV2Pragma.toTyped(block) === void 0) {
    throw new Error("Invalid CAR header format");
  }
  if (block.version !== 1 && block.version !== 2 || strictVersion !== void 0 && block.version !== strictVersion) {
    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== void 0 ? ` (expected ${strictVersion})` : ""}`);
  }
  if (block.version === 1) {
    if (!Array.isArray(block.roots)) {
      throw new Error("Invalid CAR header format");
    }
    return block;
  }
  if (block.roots !== void 0) {
    throw new Error("Invalid CAR header format");
  }
  const v2Header = decodeV2Header(await reader.exactly(V2_HEADER_LENGTH, true));
  reader.seek(v2Header.dataOffset - reader.pos);
  const v1Header = await readHeader2(reader, 1);
  return Object.assign(v1Header, v2Header);
}
async function readCid2(reader) {
  const first2 = await reader.exactly(2, false);
  if (first2[0] === CIDV0_BYTES.SHA2_256 && first2[1] === CIDV0_BYTES.LENGTH) {
    const bytes3 = await reader.exactly(34, true);
    const multihash2 = decode17(bytes3);
    return CID2.create(0, CIDV0_BYTES.DAG_PB, multihash2);
  }
  const version3 = decodeVarint2(await reader.upTo(8), reader);
  if (version3 !== 1) {
    throw new Error(`Unexpected CID version (${version3})`);
  }
  const codec = decodeVarint2(await reader.upTo(8), reader);
  const bytes2 = await reader.exactly(getMultihashLength(await reader.upTo(8)), true);
  const multihash = decode17(bytes2);
  return CID2.create(version3, codec, multihash);
}
async function readBlockHead2(reader) {
  const start = reader.pos;
  let length5 = decodeVarint2(await reader.upTo(8), reader);
  if (length5 === 0) {
    throw new Error("Invalid CAR section (zero length)");
  }
  length5 += reader.pos - start;
  const cid = await readCid2(reader);
  const blockLength2 = length5 - Number(reader.pos - start);
  return { cid, length: length5, blockLength: blockLength2 };
}
async function readBlock(reader) {
  const { cid, blockLength: blockLength2 } = await readBlockHead2(reader);
  const bytes2 = await reader.exactly(blockLength2, true);
  return { bytes: bytes2, cid };
}
async function readBlockIndex(reader) {
  const offset2 = reader.pos;
  const { cid, length: length5, blockLength: blockLength2 } = await readBlockHead2(reader);
  const index2 = { cid, length: length5, blockLength: blockLength2, offset: offset2, blockOffset: reader.pos };
  reader.seek(index2.blockLength);
  return index2;
}
function createDecoder(reader) {
  const headerPromise = (async () => {
    const header = await readHeader2(reader);
    if (header.version === 2) {
      const v1length = reader.pos - header.dataOffset;
      reader = limitReader2(reader, header.dataSize - v1length);
    }
    return header;
  })();
  return {
    header: () => headerPromise,
    async *blocks() {
      await headerPromise;
      while ((await reader.upTo(8)).length > 0) {
        yield await readBlock(reader);
      }
    },
    async *blocksIndex() {
      await headerPromise;
      while ((await reader.upTo(8)).length > 0) {
        yield await readBlockIndex(reader);
      }
    }
  };
}
function bytesReader2(bytes2) {
  let pos = 0;
  return {
    async upTo(length5) {
      const out = bytes2.subarray(pos, pos + Math.min(length5, bytes2.length - pos));
      return out;
    },
    async exactly(length5, seek = false) {
      if (length5 > bytes2.length - pos) {
        throw new Error("Unexpected end of data");
      }
      const out = bytes2.subarray(pos, pos + length5);
      if (seek) {
        pos += length5;
      }
      return out;
    },
    seek(length5) {
      pos += length5;
    },
    get pos() {
      return pos;
    }
  };
}
function chunkReader(readChunk) {
  let pos = 0;
  let have = 0;
  let offset2 = 0;
  let currentChunk = new Uint8Array(0);
  const read10 = async (length5) => {
    have = currentChunk.length - offset2;
    const bufa = [currentChunk.subarray(offset2)];
    while (have < length5) {
      const chunk = await readChunk();
      if (chunk == null) {
        break;
      }
      if (have < 0) {
        if (chunk.length > have) {
          bufa.push(chunk.subarray(-have));
        }
      } else {
        bufa.push(chunk);
      }
      have += chunk.length;
    }
    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));
    let off = 0;
    for (const b of bufa) {
      currentChunk.set(b, off);
      off += b.length;
    }
    offset2 = 0;
  };
  return {
    async upTo(length5) {
      if (currentChunk.length - offset2 < length5) {
        await read10(length5);
      }
      return currentChunk.subarray(offset2, offset2 + Math.min(currentChunk.length - offset2, length5));
    },
    async exactly(length5, seek = false) {
      if (currentChunk.length - offset2 < length5) {
        await read10(length5);
      }
      if (currentChunk.length - offset2 < length5) {
        throw new Error("Unexpected end of data");
      }
      const out = currentChunk.subarray(offset2, offset2 + length5);
      if (seek) {
        pos += length5;
        offset2 += length5;
      }
      return out;
    },
    seek(length5) {
      pos += length5;
      offset2 += length5;
    },
    get pos() {
      return pos;
    }
  };
}
function asyncIterableReader(asyncIterable) {
  const iterator = asyncIterable[Symbol.asyncIterator]();
  async function readChunk() {
    const next = await iterator.next();
    if (next.done) {
      return null;
    }
    return next.value;
  }
  return chunkReader(readChunk);
}
function limitReader2(reader, byteLimit) {
  let bytesRead = 0;
  return {
    async upTo(length5) {
      let bytes2 = await reader.upTo(length5);
      if (bytes2.length + bytesRead > byteLimit) {
        bytes2 = bytes2.subarray(0, byteLimit - bytesRead);
      }
      return bytes2;
    },
    async exactly(length5, seek = false) {
      const bytes2 = await reader.exactly(length5, seek);
      if (bytes2.length + bytesRead > byteLimit) {
        throw new Error("Unexpected end of data");
      }
      if (seek) {
        bytesRead += length5;
      }
      return bytes2;
    },
    seek(length5) {
      bytesRead += length5;
      reader.seek(length5);
    },
    get pos() {
      return reader.pos;
    }
  };
}
var init_decoder = __esm({
  "../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/decoder.js"() {
    init_src5();
    init_cid2();
    init_digest3();
    init_decoder_common();
    init_header_validator();
  }
});

// ../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/indexer.js
var init_indexer = __esm({
  "../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/indexer.js"() {
    init_decoder();
  }
});

// ../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/reader-browser.js
var init_reader_browser = __esm({
  "../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/reader-browser.js"() {
    init_decoder();
  }
});

// ../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/reader.js
var import_fs2, import_util8, fsread2;
var init_reader = __esm({
  "../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/reader.js"() {
    import_fs2 = __toESM(require("fs"), 1);
    import_util8 = require("util");
    init_reader_browser();
    fsread2 = (0, import_util8.promisify)(import_fs2.default.read);
  }
});

// ../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/indexed-reader.js
var init_indexed_reader = __esm({
  "../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/indexed-reader.js"() {
    init_cid2();
    init_indexer();
    init_reader();
  }
});

// ../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/iterator.js
async function fromBytes5(bytes2) {
  if (!(bytes2 instanceof Uint8Array)) {
    throw new TypeError("fromBytes() requires a Uint8Array");
  }
  return decodeIterator(bytesReader2(bytes2));
}
async function fromIterable(asyncIterable) {
  if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
    throw new TypeError("fromIterable() requires an async iterable");
  }
  return decodeIterator(asyncIterableReader(asyncIterable));
}
async function decodeIterator(reader) {
  const decoder3 = createDecoder(reader);
  const { version: version3, roots } = await decoder3.header();
  return { version: version3, roots, iterator: decoder3.blocks() };
}
var CarIteratorBase, CarBlockIterator;
var init_iterator = __esm({
  "../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/iterator.js"() {
    init_decoder();
    CarIteratorBase = class {
      /**
       * @param {number} version
       * @param {CID[]} roots
       * @param {AsyncIterable<Block>|void} iterable
       */
      constructor(version3, roots, iterable) {
        this._version = version3;
        this._roots = roots;
        this._iterable = iterable;
        this._decoded = false;
      }
      get version() {
        return this._version;
      }
      /**
       * @returns {Promise<CID[]>}
       */
      async getRoots() {
        return this._roots;
      }
    };
    CarBlockIterator = class _CarBlockIterator extends CarIteratorBase {
      // inherited method
      /**
       * Get the list of roots defined by the CAR referenced by this iterator. May be
       * zero or more `CID`s.
       *
       * @function getRoots
       * @memberof CarBlockIterator
       * @instance
       * @async
       * @returns {Promise<CID[]>}
       */
      /**
       * @returns {AsyncIterator<Block>}
       */
      [Symbol.asyncIterator]() {
        if (this._decoded) {
          throw new Error("Cannot decode more than once");
        }
        if (!this._iterable) {
          throw new Error("Block iterable not found");
        }
        this._decoded = true;
        return this._iterable[Symbol.asyncIterator]();
      }
      /**
       * Instantiate a {@link CarBlockIterator} from a `Uint8Array` blob. Rather
       * than decoding the entire byte array prior to returning the iterator, as in
       * {@link CarReader.fromBytes}, only the header is decoded and the remainder
       * of the CAR is parsed as the `Block`s as yielded.
       *
       * @async
       * @static
       * @memberof CarBlockIterator
       * @param {Uint8Array} bytes
       * @returns {Promise<CarBlockIterator>}
       */
      static async fromBytes(bytes2) {
        const { version: version3, roots, iterator } = await fromBytes5(bytes2);
        return new _CarBlockIterator(version3, roots, iterator);
      }
      /**
       * Instantiate a {@link CarBlockIterator} from a `AsyncIterable<Uint8Array>`,
       * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).
       * Rather than decoding the entire byte array prior to returning the iterator,
       * as in {@link CarReader.fromIterable}, only the header is decoded and the
       * remainder of the CAR is parsed as the `Block`s as yielded.
       *
       * @async
       * @static
       * @param {AsyncIterable<Uint8Array>} asyncIterable
       * @returns {Promise<CarBlockIterator>}
       */
      static async fromIterable(asyncIterable) {
        const { version: version3, roots, iterator } = await fromIterable(asyncIterable);
        return new _CarBlockIterator(version3, roots, iterator);
      }
    };
  }
});

// ../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/encoder.js
function createHeader(roots) {
  const headerBytes = encode15({ version: CAR_V1_VERSION, roots });
  const varintBytes = import_varint7.default.encode(headerBytes.length);
  const header = new Uint8Array(varintBytes.length + headerBytes.length);
  header.set(varintBytes, 0);
  header.set(headerBytes, varintBytes.length);
  return header;
}
function createEncoder(writer) {
  return {
    /**
     * @param {CID[]} roots
     * @returns {Promise<void>}
     */
    async setRoots(roots) {
      const bytes2 = createHeader(roots);
      await writer.write(bytes2);
    },
    /**
     * @param {Block} block
     * @returns {Promise<void>}
     */
    async writeBlock(block) {
      const { cid, bytes: bytes2 } = block;
      await writer.write(new Uint8Array(import_varint7.default.encode(cid.bytes.length + bytes2.length)));
      await writer.write(cid.bytes);
      if (bytes2.length) {
        await writer.write(bytes2);
      }
    },
    /**
     * @returns {Promise<void>}
     */
    async close() {
      await writer.end();
    },
    /**
     * @returns {number}
     */
    version() {
      return CAR_V1_VERSION;
    }
  };
}
var import_varint7, CAR_V1_VERSION;
var init_encoder = __esm({
  "../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/encoder.js"() {
    init_src5();
    import_varint7 = __toESM(require_varint3(), 1);
    CAR_V1_VERSION = 1;
  }
});

// ../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/iterator-channel.js
function noop() {
}
function create18() {
  const chunkQueue = [];
  let drainer = null;
  let drainerResolver = noop;
  let ended = false;
  let outWait = null;
  let outWaitResolver = noop;
  const makeDrainer = () => {
    if (!drainer) {
      drainer = new Promise((resolve2) => {
        drainerResolver = () => {
          drainer = null;
          drainerResolver = noop;
          resolve2();
        };
      });
    }
    return drainer;
  };
  const writer = {
    /**
     * @param {T} chunk
     * @returns {Promise<void>}
     */
    write(chunk) {
      chunkQueue.push(chunk);
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    },
    async end() {
      ended = true;
      const drainer2 = makeDrainer();
      outWaitResolver();
      await drainer2;
    }
  };
  const iterator = {
    /** @returns {Promise<IteratorResult<T>>} */
    async next() {
      const chunk = chunkQueue.shift();
      if (chunk) {
        if (chunkQueue.length === 0) {
          drainerResolver();
        }
        return { done: false, value: chunk };
      }
      if (ended) {
        drainerResolver();
        return { done: true, value: void 0 };
      }
      if (!outWait) {
        outWait = new Promise((resolve2) => {
          outWaitResolver = () => {
            outWait = null;
            outWaitResolver = noop;
            return resolve2(iterator.next());
          };
        });
      }
      return outWait;
    }
  };
  return { writer, iterator };
}
var init_iterator_channel = __esm({
  "../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/iterator-channel.js"() {
  }
});

// ../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/writer-browser.js
function encodeWriter() {
  const iw = create18();
  const { writer, iterator } = iw;
  const encoder3 = createEncoder(writer);
  return { encoder: encoder3, iterator };
}
function toRoots(roots) {
  if (roots === void 0) {
    return [];
  }
  if (!Array.isArray(roots)) {
    const cid = CID2.asCID(roots);
    if (!cid) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    return [cid];
  }
  const _roots = [];
  for (const root2 of roots) {
    const _root = CID2.asCID(root2);
    if (!_root) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    _roots.push(_root);
  }
  return _roots;
}
var CarWriter, CarWriterOut;
var init_writer_browser = __esm({
  "../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/writer-browser.js"() {
    init_cid2();
    init_decoder();
    init_encoder();
    init_iterator_channel();
    CarWriter = class _CarWriter {
      /**
       * @param {CID[]} roots
       * @param {CarEncoder} encoder
       */
      constructor(roots, encoder3) {
        this._encoder = encoder3;
        this._mutex = encoder3.setRoots(roots);
        this._ended = false;
      }
      /**
       * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.
       *
       * @function
       * @memberof CarWriter
       * @instance
       * @async
       * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.
       * @returns {Promise<void>} The returned promise will only resolve once the
       * bytes this block generates are written to the `out` iterable.
       */
      async put(block) {
        if (!(block.bytes instanceof Uint8Array) || !block.cid) {
          throw new TypeError("Can only write {cid, bytes} objects");
        }
        if (this._ended) {
          throw new Error("Already closed");
        }
        const cid = CID2.asCID(block.cid);
        if (!cid) {
          throw new TypeError("Can only write {cid, bytes} objects");
        }
        this._mutex = this._mutex.then(() => this._encoder.writeBlock({ cid, bytes: block.bytes }));
        return this._mutex;
      }
      /**
       * Finalise the CAR archive and signal that the `out` iterable should end once
       * any remaining bytes are written.
       *
       * @function
       * @memberof CarWriter
       * @instance
       * @async
       * @returns {Promise<void>}
       */
      async close() {
        if (this._ended) {
          throw new Error("Already closed");
        }
        await this._mutex;
        this._ended = true;
        return this._encoder.close();
      }
      /**
       * Returns the version number of the CAR file being written
       *
       * @returns {number}
       */
      version() {
        return this._encoder.version();
      }
      /**
       * Create a new CAR writer "channel" which consists of a
       * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.
       *
       * @async
       * @static
       * @memberof CarWriter
       * @param {CID[] | CID | void} roots
       * @returns {WriterChannel} The channel takes the form of
       * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.
       */
      static create(roots) {
        roots = toRoots(roots);
        const { encoder: encoder3, iterator } = encodeWriter();
        const writer = new _CarWriter(roots, encoder3);
        const out = new CarWriterOut(iterator);
        return { writer, out };
      }
      /**
       * Create a new CAR appender "channel" which consists of a
       * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.
       * This appender does not consider roots and does not produce a CAR header.
       * It is designed to append blocks to an _existing_ CAR archive. It is
       * expected that `out` will be concatenated onto the end of an existing
       * archive that already has a properly formatted header.
       *
       * @async
       * @static
       * @memberof CarWriter
       * @returns {WriterChannel} The channel takes the form of
       * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.
       */
      static createAppender() {
        const { encoder: encoder3, iterator } = encodeWriter();
        encoder3.setRoots = () => Promise.resolve();
        const writer = new _CarWriter([], encoder3);
        const out = new CarWriterOut(iterator);
        return { writer, out };
      }
      /**
       * Update the list of roots in the header of an existing CAR as represented
       * in a Uint8Array.
       *
       * This operation is an _overwrite_, the total length of the CAR will not be
       * modified. A rejection will occur if the new header will not be the same
       * length as the existing header, in which case the CAR will not be modified.
       * It is the responsibility of the user to ensure that the roots being
       * replaced encode as the same length as the new roots.
       *
       * The byte array passed in an argument will be modified and also returned
       * upon successful modification.
       *
       * @async
       * @static
       * @memberof CarWriter
       * @param {Uint8Array} bytes
       * @param {CID[]} roots - A new list of roots to replace the existing list in
       * the CAR header. The new header must take up the same number of bytes as the
       * existing header, so the roots should collectively be the same byte length
       * as the existing roots.
       * @returns {Promise<Uint8Array>}
       */
      static async updateRootsInBytes(bytes2, roots) {
        const reader = bytesReader2(bytes2);
        await readHeader2(reader);
        const newHeader = createHeader(roots);
        if (Number(reader.pos) !== newHeader.length) {
          throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`);
        }
        bytes2.set(newHeader, 0);
        return bytes2;
      }
    };
    CarWriterOut = class {
      /**
       * @param {AsyncIterator<Uint8Array>} iterator
       */
      constructor(iterator) {
        this._iterator = iterator;
      }
      [Symbol.asyncIterator]() {
        if (this._iterating) {
          throw new Error("Multiple iterator not supported");
        }
        this._iterating = true;
        return this._iterator;
      }
    };
  }
});

// ../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/writer.js
var import_fs3, import_util9, fsread3, fswrite, CarWriter2;
var init_writer2 = __esm({
  "../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/writer.js"() {
    import_fs3 = __toESM(require("fs"), 1);
    import_util9 = require("util");
    init_decoder();
    init_encoder();
    init_writer_browser();
    fsread3 = (0, import_util9.promisify)(import_fs3.default.read);
    fswrite = (0, import_util9.promisify)(import_fs3.default.write);
    CarWriter2 = class extends CarWriter {
      /**
       * Update the list of roots in the header of an existing CAR file. The first
       * argument must be a file descriptor for CAR file that is open in read and
       * write mode (not append), e.g. `fs.open` or `fs.promises.open` with `'r+'`
       * mode.
       *
       * This operation is an _overwrite_, the total length of the CAR will not be
       * modified. A rejection will occur if the new header will not be the same
       * length as the existing header, in which case the CAR will not be modified.
       * It is the responsibility of the user to ensure that the roots being
       * replaced encode as the same length as the new roots.
       *
       * This function is **only available in Node.js** and not a browser
       * environment.
       *
       * @async
       * @static
       * @memberof CarWriter
       * @param {fs.promises.FileHandle | number} fd - A file descriptor from the
       * Node.js `fs` module. Either an integer, from `fs.open()` or a `FileHandle`
       * from `fs.promises.open()`.
       * @param {CID[]} roots - A new list of roots to replace the existing list in
       * the CAR header. The new header must take up the same number of bytes as the
       * existing header, so the roots should collectively be the same byte length
       * as the existing roots.
       * @returns {Promise<void>}
       */
      static async updateRootsInFile(fd, roots) {
        const chunkSize = 256;
        let bytes2;
        let offset2 = 0;
        let readChunk;
        if (typeof fd === "number") {
          readChunk = async () => (await fsread3(fd, bytes2, 0, chunkSize, offset2)).bytesRead;
        } else if (typeof fd === "object" && typeof fd.read === "function") {
          readChunk = async () => (await fd.read(bytes2, 0, chunkSize, offset2)).bytesRead;
        } else {
          throw new TypeError("Bad fd");
        }
        const fdReader = chunkReader(async () => {
          bytes2 = new Uint8Array(chunkSize);
          const read10 = await readChunk();
          offset2 += read10;
          return read10 < chunkSize ? bytes2.subarray(0, read10) : bytes2;
        });
        await readHeader2(fdReader);
        const newHeader = createHeader(roots);
        if (fdReader.pos !== newHeader.length) {
          throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${fdReader.pos} bytes, new header is ${newHeader.length} bytes)`);
        }
        if (typeof fd === "number") {
          await fswrite(fd, newHeader, 0, newHeader.length, 0);
        } else if (typeof fd === "object" && typeof fd.read === "function") {
          await fd.write(newHeader, 0, newHeader.length, 0);
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/index.js
var init_src12 = __esm({
  "../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/index.js"() {
    init_buffer_reader();
    init_buffer_writer();
    init_indexed_reader();
    init_indexer();
    init_iterator();
    init_reader();
    init_writer2();
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/car.js
var car_exports3 = {};
__export(car_exports3, {
  BlockStream: () => BlockStream,
  blockEncodingLength: () => blockEncodingLength,
  blockHeaderEncodingLength: () => blockHeaderEncodingLength,
  code: () => code23,
  encode: () => encode41,
  headerEncodingLength: () => headerEncodingLength
});
function headerEncodingLength(root2) {
  if (!root2)
    return NO_ROOTS_HEADER_LENGTH;
  const headerLength2 = encode15({ version: 1, roots: [root2] }).length;
  const varintLength = import_varint8.default.encodingLength(headerLength2);
  return varintLength + headerLength2;
}
function blockHeaderEncodingLength(block) {
  const payloadLength = block.cid.bytes.length + block.bytes.length;
  const varintLength = import_varint8.default.encodingLength(payloadLength);
  return varintLength + block.cid.bytes.length;
}
function blockEncodingLength(block) {
  return blockHeaderEncodingLength(block) + block.bytes.length;
}
async function encode41(blocks, root2) {
  const { writer, out } = CarWriter2.create(root2);
  let error3;
  void (async () => {
    try {
      for await (const block of blocks) {
        await writer.put(block);
      }
    } catch (err) {
      error3 = err;
    } finally {
      await writer.close();
    }
  })();
  const chunks = [];
  for await (const chunk of out)
    chunks.push(chunk);
  if (error3 != null)
    throw error3;
  const roots = root2 != null ? [root2] : [];
  return Object.assign(new Blob(chunks), { version: 1, roots });
}
function toIterable2(stream) {
  return Symbol.asyncIterator in stream ? stream : async function* () {
    const reader = stream.getReader();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          return;
        yield value;
      }
    } finally {
      reader.releaseLock();
    }
  }();
}
var import_varint8, code23, NO_ROOTS_HEADER_LENGTH, BlockStream;
var init_car3 = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/car.js"() {
    init_src12();
    init_src5();
    import_varint8 = __toESM(require_varint3(), 1);
    code23 = 514;
    NO_ROOTS_HEADER_LENGTH = 18;
    BlockStream = class extends ReadableStream {
      /** @param {import('./types.js').BlobLike} car */
      constructor(car) {
        let blocksPromise = null;
        const getBlocksIterable = () => {
          if (blocksPromise)
            return blocksPromise;
          blocksPromise = CarBlockIterator.fromIterable(toIterable2(car.stream()));
          return blocksPromise;
        };
        let iterator = null;
        super({
          async start() {
            const blocks = await getBlocksIterable();
            iterator = /** @type {AsyncIterator<Block>} */
            blocks[Symbol.asyncIterator]();
          },
          async pull(controller) {
            if (!iterator)
              throw new Error("missing blocks iterator");
            const { value, done } = await iterator.next();
            if (done)
              return controller.close();
            controller.enqueue(value);
          }
        });
        this.getRoots = async () => {
          const blocks = await getBlocksIterable();
          return await blocks.getRoots();
        };
      }
    };
  }
});

// ../../node_modules/.pnpm/@web3-storage+blob-index@1.0.4/node_modules/@web3-storage/blob-index/dist/src/api.js
var init_api10 = __esm({
  "../../node_modules/.pnpm/@web3-storage+blob-index@1.0.4/node_modules/@web3-storage/blob-index/dist/src/api.js"() {
  }
});

// ../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/util/as-uint8array.node.js
function asUint8Array3(buf3) {
  return new Uint8Array(buf3.buffer, buf3.byteOffset, buf3.byteLength);
}
var init_as_uint8array_node = __esm({
  "../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/util/as-uint8array.node.js"() {
  }
});

// ../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/alloc.node.js
function alloc3(size5 = 0) {
  return asUint8Array3(import_node_buffer.Buffer.alloc(size5));
}
function allocUnsafe2(size5 = 0) {
  return asUint8Array3(import_node_buffer.Buffer.allocUnsafe(size5));
}
var import_node_buffer;
var init_alloc_node = __esm({
  "../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/alloc.node.js"() {
    import_node_buffer = require("node:buffer");
    init_as_uint8array_node();
  }
});

// ../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/xor.js
var init_xor = __esm({
  "../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/xor.js"() {
    init_alloc_node();
    init_as_uint8array_node();
  }
});

// ../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/compare.node.js
function compare3(a, b) {
  return import_node_buffer2.Buffer.compare(a, b);
}
var import_node_buffer2;
var init_compare_node = __esm({
  "../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/compare.node.js"() {
    import_node_buffer2 = require("node:buffer");
  }
});

// ../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/concat.node.js
function concat3(arrays, length5) {
  return asUint8Array3(import_node_buffer3.Buffer.concat(arrays, length5));
}
var import_node_buffer3;
var init_concat_node = __esm({
  "../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/concat.node.js"() {
    import_node_buffer3 = require("node:buffer");
    init_as_uint8array_node();
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base10.js
var base10_exports2 = {};
__export(base10_exports2, {
  base10: () => base102
});
var base102;
var init_base102 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base10.js"() {
    init_base3();
    base102 = baseX2({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base16.js
var base16_exports2 = {};
__export(base16_exports2, {
  base16: () => base162,
  base16upper: () => base16upper2
});
var base162, base16upper2;
var init_base162 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base16.js"() {
    init_base3();
    base162 = rfc46482({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    base16upper2 = rfc46482({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base2.js
var base2_exports2 = {};
__export(base2_exports2, {
  base2: () => base22
});
var base22;
var init_base22 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base2.js"() {
    init_base3();
    base22 = rfc46482({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports2 = {};
__export(base256emoji_exports2, {
  base256emoji: () => base256emoji2
});
function encode42(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars2[c];
    return p;
  }, "");
}
function decode51(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes2[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var alphabet2, alphabetBytesToChars2, alphabetCharsToBytes2, base256emoji2;
var init_base256emoji2 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base256emoji.js"() {
    init_base3();
    alphabet2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    alphabetBytesToChars2 = alphabet2.reduce((p, c, i) => {
      p[i] = c;
      return p;
    }, []);
    alphabetCharsToBytes2 = alphabet2.reduce((p, c, i) => {
      p[c.codePointAt(0)] = i;
      return p;
    }, []);
    base256emoji2 = from4({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: encode42,
      decode: decode51
    });
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base36.js
var base36_exports2 = {};
__export(base36_exports2, {
  base36: () => base362,
  base36upper: () => base36upper2
});
var base362, base36upper2;
var init_base362 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base36.js"() {
    init_base3();
    base362 = baseX2({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    base36upper2 = baseX2({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base8.js
var base8_exports2 = {};
__export(base8_exports2, {
  base8: () => base82
});
var base82;
var init_base82 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/base8.js"() {
    init_base3();
    base82 = rfc46482({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/identity.js
var identity_exports3 = {};
__export(identity_exports3, {
  identity: () => identity4
});
var identity4;
var init_identity4 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/bases/identity.js"() {
    init_bytes5();
    init_base3();
    identity4 = from4({
      prefix: "\0",
      name: "identity",
      encode: (buf3) => toString5(buf3),
      decode: (str) => fromString5(str)
    });
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/codecs/json.js
var textEncoder8, textDecoder6;
var init_json4 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/codecs/json.js"() {
    textEncoder8 = new TextEncoder();
    textDecoder6 = new TextDecoder();
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/codecs/raw.js
var init_raw4 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/codecs/raw.js"() {
    init_bytes5();
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports4 = {};
__export(identity_exports4, {
  identity: () => identity5
});
function digest5(input10) {
  return create3(code24, encode43(input10));
}
var code24, name19, encode43, identity5;
var init_identity5 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/hashes/identity.js"() {
    init_bytes5();
    init_digest3();
    code24 = 0;
    name19 = "identity";
    encode43 = coerce3;
    identity5 = { code: code24, name: name19, encode: encode43, digest: digest5 };
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/hashes/sha2.js
var sha2_exports2 = {};
__export(sha2_exports2, {
  sha256: () => sha2564,
  sha512: () => sha5124
});
var import_crypto6, sha2564, sha5124;
var init_sha24 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/hashes/sha2.js"() {
    import_crypto6 = __toESM(require("crypto"), 1);
    init_bytes5();
    init_hasher3();
    sha2564 = from8({
      name: "sha2-256",
      code: 18,
      encode: (input10) => coerce3(import_crypto6.default.createHash("sha256").update(input10).digest())
    });
    sha5124 = from8({
      name: "sha2-512",
      code: 19,
      encode: (input10) => coerce3(import_crypto6.default.createHash("sha512").update(input10).digest())
    });
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/basics.js
var bases2, hashes2;
var init_basics2 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/basics.js"() {
    init_base102();
    init_base162();
    init_base22();
    init_base256emoji2();
    init_base322();
    init_base362();
    init_base582();
    init_base643();
    init_base82();
    init_identity4();
    init_json4();
    init_raw4();
    init_identity5();
    init_sha24();
    init_src7();
    bases2 = { ...identity_exports3, ...base2_exports2, ...base8_exports2, ...base10_exports2, ...base16_exports2, ...base32_exports2, ...base36_exports2, ...base58_exports2, ...base64_exports2, ...base256emoji_exports2 };
    hashes2 = { ...sha2_exports2, ...identity_exports4 };
  }
});

// ../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec2(name20, prefix2, encode45, decode53) {
  return {
    name: name20,
    prefix: prefix2,
    encoder: {
      name: name20,
      prefix: prefix2,
      encode: encode45
    },
    decoder: {
      decode: decode53
    }
  };
}
var string3, ascii2, BASES2;
var init_bases2 = __esm({
  "../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/util/bases.js"() {
    init_basics2();
    init_alloc_node();
    string3 = createCodec2("utf8", "u", (buf3) => {
      const decoder3 = new TextDecoder("utf8");
      return "u" + decoder3.decode(buf3);
    }, (str) => {
      const encoder3 = new TextEncoder();
      return encoder3.encode(str.substring(1));
    });
    ascii2 = createCodec2("ascii", "a", (buf3) => {
      let string4 = "a";
      for (let i = 0; i < buf3.length; i++) {
        string4 += String.fromCharCode(buf3[i]);
      }
      return string4;
    }, (str) => {
      str = str.substring(1);
      const buf3 = allocUnsafe2(str.length);
      for (let i = 0; i < str.length; i++) {
        buf3[i] = str.charCodeAt(i);
      }
      return buf3;
    });
    BASES2 = {
      utf8: string3,
      "utf-8": string3,
      hex: bases2.base16,
      latin1: ascii2,
      ascii: ascii2,
      binary: ascii2,
      ...bases2
    };
  }
});

// ../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/from-string.node.js
var init_from_string_node = __esm({
  "../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/from-string.node.js"() {
    init_bases2();
    init_as_uint8array_node();
  }
});

// ../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/to-string.node.js
var init_to_string_node = __esm({
  "../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/to-string.node.js"() {
    init_bases2();
  }
});

// ../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/index.js
var init_src13 = __esm({
  "../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/dist/src/index.js"() {
    init_equals();
    init_xor();
    init_compare_node();
    init_concat_node();
    init_from_string_node();
    init_to_string_node();
  }
});

// ../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/link.js
function createLegacy2(digest6) {
  return CID2.create(0, DAG_PB_CODE6, digest6);
}
function create19(code25, digest6) {
  return CID2.create(1, code25, digest6);
}
var DAG_PB_CODE6;
var init_link5 = __esm({
  "../../node_modules/.pnpm/multiformats@13.2.2/node_modules/multiformats/dist/src/link.js"() {
    init_cid2();
    init_interface();
    DAG_PB_CODE6 = 112;
  }
});

// ../../node_modules/.pnpm/@web3-storage+blob-index@1.0.4/node_modules/@web3-storage/blob-index/dist/src/digest-map.js
var cache4, toBase58String, DigestMap;
var init_digest_map = __esm({
  "../../node_modules/.pnpm/@web3-storage+blob-index@1.0.4/node_modules/@web3-storage/blob-index/dist/src/digest-map.js"() {
    init_api10();
    init_base582();
    cache4 = /* @__PURE__ */ new WeakMap();
    toBase58String = (digest6) => {
      let str = cache4.get(digest6.bytes);
      if (!str) {
        str = base58btc2.encode(digest6.bytes);
        cache4.set(digest6.bytes, str);
      }
      return str;
    };
    DigestMap = class {
      /** @type {Map<string, [Key, Value]>} */
      #data;
      /**
       * @param {Array<[Key, Value]>} [entries]
       */
      constructor(entries3) {
        this.#data = /* @__PURE__ */ new Map();
        for (const [k, v] of entries3 ?? []) {
          this.set(k, v);
        }
      }
      get [Symbol.toStringTag]() {
        return "DigestMap";
      }
      clear() {
        this.#data.clear();
      }
      /**
       * @param {Key} key
       * @returns {boolean}
       */
      delete(key) {
        const mhstr = toBase58String(key);
        return this.#data.delete(mhstr);
      }
      /**
       * @param {(value: Value, key: Key, map: Map<Key, Value>) => void} callbackfn
       * @param {any} [thisArg]
       */
      forEach(callbackfn, thisArg) {
        for (const [k, v] of this.#data.values()) {
          callbackfn.call(thisArg, v, k, this);
        }
      }
      /**
       * @param {Key} key
       * @returns {Value|undefined}
       */
      get(key) {
        const data = this.#data.get(toBase58String(key));
        if (data)
          return data[1];
      }
      /**
       * @param {Key} key
       * @returns {boolean}
       */
      has(key) {
        return this.#data.has(toBase58String(key));
      }
      /**
       * @param {Key} key
       * @param {Value} value
       */
      set(key, value) {
        this.#data.set(toBase58String(key), [key, value]);
        return this;
      }
      /** @returns {number} */
      get size() {
        return this.#data.size;
      }
      /** @returns */
      [Symbol.iterator]() {
        return this.entries();
      }
      /** @returns {IterableIterator<[Key, Value]>} */
      *entries() {
        yield* this.#data.values();
      }
      /** @returns {IterableIterator<Key>} */
      *keys() {
        for (const [k] of this.#data.values()) {
          yield k;
        }
      }
      /** @returns {IterableIterator<Value>} */
      *values() {
        for (const [, v] of this.#data.values()) {
          yield v;
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/@web3-storage+blob-index@1.0.4/node_modules/@web3-storage/blob-index/dist/src/sharded-dag-index.js
var version2, ShardedDAGIndexSchema, MultihashSchema, BlobIndexSchema, ShardedDAGIndex, create20, archive2;
var init_sharded_dag_index = __esm({
  "../../node_modules/.pnpm/@web3-storage+blob-index@1.0.4/node_modules/@web3-storage/blob-index/dist/src/sharded-dag-index.js"() {
    init_api10();
    init_lib3();
    init_src13();
    init_src5();
    init_digest3();
    init_link5();
    init_sha24();
    init_digest_map();
    version2 = "index/sharded/dag@0.1";
    ShardedDAGIndexSchema = schema_exports3.variant({
      [version2]: schema_exports3.struct({
        /** DAG root. */
        content: schema_exports3.link(),
        /** Shards the DAG can be found in. */
        shards: schema_exports3.array(schema_exports3.link())
      })
    });
    MultihashSchema = schema_exports3.bytes();
    BlobIndexSchema = schema_exports3.tuple([
      MultihashSchema,
      schema_exports3.array(
        /** multihash bytes, offset, length. */
        schema_exports3.tuple([
          MultihashSchema,
          schema_exports3.tuple([schema_exports3.number(), schema_exports3.number()])
        ])
      )
    ]);
    ShardedDAGIndex = class {
      #content;
      #shards;
      /** @param {API.UnknownLink} content */
      constructor(content2) {
        this.#content = content2;
        this.#shards = new DigestMap();
      }
      get content() {
        return this.#content;
      }
      get shards() {
        return this.#shards;
      }
      /**
       * @param {API.ShardDigest} shard
       * @param {API.SliceDigest} slice
       * @param {API.Position} pos
       */
      setSlice(shard, slice4, pos) {
        let index2 = this.#shards.get(shard);
        if (!index2) {
          index2 = new DigestMap();
          this.#shards.set(shard, index2);
        }
        index2.set(slice4, pos);
      }
      archive() {
        return archive2(this);
      }
    };
    create20 = (content2) => new ShardedDAGIndex(content2);
    archive2 = async (model) => {
      const blocks = /* @__PURE__ */ new Map();
      const shards = [...model.shards.entries()].sort((a, b) => compare3(a[0].digest, b[0].digest));
      const index2 = {
        content: model.content,
        shards: (
          /** @type {API.Link[]} */
          []
        )
      };
      for (const s of shards) {
        const slices = [...s[1].entries()].sort((a, b) => compare3(a[0].digest, b[0].digest)).map((e) => [e[0].bytes, e[1]]);
        const bytes3 = encode15([s[0].bytes, slices]);
        const digest7 = await sha2564.digest(bytes3);
        const cid2 = create19(code9, digest7);
        blocks.set(cid2.toString(), { cid: cid2, bytes: bytes3 });
        index2.shards.push(cid2);
      }
      const bytes2 = encode15({ [version2]: index2 });
      const digest6 = await sha2564.digest(bytes2);
      const cid = create19(code9, digest6);
      return ok(car_exports.encode({ roots: [{ cid, bytes: bytes2 }], blocks }));
    };
  }
});

// ../../node_modules/.pnpm/uint8arraylist@2.4.8/node_modules/uint8arraylist/dist/src/index.js
function findBufAndOffset(bufs, index2) {
  if (index2 == null || index2 < 0) {
    throw new RangeError("index is out of bounds");
  }
  let offset2 = 0;
  for (const buf3 of bufs) {
    const bufEnd = offset2 + buf3.byteLength;
    if (index2 < bufEnd) {
      return {
        buf: buf3,
        index: index2 - offset2
      };
    }
    offset2 = bufEnd;
  }
  throw new RangeError("index is out of bounds");
}
function isUint8ArrayList(value) {
  return Boolean(value?.[symbol]);
}
var symbol, Uint8ArrayList;
var init_src14 = __esm({
  "../../node_modules/.pnpm/uint8arraylist@2.4.8/node_modules/uint8arraylist/dist/src/index.js"() {
    init_alloc_node();
    init_concat_node();
    init_equals();
    symbol = Symbol.for("@achingbrain/uint8arraylist");
    Uint8ArrayList = class _Uint8ArrayList {
      bufs;
      length;
      [symbol] = true;
      constructor(...data) {
        this.bufs = [];
        this.length = 0;
        if (data.length > 0) {
          this.appendAll(data);
        }
      }
      *[Symbol.iterator]() {
        yield* this.bufs;
      }
      get byteLength() {
        return this.length;
      }
      /**
       * Add one or more `bufs` to the end of this Uint8ArrayList
       */
      append(...bufs) {
        this.appendAll(bufs);
      }
      /**
       * Add all `bufs` to the end of this Uint8ArrayList
       */
      appendAll(bufs) {
        let length5 = 0;
        for (const buf3 of bufs) {
          if (buf3 instanceof Uint8Array) {
            length5 += buf3.byteLength;
            this.bufs.push(buf3);
          } else if (isUint8ArrayList(buf3)) {
            length5 += buf3.byteLength;
            this.bufs.push(...buf3.bufs);
          } else {
            throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
          }
        }
        this.length += length5;
      }
      /**
       * Add one or more `bufs` to the start of this Uint8ArrayList
       */
      prepend(...bufs) {
        this.prependAll(bufs);
      }
      /**
       * Add all `bufs` to the start of this Uint8ArrayList
       */
      prependAll(bufs) {
        let length5 = 0;
        for (const buf3 of bufs.reverse()) {
          if (buf3 instanceof Uint8Array) {
            length5 += buf3.byteLength;
            this.bufs.unshift(buf3);
          } else if (isUint8ArrayList(buf3)) {
            length5 += buf3.byteLength;
            this.bufs.unshift(...buf3.bufs);
          } else {
            throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
          }
        }
        this.length += length5;
      }
      /**
       * Read the value at `index`
       */
      get(index2) {
        const res = findBufAndOffset(this.bufs, index2);
        return res.buf[res.index];
      }
      /**
       * Set the value at `index` to `value`
       */
      set(index2, value) {
        const res = findBufAndOffset(this.bufs, index2);
        res.buf[res.index] = value;
      }
      /**
       * Copy bytes from `buf` to the index specified by `offset`
       */
      write(buf3, offset2 = 0) {
        if (buf3 instanceof Uint8Array) {
          for (let i = 0; i < buf3.length; i++) {
            this.set(offset2 + i, buf3[i]);
          }
        } else if (isUint8ArrayList(buf3)) {
          for (let i = 0; i < buf3.length; i++) {
            this.set(offset2 + i, buf3.get(i));
          }
        } else {
          throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
        }
      }
      /**
       * Remove bytes from the front of the pool
       */
      consume(bytes2) {
        bytes2 = Math.trunc(bytes2);
        if (Number.isNaN(bytes2) || bytes2 <= 0) {
          return;
        }
        if (bytes2 === this.byteLength) {
          this.bufs = [];
          this.length = 0;
          return;
        }
        while (this.bufs.length > 0) {
          if (bytes2 >= this.bufs[0].byteLength) {
            bytes2 -= this.bufs[0].byteLength;
            this.length -= this.bufs[0].byteLength;
            this.bufs.shift();
          } else {
            this.bufs[0] = this.bufs[0].subarray(bytes2);
            this.length -= bytes2;
            break;
          }
        }
      }
      /**
       * Extracts a section of an array and returns a new array.
       *
       * This is a copy operation as it is with Uint8Arrays and Arrays
       * - note this is different to the behaviour of Node Buffers.
       */
      slice(beginInclusive, endExclusive) {
        const { bufs, length: length5 } = this._subList(beginInclusive, endExclusive);
        return concat3(bufs, length5);
      }
      /**
       * Returns a alloc from the given start and end element index.
       *
       * In the best case where the data extracted comes from a single Uint8Array
       * internally this is a no-copy operation otherwise it is a copy operation.
       */
      subarray(beginInclusive, endExclusive) {
        const { bufs, length: length5 } = this._subList(beginInclusive, endExclusive);
        if (bufs.length === 1) {
          return bufs[0];
        }
        return concat3(bufs, length5);
      }
      /**
       * Returns a allocList from the given start and end element index.
       *
       * This is a no-copy operation.
       */
      sublist(beginInclusive, endExclusive) {
        const { bufs, length: length5 } = this._subList(beginInclusive, endExclusive);
        const list7 = new _Uint8ArrayList();
        list7.length = length5;
        list7.bufs = [...bufs];
        return list7;
      }
      _subList(beginInclusive, endExclusive) {
        beginInclusive = beginInclusive ?? 0;
        endExclusive = endExclusive ?? this.length;
        if (beginInclusive < 0) {
          beginInclusive = this.length + beginInclusive;
        }
        if (endExclusive < 0) {
          endExclusive = this.length + endExclusive;
        }
        if (beginInclusive < 0 || endExclusive > this.length) {
          throw new RangeError("index is out of bounds");
        }
        if (beginInclusive === endExclusive) {
          return { bufs: [], length: 0 };
        }
        if (beginInclusive === 0 && endExclusive === this.length) {
          return { bufs: this.bufs, length: this.length };
        }
        const bufs = [];
        let offset2 = 0;
        for (let i = 0; i < this.bufs.length; i++) {
          const buf3 = this.bufs[i];
          const bufStart = offset2;
          const bufEnd = bufStart + buf3.byteLength;
          offset2 = bufEnd;
          if (beginInclusive >= bufEnd) {
            continue;
          }
          const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
          const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
          if (sliceStartInBuf && sliceEndsInBuf) {
            if (beginInclusive === bufStart && endExclusive === bufEnd) {
              bufs.push(buf3);
              break;
            }
            const start = beginInclusive - bufStart;
            bufs.push(buf3.subarray(start, start + (endExclusive - beginInclusive)));
            break;
          }
          if (sliceStartInBuf) {
            if (beginInclusive === 0) {
              bufs.push(buf3);
              continue;
            }
            bufs.push(buf3.subarray(beginInclusive - bufStart));
            continue;
          }
          if (sliceEndsInBuf) {
            if (endExclusive === bufEnd) {
              bufs.push(buf3);
              break;
            }
            bufs.push(buf3.subarray(0, endExclusive - bufStart));
            break;
          }
          bufs.push(buf3);
        }
        return { bufs, length: endExclusive - beginInclusive };
      }
      indexOf(search, offset2 = 0) {
        if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {
          throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
        }
        const needle = search instanceof Uint8Array ? search : search.subarray();
        offset2 = Number(offset2 ?? 0);
        if (isNaN(offset2)) {
          offset2 = 0;
        }
        if (offset2 < 0) {
          offset2 = this.length + offset2;
        }
        if (offset2 < 0) {
          offset2 = 0;
        }
        if (search.length === 0) {
          return offset2 > this.length ? this.length : offset2;
        }
        const M = needle.byteLength;
        if (M === 0) {
          throw new TypeError("search must be at least 1 byte long");
        }
        const radix = 256;
        const rightmostPositions = new Int32Array(radix);
        for (let c = 0; c < radix; c++) {
          rightmostPositions[c] = -1;
        }
        for (let j = 0; j < M; j++) {
          rightmostPositions[needle[j]] = j;
        }
        const right = rightmostPositions;
        const lastIndex = this.byteLength - needle.byteLength;
        const lastPatIndex = needle.byteLength - 1;
        let skip2;
        for (let i = offset2; i <= lastIndex; i += skip2) {
          skip2 = 0;
          for (let j = lastPatIndex; j >= 0; j--) {
            const char = this.get(i + j);
            if (needle[j] !== char) {
              skip2 = Math.max(1, j - right[char]);
              break;
            }
          }
          if (skip2 === 0) {
            return i;
          }
        }
        return -1;
      }
      getInt8(byteOffset) {
        const buf3 = this.subarray(byteOffset, byteOffset + 1);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        return view6.getInt8(0);
      }
      setInt8(byteOffset, value) {
        const buf3 = allocUnsafe2(1);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        view6.setInt8(0, value);
        this.write(buf3, byteOffset);
      }
      getInt16(byteOffset, littleEndian) {
        const buf3 = this.subarray(byteOffset, byteOffset + 2);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        return view6.getInt16(0, littleEndian);
      }
      setInt16(byteOffset, value, littleEndian) {
        const buf3 = alloc3(2);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        view6.setInt16(0, value, littleEndian);
        this.write(buf3, byteOffset);
      }
      getInt32(byteOffset, littleEndian) {
        const buf3 = this.subarray(byteOffset, byteOffset + 4);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        return view6.getInt32(0, littleEndian);
      }
      setInt32(byteOffset, value, littleEndian) {
        const buf3 = alloc3(4);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        view6.setInt32(0, value, littleEndian);
        this.write(buf3, byteOffset);
      }
      getBigInt64(byteOffset, littleEndian) {
        const buf3 = this.subarray(byteOffset, byteOffset + 8);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        return view6.getBigInt64(0, littleEndian);
      }
      setBigInt64(byteOffset, value, littleEndian) {
        const buf3 = alloc3(8);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        view6.setBigInt64(0, value, littleEndian);
        this.write(buf3, byteOffset);
      }
      getUint8(byteOffset) {
        const buf3 = this.subarray(byteOffset, byteOffset + 1);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        return view6.getUint8(0);
      }
      setUint8(byteOffset, value) {
        const buf3 = allocUnsafe2(1);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        view6.setUint8(0, value);
        this.write(buf3, byteOffset);
      }
      getUint16(byteOffset, littleEndian) {
        const buf3 = this.subarray(byteOffset, byteOffset + 2);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        return view6.getUint16(0, littleEndian);
      }
      setUint16(byteOffset, value, littleEndian) {
        const buf3 = alloc3(2);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        view6.setUint16(0, value, littleEndian);
        this.write(buf3, byteOffset);
      }
      getUint32(byteOffset, littleEndian) {
        const buf3 = this.subarray(byteOffset, byteOffset + 4);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        return view6.getUint32(0, littleEndian);
      }
      setUint32(byteOffset, value, littleEndian) {
        const buf3 = alloc3(4);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        view6.setUint32(0, value, littleEndian);
        this.write(buf3, byteOffset);
      }
      getBigUint64(byteOffset, littleEndian) {
        const buf3 = this.subarray(byteOffset, byteOffset + 8);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        return view6.getBigUint64(0, littleEndian);
      }
      setBigUint64(byteOffset, value, littleEndian) {
        const buf3 = alloc3(8);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        view6.setBigUint64(0, value, littleEndian);
        this.write(buf3, byteOffset);
      }
      getFloat32(byteOffset, littleEndian) {
        const buf3 = this.subarray(byteOffset, byteOffset + 4);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        return view6.getFloat32(0, littleEndian);
      }
      setFloat32(byteOffset, value, littleEndian) {
        const buf3 = alloc3(4);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        view6.setFloat32(0, value, littleEndian);
        this.write(buf3, byteOffset);
      }
      getFloat64(byteOffset, littleEndian) {
        const buf3 = this.subarray(byteOffset, byteOffset + 8);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        return view6.getFloat64(0, littleEndian);
      }
      setFloat64(byteOffset, value, littleEndian) {
        const buf3 = alloc3(8);
        const view6 = new DataView(buf3.buffer, buf3.byteOffset, buf3.byteLength);
        view6.setFloat64(0, value, littleEndian);
        this.write(buf3, byteOffset);
      }
      equals(other) {
        if (other == null) {
          return false;
        }
        if (!(other instanceof _Uint8ArrayList)) {
          return false;
        }
        if (other.bufs.length !== this.bufs.length) {
          return false;
        }
        for (let i = 0; i < this.bufs.length; i++) {
          if (!equals7(this.bufs[i], other.bufs[i])) {
            return false;
          }
        }
        return true;
      }
      /**
       * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this
       * method if you know the total size of all the Uint8Arrays ahead of time.
       */
      static fromUint8Arrays(bufs, length5) {
        const list7 = new _Uint8ArrayList();
        list7.bufs = bufs;
        if (length5 == null) {
          length5 = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);
        }
        list7.length = length5;
        return list7;
      }
    };
  }
});

// ../../node_modules/.pnpm/carstream@2.2.0/node_modules/carstream/src/varint.js
var MSB5, REST5, MSBALL5, INT5, encode44, decode52;
var init_varint9 = __esm({
  "../../node_modules/.pnpm/carstream@2.2.0/node_modules/carstream/src/varint.js"() {
    MSB5 = 128;
    REST5 = 127;
    MSBALL5 = ~REST5;
    INT5 = Math.pow(2, 31);
    encode44 = (num) => {
      const out = [];
      let offset2 = 0;
      while (num >= INT5) {
        out[offset2++] = num & 255 | MSB5;
        num /= 128;
      }
      while (num & MSBALL5) {
        out[offset2++] = num & 255 | MSB5;
        num >>>= 7;
      }
      out[offset2] = num | 0;
      return out;
    };
    decode52 = (buf3, offset2) => {
      let res = 0;
      offset2 = offset2 || 0;
      let shift = 0;
      let counter = offset2;
      let b;
      const l = buf3.length;
      do {
        if (counter >= l || shift > 49) throw new RangeError("Could not decode varint");
        b = buf3.get(counter++);
        res += shift < 28 ? (b & REST5) << shift : (b & REST5) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB5);
      return [res, counter - offset2];
    };
  }
});

// ../../node_modules/.pnpm/carstream@2.2.0/node_modules/carstream/src/reader.js
var State, CIDV0_BYTES2, CARReaderStream, getMultihashLength2;
var init_reader2 = __esm({
  "../../node_modules/.pnpm/carstream@2.2.0/node_modules/carstream/src/reader.js"() {
    init_src14();
    init_src5();
    init_digest3();
    init_link5();
    init_varint9();
    State = {
      ReadHeaderLength: 0,
      ReadHeader: 1,
      ReadBlockLength: 2,
      ReadBlock: 3
    };
    CIDV0_BYTES2 = {
      SHA2_256: 18,
      LENGTH: 32,
      DAG_PB: 112
    };
    CARReaderStream = class extends TransformStream {
      /** @type {Promise<import('./api.js').CARHeader>} */
      #headerPromise;
      /**
       * @param {QueuingStrategy<Uint8Array>} [writableStrategy]
       * An object that optionally defines a queuing strategy for the stream.
       * @param {QueuingStrategy<import('./api.js').Block & import('./api.js').Position>} [readableStrategy]
       * An object that optionally defines a queuing strategy for the stream.
       * Defaults to a CountQueuingStrategy with highWaterMark of `1` to allow
       * `getHeader` to be called before the stream is consumed.
       */
      constructor(writableStrategy, readableStrategy) {
        const buffer3 = new Uint8ArrayList();
        let offset2 = 0;
        let prevOffset = offset2;
        let wanted = 8;
        let state = State.ReadHeaderLength;
        let resolveHeader;
        const headerPromise = new Promise((resolve2) => {
          resolveHeader = resolve2;
        });
        super({
          transform(chunk, controller) {
            buffer3.append(chunk);
            while (true) {
              if (buffer3.length < wanted) break;
              if (state === State.ReadHeaderLength) {
                const [length5, bytes2] = decode52(buffer3);
                buffer3.consume(bytes2);
                prevOffset = offset2;
                offset2 += bytes2;
                state = State.ReadHeader;
                wanted = length5;
              } else if (state === State.ReadHeader) {
                const header = decode18(buffer3.slice(0, wanted));
                resolveHeader && resolveHeader(header);
                buffer3.consume(wanted);
                prevOffset = offset2;
                offset2 += wanted;
                state = State.ReadBlockLength;
                wanted = 8;
              } else if (state === State.ReadBlockLength) {
                const [length5, bytes2] = decode52(buffer3);
                buffer3.consume(bytes2);
                prevOffset = offset2;
                offset2 += bytes2;
                state = State.ReadBlock;
                wanted = length5;
              } else if (state === State.ReadBlock) {
                const _offset = prevOffset;
                const length5 = offset2 - prevOffset + wanted;
                prevOffset = offset2;
                let cid;
                if (buffer3.get(0) === CIDV0_BYTES2.SHA2_256 && buffer3.get(1) === CIDV0_BYTES2.LENGTH) {
                  const bytes3 = buffer3.subarray(0, 34);
                  const multihash = decode17(bytes3);
                  cid = createLegacy2(multihash);
                  buffer3.consume(34);
                  offset2 += 34;
                } else {
                  const [version3, versionBytes] = decode52(buffer3);
                  if (version3 !== 1) throw new Error(`unexpected CID version (${version3})`);
                  buffer3.consume(versionBytes);
                  offset2 += versionBytes;
                  const [codec, codecBytes] = decode52(buffer3);
                  buffer3.consume(codecBytes);
                  offset2 += codecBytes;
                  const multihashBytes = getMultihashLength2(buffer3);
                  const multihash = decode17(buffer3.subarray(0, multihashBytes));
                  cid = create19(codec, multihash);
                  buffer3.consume(multihashBytes);
                  offset2 += multihashBytes;
                }
                const blockBytes = wanted - (offset2 - prevOffset);
                const bytes2 = buffer3.subarray(0, blockBytes);
                controller.enqueue({ cid, bytes: bytes2, offset: _offset, length: length5, blockOffset: offset2, blockLength: blockBytes });
                buffer3.consume(blockBytes);
                prevOffset = offset2;
                offset2 += blockBytes;
                state = State.ReadBlockLength;
                wanted = 8;
              }
            }
          },
          flush(controller) {
            if (state !== State.ReadBlockLength) {
              controller.error(new Error("unexpected end of data"));
            }
          }
        }, writableStrategy, readableStrategy ?? new CountQueuingStrategy({ highWaterMark: 1 }));
        this.#headerPromise = headerPromise;
      }
      /**
       * Get the decoded CAR header.
       */
      getHeader() {
        return this.#headerPromise;
      }
    };
    getMultihashLength2 = (bytes2) => {
      const [, codeBytes] = decode52(bytes2);
      const [length5, lengthBytes] = decode52(bytes2, codeBytes);
      return codeBytes + lengthBytes + length5;
    };
  }
});

// ../../node_modules/.pnpm/carstream@2.2.0/node_modules/carstream/src/writer.js
var encodeHeader2, encodeBlock, CARWriterStream;
var init_writer3 = __esm({
  "../../node_modules/.pnpm/carstream@2.2.0/node_modules/carstream/src/writer.js"() {
    init_src5();
    init_varint9();
    encodeHeader2 = (roots) => {
      const headerBytes = encode15({ version: 1, roots });
      const varintBytes = encode44(headerBytes.length);
      const header = new Uint8Array(varintBytes.length + headerBytes.length);
      header.set(varintBytes, 0);
      header.set(headerBytes, varintBytes.length);
      return header;
    };
    encodeBlock = (block) => {
      const varintBytes = encode44(block.cid.bytes.length + block.bytes.length);
      const bytes2 = new Uint8Array(varintBytes.length + block.cid.bytes.length + block.bytes.length);
      bytes2.set(varintBytes);
      bytes2.set(block.cid.bytes, varintBytes.length);
      bytes2.set(block.bytes, varintBytes.length + block.cid.bytes.length);
      return bytes2;
    };
    CARWriterStream = class extends TransformStream {
      /**
       * @param {import('multiformats').UnknownLink[]} [roots]
       * @param {QueuingStrategy<import('./api.js').Block>} [writableStrategy]
       * @param {QueuingStrategy<Uint8Array>} [readableStrategy]
       */
      constructor(roots = [], writableStrategy, readableStrategy) {
        super({
          start: (controller) => controller.enqueue(encodeHeader2(roots)),
          transform: (block, controller) => controller.enqueue(encodeBlock(block))
        }, writableStrategy, readableStrategy);
      }
    };
  }
});

// ../../node_modules/.pnpm/carstream@2.2.0/node_modules/carstream/src/index.js
var init_src15 = __esm({
  "../../node_modules/.pnpm/carstream@2.2.0/node_modules/carstream/src/index.js"() {
    init_reader2();
    init_writer3();
  }
});

// ../../node_modules/.pnpm/@web3-storage+blob-index@1.0.4/node_modules/@web3-storage/blob-index/dist/src/util.js
async function indexShardedDAG(root2, shards, shardIndexes) {
  const index2 = create20(root2);
  for (const [i, shard] of shards.entries()) {
    const slices = shardIndexes[i];
    index2.shards.set(shard.multihash, slices);
  }
  return await index2.archive();
}
var init_util5 = __esm({
  "../../node_modules/.pnpm/@web3-storage+blob-index@1.0.4/node_modules/@web3-storage/blob-index/dist/src/util.js"() {
    init_src15();
    init_sha24();
    init_api10();
    init_sharded_dag_index();
  }
});

// ../../node_modules/.pnpm/@web3-storage+blob-index@1.0.4/node_modules/@web3-storage/blob-index/dist/src/index.js
var init_src16 = __esm({
  "../../node_modules/.pnpm/@web3-storage+blob-index@1.0.4/node_modules/@web3-storage/blob-index/dist/src/index.js"() {
    init_sharded_dag_index();
    init_digest_map();
    init_util5();
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/sharding.js
function ascending(a, b, getComparedValue) {
  const ask = getComparedValue(a);
  const bsk = getComparedValue(b);
  if (ask === bsk)
    return 0;
  else if (ask < bsk)
    return -1;
  return 1;
}
var SHARD_SIZE, ShardingStream, defaultFileComparator, encodeCAR;
var init_sharding = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/sharding.js"() {
    init_src16();
    init_car3();
    SHARD_SIZE = 133169152;
    ShardingStream = class extends TransformStream {
      /**
       * @param {import('./types.js').ShardingOptions} [options]
       */
      constructor(options = {}) {
        const shardSize2 = options.shardSize ?? SHARD_SIZE;
        const maxBlockLength = shardSize2 - headerEncodingLength();
        let blocks = [];
        let readyBlocks = null;
        let slices = new DigestMap();
        let readySlices = null;
        let currentLength = 0;
        super({
          async transform(block, controller) {
            if (readyBlocks != null && readySlices != null) {
              controller.enqueue(await encodeCAR(readyBlocks, readySlices));
              readyBlocks = null;
              readySlices = null;
            }
            const blockHeaderLength = blockHeaderEncodingLength(block);
            const blockLength2 = blockHeaderLength + block.bytes.length;
            if (blockLength2 > maxBlockLength) {
              throw new Error(`block will cause CAR to exceed shard size: ${block.cid}`);
            }
            if (blocks.length && currentLength + blockLength2 > maxBlockLength) {
              readyBlocks = blocks;
              readySlices = slices;
              blocks = [];
              slices = new DigestMap();
              currentLength = 0;
            }
            blocks.push(block);
            slices.set(block.cid.multihash, [
              headerEncodingLength() + currentLength + blockHeaderLength,
              block.bytes.length
            ]);
            currentLength += blockLength2;
          },
          async flush(controller) {
            if (readyBlocks != null && readySlices != null) {
              controller.enqueue(await encodeCAR(readyBlocks, readySlices));
            }
            const rootBlock = blocks.at(-1);
            if (rootBlock == null)
              return;
            const rootCID = options.rootCID ?? rootBlock.cid;
            const headerLength2 = headerEncodingLength(rootCID);
            if (headerLength2 + currentLength > shardSize2) {
              const overage = headerLength2 + currentLength - shardSize2;
              const overflowBlocks = [];
              let overflowCurrentLength = 0;
              while (overflowCurrentLength < overage) {
                const block = blocks[blocks.length - 1];
                blocks.pop();
                slices.delete(block.cid.multihash);
                overflowBlocks.unshift(block);
                overflowCurrentLength += blockEncodingLength(block);
                if (blocks.length < 1)
                  throw new Error(`block will cause CAR to exceed shard size: ${block.cid}`);
              }
              controller.enqueue(await encodeCAR(blocks, slices));
              overflowCurrentLength = 0;
              const overflowSlices = new DigestMap();
              for (const block of blocks) {
                const overflowBlockHeaderLength = blockHeaderEncodingLength(block);
                overflowSlices.set(block.cid.multihash, [
                  headerLength2 + overflowCurrentLength + overflowBlockHeaderLength,
                  block.bytes.length
                ]);
                overflowCurrentLength += overflowBlockHeaderLength + block.bytes.length;
              }
              controller.enqueue(await encodeCAR(overflowBlocks, overflowSlices, rootCID));
            } else {
              const diff = headerLength2 - headerEncodingLength();
              for (const slice4 of slices.values()) {
                slice4[0] += diff;
              }
              controller.enqueue(await encodeCAR(blocks, slices, rootCID));
            }
          }
        });
      }
    };
    defaultFileComparator = (a, b, getComparedValue = (file) => file.name) => {
      return ascending(a, b, getComparedValue);
    };
    encodeCAR = async (blocks, slices, root2) => Object.assign(await encode41(blocks, root2), { slices });
  }
});

// ../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/index.js
var src_exports6 = {};
__export(src_exports6, {
  Blob: () => blob_exports3,
  CAR: () => car_exports3,
  Index: () => index_exports2,
  Receipt: () => receipts_exports,
  ShardingStream: () => ShardingStream,
  Store: () => store_exports,
  UnixFS: () => unixfs_exports4,
  Upload: () => upload_exports2,
  defaultFileComparator: () => defaultFileComparator,
  receiptsEndpoint: () => receiptsEndpoint,
  uploadCAR: () => uploadCAR,
  uploadDirectory: () => uploadDirectory,
  uploadFile: () => uploadFile
});
async function uploadFile(conf, file, options = {}) {
  return await uploadBlockStream(conf, createFileEncoderStream(file, options), options);
}
async function uploadDirectory(conf, files, options = {}) {
  const { customOrder = false } = options;
  const entries3 = customOrder ? files : [...files].sort(defaultFileComparator);
  return await uploadBlockStream(conf, createDirectoryEncoderStream(entries3, options), options);
}
async function uploadCAR(conf, car, options = {}) {
  const blocks = new BlockStream(car);
  options.rootCID = options.rootCID ?? (await blocks.getRoots())[0];
  return await uploadBlockStream(conf, blocks, options);
}
async function uploadBlockStream(conf, blocks, { pieceHasher = multihash_exports, ...options } = {}) {
  const configure7 = typeof conf === "function" ? conf : () => conf;
  const shardIndexes = [];
  const shards = [];
  let root2 = null;
  await blocks.pipeThrough(new ShardingStream(options)).pipeThrough(
    /** @type {TransformStream<import('./types.js').IndexedCARFile, import('./types.js').CARMetadata>} */
    new TransformStream({
      async transform(car, controller) {
        const bytes2 = new Uint8Array(await car.arrayBuffer());
        const digest6 = await sha2563.digest(bytes2);
        const conf2 = await configure7([
          {
            can: ability,
            nb: input(digest6, bytes2.length)
          }
        ]);
        await add4(conf2, digest6, bytes2, options);
        const cid = create12(code23, digest6);
        let piece;
        if (pieceHasher) {
          const multihashDigest = await pieceHasher.digest(bytes2);
          piece = create12(code16, multihashDigest);
          const content2 = create12(code16, digest6);
          const result = await storefront_exports.filecoinOffer({
            issuer: conf2.issuer,
            audience: conf2.audience,
            // Resource of invocation is the issuer did for being self issued
            with: conf2.issuer.did(),
            proofs: conf2.proofs
          }, content2, piece, options);
          if (result.out.error) {
            throw new Error("failed to offer piece for aggregation into filecoin deal", { cause: result.out.error });
          }
        }
        const { version: version3, roots, size: size5, slices } = car;
        controller.enqueue({ version: version3, roots, size: size5, cid, piece, slices });
      }
    })
  ).pipeTo(new WritableStream({
    write(meta) {
      root2 = root2 || meta.roots[0];
      shards.push(meta.cid);
      meta.slices.set(meta.cid.multihash, [0, meta.size]);
      shardIndexes.push(meta.slices);
      if (options.onShardStored)
        options.onShardStored(meta);
    }
  }));
  if (!root2)
    throw new Error("missing root CID");
  const indexBytes = await indexShardedDAG(root2, shards, shardIndexes);
  if (!indexBytes.ok) {
    throw new Error("failed to archive DAG index", { cause: indexBytes.error });
  }
  const indexDigest = await sha2563.digest(indexBytes.ok);
  const indexLink = create12(code23, indexDigest);
  const [blobAddConf, indexAddConf, uploadAddConf] = await Promise.all([
    configure7([
      {
        can: ability,
        nb: input(indexDigest, indexBytes.ok.length)
      }
    ]),
    configure7([
      {
        can: ability5,
        nb: input5(indexLink)
      }
    ]),
    configure7([
      {
        can: ability6,
        nb: input6(root2, shards)
      }
    ])
  ]);
  await add4(blobAddConf, indexDigest, indexBytes.ok, options);
  await add6(indexAddConf, indexLink, options);
  await add8(uploadAddConf, root2, shards, options);
  return root2;
}
var init_src17 = __esm({
  "../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/dist/src/index.js"() {
    init_multihash();
    init_src9();
    init_link4();
    init_raw3();
    init_sha23();
    init_store2();
    init_blob3();
    init_add6();
    init_index2();
    init_add7();
    init_upload2();
    init_add8();
    init_unixfs5();
    init_car3();
    init_sharding();
    init_src16();
    init_sharding();
    init_service3();
    init_receipts();
  }
});

// src/index.ts
var src_exports7 = {};
__export(src_exports7, {
  ApplicationAccessTokenService: () => ApplicationAccessTokenService,
  FleekSdk: () => FleekSdk,
  PersonalAccessTokenService: () => PersonalAccessTokenService,
  StaticAccessTokenService: () => StaticAccessTokenService,
  createClient: () => createClient2
});
module.exports = __toCommonJS(src_exports7);

// src/FleekSdk.ts
var import_auth3 = __toESM(require_dist2());
var import_errors12 = __toESM(require_dist());

// ../gql-client-utils/dist/runtime/error.ts
var GenqlError = class extends Error {
  constructor(errors2, data) {
    let message = Array.isArray(errors2) ? errors2.map((x) => x?.message || "").join("\n") : "";
    if (!message) {
      message = "GraphQL error";
    }
    super(message);
    this.errors = [];
    this.errors = errors2;
    this.data = data;
  }
};

// ../gql-client-utils/dist/runtime/batcher.ts
function dispatchQueueBatch(client, queue) {
  let batchedQuery = queue.map((item) => item.request);
  if (batchedQuery.length === 1) {
    batchedQuery = batchedQuery[0];
  }
  (() => {
    try {
      return client.fetcher(batchedQuery);
    } catch (e) {
      return Promise.reject(e);
    }
  })().then((responses) => {
    if (queue.length === 1 && !Array.isArray(responses)) {
      if (responses.errors && responses.errors.length) {
        queue[0].reject(
          new GenqlError(responses.errors, responses.data)
        );
        return;
      }
      queue[0].resolve(responses);
      return;
    } else if (responses.length !== queue.length) {
      throw new Error("response length did not match query length");
    }
    for (let i = 0; i < queue.length; i++) {
      if (responses[i].errors && responses[i].errors.length) {
        queue[i].reject(
          new GenqlError(responses[i].errors, responses[i].data)
        );
      } else {
        queue[i].resolve(responses[i]);
      }
    }
  }).catch((e) => {
    for (let i = 0; i < queue.length; i++) {
      queue[i].reject(e);
    }
  });
}
function dispatchQueue(client, options) {
  const queue = client._queue;
  const maxBatchSize = options.maxBatchSize || 0;
  client._queue = [];
  if (maxBatchSize > 0 && maxBatchSize < queue.length) {
    for (let i = 0; i < queue.length / maxBatchSize; i++) {
      dispatchQueueBatch(
        client,
        queue.slice(i * maxBatchSize, (i + 1) * maxBatchSize)
      );
    }
  } else {
    dispatchQueueBatch(client, queue);
  }
}
var QueryBatcher = class _QueryBatcher {
  constructor(fetcher, {
    batchInterval = 6,
    shouldBatch = true,
    maxBatchSize = 0
  } = {}) {
    this.fetcher = fetcher;
    this._options = {
      batchInterval,
      shouldBatch,
      maxBatchSize
    };
    this._queue = [];
  }
  /**
   * Fetch will send a graphql request and return the parsed json.
   * @param {string}      query          - the graphql query.
   * @param {Variables}   variables      - any variables you wish to inject as key/value pairs.
   * @param {[string]}    operationName  - the graphql operationName.
   * @param {Options}     overrides      - the client options overrides.
   *
   * @return {promise} resolves to parsed json of server response
   *
   * @example
   * client.fetch(`
   *    query getHuman($id: ID!) {
   *      human(id: $id) {
   *        name
   *        height
   *      }
   *    }
   * `, { id: "1001" }, 'getHuman')
   *    .then(human => {
   *      // do something with human
   *      console.log(human);
   *    });
   */
  fetch(query, variables, operationName, overrides = {}) {
    const request = {
      query
    };
    const options = Object.assign({}, this._options, overrides);
    if (variables) {
      request.variables = variables;
    }
    if (operationName) {
      request.operationName = operationName;
    }
    const promise = new Promise((resolve2, reject) => {
      this._queue.push({
        request,
        resolve: resolve2,
        reject
      });
      if (this._queue.length === 1) {
        if (options.shouldBatch) {
          setTimeout(
            () => dispatchQueue(this, options),
            options.batchInterval
          );
        } else {
          dispatchQueue(this, options);
        }
      }
    });
    return promise;
  }
  /**
   * Fetch will send a graphql request and return the parsed json.
   * @param {string}      query          - the graphql query.
   * @param {Variables}   variables      - any variables you wish to inject as key/value pairs.
   * @param {[string]}    operationName  - the graphql operationName.
   * @param {Options}     overrides      - the client options overrides.
   *
   * @return {Promise<Array<Result>>} resolves to parsed json of server response
   *
   * @example
   * client.forceFetch(`
   *    query getHuman($id: ID!) {
   *      human(id: $id) {
   *        name
   *        height
   *      }
   *    }
   * `, { id: "1001" }, 'getHuman')
   *    .then(human => {
   *      // do something with human
   *      console.log(human);
   *    });
   */
  forceFetch(query, variables, operationName, overrides = {}) {
    const request = {
      query
    };
    const options = Object.assign({}, this._options, overrides, {
      shouldBatch: false
    });
    if (variables) {
      request.variables = variables;
    }
    if (operationName) {
      request.operationName = operationName;
    }
    const promise = new Promise((resolve2, reject) => {
      const client = new _QueryBatcher(this.fetcher, this._options);
      client._queue = [
        {
          request,
          resolve: resolve2,
          reject
        }
      ];
      dispatchQueue(client, options);
    });
    return promise;
  }
};

// ../gql-client-utils/dist/runtime/fetcher.ts
var DEFAULT_BATCH_OPTIONS = {
  maxBatchSize: 10,
  batchInterval: 40
};
var createFetcher = ({
  url,
  headers = {},
  fetcher,
  fetch: _fetch,
  batch: batch2 = false,
  ...rest
}) => {
  if (!url && !fetcher) {
    throw new Error("url or fetcher is required");
  }
  fetcher = fetcher || (async (body) => {
    let headersObject = typeof headers == "function" ? await headers() : headers;
    headersObject = headersObject || {};
    if (typeof fetch === "undefined" && !_fetch) {
      throw new Error(
        "Global `fetch` function is not available, pass a fetch polyfill to Genql `createClient`"
      );
    }
    let fetchImpl = _fetch || fetch;
    const res = await fetchImpl(url, {
      headers: {
        "Content-Type": "application/json",
        ...headersObject
      },
      method: "POST",
      body: JSON.stringify(body),
      ...rest
    });
    if (!res.ok) {
      throw new Error(`${res.statusText}: ${await res.text()}`);
    }
    const json = await res.json();
    return json;
  });
  if (!batch2) {
    return async (body) => {
      const json = await fetcher(body);
      if (Array.isArray(json)) {
        return json.map((json2) => {
          if (json2?.errors?.length) {
            throw new GenqlError(json2.errors || [], json2.data);
          }
          return json2.data;
        });
      } else {
        if (json?.errors?.length) {
          throw new GenqlError(json.errors || [], json.data);
        }
        return json.data;
      }
    };
  }
  const batcher = new QueryBatcher(
    async (batchedQuery) => {
      const json = await fetcher(batchedQuery);
      return json;
    },
    batch2 === true ? DEFAULT_BATCH_OPTIONS : batch2
  );
  return async ({ query, variables }) => {
    const json = await batcher.fetch(query, variables);
    if (json?.data) {
      return json.data;
    }
    throw new Error(
      "Genql batch fetcher returned unexpected result " + JSON.stringify(json)
    );
  };
};

// ../gql-client-utils/dist/runtime/generateGraphqlOperation.ts
var parseRequest = (request, ctx, path) => {
  if (typeof request === "object" && "__args" in request) {
    const args = request.__args;
    let fields = { ...request };
    delete fields.__args;
    const argNames = Object.keys(args);
    if (argNames.length === 0) {
      return parseRequest(fields, ctx, path);
    }
    const field = getFieldFromPath(ctx.root, path);
    const argStrings = argNames.map((argName) => {
      ctx.varCounter++;
      const varName = `v${ctx.varCounter}`;
      const typing = field.args && field.args[argName];
      if (!typing) {
        throw new Error(
          `no typing defined for argument \`${argName}\` in path \`${path.join(
            "."
          )}\``
        );
      }
      ctx.variables[varName] = {
        value: args[argName],
        typing
      };
      return `${argName}:$${varName}`;
    });
    return `(${argStrings})${parseRequest(fields, ctx, path)}`;
  } else if (typeof request === "object" && Object.keys(request).length > 0) {
    const fields = request;
    const fieldNames = Object.keys(fields).filter((k) => Boolean(fields[k]));
    if (fieldNames.length === 0) {
      throw new Error(
        `field selection should not be empty: ${path.join(".")}`
      );
    }
    const type2 = path.length > 0 ? getFieldFromPath(ctx.root, path).type : ctx.root;
    const scalarFields = type2.scalar;
    let scalarFieldsFragment;
    if (fieldNames.includes("__scalar")) {
      const falsyFieldNames = new Set(
        Object.keys(fields).filter((k) => !Boolean(fields[k]))
      );
      if (scalarFields?.length) {
        ctx.fragmentCounter++;
        scalarFieldsFragment = `f${ctx.fragmentCounter}`;
        ctx.fragments.push(
          `fragment ${scalarFieldsFragment} on ${type2.name}{${scalarFields.filter((f) => !falsyFieldNames.has(f)).join(",")}}`
        );
      }
    }
    const fieldsSelection = fieldNames.filter((f) => !["__scalar", "__name"].includes(f)).map((f) => {
      const parsed = parseRequest(fields[f], ctx, [...path, f]);
      if (f.startsWith("on_")) {
        ctx.fragmentCounter++;
        const implementationFragment = `f${ctx.fragmentCounter}`;
        const typeMatch = f.match(/^on_(.+)/);
        if (!typeMatch || !typeMatch[1])
          throw new Error("match failed");
        ctx.fragments.push(
          `fragment ${implementationFragment} on ${typeMatch[1]}${parsed}`
        );
        return `...${implementationFragment}`;
      } else {
        return `${f}${parsed}`;
      }
    }).concat(scalarFieldsFragment ? [`...${scalarFieldsFragment}`] : []).join(",");
    return `{${fieldsSelection}}`;
  } else {
    return "";
  }
};
var generateGraphqlOperation = (operation, root2, fields) => {
  const ctx = {
    root: root2,
    varCounter: 0,
    variables: {},
    fragmentCounter: 0,
    fragments: []
  };
  const result = parseRequest(fields, ctx, []);
  const varNames = Object.keys(ctx.variables);
  const varsString = varNames.length > 0 ? `(${varNames.map((v) => {
    const variableType = ctx.variables[v].typing[1];
    return `$${v}:${variableType}`;
  })})` : "";
  const operationName = fields?.__name || "";
  return {
    query: [
      `${operation} ${operationName}${varsString}${result}`,
      ...ctx.fragments
    ].join(","),
    variables: Object.keys(ctx.variables).reduce(
      (r, v) => {
        r[v] = ctx.variables[v].value;
        return r;
      },
      {}
    ),
    ...operationName ? { operationName: operationName.toString() } : {}
  };
};
var getFieldFromPath = (root2, path) => {
  let current2;
  if (!root2) throw new Error("root type is not provided");
  if (path.length === 0) throw new Error(`path is empty`);
  path.forEach((f) => {
    const type2 = current2 ? current2.type : root2;
    if (!type2.fields)
      throw new Error(`type \`${type2.name}\` does not have fields`);
    const possibleTypes = Object.keys(type2.fields).filter((i) => i.startsWith("on_")).reduce(
      (types, fieldName) => {
        const field2 = type2.fields && type2.fields[fieldName];
        if (field2) types.push(field2.type);
        return types;
      },
      [type2]
    );
    let field = null;
    possibleTypes.forEach((type3) => {
      const found = type3.fields && type3.fields[f];
      if (found) field = found;
    });
    if (!field)
      throw new Error(
        `type \`${type2.name}\` does not have a field \`${f}\``
      );
    current2 = field;
  });
  return current2;
};

// ../gql-client-utils/dist/runtime/createClient.ts
var createClient = ({
  queryRoot,
  mutationRoot,
  subscriptionRoot,
  ...options
}) => {
  const fetcher = createFetcher(options);
  const client = {};
  if (queryRoot) {
    client.query = (request) => {
      if (!queryRoot) throw new Error("queryRoot argument is missing");
      const resultPromise = fetcher(
        generateGraphqlOperation("query", queryRoot, request)
      );
      return resultPromise;
    };
  }
  if (mutationRoot) {
    client.mutation = (request) => {
      if (!mutationRoot)
        throw new Error("mutationRoot argument is missing");
      const resultPromise = fetcher(
        generateGraphqlOperation("mutation", mutationRoot, request)
      );
      return resultPromise;
    };
  }
  return client;
};

// ../gql-client-utils/dist/runtime/linkTypeMap.ts
var linkTypeMap = (typeMap2) => {
  const indexToName = Object.assign(
    {},
    ...Object.keys(typeMap2.types).map((k, i) => ({ [i]: k }))
  );
  let intermediaryTypeMap = Object.assign(
    {},
    ...Object.keys(typeMap2.types || {}).map(
      (k) => {
        const type2 = typeMap2.types[k];
        const fields = type2 || {};
        return {
          [k]: {
            name: k,
            // type scalar properties
            scalar: Object.keys(fields).filter((f) => {
              const [type3] = fields[f] || [];
              const isScalar = type3 && typeMap2.scalars.includes(type3);
              if (!isScalar) {
                return false;
              }
              const args = fields[f]?.[1];
              const argTypes = Object.values(args || {}).map((x) => x?.[1]).filter(Boolean);
              const hasRequiredArgs = argTypes.some(
                (str) => str && str.endsWith("!")
              );
              if (hasRequiredArgs) {
                return false;
              }
              return true;
            }),
            // fields with corresponding `type` and `args`
            fields: Object.assign(
              {},
              ...Object.keys(fields).map(
                (f) => {
                  const [typeIndex, args] = fields[f] || [];
                  if (typeIndex == null) {
                    return {};
                  }
                  return {
                    [f]: {
                      // replace index with type name
                      type: indexToName[typeIndex],
                      args: Object.assign(
                        {},
                        ...Object.keys(args || {}).map(
                          (k2) => {
                            if (!args || !args[k2]) {
                              return;
                            }
                            const [
                              argTypeName,
                              argTypeString
                            ] = args[k2];
                            return {
                              [k2]: [
                                indexToName[argTypeName],
                                argTypeString || indexToName[argTypeName]
                              ]
                            };
                          }
                        )
                      )
                    }
                  };
                }
              )
            )
          }
        };
      }
    )
  );
  const res = resolveConcreteTypes(intermediaryTypeMap);
  return res;
};
var resolveConcreteTypes = (linkedTypeMap) => {
  Object.keys(linkedTypeMap).forEach((typeNameFromKey) => {
    const type2 = linkedTypeMap[typeNameFromKey];
    if (!type2.fields) {
      return;
    }
    const fields = type2.fields;
    Object.keys(fields).forEach((f) => {
      const field = fields[f];
      if (field.args) {
        const args = field.args;
        Object.keys(args).forEach((key) => {
          const arg = args[key];
          if (arg) {
            const [typeName2] = arg;
            if (typeof typeName2 === "string") {
              if (!linkedTypeMap[typeName2]) {
                linkedTypeMap[typeName2] = { name: typeName2 };
              }
              arg[0] = linkedTypeMap[typeName2];
            }
          }
        });
      }
      const typeName = field.type;
      if (typeof typeName === "string") {
        if (!linkedTypeMap[typeName]) {
          linkedTypeMap[typeName] = { name: typeName };
        }
        field.type = linkedTypeMap[typeName];
      }
    });
  });
  return linkedTypeMap;
};

// ../gql-client-utils/dist/types.ts
var types_default = {
  "scalars": [
    1,
    3,
    8,
    9,
    14,
    16,
    18,
    23,
    24,
    26,
    27,
    28,
    30,
    38,
    39,
    73,
    95,
    96,
    105,
    106,
    110,
    123,
    131,
    145,
    163,
    180,
    194,
    204,
    210,
    212,
    256,
    262,
    263,
    264,
    274,
    284,
    285,
    287,
    288,
    295,
    305,
    344,
    345,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360
  ],
  "types": {
    "AcceptInvitationWhereInput": {
      "hash": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "ID": {},
    "Application": {
      "clientId": [
        3
      ],
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "updatedAt": [
        73
      ],
      "whiteLabelDomains": [
        6
      ],
      "whiteLabelDomainsPaginated": [
        7,
        {
          "filter": [
            215
          ]
        }
      ],
      "whitelistDomains": [
        10
      ],
      "__typename": [
        3
      ]
    },
    "String": {},
    "ApplicationNameAvailabilityWhereInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "ApplicationWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "ApplicationWhiteLabelDomain": {
      "createdAt": [
        73
      ],
      "hostname": [
        3
      ],
      "id": [
        1
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "ApplicationWhiteLabelDomainsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        6
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "Int": {},
    "Boolean": {},
    "ApplicationWhitelistDomain": {
      "createdAt": [
        73
      ],
      "hostname": [
        3
      ],
      "id": [
        1
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "ApplicationsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "ApplicationsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        2
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "ArweavePin": {
      "bundlrId": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "BigInt": {},
    "BillingCycle": {
      "billingCycleUsages": [
        17
      ],
      "billingPartnerTransactionId": [
        3
      ],
      "createdAt": [
        73
      ],
      "endDate": [
        73
      ],
      "id": [
        1
      ],
      "project": [
        238
      ],
      "projectId": [
        3
      ],
      "startDate": [
        73
      ],
      "status": [
        16
      ],
      "subscription": [
        34
      ],
      "subscriptionId": [
        3
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "BillingCycleStatus": {},
    "BillingCycleUsage": {
      "amount": [
        18
      ],
      "billingCycle": [
        15
      ],
      "billingCycleId": [
        3
      ],
      "billingPlanOverageRule": [
        25
      ],
      "billingPlanOverageRuleId": [
        3
      ],
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "Float": {},
    "BillingCycleUsagesPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "BillingCycleUsagesWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        17
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "BillingPlan": {
      "billingPartnerId": [
        3
      ],
      "billingPlanEnablementRules": [
        22
      ],
      "billingPlanOverageRules": [
        25
      ],
      "billingPlanTierRules": [
        29
      ],
      "createdAt": [
        73
      ],
      "disabledAt": [
        73
      ],
      "id": [
        1
      ],
      "isActive": [
        9
      ],
      "isPublicPlan": [
        9
      ],
      "name": [
        3
      ],
      "planLevel": [
        24
      ],
      "price": [
        18
      ],
      "updatedAt": [
        73
      ],
      "version": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "BillingPlanEnablementRule": {
      "billingPlan": [
        21
      ],
      "billingPlanId": [
        3
      ],
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "isIncluded": [
        9
      ],
      "name": [
        3
      ],
      "type": [
        23
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "BillingPlanEnablementRuleType": {},
    "BillingPlanLevel": {},
    "BillingPlanOverageRule": {
      "billingPlanId": [
        1
      ],
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "includedAmount": [
        8
      ],
      "name": [
        3
      ],
      "overageBucketSize": [
        8
      ],
      "overagePrice": [
        18
      ],
      "overageType": [
        27
      ],
      "type": [
        26
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "BillingPlanOverageRuleType": {},
    "BillingPlanOverageType": {},
    "BillingPlanStatus": {},
    "BillingPlanTierRule": {
      "billingPlan": [
        21
      ],
      "billingPlanId": [
        3
      ],
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "type": [
        3
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "BillingPlanTierRuleType": {},
    "BillingPlanWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "BillingPlansPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "BillingPlansWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        21
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "BillingSubscription": {
      "billingPartnerSubscriptionId": [
        3
      ],
      "createdAt": [
        73
      ],
      "endDate": [
        73
      ],
      "id": [
        1
      ],
      "isActive": [
        9
      ],
      "project": [
        238
      ],
      "projectId": [
        3
      ],
      "startDate": [
        73
      ],
      "type": [
        288
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "Build": {
      "baseDirectory": [
        3
      ],
      "buildCommand": [
        3
      ],
      "distDirectory": [
        3
      ],
      "dockerImage": [
        3
      ],
      "id": [
        1
      ],
      "logs": [
        36
      ],
      "logsPaginated": [
        37,
        {
          "filter": [
            215
          ]
        }
      ],
      "status": [
        38
      ],
      "__typename": [
        3
      ]
    },
    "BuildLog": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "text": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "BuildLogsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        36
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "BuildStatus": {},
    "CID": {},
    "CreateApplicationDataInput": {
      "name": [
        3
      ],
      "whiteLabelDomains": [
        3
      ],
      "whitelistDomains": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateBillingCycleUsageDataInput": {
      "amount": [
        18
      ],
      "billingCycleId": [
        1
      ],
      "billingPlanOverageRuleId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateBillingPlanDataInput": {
      "billingPartnerId": [
        1
      ],
      "description": [
        3
      ],
      "isActive": [
        9
      ],
      "isPublicPlan": [
        9
      ],
      "name": [
        3
      ],
      "planLevel": [
        24
      ],
      "price": [
        18
      ],
      "version": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "CreateCustomIpfsDeploymentDataInput": {
      "cid": [
        39
      ],
      "siteId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateDnsConfigDataInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateDnsConfigWhereInput": {
      "domainId": [
        1
      ],
      "siteId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateDomainDataInput": {
      "hostname": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateDomainWhereInput": {
      "zoneId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateEnsRecordDataInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateEnsRecordWhereInput": {
      "ipnsRecordId": [
        1
      ],
      "siteId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateFleekFunctionDataInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateFolderDataInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateFolderWhereInput": {
      "parentFolderId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateGithubAppAuthorizationUrlWhereInput": {
      "gitProviderId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateGithubAppInstallationUrlWhereInput": {
      "gitProviderId": [
        1
      ],
      "projectId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateGithubIntegrationForProjectDataInput": {
      "projectId": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateGithubRepoFromTemplateDataInput": {
      "isPrivate": [
        9
      ],
      "repoName": [
        3
      ],
      "repoOwner": [
        3
      ],
      "templateOwner": [
        3
      ],
      "templateRepo": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateGithubRepoFromTemplateWhereInput": {
      "gitIntegrationId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateInvitationDataInput": {
      "email": [
        3
      ],
      "permissionGroupId": [
        1
      ],
      "role": [
        256
      ],
      "__typename": [
        3
      ]
    },
    "CreateIpnsRecordForSiteWhereInput": {
      "siteId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateLoginVerificationSessionWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateMigrationRequestsFromTokenDataInput": {
      "token": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateMigrationTokenDataInput": {
      "teamIds": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreatePersonalAccessTokenFromVerificationSessionDataInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreatePersonalAccessTokenFromVerificationSessionWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreatePrivateGatewayDataInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreatePrivateGatewayWhereInput": {
      "zoneId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateProjectDataInput": {
      "name": [
        3
      ],
      "planId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateSalesContactRequestDataInput": {
      "description": [
        3
      ],
      "email": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "CreateSecretDataInput": {
      "groupId": [
        1
      ],
      "key": [
        3
      ],
      "value": [
        3
      ],
      "visibility": [
        264
      ],
      "__typename": [
        3
      ]
    },
    "CreateSiteDataInput": {
      "baseDirectory": [
        3
      ],
      "buildCommand": [
        3
      ],
      "distDirectory": [
        3
      ],
      "dockerImage": [
        3
      ],
      "enablePreviews": [
        9
      ],
      "frameworkId": [
        1
      ],
      "gitIntegrationId": [
        1
      ],
      "githubInstallationId": [
        8
      ],
      "name": [
        3
      ],
      "sourceBranch": [
        3
      ],
      "sourceProvider": [
        285
      ],
      "sourceRepositoryId": [
        3
      ],
      "sourceRepositoryName": [
        3
      ],
      "sourceRepositoryOwner": [
        3
      ],
      "templateId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateTemplateDataInput": {
      "banner": [
        131
      ],
      "description": [
        3
      ],
      "name": [
        3
      ],
      "siteId": [
        1
      ],
      "templateCategoryId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "CreateZoneForSiteWhereInput": {
      "siteId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "Date": {},
    "DeclineInvitationWhereInput": {
      "hash": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "DeleteApplicationWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteDomainWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteEnsRecordWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteFleekFunctionWhereInput": {
      "id": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "DeleteFolderWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteInvitationWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteIpnsRecordWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteMembershipWhereInput": {
      "projectId": [
        1
      ],
      "userId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeletePersonalAccessTokenWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeletePinWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeletePrivateGatewayWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteProjectWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteRecoveryCodesWhereInput": {
      "secretKeyId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteSecretKeyWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteSecretWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteSiteWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteTemplateWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteUserWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeleteZoneWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "Deployment": {
      "build": [
        35
      ],
      "cid": [
        3
      ],
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "previewImageUrl": [
        3
      ],
      "previewOnly": [
        9
      ],
      "previewUrlSlug": [
        3
      ],
      "siteId": [
        1
      ],
      "sourceAuthor": [
        3
      ],
      "sourceBranch": [
        3
      ],
      "sourceMessage": [
        3
      ],
      "sourceProvider": [
        285
      ],
      "sourceRef": [
        3
      ],
      "sourceRepositoryId": [
        3
      ],
      "sourceRepositoryName": [
        3
      ],
      "sourceRepositoryOwner": [
        3
      ],
      "startedAt": [
        73
      ],
      "status": [
        96
      ],
      "storageType": [
        287
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "DeploymentMode": {},
    "DeploymentStatus": {},
    "DeploymentWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeploymentsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        349
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "DeploymentsQueueLimitWhereInput": {
      "siteId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DeploymentsWhereInput": {
      "branch": [
        3
      ],
      "deploymentMode": [
        95
      ],
      "endDate": [
        73
      ],
      "siteId": [
        1
      ],
      "startDate": [
        73
      ],
      "status": [
        96
      ],
      "statuses": [
        96
      ],
      "__typename": [
        3
      ]
    },
    "DeploymentsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        94
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "DeploymentsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        94
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "DisableTwoFactorProtectedActionWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DnsConfig": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "type": [
        105
      ],
      "updatedAt": [
        73
      ],
      "value": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "DnsConfigType": {},
    "DnslinkStatus": {},
    "Domain": {
      "createdAt": [
        73
      ],
      "dnsConfigs": [
        104
      ],
      "dnslinkStatus": [
        106
      ],
      "errorMessage": [
        3
      ],
      "hostname": [
        3
      ],
      "id": [
        1
      ],
      "isVerified": [
        9
      ],
      "project": [
        238
      ],
      "status": [
        110
      ],
      "updatedAt": [
        73
      ],
      "zone": [
        343
      ],
      "__typename": [
        3
      ]
    },
    "DomainAvailabilityWhereInput": {
      "hostname": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "DomainByHostnameWhereInput": {
      "hostname": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "DomainStatus": {},
    "DomainWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DomainsByZoneIdPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "DomainsByZoneIdWhereInput": {
      "zoneId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "DomainsByZoneIdWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        107
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "DomainsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "DomainsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        107
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "DomainsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        107
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "EmailAvailabilityWhereInput": {
      "email": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "EnableTwoFactorProtectedActionWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "EnsNameAvailabilityWhereInput": {
      "name": [
        3
      ],
      "siteId": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "EnsRecord": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "ipnsRecord": [
        175
      ],
      "name": [
        3
      ],
      "site": [
        267
      ],
      "status": [
        123
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "EnsRecordByNameWhereInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "EnsRecordStatus": {},
    "EnsRecordWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "EnsRecordsByIpnsIdPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "EnsRecordsByIpnsIdWhereInput": {
      "ipnsRecordId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "EnsRecordsByIpnsIdWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        121
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "EnsRecordsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "EnsRecordsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        121
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "EnsRecordsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        121
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "File": {},
    "FilecoinDeal": {
      "activation": [
        73
      ],
      "cid": [
        3
      ],
      "created": [
        73
      ],
      "dataModelSelector": [
        3
      ],
      "dealId": [
        8
      ],
      "expiration": [
        73
      ],
      "pieceCid": [
        3
      ],
      "status": [
        3
      ],
      "storageProvider": [
        3
      ],
      "updated": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "FilecoinDealsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        350
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "FilecoinDealsWhereInput": {
      "cid": [
        39
      ],
      "__typename": [
        3
      ]
    },
    "FilecoinDealsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        132
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "FilecoinDealsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        132
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "FilecoinPin": {
      "cid": [
        3
      ],
      "deals": [
        132
      ],
      "dealsPaginated": [
        136,
        {
          "filter": [
            215
          ]
        }
      ],
      "__typename": [
        3
      ]
    },
    "FleekFunction": {
      "createdAt": [
        73
      ],
      "currentDeployment": [
        140
      ],
      "currentDeploymentId": [
        3
      ],
      "deployments": [
        140
      ],
      "id": [
        1
      ],
      "invokeUrl": [
        3
      ],
      "name": [
        3
      ],
      "projectId": [
        3
      ],
      "slug": [
        3
      ],
      "status": [
        145
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "FleekFunctionByNameWhereInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "FleekFunctionDeployment": {
      "blake3Hash": [
        3
      ],
      "cid": [
        3
      ],
      "createdAt": [
        73
      ],
      "fleekFunctionId": [
        3
      ],
      "id": [
        1
      ],
      "projectId": [
        3
      ],
      "sgx": [
        9
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "FleekFunctionDeploymentWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "FleekFunctionDeploymentsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "FleekFunctionDeploymentsWhereInput": {
      "fleekFunctionId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "FleekFunctionDeploymentsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        140
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "FleekFunctionStatus": {},
    "FleekFunctionsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "FleekFunctionsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        138
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "Folder": {
      "createdAt": [
        73
      ],
      "folderCount": [
        8
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "path": [
        3
      ],
      "pinCount": [
        8
      ],
      "sizeBigInt": [
        14
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "FolderOrPin": {
      "on_Folder": [
        148
      ],
      "on_Pin": [
        222
      ],
      "__typename": [
        3
      ]
    },
    "FolderWhereInput": {
      "id": [
        1
      ],
      "path": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "GenerateRecoveryCodesWhereInput": {
      "secretKeyId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "GitApiBranch": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "GitApiBranchesWhereInput": {
      "gitProviderId": [
        1
      ],
      "sourceRepositoryName": [
        3
      ],
      "sourceRepositoryOwner": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "GitApiInsatallation": {
      "avatar": [
        3
      ],
      "installationId": [
        8
      ],
      "isOrganization": [
        9
      ],
      "name": [
        3
      ],
      "repos": [
        157
      ],
      "__typename": [
        3
      ]
    },
    "GitApiInstallationsWhereInput": {
      "gitProviderId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "GitApiIsRepoNameAvailableWhereInput": {
      "gitProviderId": [
        1
      ],
      "owner": [
        3
      ],
      "repo": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "GitApiRepo": {
      "defaultBranch": [
        3
      ],
      "id": [
        8
      ],
      "installationId": [
        8
      ],
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "GitApiTree": {
      "mode": [
        3
      ],
      "path": [
        3
      ],
      "sha": [
        3
      ],
      "size": [
        8
      ],
      "type": [
        3
      ],
      "url": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "GitApiTreeWhereInput": {
      "gitProviderId": [
        1
      ],
      "sourceBranch": [
        3
      ],
      "sourceRepositoryName": [
        3
      ],
      "sourceRepositoryOwner": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "GitIntegration": {
      "createdAt": [
        73
      ],
      "gitProvider": [
        162
      ],
      "githubAppInstallation": [
        166
      ],
      "id": [
        1
      ],
      "projectId": [
        3
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "GitIntegrationWhereInput": {
      "gitProviderId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "GitProvider": {
      "createdAt": [
        73
      ],
      "enabled": [
        9
      ],
      "gitUserAccessTokens": [
        165
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "sourceProvider": [
        285
      ],
      "tags": [
        180
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "GitProviderTags": {},
    "GitProviderWhereInput": {
      "tag": [
        163
      ],
      "__typename": [
        3
      ]
    },
    "GitUserAccessToken": {
      "createdAt": [
        73
      ],
      "gitProviderId": [
        3
      ],
      "id": [
        1
      ],
      "token": [
        3
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "GithubAppInstallation": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "installationId": [
        3
      ],
      "projectId": [
        3
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "GithubAppInstallationsWhereInput": {
      "gitProviderId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "GithubRepo": {
      "defaultBranch": [
        3
      ],
      "isPrivate": [
        9
      ],
      "name": [
        3
      ],
      "repositoryId": [
        8
      ],
      "url": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "Invitation": {
      "createdAt": [
        73
      ],
      "createdBy": [
        334
      ],
      "email": [
        3
      ],
      "id": [
        1
      ],
      "permissionGroup": [
        216
      ],
      "role": [
        256
      ],
      "__typename": [
        3
      ]
    },
    "InvitationDetail": {
      "hash": [
        3
      ],
      "permissionGroup": [
        216
      ],
      "projectAvatar": [
        131
      ],
      "projectId": [
        3
      ],
      "projectName": [
        3
      ],
      "role": [
        256
      ],
      "__typename": [
        3
      ]
    },
    "InvitationDetailsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        170
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "InvitationWhereInput": {
      "hash": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "InvitationsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        351
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "InvitationsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        169
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "IpnsRecord": {
      "createdAt": [
        73
      ],
      "ensRecords": [
        121
      ],
      "ensRecordsPaginated": [
        130,
        {
          "filter": [
            215
          ]
        }
      ],
      "hash": [
        3
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "IpnsRecordWhereInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "IpnsRecordsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "IpnsRecordsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        175
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "IpnsRecordsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        175
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "JSON": {},
    "LeaveProjectWhereInput": {
      "projectId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "LinkPublicKeyDataInput": {
      "message": [
        3
      ],
      "signature": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "ListDeploymentBranchesWhereInput": {
      "deploymentMode": [
        95
      ],
      "endDate": [
        73
      ],
      "siteId": [
        1
      ],
      "startDate": [
        73
      ],
      "statuses": [
        96
      ],
      "__typename": [
        3
      ]
    },
    "ListFolderPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        352
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "ListFolderWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "ListFolderWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        149
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "LoginWithAdminAccessTokenDataInput": {
      "adminAccessToken": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "LoginWithDynamicDataInput": {
      "authToken": [
        3
      ],
      "projectId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "LoginWithPersonalAccessTokenDataInput": {
      "personalAccessToken": [
        3
      ],
      "projectId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "MarkNotificationsAsReadWhereInput": {
      "ids": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "Membership": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "permissionGroup": [
        216
      ],
      "role": [
        256
      ],
      "updatedAt": [
        73
      ],
      "user": [
        334
      ],
      "__typename": [
        3
      ]
    },
    "MembershipsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        191
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "MigrationFailedEntity": {
      "id": [
        1
      ],
      "name": [
        3
      ],
      "type": [
        194
      ],
      "__typename": [
        3
      ]
    },
    "MigrationFailedEntityType": {},
    "MigrationLog": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "text": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "MigrationLogsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        195
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "MigrationRequest": {
      "createdAt": [
        73
      ],
      "failedEntities": [
        193
      ],
      "id": [
        1
      ],
      "logs": [
        196,
        {
          "filter": [
            215
          ]
        }
      ],
      "status": [
        204
      ],
      "teamId": [
        3
      ],
      "teamInfo": [
        206
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "MigrationRequestWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "MigrationRequestsByTokenWhereInput": {
      "token": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "MigrationRequestsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        353
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "MigrationRequestsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        197
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "MigrationScheduledRequest": {
      "status": [
        204
      ],
      "teamId": [
        3
      ],
      "triggerAfter": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "MigrationScheduledRequestWhereInput": {
      "teamId": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "MigrationStatus": {},
    "MigrationStatusByTeamIdWhereInput": {
      "teamId": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "MigrationTeamInfo": {
      "filesCount": [
        8
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "sitesCount": [
        8
      ],
      "usersCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "MigrationTeamInfosFromTokenWhereInput": {
      "token": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "Mutation": {
      "acceptInvitation": [
        191,
        {
          "where": [
            0,
            "AcceptInvitationWhereInput!"
          ]
        }
      ],
      "createApplication": [
        2,
        {
          "data": [
            40,
            "CreateApplicationDataInput!"
          ]
        }
      ],
      "createBillingCycleUsage": [
        17,
        {
          "data": [
            41,
            "CreateBillingCycleUsageDataInput!"
          ]
        }
      ],
      "createBillingPlan": [
        21,
        {
          "data": [
            42,
            "CreateBillingPlanDataInput!"
          ]
        }
      ],
      "createCustomIpfsDeployment": [
        94,
        {
          "data": [
            43,
            "CreateCustomIpfsDeploymentDataInput!"
          ]
        }
      ],
      "createDnsConfig": [
        104,
        {
          "data": [
            44,
            "CreateDnsConfigDataInput!"
          ],
          "where": [
            45,
            "CreateDnsConfigWhereInput!"
          ]
        }
      ],
      "createDomain": [
        107,
        {
          "data": [
            46,
            "CreateDomainDataInput!"
          ],
          "where": [
            47,
            "CreateDomainWhereInput!"
          ]
        }
      ],
      "createEnsRecord": [
        121,
        {
          "data": [
            48,
            "CreateEnsRecordDataInput!"
          ],
          "where": [
            49,
            "CreateEnsRecordWhereInput!"
          ]
        }
      ],
      "createFleekFunction": [
        138,
        {
          "data": [
            50,
            "CreateFleekFunctionDataInput!"
          ]
        }
      ],
      "createFolder": [
        148,
        {
          "data": [
            51,
            "CreateFolderDataInput!"
          ],
          "where": [
            52,
            "CreateFolderWhereInput!"
          ]
        }
      ],
      "createGithubAppAuthorizationUrl": [
        3,
        {
          "where": [
            53,
            "CreateGithubAppAuthorizationUrlWhereInput!"
          ]
        }
      ],
      "createGithubAppInstallationUrl": [
        3,
        {
          "where": [
            54,
            "CreateGithubAppInstallationUrlWhereInput!"
          ]
        }
      ],
      "createGithubIntegrationForProject": [
        9,
        {
          "data": [
            55,
            "CreateGithubIntegrationForProjectDataInput!"
          ]
        }
      ],
      "createGithubRepoFromTemplate": [
        168,
        {
          "data": [
            56,
            "CreateGithubRepoFromTemplateDataInput!"
          ],
          "where": [
            57,
            "CreateGithubRepoFromTemplateWhereInput!"
          ]
        }
      ],
      "createInvitation": [
        3,
        {
          "data": [
            58,
            "CreateInvitationDataInput!"
          ]
        }
      ],
      "createIpnsRecord": [
        175
      ],
      "createIpnsRecordForSite": [
        175,
        {
          "where": [
            59,
            "CreateIpnsRecordForSiteWhereInput!"
          ]
        }
      ],
      "createLoginVerificationSession": [
        9,
        {
          "where": [
            60,
            "CreateLoginVerificationSessionWhereInput!"
          ]
        }
      ],
      "createMigrationRequestsFromToken": [
        197,
        {
          "data": [
            61,
            "CreateMigrationRequestsFromTokenDataInput!"
          ]
        }
      ],
      "createMigrationToken": [
        3,
        {
          "data": [
            62,
            "CreateMigrationTokenDataInput!"
          ]
        }
      ],
      "createPersonalAccessTokenFromVerificationSession": [
        3,
        {
          "data": [
            63,
            "CreatePersonalAccessTokenFromVerificationSessionDataInput!"
          ],
          "where": [
            64,
            "CreatePersonalAccessTokenFromVerificationSessionWhereInput!"
          ]
        }
      ],
      "createPrivateGateway": [
        232,
        {
          "data": [
            65,
            "CreatePrivateGatewayDataInput!"
          ],
          "where": [
            66,
            "CreatePrivateGatewayWhereInput!"
          ]
        }
      ],
      "createProject": [
        238,
        {
          "data": [
            67,
            "CreateProjectDataInput!"
          ]
        }
      ],
      "createPublicKeyChallenge": [
        3
      ],
      "createSalesContactRequest": [
        257,
        {
          "data": [
            68,
            "CreateSalesContactRequestDataInput!"
          ]
        }
      ],
      "createSecret": [
        258,
        {
          "data": [
            69,
            "CreateSecretDataInput!"
          ]
        }
      ],
      "createSite": [
        267,
        {
          "data": [
            70,
            "CreateSiteDataInput!"
          ]
        }
      ],
      "createTemplate": [
        289,
        {
          "data": [
            71,
            "CreateTemplateDataInput!"
          ]
        }
      ],
      "createZoneForPrivateGateway": [
        343
      ],
      "createZoneForSite": [
        343,
        {
          "where": [
            72,
            "CreateZoneForSiteWhereInput!"
          ]
        }
      ],
      "declineInvitation": [
        9,
        {
          "where": [
            74,
            "DeclineInvitationWhereInput!"
          ]
        }
      ],
      "deleteApplication": [
        2,
        {
          "where": [
            75,
            "DeleteApplicationWhereInput!"
          ]
        }
      ],
      "deleteDomain": [
        107,
        {
          "where": [
            76,
            "DeleteDomainWhereInput!"
          ]
        }
      ],
      "deleteEnsRecord": [
        121,
        {
          "where": [
            77,
            "DeleteEnsRecordWhereInput!"
          ]
        }
      ],
      "deleteFleekFunction": [
        138,
        {
          "where": [
            78,
            "DeleteFleekFunctionWhereInput!"
          ]
        }
      ],
      "deleteFolder": [
        148,
        {
          "where": [
            79,
            "DeleteFolderWhereInput!"
          ]
        }
      ],
      "deleteInvitation": [
        169,
        {
          "where": [
            80,
            "DeleteInvitationWhereInput!"
          ]
        }
      ],
      "deleteIpnsRecord": [
        175,
        {
          "where": [
            81,
            "DeleteIpnsRecordWhereInput!"
          ]
        }
      ],
      "deleteMembership": [
        191,
        {
          "where": [
            82,
            "DeleteMembershipWhereInput!"
          ]
        }
      ],
      "deletePersonalAccessToken": [
        219,
        {
          "where": [
            83,
            "DeletePersonalAccessTokenWhereInput!"
          ]
        }
      ],
      "deletePin": [
        222,
        {
          "where": [
            84,
            "DeletePinWhereInput!"
          ]
        }
      ],
      "deletePrivateGateway": [
        232,
        {
          "where": [
            85,
            "DeletePrivateGatewayWhereInput!"
          ]
        }
      ],
      "deleteProject": [
        238,
        {
          "where": [
            86,
            "DeleteProjectWhereInput!"
          ]
        }
      ],
      "deleteRecoveryCodes": [
        9,
        {
          "where": [
            87,
            "DeleteRecoveryCodesWhereInput!"
          ]
        }
      ],
      "deleteSecret": [
        258,
        {
          "where": [
            89,
            "DeleteSecretWhereInput!"
          ]
        }
      ],
      "deleteSecretKey": [
        9,
        {
          "where": [
            88,
            "DeleteSecretKeyWhereInput!"
          ]
        }
      ],
      "deleteSite": [
        267,
        {
          "where": [
            90,
            "DeleteSiteWhereInput!"
          ]
        }
      ],
      "deleteTemplate": [
        289,
        {
          "where": [
            91,
            "DeleteTemplateWhereInput!"
          ]
        }
      ],
      "deleteUser": [
        334,
        {
          "where": [
            92,
            "DeleteUserWhereInput!"
          ]
        }
      ],
      "deleteZone": [
        343,
        {
          "where": [
            93,
            "DeleteZoneWhereInput!"
          ]
        }
      ],
      "disableTwoFactorProtectedAction": [
        9,
        {
          "where": [
            103,
            "DisableTwoFactorProtectedActionWhereInput!"
          ]
        }
      ],
      "enableTwoFactorProtectedAction": [
        9,
        {
          "where": [
            119,
            "EnableTwoFactorProtectedActionWhereInput!"
          ]
        }
      ],
      "generateRecoveryCodes": [
        251,
        {
          "where": [
            151,
            "GenerateRecoveryCodesWhereInput!"
          ]
        }
      ],
      "generateTwoFactorSecretKey": [
        261
      ],
      "leaveProject": [
        191,
        {
          "where": [
            181,
            "LeaveProjectWhereInput!"
          ]
        }
      ],
      "linkPublicKey": [
        243,
        {
          "data": [
            182,
            "LinkPublicKeyDataInput!"
          ]
        }
      ],
      "loginWithAdminAccessToken": [
        3,
        {
          "data": [
            187,
            "LoginWithAdminAccessTokenDataInput!"
          ]
        }
      ],
      "loginWithDynamic": [
        3,
        {
          "data": [
            188,
            "LoginWithDynamicDataInput!"
          ]
        }
      ],
      "loginWithPersonalAccessToken": [
        3,
        {
          "data": [
            189,
            "LoginWithPersonalAccessTokenDataInput!"
          ]
        }
      ],
      "markNotificationsAsRead": [
        9,
        {
          "where": [
            190,
            "MarkNotificationsAsReadWhereInput!"
          ]
        }
      ],
      "promoteDeployment": [
        9,
        {
          "where": [
            242,
            "PromoteDeploymentWhereInput!"
          ]
        }
      ],
      "publishIpnsRecord": [
        175,
        {
          "data": [
            245,
            "PublishIpnsRecordDataInput!"
          ],
          "where": [
            246,
            "PublishIpnsRecordWhereInput!"
          ]
        }
      ],
      "publishSignedIpnsName": [
        3,
        {
          "data": [
            247,
            "PublishSignedIpnsNameDataInput!"
          ]
        }
      ],
      "purgeSiteCache": [
        267,
        {
          "where": [
            248,
            "PurgeSiteCacheWhereInput!"
          ]
        }
      ],
      "retryDeployment": [
        94,
        {
          "where": [
            253,
            "RetryDeploymentWhereInput!"
          ]
        }
      ],
      "retryMigrationRequest": [
        197,
        {
          "data": [
            254,
            "RetryMigrationRequestDataInput!"
          ],
          "where": [
            255,
            "RetryMigrationRequestWhereInput!"
          ]
        }
      ],
      "selectPrimaryDomain": [
        107,
        {
          "where": [
            266,
            "SelectPrimaryDomainWhereInput!"
          ]
        }
      ],
      "siteDeploymentRequirements": [
        271,
        {
          "where": [
            272,
            "SiteDeploymentRequirementsWhereInput!"
          ]
        }
      ],
      "stopDeployment": [
        9,
        {
          "where": [
            286,
            "StopDeploymentWhereInput!"
          ]
        }
      ],
      "triggerDeployment": [
        94,
        {
          "where": [
            301,
            "TriggerDeploymentWhereInput!"
          ]
        }
      ],
      "triggerFleekFunctionDeployment": [
        140,
        {
          "data": [
            302
          ],
          "where": [
            303,
            "TriggerFleekFunctionDeploymentWhereInput!"
          ]
        }
      ],
      "updateApplication": [
        2,
        {
          "data": [
            308,
            "UpdateApplicationDataInput!"
          ],
          "where": [
            309,
            "UpdateApplicationWhereInput!"
          ]
        }
      ],
      "updateBillingPlan": [
        21,
        {
          "data": [
            310,
            "UpdateBillingPlanDataInput!"
          ],
          "where": [
            311,
            "UpdateBillingPlanWhereInput!"
          ]
        }
      ],
      "updateFleekFunction": [
        138,
        {
          "data": [
            312,
            "UpdateFleekFunctionDataInput!"
          ],
          "where": [
            313,
            "UpdateFleekFunctionWhereInput!"
          ]
        }
      ],
      "updateFolder": [
        148,
        {
          "data": [
            314,
            "UpdateFolderDataInput!"
          ],
          "where": [
            315,
            "UpdateFolderWhereInput!"
          ]
        }
      ],
      "updateMembership": [
        191,
        {
          "data": [
            316,
            "UpdateMembershipDataInput!"
          ],
          "where": [
            317,
            "UpdateMembershipWhereInput!"
          ]
        }
      ],
      "updateNotificationSettings": [
        9,
        {
          "data": [
            318,
            "UpdateNotificationSettingsDataInput!"
          ]
        }
      ],
      "updatePin": [
        222,
        {
          "data": [
            319,
            "UpdatePinDataInput!"
          ],
          "where": [
            320,
            "UpdatePinWhereInput!"
          ]
        }
      ],
      "updatePrivateGateway": [
        232,
        {
          "data": [
            321,
            "UpdatePrivateGatewayDataInput!"
          ],
          "where": [
            322,
            "UpdatePrivateGatewayWhereInput!"
          ]
        }
      ],
      "updateProject": [
        238,
        {
          "data": [
            323,
            "UpdateProjectDataInput!"
          ],
          "where": [
            324,
            "UpdateProjectWhereInput!"
          ]
        }
      ],
      "updateSecret": [
        258,
        {
          "data": [
            325,
            "UpdateSecretDataInput!"
          ],
          "where": [
            326,
            "UpdateSecretWhereInput!"
          ]
        }
      ],
      "updateSite": [
        267,
        {
          "data": [
            327,
            "UpdateSiteDataInput!"
          ],
          "where": [
            328,
            "UpdateSiteWhereInput!"
          ]
        }
      ],
      "updateTemplate": [
        289,
        {
          "data": [
            329,
            "UpdateTemplateDataInput!"
          ],
          "where": [
            330,
            "UpdateTemplateWhereInput!"
          ]
        }
      ],
      "updateTwoFactorSecretKey": [
        261,
        {
          "data": [
            331,
            "UpdateTwoFactorSecretKeyDataInput!"
          ],
          "where": [
            332,
            "UpdateTwoFactorSecretKeyWhereInput!"
          ]
        }
      ],
      "updateUser": [
        334,
        {
          "data": [
            333,
            "UpdateUserDataInput!"
          ]
        }
      ],
      "verifyDnslink": [
        107,
        {
          "where": [
            336,
            "VerifyDnslinkWhereInput!"
          ]
        }
      ],
      "verifyDomain": [
        107,
        {
          "data": [
            337
          ],
          "where": [
            338,
            "VerifyDomainWhereInput!"
          ]
        }
      ],
      "verifyEnsRecord": [
        121,
        {
          "where": [
            339,
            "VerifyEnsRecordWhereInput!"
          ]
        }
      ],
      "verifyTwoFactorSecretKey": [
        261,
        {
          "data": [
            340,
            "VerifyTwoFactorSecretKeyDataInput!"
          ],
          "where": [
            341,
            "VerifyTwoFactorSecretKeyWhereInput!"
          ]
        }
      ],
      "__typename": [
        3
      ]
    },
    "Notification": {
      "content": [
        3
      ],
      "createdAt": [
        73
      ],
      "data": [
        180
      ],
      "id": [
        1
      ],
      "isRead": [
        9
      ],
      "title": [
        3
      ],
      "type": [
        212
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "NotificationChannel": {},
    "NotificationSettings": {
      "isEnabled": [
        9
      ],
      "notificationChannel": [
        210
      ],
      "notificationType": [
        212
      ],
      "__typename": [
        3
      ]
    },
    "NotificationType": {},
    "NotificationsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "NotificationsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        209
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PaginationInput": {
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PermissionGroup": {
      "createdAt": [
        73
      ],
      "description": [
        3
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "permissions": [
        3
      ],
      "systemRole": [
        256
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "PermissionGroupsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PermissionGroupsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        216
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PersonalAccessToken": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "maskedToken": [
        3
      ],
      "name": [
        3
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "PersonalAccessTokensPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        354
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PersonalAccessTokensWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        219
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "Pin": {
      "arweavePin": [
        13
      ],
      "cid": [
        1
      ],
      "createdAt": [
        73
      ],
      "deployments": [
        94
      ],
      "deploymentsPaginated": [
        102,
        {
          "filter": [
            215
          ]
        }
      ],
      "extension": [
        3
      ],
      "filecoinPin": [
        137
      ],
      "filename": [
        3
      ],
      "id": [
        1
      ],
      "pathInFolder": [
        3
      ],
      "projectId": [
        3
      ],
      "size": [
        8
      ],
      "sizeBigInt": [
        14
      ],
      "storedOnArweave": [
        9
      ],
      "storedOnFilecoin": [
        9
      ],
      "storedOnS3": [
        9
      ],
      "__typename": [
        3
      ]
    },
    "PinNameAvailabilityInParentFolderDataInput": {
      "extension": [
        3
      ],
      "filename": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "PinNameAvailabilityInParentFolderWhereInput": {
      "parentFolderId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "PinWhereInput": {
      "cid": [
        39
      ],
      "__typename": [
        3
      ]
    },
    "PinsByFilenamePaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        355
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PinsByFilenameWhereInput": {
      "extension": [
        3
      ],
      "filename": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "PinsByFilenameWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        222
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PinsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        356
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PinsWhereInput": {
      "storedOnArweave": [
        9
      ],
      "storedOnFilecoin": [
        9
      ],
      "__typename": [
        3
      ]
    },
    "PinsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        222
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PrivateGateway": {
      "createdAt": [
        73
      ],
      "domains": [
        107
      ],
      "domainsPaginated": [
        117,
        {
          "filter": [
            215
          ]
        }
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "primaryDomain": [
        107
      ],
      "project": [
        238
      ],
      "slug": [
        3
      ],
      "updatedAt": [
        73
      ],
      "zone": [
        343
      ],
      "__typename": [
        3
      ]
    },
    "PrivateGatewayBySlugWhereInput": {
      "slug": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "PrivateGatewayNameAvailabilityWhereInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "PrivateGatewayWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "PrivateGatewaysPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PrivateGatewaysWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        232
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "Project": {
      "allowAccessFromOfacCountries": [
        9
      ],
      "avatar": [
        131
      ],
      "backupStorageOnArweave": [
        9
      ],
      "backupStorageOnFilecoin": [
        9
      ],
      "createdAt": [
        73
      ],
      "currentUserMembership": [
        191
      ],
      "id": [
        1
      ],
      "memberships": [
        191
      ],
      "membershipsPaginated": [
        192,
        {
          "filter": [
            215
          ]
        }
      ],
      "name": [
        3
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "ProjectWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "ProjectsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        357
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "ProjectsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        238
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PromoteDeploymentWhereInput": {
      "deploymentId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "PublicKey": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "publicKey": [
        3
      ],
      "type": [
        3
      ],
      "updatedAt": [
        73
      ],
      "user": [
        334
      ],
      "__typename": [
        3
      ]
    },
    "PublicKeysWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        243
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "PublishIpnsRecordDataInput": {
      "hash": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "PublishIpnsRecordWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "PublishSignedIpnsNameDataInput": {
      "input": [
        3
      ],
      "key": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "PurgeSiteCacheWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "Query": {
      "application": [
        2,
        {
          "where": [
            5,
            "ApplicationWhereInput!"
          ]
        }
      ],
      "applicationNameAvailability": [
        9,
        {
          "where": [
            4,
            "ApplicationNameAvailabilityWhereInput!"
          ]
        }
      ],
      "applications": [
        12,
        {
          "filter": [
            11
          ]
        }
      ],
      "billingCycleUsages": [
        20,
        {
          "filter": [
            19
          ]
        }
      ],
      "billingPlan": [
        21,
        {
          "where": [
            31,
            "BillingPlanWhereInput!"
          ]
        }
      ],
      "billingPlans": [
        33,
        {
          "filter": [
            32
          ]
        }
      ],
      "deployment": [
        94,
        {
          "where": [
            97,
            "DeploymentWhereInput!"
          ]
        }
      ],
      "deployments": [
        101,
        {
          "filter": [
            98
          ],
          "where": [
            100,
            "DeploymentsWhereInput!"
          ]
        }
      ],
      "deploymentsQueueLimit": [
        9,
        {
          "where": [
            99,
            "DeploymentsQueueLimitWhereInput!"
          ]
        }
      ],
      "domain": [
        107,
        {
          "where": [
            111,
            "DomainWhereInput!"
          ]
        }
      ],
      "domainAvailability": [
        9,
        {
          "where": [
            108,
            "DomainAvailabilityWhereInput!"
          ]
        }
      ],
      "domainByHostname": [
        107,
        {
          "where": [
            109,
            "DomainByHostnameWhereInput!"
          ]
        }
      ],
      "domains": [
        116,
        {
          "filter": [
            115
          ]
        }
      ],
      "domainsByZoneId": [
        114,
        {
          "filter": [
            112
          ],
          "where": [
            113,
            "DomainsByZoneIdWhereInput!"
          ]
        }
      ],
      "emailAvailability": [
        9,
        {
          "where": [
            118,
            "EmailAvailabilityWhereInput!"
          ]
        }
      ],
      "ensNameAvailability": [
        9,
        {
          "where": [
            120,
            "EnsNameAvailabilityWhereInput!"
          ]
        }
      ],
      "ensRecord": [
        121,
        {
          "where": [
            124,
            "EnsRecordWhereInput!"
          ]
        }
      ],
      "ensRecordByName": [
        121,
        {
          "where": [
            122,
            "EnsRecordByNameWhereInput!"
          ]
        }
      ],
      "ensRecords": [
        129,
        {
          "filter": [
            128
          ]
        }
      ],
      "ensRecordsByIpnsId": [
        127,
        {
          "filter": [
            125
          ],
          "where": [
            126,
            "EnsRecordsByIpnsIdWhereInput!"
          ]
        }
      ],
      "filecoinDeals": [
        135,
        {
          "filter": [
            133
          ],
          "where": [
            134,
            "FilecoinDealsWhereInput!"
          ]
        }
      ],
      "fleekFunctionByName": [
        138,
        {
          "where": [
            139,
            "FleekFunctionByNameWhereInput!"
          ]
        }
      ],
      "fleekFunctionDeployment": [
        140,
        {
          "where": [
            141,
            "FleekFunctionDeploymentWhereInput!"
          ]
        }
      ],
      "fleekFunctionDeployments": [
        144,
        {
          "filter": [
            142
          ],
          "where": [
            143,
            "FleekFunctionDeploymentsWhereInput!"
          ]
        }
      ],
      "fleekFunctions": [
        147,
        {
          "filter": [
            146
          ]
        }
      ],
      "folder": [
        148,
        {
          "where": [
            150,
            "FolderWhereInput!"
          ]
        }
      ],
      "gitApiBranches": [
        152,
        {
          "where": [
            153,
            "GitApiBranchesWhereInput!"
          ]
        }
      ],
      "gitApiInstallations": [
        154,
        {
          "where": [
            155,
            "GitApiInstallationsWhereInput!"
          ]
        }
      ],
      "gitApiIsRepoNameAvailable": [
        9,
        {
          "where": [
            156,
            "GitApiIsRepoNameAvailableWhereInput!"
          ]
        }
      ],
      "gitApiTree": [
        158,
        {
          "where": [
            159,
            "GitApiTreeWhereInput!"
          ]
        }
      ],
      "gitIntegration": [
        160,
        {
          "where": [
            161,
            "GitIntegrationWhereInput!"
          ]
        }
      ],
      "gitProvider": [
        162,
        {
          "where": [
            164,
            "GitProviderWhereInput!"
          ]
        }
      ],
      "gitProviders": [
        162
      ],
      "githubAppInstallations": [
        166,
        {
          "where": [
            167,
            "GithubAppInstallationsWhereInput!"
          ]
        }
      ],
      "invitation": [
        170,
        {
          "where": [
            172,
            "InvitationWhereInput!"
          ]
        }
      ],
      "invitations": [
        174,
        {
          "filter": [
            173
          ]
        }
      ],
      "ipnsRecord": [
        175,
        {
          "where": [
            176,
            "IpnsRecordWhereInput!"
          ]
        }
      ],
      "ipnsRecords": [
        178,
        {
          "filter": [
            177
          ]
        }
      ],
      "listDeploymentBranches": [
        3,
        {
          "where": [
            183,
            "ListDeploymentBranchesWhereInput!"
          ]
        }
      ],
      "listFolder": [
        186,
        {
          "filter": [
            184
          ],
          "where": [
            185,
            "ListFolderWhereInput!"
          ]
        }
      ],
      "migrationRequest": [
        197,
        {
          "where": [
            198,
            "MigrationRequestWhereInput!"
          ]
        }
      ],
      "migrationRequests": [
        201,
        {
          "filter": [
            200
          ]
        }
      ],
      "migrationRequestsByToken": [
        197,
        {
          "where": [
            199,
            "MigrationRequestsByTokenWhereInput!"
          ]
        }
      ],
      "migrationScheduledRequest": [
        202,
        {
          "where": [
            203,
            "MigrationScheduledRequestWhereInput!"
          ]
        }
      ],
      "migrationStatusByTeamId": [
        204,
        {
          "where": [
            205,
            "MigrationStatusByTeamIdWhereInput!"
          ]
        }
      ],
      "migrationTeamInfosFromToken": [
        206,
        {
          "where": [
            207,
            "MigrationTeamInfosFromTokenWhereInput!"
          ]
        }
      ],
      "notificationSettings": [
        211
      ],
      "notifications": [
        214,
        {
          "filter": [
            213
          ]
        }
      ],
      "permissionGroups": [
        218,
        {
          "filter": [
            217
          ]
        }
      ],
      "personalAccessTokens": [
        221,
        {
          "filter": [
            220
          ]
        }
      ],
      "pin": [
        222,
        {
          "where": [
            225,
            "PinWhereInput!"
          ]
        }
      ],
      "pinNameAvailabilityInParentFolder": [
        9,
        {
          "data": [
            223,
            "PinNameAvailabilityInParentFolderDataInput!"
          ],
          "where": [
            224,
            "PinNameAvailabilityInParentFolderWhereInput!"
          ]
        }
      ],
      "pins": [
        231,
        {
          "filter": [
            229
          ],
          "where": [
            230
          ]
        }
      ],
      "pinsByFilename": [
        228,
        {
          "filter": [
            226
          ],
          "where": [
            227,
            "PinsByFilenameWhereInput!"
          ]
        }
      ],
      "privateGateway": [
        232,
        {
          "where": [
            235,
            "PrivateGatewayWhereInput!"
          ]
        }
      ],
      "privateGatewayBySlug": [
        232,
        {
          "where": [
            233,
            "PrivateGatewayBySlugWhereInput!"
          ]
        }
      ],
      "privateGatewayNameAvailability": [
        9,
        {
          "where": [
            234,
            "PrivateGatewayNameAvailabilityWhereInput!"
          ]
        }
      ],
      "privateGateways": [
        237,
        {
          "filter": [
            236
          ]
        }
      ],
      "project": [
        238,
        {
          "where": [
            239,
            "ProjectWhereInput!"
          ]
        }
      ],
      "projects": [
        241,
        {
          "filter": [
            240
          ]
        }
      ],
      "resolveIpnsName": [
        3,
        {
          "where": [
            252,
            "ResolveIpnsNameWhereInput!"
          ]
        }
      ],
      "secretAvailability": [
        9,
        {
          "where": [
            259,
            "SecretAvailabilityWhereInput!"
          ]
        }
      ],
      "site": [
        267,
        {
          "where": [
            277,
            "SiteWhereInput!"
          ]
        }
      ],
      "siteBuildSettings": [
        268,
        {
          "where": [
            269,
            "SiteBuildSettingsWhereInput!"
          ]
        }
      ],
      "siteBySlug": [
        267,
        {
          "where": [
            270,
            "SiteBySlugWhereInput!"
          ]
        }
      ],
      "siteFramework": [
        273,
        {
          "where": [
            275,
            "SiteFrameworkWhereInput!"
          ]
        }
      ],
      "siteFrameworks": [
        273
      ],
      "siteNameAvailability": [
        9,
        {
          "where": [
            276,
            "SiteNameAvailabilityWhereInput!"
          ]
        }
      ],
      "sites": [
        282,
        {
          "filter": [
            280
          ],
          "where": [
            281,
            "SitesWhereInput!"
          ]
        }
      ],
      "slugAvailability": [
        9,
        {
          "where": [
            283,
            "SlugAvailabilityWhereInput!"
          ]
        }
      ],
      "template": [
        289,
        {
          "where": [
            296,
            "TemplateWhereInput!"
          ]
        }
      ],
      "templateCategories": [
        291,
        {
          "filter": [
            290
          ]
        }
      ],
      "templateCategory": [
        292,
        {
          "where": [
            293,
            "TemplateCategoryWhereInput!"
          ]
        }
      ],
      "templateNameAvailability": [
        9,
        {
          "where": [
            294,
            "TemplateNameAvailabilityWhereInput!"
          ]
        }
      ],
      "templates": [
        299,
        {
          "filter": [
            297
          ],
          "where": [
            298,
            "TemplatesWhereInput!"
          ]
        }
      ],
      "twoFactorProtectedActions": [
        307,
        {
          "filter": [
            306
          ]
        }
      ],
      "user": [
        334
      ],
      "usernameAvailability": [
        9,
        {
          "where": [
            335,
            "UsernameAvailabilityWhereInput!"
          ]
        }
      ],
      "version": [
        342
      ],
      "zone": [
        343,
        {
          "where": [
            346,
            "ZoneWhereInput!"
          ]
        }
      ],
      "zones": [
        348,
        {
          "filter": [
            347
          ]
        }
      ],
      "__typename": [
        3
      ]
    },
    "RecoveryCode": {
      "code": [
        3
      ],
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "isUsed": [
        9
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "RecoveryCodes": {
      "recoveryCodes": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "ResolveIpnsNameWhereInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "RetryDeploymentWhereInput": {
      "deploymentId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "RetryMigrationRequestDataInput": {
      "skipFailedEntities": [
        9
      ],
      "__typename": [
        3
      ]
    },
    "RetryMigrationRequestWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "Role": {},
    "SalesContactRequest": {
      "createdAt": [
        73
      ],
      "description": [
        3
      ],
      "email": [
        3
      ],
      "id": [
        1
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "Secret": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "key": [
        3
      ],
      "updatedAt": [
        73
      ],
      "value": [
        3
      ],
      "visibility": [
        264
      ],
      "__typename": [
        3
      ]
    },
    "SecretAvailabilityWhereInput": {
      "key": [
        3
      ],
      "siteId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "SecretGroup": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "secrets": [
        258
      ],
      "secretsPaginated": [
        265,
        {
          "filter": [
            215
          ]
        }
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "SecretKey": {
      "algorithm": [
        262
      ],
      "createdAt": [
        73
      ],
      "digits": [
        8
      ],
      "id": [
        1
      ],
      "isActive": [
        9
      ],
      "isVerified": [
        9
      ],
      "key": [
        3
      ],
      "period": [
        8
      ],
      "recoveryCodes": [
        250
      ],
      "type": [
        263
      ],
      "updatedAt": [
        73
      ],
      "verifiedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "SecretKeyAlgorithm": {},
    "SecretKeyType": {},
    "SecretVisibility": {},
    "SecretsWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        258
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "SelectPrimaryDomainWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "Site": {
      "avatar": [
        131
      ],
      "baseDirectory": [
        3
      ],
      "buildCommand": [
        3
      ],
      "buildDurationLimitSeconds": [
        8
      ],
      "cpuLimit": [
        3
      ],
      "currentDeployment": [
        94
      ],
      "deployments": [
        94
      ],
      "deploymentsPaginated": [
        102,
        {
          "filter": [
            215
          ]
        }
      ],
      "distDirectory": [
        3
      ],
      "dockerImage": [
        3
      ],
      "domains": [
        107
      ],
      "domainsPaginated": [
        117,
        {
          "filter": [
            215
          ]
        }
      ],
      "enablePreviews": [
        9
      ],
      "framework": [
        273
      ],
      "gitIntegration": [
        160
      ],
      "githubInstallationId": [
        8
      ],
      "id": [
        1
      ],
      "ipnsRecords": [
        175
      ],
      "ipnsRecordsPaginated": [
        179,
        {
          "filter": [
            215
          ]
        }
      ],
      "lastDeployment": [
        94
      ],
      "memoryLimit": [
        3
      ],
      "name": [
        3
      ],
      "primaryDomain": [
        107
      ],
      "secretGroup": [
        260
      ],
      "slug": [
        3
      ],
      "sourceBranch": [
        3
      ],
      "sourceProvider": [
        285
      ],
      "sourceRepositoryId": [
        3
      ],
      "sourceRepositoryName": [
        3
      ],
      "sourceRepositoryOwner": [
        3
      ],
      "zones": [
        278
      ],
      "zonesPaginated": [
        279,
        {
          "filter": [
            215
          ]
        }
      ],
      "__typename": [
        3
      ]
    },
    "SiteBuildSettings": {
      "buildCommand": [
        3
      ],
      "dockerImage": [
        3
      ],
      "envVars": [
        180
      ],
      "frameworkId": [
        3
      ],
      "publishDirectory": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "SiteBuildSettingsWhereInput": {
      "baseDirectory": [
        3
      ],
      "gitProviderId": [
        1
      ],
      "sourceBranch": [
        3
      ],
      "sourceRepositoryName": [
        3
      ],
      "sourceRepositoryOwner": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "SiteBySlugWhereInput": {
      "slug": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "SiteDeploymentRequirements": {
      "authorizationUrl": [
        3
      ],
      "installationUrl": [
        3
      ],
      "shouldAuthenticate": [
        9
      ],
      "shouldInstall": [
        9
      ],
      "__typename": [
        3
      ]
    },
    "SiteDeploymentRequirementsWhereInput": {
      "gitProviderId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "SiteFramework": {
      "avatar": [
        131
      ],
      "buildScript": [
        3
      ],
      "createdAt": [
        73
      ],
      "dockerImage": [
        3
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "publishDirectory": [
        3
      ],
      "recognitionArgument": [
        3
      ],
      "recognitionStrategy": [
        274
      ],
      "slug": [
        3
      ],
      "templatesCount": [
        8
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "SiteFrameworkRecognitionStrategy": {},
    "SiteFrameworkWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "SiteNameAvailabilityWhereInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "SiteWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "SiteZone": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "status": [
        344
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "SiteZonesWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        278
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "SitesPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        358
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "SitesWhereInput": {
      "hasSourceProvider": [
        9
      ],
      "isDeployed": [
        9
      ],
      "isTemplate": [
        9
      ],
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "SitesWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        267
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "SlugAvailabilityWhereInput": {
      "slug": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "SortOrder": {},
    "SourceProvider": {},
    "StopDeploymentWhereInput": {
      "deploymentId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "StorageType": {},
    "SubscriptionType": {},
    "Template": {
      "banner": [
        131
      ],
      "category": [
        292
      ],
      "createdAt": [
        73
      ],
      "creator": [
        334
      ],
      "deployment": [
        94
      ],
      "description": [
        3
      ],
      "framework": [
        273
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "reviewComment": [
        3
      ],
      "reviewStatus": [
        295
      ],
      "reviewedAt": [
        73
      ],
      "site": [
        267
      ],
      "siteAvatar": [
        131
      ],
      "siteId": [
        3
      ],
      "siteSlug": [
        3
      ],
      "updatedAt": [
        73
      ],
      "usageCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "TemplateCategoriesPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        359
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "TemplateCategoriesWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        292
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "TemplateCategory": {
      "id": [
        1
      ],
      "name": [
        3
      ],
      "slug": [
        3
      ],
      "templates": [
        289
      ],
      "templatesCount": [
        8
      ],
      "templatesPaginated": [
        300,
        {
          "filter": [
            215
          ]
        }
      ],
      "__typename": [
        3
      ]
    },
    "TemplateCategoryWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "TemplateNameAvailabilityWhereInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "TemplateReviewStatus": {},
    "TemplateWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "TemplatesPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "sortField": [
        360
      ],
      "sortOrder": [
        284
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "TemplatesWhereInput": {
      "categoryId": [
        1
      ],
      "createdById": [
        1
      ],
      "frameworkId": [
        1
      ],
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "TemplatesWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        289
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "TemplatesWithNestedAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        289
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "TriggerDeploymentWhereInput": {
      "siteId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "TriggerFleekFunctionDeploymentDataInput": {
      "blake3Hash": [
        3
      ],
      "sgx": [
        9
      ],
      "__typename": [
        3
      ]
    },
    "TriggerFleekFunctionDeploymentWhereInput": {
      "cid": [
        3
      ],
      "functionId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "TwoFactorProtectedAction": {
      "createdAt": [
        73
      ],
      "enabled": [
        9
      ],
      "id": [
        1
      ],
      "name": [
        3
      ],
      "type": [
        305
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "TwoFactorProtectedActionType": {},
    "TwoFactorProtectedActionsPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "TwoFactorProtectedActionsWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        304
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "UpdateApplicationDataInput": {
      "name": [
        3
      ],
      "whiteLabelDomains": [
        3
      ],
      "whitelistDomains": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "UpdateApplicationWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateBillingPlanDataInput": {
      "isActive": [
        9
      ],
      "price": [
        18
      ],
      "__typename": [
        3
      ]
    },
    "UpdateBillingPlanWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateFleekFunctionDataInput": {
      "name": [
        3
      ],
      "slug": [
        3
      ],
      "status": [
        145
      ],
      "__typename": [
        3
      ]
    },
    "UpdateFleekFunctionWhereInput": {
      "id": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "UpdateFolderDataInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "UpdateFolderWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateMembershipDataInput": {
      "permissionGroupId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateMembershipWhereInput": {
      "id": [
        1
      ],
      "userId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateNotificationSettingsDataInput": {
      "isEnabled": [
        9
      ],
      "notificationChannel": [
        210
      ],
      "notificationType": [
        212
      ],
      "__typename": [
        3
      ]
    },
    "UpdatePinDataInput": {
      "filename": [
        3
      ],
      "moveToRoot": [
        9
      ],
      "parentFolderId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdatePinWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdatePrivateGatewayDataInput": {
      "name": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "UpdatePrivateGatewayWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateProjectDataInput": {
      "allowAccessFromOfacCountries": [
        9
      ],
      "avatar": [
        131
      ],
      "backupStorageOnArweave": [
        9
      ],
      "backupStorageOnFilecoin": [
        9
      ],
      "name": [
        3
      ],
      "planId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateProjectWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateSecretDataInput": {
      "value": [
        3
      ],
      "visibility": [
        264
      ],
      "__typename": [
        3
      ]
    },
    "UpdateSecretWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateSiteDataInput": {
      "avatar": [
        131
      ],
      "baseDirectory": [
        3
      ],
      "buildCommand": [
        3
      ],
      "distDirectory": [
        3
      ],
      "dockerImage": [
        3
      ],
      "enablePreviews": [
        9
      ],
      "frameworkId": [
        1
      ],
      "githubInstallationId": [
        8
      ],
      "name": [
        3
      ],
      "slug": [
        3
      ],
      "sourceBranch": [
        3
      ],
      "sourceProvider": [
        285
      ],
      "sourceRepositoryId": [
        3
      ],
      "sourceRepositoryName": [
        3
      ],
      "sourceRepositoryOwner": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "UpdateSiteWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateTemplateDataInput": {
      "banner": [
        131
      ],
      "description": [
        3
      ],
      "name": [
        3
      ],
      "templateCategoryId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateTemplateWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateTwoFactorSecretKeyDataInput": {
      "isActive": [
        9
      ],
      "key": [
        9
      ],
      "__typename": [
        3
      ]
    },
    "UpdateTwoFactorSecretKeyWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "UpdateUserDataInput": {
      "avatar": [
        131
      ],
      "email": [
        3
      ],
      "firstName": [
        3
      ],
      "lastName": [
        3
      ],
      "username": [
        3
      ],
      "walletAddress": [
        3
      ],
      "walletChain": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "User": {
      "avatar": [
        131
      ],
      "createdAt": [
        73
      ],
      "email": [
        3
      ],
      "firstName": [
        3
      ],
      "gitUserAccessTokens": [
        165
      ],
      "githubUserAccessToken": [
        3
      ],
      "id": [
        1
      ],
      "lastName": [
        3
      ],
      "pendingInvitations": [
        170
      ],
      "pendingInvitationsPaginated": [
        171,
        {
          "filter": [
            215
          ]
        }
      ],
      "project": [
        238
      ],
      "publicKeys": [
        243
      ],
      "publicKeysPaginated": [
        244,
        {
          "filter": [
            215
          ]
        }
      ],
      "secretKeys": [
        261
      ],
      "updatedAt": [
        73
      ],
      "username": [
        3
      ],
      "walletAddress": [
        3
      ],
      "walletChain": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "UsernameAvailabilityWhereInput": {
      "username": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "VerifyDnslinkWhereInput": {
      "domainId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "VerifyDomainDataInput": {
      "placeholder": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "VerifyDomainWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "VerifyEnsRecordWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "VerifyTwoFactorSecretKeyDataInput": {
      "token": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "VerifyTwoFactorSecretKeyWhereInput": {
      "secretKeyId": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "Version": {
      "commitHash": [
        3
      ],
      "__typename": [
        3
      ]
    },
    "Zone": {
      "createdAt": [
        73
      ],
      "id": [
        1
      ],
      "originUrl": [
        3
      ],
      "originUrlChangedAt": [
        73
      ],
      "originUrlChangedBy": [
        334
      ],
      "project": [
        238
      ],
      "status": [
        344
      ],
      "type": [
        345
      ],
      "updatedAt": [
        73
      ],
      "__typename": [
        3
      ]
    },
    "ZoneStatus": {},
    "ZoneType": {},
    "ZoneWhereInput": {
      "id": [
        1
      ],
      "__typename": [
        3
      ]
    },
    "ZonesPaginationInput": {
      "match": [
        3
      ],
      "page": [
        8
      ],
      "take": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "ZonesWithAggregation": {
      "currentPage": [
        8
      ],
      "data": [
        343
      ],
      "isFirstPage": [
        9
      ],
      "isLastPage": [
        9
      ],
      "nextPage": [
        8
      ],
      "pageCount": [
        8
      ],
      "previousPage": [
        8
      ],
      "totalCount": [
        8
      ],
      "__typename": [
        3
      ]
    },
    "deploymentsSortableFields": {},
    "filecoinDealsSortableFields": {},
    "invitationsSortableFields": {},
    "listFolderSortableFields": {},
    "migrationRequestsSortableFields": {},
    "personalAccessTokensSortableFields": {},
    "pinsByFilenameSortableFields": {},
    "pinsSortableFields": {},
    "projectsSortableFields": {},
    "sitesSortableFields": {},
    "templateCategoriesSortableFields": {},
    "templatesSortableFields": {}
  }
};

// ../gql-client-utils/dist/index.ts
var typeMap = linkTypeMap(types_default);
var createClient2 = function(options) {
  return createClient({
    url: void 0,
    ...options,
    queryRoot: typeMap.Query,
    mutationRoot: typeMap.Mutation,
    subscriptionRoot: typeMap.Subscription
  });
};

// src/clients/applications.ts
var ApplicationsClient = class _ApplicationsClient {
  constructor(options) {
    this.get = async ({ id }) => {
      const response = await this.graphqlClient.query({
        application: {
          __args: {
            where: {
              id
            }
          },
          ..._ApplicationsClient.APPLICATION_MAPPED_PROPERTIES
        }
      });
      return response.application;
    };
    this.list = async () => {
      const response = await this.graphqlClient.query({
        applications: { data: _ApplicationsClient.APPLICATION_MAPPED_PROPERTIES }
      });
      return response.applications.data;
    };
    this.create = async ({ name: name20, whitelistDomains }) => {
      const response = await this.graphqlClient.mutation({
        createApplication: {
          __args: {
            data: {
              name: name20,
              whitelistDomains,
              // Warning: The whiteLabelDomains has been deprecated
              // providing ephemeral retroactivity
              whiteLabelDomains: [
                ...whitelistDomains
              ]
            }
          },
          ..._ApplicationsClient.APPLICATION_MAPPED_PROPERTIES
        }
      });
      return response.createApplication;
    };
    this.update = async ({ id, name: name20, whitelistDomains }) => {
      const response = await this.graphqlClient.mutation({
        updateApplication: {
          __args: {
            where: { id },
            data: {
              name: name20,
              whitelistDomains,
              // Warning: The whiteLabelDomains has been deprecated
              // providing ephemeral retroactivity
              whiteLabelDomains: whitelistDomains ? [...whitelistDomains] : []
            }
          },
          ..._ApplicationsClient.APPLICATION_MAPPED_PROPERTIES
        }
      });
      return response.updateApplication;
    };
    this.delete = async ({ id }) => {
      const response = await this.graphqlClient.mutation({
        deleteApplication: {
          __args: {
            where: {
              id
            }
          },
          ..._ApplicationsClient.APPLICATION_MAPPED_PROPERTIES
        }
      });
      return response.deleteApplication;
    };
    this.graphqlClient = options.graphqlClient;
  }
  static {
    this.WHITE_LIST_DOMAIN_MAPPED_PROPERTIES = {
      id: true,
      hostname: true
    };
  }
  static {
    this.APPLICATION_MAPPED_PROPERTIES = {
      id: true,
      name: true,
      clientId: true,
      whitelistDomains: _ApplicationsClient.WHITE_LIST_DOMAIN_MAPPED_PROPERTIES,
      whiteLabelDomains: _ApplicationsClient.WHITE_LIST_DOMAIN_MAPPED_PROPERTIES,
      updatedAt: true,
      createdAt: true
    };
  }
};

// src/clients/domains.ts
var import_errors = __toESM(require_dist());

// src/utils/graphql.ts
var requiredByCategory = {
  Deployment: {
    keys: ["cid", "siteId"],
    typename: "Deployment"
  },
  PrivateGateway: {
    keys: ["primaryDomain", "slug"],
    typename: "PrivateGateway"
  },
  Domain: {
    keys: ["id", "hostname"],
    typename: "Domain"
  },
  Site: {
    keys: ["id", "slug"],
    typename: "Site"
  },
  Pin: {
    keys: ["cid", "filename"],
    typename: "Pin"
  },
  FilecoinDeal: {
    keys: ["cid", "dealId"],
    typename: "FilecoinDeal"
  }
};
var isDeploymentResponseQuery = (response) => isQueryTypename({
  obj: response,
  typename: "Deployment"
});
var isPrivateGatewayResponseQuery = (response) => isQueryTypename({
  obj: response,
  typename: "PrivateGateway"
});
var isPrivateGatewaysResponseQuery = (response) => response.every((obj) => isQueryTypename({
  obj,
  typename: "PrivateGateway"
}));
var isDomainResponseQuery = (response) => isQueryTypename({
  obj: response,
  typename: "Domain"
});
var isDomainsResponseQuery = (response) => response.every((obj) => isQueryTypename({
  obj,
  typename: "Domain"
}));
var isSiteResponseQuery = (response) => isQueryTypename({
  obj: response,
  typename: "Site"
});
var isSitesResponseQuery = (response) => response.every((obj) => isQueryTypename({
  obj,
  typename: "Site"
}));
var isPinResponseQuery = (response) => isQueryTypename({
  obj: response,
  typename: "Pin"
});
var isPinsResponseQuery = (response) => response.every((obj) => isQueryTypename({
  obj,
  typename: "Pin"
}));
var isFilecoinDealsResponseQuery = (response) => response.every((obj) => isQueryTypename({
  obj,
  typename: "FilecoinDeal"
}));
var isQueryTypename = ({
  obj,
  typename
}) => {
  if (!obj) {
    return false;
  }
  return obj.__typename === requiredByCategory?.[typename].typename && requiredByCategory?.[typename].keys.every((key) => key in obj);
};

// src/clients/domains.ts
var DomainsClient = class _DomainsClient {
  constructor(options) {
    // TODO: Check which is the right type
    // Promise<DomainsWithAggregation["data"]> fails for some reason
    this.list = async () => {
      const response = await this.graphqlClient.query({
        domains: {
          data: {
            ..._DomainsClient.DOMAIN_MAPPED_PROPERTIES
          },
          __typename: true
        }
      });
      if (!isDomainsResponseQuery(response.domains?.data)) {
        throw new import_errors.DomainsNotFoundError();
      }
      return response.domains.data;
    };
    this.get = async ({ domainId }) => {
      const response = await this.graphqlClient.query({
        domain: {
          __args: {
            where: {
              id: domainId
            }
          },
          ..._DomainsClient.DOMAIN_MAPPED_PROPERTIES
        }
      });
      if (!isDomainResponseQuery(response.domain)) {
        throw new import_errors.DomainNotFoundError({ domain: { id: domainId } });
      }
      return response.domain;
    };
    this.getByHostname = async ({ hostname }) => {
      const response = await this.graphqlClient.query({
        domainByHostname: {
          __args: {
            where: {
              hostname
            }
          },
          ..._DomainsClient.DOMAIN_MAPPED_PROPERTIES
        }
      });
      if (!isDomainResponseQuery(response.domainByHostname)) {
        throw new import_errors.DomainNotFoundError({ domain: { hostname } });
      }
      return response.domainByHostname;
    };
    this.listByZoneId = async ({ zoneId }) => {
      const response = await this.graphqlClient.query({
        domainsByZoneId: {
          __args: {
            where: {
              zoneId
            }
          },
          data: {
            ..._DomainsClient.DOMAIN_MAPPED_PROPERTIES
          },
          __typename: true
        }
      });
      if (!isDomainsResponseQuery(response.domainsByZoneId?.data)) {
        throw new import_errors.DomainsNotFoundError();
      }
      return response.domainsByZoneId.data;
    };
    this.createDomain = async ({ zoneId, hostname }) => {
      const response = await this.graphqlClient.mutation({
        createDomain: {
          __args: {
            where: {
              zoneId
            },
            data: {
              hostname
            }
          },
          // TODO: The `DOMAIN_MAPPED_PROPERTIES` when used here
          // seem to break the query. Thus, using `__scalar` true.
          // Ideally, check what cause need for this change.
          __scalar: true
        }
      });
      return response.createDomain;
    };
    this.deleteDomain = async ({ domainId }) => {
      const response = await this.graphqlClient.mutation({
        deleteDomain: {
          __args: {
            where: {
              id: domainId
            }
          },
          ..._DomainsClient.DOMAIN_MAPPED_PROPERTIES
        }
      });
      return response.deleteDomain;
    };
    this.verifyDomain = async ({ domainId }) => {
      const response = await this.graphqlClient.mutation({
        verifyDomain: {
          __args: {
            where: {
              id: domainId
            }
          },
          ..._DomainsClient.DOMAIN_MAPPED_PROPERTIES
        }
      });
      return response.verifyDomain;
    };
    this.listZones = async () => {
      const response = await this.graphqlClient.query({ zones: { data: _DomainsClient.ZONE_MAPPED_PROPERTIES } });
      return response.zones.data;
    };
    this.getZone = async ({ id }) => {
      const response = await this.graphqlClient.query({
        zone: {
          __args: {
            where: {
              id
            }
          },
          ..._DomainsClient.ZONE_MAPPED_PROPERTIES
        }
      });
      return response.zone;
    };
    this.createZoneForSite = async ({ siteId }) => {
      const response = await this.graphqlClient.mutation({
        createZoneForSite: {
          __args: {
            where: {
              siteId
            }
          },
          // TODO: Investigate why the previous fields
          // would now throw> Error: type `Zone` does not have a field `zone`
          // ...DomainsClient.DOMAIN_MAPPED_PROPERTIES,
          __scalar: true
        }
      });
      return response.createZoneForSite;
    };
    this.createZoneForPrivateGateway = async () => {
      const response = await this.graphqlClient.mutation({ createZoneForPrivateGateway: _DomainsClient.ZONE_MAPPED_PROPERTIES });
      return response.createZoneForPrivateGateway;
    };
    this.deleteZone = async ({ id }) => {
      const response = await this.graphqlClient.mutation({
        deleteZone: {
          __args: {
            where: {
              id
            }
          },
          ..._DomainsClient.ZONE_MAPPED_PROPERTIES
        }
      });
      return response.deleteZone;
    };
    this.graphqlClient = options.graphqlClient;
  }
  static {
    this.DOMAIN_MAPPED_PROPERTIES = {
      id: true,
      zone: { id: true, __typename: true },
      hostname: true,
      isVerified: true,
      updatedAt: true,
      createdAt: true,
      dnsConfigs: { id: true, type: true, name: true, value: true, createdAt: true, updatedAt: true, __typename: true },
      status: true,
      __typename: true
    };
  }
  static {
    this.ZONE_MAPPED_PROPERTIES = {
      id: true,
      originUrl: true,
      createdAt: true,
      updatedAt: true,
      type: true,
      status: true,
      __typename: true
    };
  }
};

// src/clients/ens.ts
var EnsClient = class _EnsClient {
  constructor(options) {
    this.create = async ({ name: name20, siteId, ipnsRecordId }) => {
      const response = await this.graphqlClient.mutation({
        createEnsRecord: {
          __args: {
            where: {
              ipnsRecordId,
              siteId
            },
            data: {
              name: name20
            }
          },
          ..._EnsClient.ENS_MAPPED_PROPERTIES
        }
      });
      return response.createEnsRecord;
    };
    this.get = async ({ id }) => {
      const response = await this.graphqlClient.query({
        ensRecord: {
          __args: {
            where: {
              id
            }
          },
          ..._EnsClient.ENS_MAPPED_PROPERTIES
        }
      });
      return response.ensRecord;
    };
    this.getByName = async ({ name: name20 }) => {
      const response = await this.graphqlClient.query({
        ensRecordByName: {
          __args: {
            where: {
              name: name20
            }
          },
          ..._EnsClient.ENS_MAPPED_PROPERTIES
        }
      });
      return response.ensRecordByName;
    };
    this.verify = async ({ id }) => {
      const response = await this.graphqlClient.mutation({
        verifyEnsRecord: {
          __args: {
            where: {
              id
            }
          },
          ..._EnsClient.ENS_MAPPED_PROPERTIES
        }
      });
      return response.verifyEnsRecord;
    };
    this.delete = async ({ id }) => {
      const response = await this.graphqlClient.mutation({
        deleteEnsRecord: {
          __args: {
            where: {
              id
            }
          },
          ..._EnsClient.ENS_MAPPED_PROPERTIES
        }
      });
      return response.deleteEnsRecord;
    };
    this.list = async () => {
      const response = await this.graphqlClient.query({
        ensRecords: {
          data: {
            ..._EnsClient.ENS_MAPPED_PROPERTIES
          }
        }
      });
      return response.ensRecords.data;
    };
    this.listByIpnsRecordId = async ({ ipnsRecordId }) => {
      const response = await this.graphqlClient.query({
        ensRecordsByIpnsId: {
          __args: {
            where: {
              ipnsRecordId
            }
          },
          data: {
            ..._EnsClient.ENS_MAPPED_PROPERTIES
          }
        }
      });
      return response.ensRecordsByIpnsId.data;
    };
    this.graphqlClient = options.graphqlClient;
  }
  static {
    this.ENS_MAPPED_PROPERTIES = {
      id: true,
      name: true,
      updatedAt: true,
      createdAt: true,
      status: true,
      site: {
        id: true
      },
      ipnsRecord: {
        name: true,
        id: true,
        hash: true
      }
    };
  }
};

// src/clients/functions.ts
var FunctionsClient = class _FunctionsClient {
  constructor(options) {
    this.get = async ({ name: name20 }) => {
      const response = await this.graphqlClient.query({
        fleekFunctionByName: {
          __args: {
            where: {
              name: name20
            }
          },
          ..._FunctionsClient.FleekFunction_MAPPED_PROPERTIES
        }
      });
      return response.fleekFunctionByName;
    };
    this.list = async () => {
      const response = await this.graphqlClient.query({
        fleekFunctions: {
          __args: {},
          data: {
            ..._FunctionsClient.FleekFunction_MAPPED_PROPERTIES
          }
        }
      });
      return response.fleekFunctions.data;
    };
    this.listDeployments = async ({ functionId }) => {
      const response = await this.graphqlClient.query({
        fleekFunctionDeployments: {
          __args: {
            where: {
              fleekFunctionId: functionId
            }
          },
          data: {
            ..._FunctionsClient.Deployment_MAPPED_PROPERTIES
          }
        }
      });
      return response.fleekFunctionDeployments.data;
    };
    this.create = async ({ name: name20 }) => {
      const response = await this.graphqlClient.mutation({
        createFleekFunction: {
          __args: {
            data: {
              name: name20
            }
          },
          ..._FunctionsClient.FleekFunction_MAPPED_PROPERTIES
        }
      });
      return response.createFleekFunction;
    };
    this.deploy = async ({ functionId, cid, sgx, blake3Hash }) => {
      const response = await this.graphqlClient.mutation({
        triggerFleekFunctionDeployment: {
          __args: {
            where: {
              functionId,
              cid
            },
            data: { sgx, blake3Hash }
          },
          ..._FunctionsClient.Deployment_MAPPED_PROPERTIES
        }
      });
      return response.triggerFleekFunctionDeployment;
    };
    this.delete = async ({ id }) => {
      const response = await this.graphqlClient.mutation({
        deleteFleekFunction: {
          __args: {
            where: {
              id
            }
          },
          ..._FunctionsClient.FleekFunction_MAPPED_PROPERTIES
        }
      });
      return response.deleteFleekFunction;
    };
    this.update = async ({ id, slug, name: name20, status }) => {
      const response = await this.graphqlClient.mutation({
        updateFleekFunction: {
          __args: {
            where: {
              id
            },
            data: {
              slug,
              name: name20,
              status
            }
          },
          ..._FunctionsClient.FleekFunction_MAPPED_PROPERTIES
        }
      });
      return response.updateFleekFunction;
    };
    this.graphqlClient = options.graphqlClient;
  }
  static {
    this.Deployment_MAPPED_PROPERTIES = {
      id: true,
      fleekFunctionId: true,
      cid: true,
      updatedAt: true,
      createdAt: true
    };
  }
  static {
    this.FleekFunction_MAPPED_PROPERTIES = {
      id: true,
      name: true,
      slug: true,
      invokeUrl: true,
      projectId: true,
      currentDeploymentId: true,
      currentDeployment: {
        cid: true
      },
      status: true
    };
  }
};

// src/clients/ipfs.ts
var import_auth = __toESM(require_dist2());
var import_errors4 = __toESM(require_dist());
var import_files_from_path = require("files-from-path");

// src/libs/requireNodeEnv.ts
var import_errors2 = __toESM(require_dist());

// src/utils/node.ts
var isNode = typeof window === "undefined" || process?.env?.IS_NODE;

// src/libs/requireNodeEnv.ts
var requireNodeEnv = () => {
  if (isNode) {
    return;
  }
  throw new import_errors2.SdkRequiredNodeRuntimeError();
};

// src/libs/writeFilesFromStream.ts
var import_errors3 = __toESM(require_dist());
var writeFilesFromStream = async (fileStreams) => {
  if (!isNode) {
    throw new import_errors3.SdkRequiredNodeRuntimeError();
  }
  try {
    const fs4 = await import("fs");
    const path = await import("path");
    const { pipeline } = await import("stream");
    const { promisify: promisify3 } = await import("util");
    const pipelineAsync = promisify3(pipeline);
    await Promise.all(
      fileStreams.map(async ({ readStream, outputPath }) => {
        const dir = path.dirname(outputPath);
        await fs4.promises.mkdir(dir, { recursive: true });
        const writeStream = fs4.createWriteStream(outputPath);
        return pipelineAsync(readStream, writeStream);
      })
    );
  } catch (error3) {
    throw new import_errors3.WriteFileFromStreamError();
  }
};

// src/clients/ipfs.ts
var IpfsClient = class {
  constructor(options) {
    this.getClient = async () => {
      if (!this.client) {
        const { create: create21 } = await Promise.resolve().then(() => (init_src4(), src_exports2));
        this.client = create21({
          url: this.ipfsStorageApiUrl
        });
      }
      return this.client;
    };
    this.pinToUploadResult = async (pin, path) => {
      const { CID: CID5 } = await Promise.resolve().then(() => (init_src4(), src_exports2));
      return {
        cid: CID5.parse(pin.cid),
        size: pin.size,
        path
      };
    };
    this.add = async (file) => {
      const nodePath = await import("path");
      const path = file.path ? nodePath.basename(file.path) : "";
      const blob3 = new Blob([file.content]);
      const { UnixFS } = await Promise.resolve().then(() => (init_src17(), src_exports6));
      const getStream = () => UnixFS.createFileEncoderStream({ stream: () => blob3.stream() });
      try {
        const { pin } = await this.uploadProxyClient.uploadContent({ getStream, basename: path });
        return this.pinToUploadResult(pin, path);
      } catch {
        throw new import_errors4.StorageIpfsUploadFailedError();
      }
    };
    this.addAll = async (files, options = {}) => {
      const added = [];
      try {
        if (Array.isArray(files)) {
          const pins = await Promise.all(files.map(async (file) => await this.add(file)));
          added.push(...pins);
        } else {
          requireNodeEnv();
          const fileStreams = [];
          const basename = options.basename ?? "wrapped";
          const { randomBytes } = await import("crypto");
          const wrappedRandomDir = `wrapped_${randomBytes(10).toString("hex")}`;
          const wrapped = `${wrappedRandomDir}/${basename}`;
          const path = await import("path");
          for await (const file of files) {
            if (file.content === void 0) {
              continue;
            }
            fileStreams.push({
              readStream: file.content,
              outputPath: path.join(wrapped, file.path.slice(1))
            });
          }
          await writeFilesFromStream(fileStreams);
          const filesFromPath = await (0, import_files_from_path.filesFromPaths)([wrapped]);
          const { UnixFS } = await Promise.resolve().then(() => (init_src17(), src_exports6));
          if (options.wrapWithDirectory) {
            const getStream = () => UnixFS.createDirectoryEncoderStream(filesFromPath);
            const { pin } = await this.uploadProxyClient.uploadContent({ getStream, basename });
            const uploadResult = await this.pinToUploadResult(pin, basename);
            added.push(uploadResult);
          } else {
            const pins = await Promise.all(
              filesFromPath.map(async (path2) => {
                const getStream = () => UnixFS.createDirectoryEncoderStream([path2]);
                const { pin } = await this.uploadProxyClient.uploadContent({ getStream, basename: path2.name });
                return this.pinToUploadResult(pin, path2.name);
              })
            );
            added.push(...pins);
          }
          const { promises: fs4 } = await import("fs");
          await fs4.rm(wrappedRandomDir, { recursive: true, force: true });
        }
        return added;
      } catch (err) {
        console.log(err);
        throw new import_errors4.StorageIpfsUploadFailedError();
      }
    };
    this.addFromPath = async (path, _options = {}) => {
      requireNodeEnv();
      const nodePath = await import("path");
      const basename = nodePath.basename(path);
      const { promises: fs4 } = await import("fs");
      const stat = await fs4.stat(path);
      const { UnixFS } = await Promise.resolve().then(() => (init_src17(), src_exports6));
      if (!stat.isDirectory()) {
        const fileFromPath = await (0, import_files_from_path.filesFromPaths)([path]);
        const getStream2 = () => UnixFS.createFileEncoderStream(fileFromPath[0]);
        const { pin: pin2 } = await this.uploadProxyClient.uploadContent({ getStream: getStream2, basename });
        return [this.pinToUploadResult(pin2, basename)];
      }
      const filesfromPath = await (0, import_files_from_path.filesFromPaths)([path]);
      const getStream = () => UnixFS.createDirectoryEncoderStream(filesfromPath);
      const { pin } = await this.uploadProxyClient.uploadContent({ getStream, basename });
      return [this.pinToUploadResult(pin, basename)];
    };
    this.addSitesToIpfs = async (path, options = {}) => {
      requireNodeEnv();
      const accessToken = await this.accessTokenService.getAccessToken();
      if (!accessToken) {
        throw new import_errors4.AuthorizationError();
      }
      try {
        const globSource2 = (await Promise.resolve().then(() => (init_src4(), src_exports2))).globSource;
        const client = await this.getClient();
        const iterable = client.addAll(globSource2(path, "**/*"), {
          headers: {
            [import_auth.constants.AUTHORIZATION_HEADER_NAME]: `Bearer ${accessToken}`
          },
          ...options,
          wrapWithDirectory: true
        });
        const added = [];
        for await (const file of iterable) {
          added.push(file);
        }
        return added;
      } catch (err) {
        throw new import_errors4.StorageIpfsUploadFailedError();
      }
    };
    if (!isNode) {
      throw new import_errors4.SdkRequiredNodeRuntimeError();
    }
    this.uploadProxyClient = options.uploadProxyClient;
    this.ipfsStorageApiUrl = options.ipfsStorageApiUrl;
    this.accessTokenService = options.accessTokenService;
  }
};

// src/clients/ipns.ts
var IpnsClient = class _IpnsClient {
  constructor(options) {
    this.publishSignedName = async ({ key, input: input10 }) => {
      const response = await this.graphqlClient.mutation({
        publishSignedIpnsName: {
          __args: {
            data: {
              input: input10,
              key
            }
          }
        }
      });
      return response.publishSignedIpnsName;
    };
    this.resolveName = async ({ name: name20 }) => {
      const response = await this.graphqlClient.query({
        resolveIpnsName: {
          __args: {
            where: {
              name: name20
            }
          }
        }
      });
      return response.resolveIpnsName;
    };
    this.publishRecord = async ({ hash, id }) => {
      const response = await this.graphqlClient.mutation({
        publishIpnsRecord: {
          __args: {
            where: {
              id
            },
            data: {
              hash
            }
          },
          ..._IpnsClient.RECORD_MAPPED_PROPERTIES
        }
      });
      return response.publishIpnsRecord;
    };
    this.createRecord = async () => {
      const response = await this.graphqlClient.mutation({
        createIpnsRecord: _IpnsClient.RECORD_MAPPED_PROPERTIES
      });
      return response.createIpnsRecord;
    };
    this.createRecordForSite = async ({ siteId }) => {
      const response = await this.graphqlClient.mutation({
        createIpnsRecordForSite: {
          __args: {
            where: {
              siteId
            }
          },
          ..._IpnsClient.RECORD_MAPPED_PROPERTIES
        }
      });
      return response.createIpnsRecordForSite;
    };
    this.deleteRecord = async ({ id }) => {
      const response = await this.graphqlClient.mutation({
        deleteIpnsRecord: {
          __args: {
            where: {
              id
            }
          },
          ..._IpnsClient.RECORD_MAPPED_PROPERTIES
        }
      });
      return response.deleteIpnsRecord;
    };
    this.listRecords = async () => {
      const response = await this.graphqlClient.query({
        ipnsRecords: { data: _IpnsClient.RECORD_MAPPED_PROPERTIES }
      });
      return response.ipnsRecords.data;
    };
    this.getRecord = async ({ name: name20 }) => {
      const response = await this.graphqlClient.query({
        ipnsRecord: {
          __args: {
            where: {
              name: name20
            }
          },
          ..._IpnsClient.RECORD_MAPPED_PROPERTIES
        }
      });
      return response.ipnsRecord;
    };
    this.graphqlClient = options.graphqlClient;
  }
  static {
    this.RECORD_MAPPED_PROPERTIES = {
      id: true,
      name: true,
      hash: true,
      ensRecords: { id: true }
    };
  }
};

// src/clients/privateGateway.ts
var import_errors5 = __toESM(require_dist());
var PrivateGatewayClient = class _PrivateGatewayClient {
  constructor(options) {
    this.get = async ({ id }) => {
      const response = await this.graphqlClient.query({
        privateGateway: {
          __args: {
            where: {
              id
            }
          },
          ..._PrivateGatewayClient.PRIVATE_GATEWAY_MAPPED_PROPERTIES
        }
      });
      if (!isPrivateGatewayResponseQuery(response.privateGateway)) {
        throw new import_errors5.PrivateGatewayNotFoundError({ privateGateway: { id } });
      }
      return response.privateGateway;
    };
    this.getBySlug = async ({ slug }) => {
      const response = await this.graphqlClient.query({
        privateGatewayBySlug: {
          __args: {
            where: {
              slug
            }
          },
          ..._PrivateGatewayClient.PRIVATE_GATEWAY_MAPPED_PROPERTIES
        }
      });
      if (!isPrivateGatewayResponseQuery(response.privateGatewayBySlug)) {
        throw new import_errors5.PrivateGatewayNotFoundError({ privateGateway: { slug } });
      }
      return response.privateGatewayBySlug;
    };
    this.list = async () => {
      const response = await this.graphqlClient.query({
        privateGateways: {
          data: {
            ..._PrivateGatewayClient.PRIVATE_GATEWAY_MAPPED_PROPERTIES
          },
          __typename: true
        }
      });
      if (!isPrivateGatewaysResponseQuery(response.privateGateways.data)) {
        throw new import_errors5.PrivateGatewaysNotFoundError({});
      }
      return response.privateGateways.data;
    };
    this.create = async ({ name: name20, zoneId }) => {
      const response = await this.graphqlClient.mutation({
        createPrivateGateway: {
          __args: {
            where: {
              zoneId
            },
            data: {
              name: name20
            }
          },
          ..._PrivateGatewayClient.PRIVATE_GATEWAY_MAPPED_PROPERTIES
        }
      });
      return response.createPrivateGateway;
    };
    this.delete = async ({ id }) => {
      const response = await this.graphqlClient.mutation({
        deletePrivateGateway: {
          __args: {
            where: {
              id
            }
          },
          ..._PrivateGatewayClient.PRIVATE_GATEWAY_MAPPED_PROPERTIES
        }
      });
      return response.deletePrivateGateway;
    };
    this.update = async ({ id, name: name20 }) => {
      const response = await this.graphqlClient.mutation({
        updatePrivateGateway: {
          __args: {
            where: {
              id
            },
            data: {
              name: name20
            }
          },
          ..._PrivateGatewayClient.PRIVATE_GATEWAY_MAPPED_PROPERTIES
        }
      });
      return response.updatePrivateGateway;
    };
    this.graphqlClient = options.graphqlClient;
  }
  static {
    this.PRIVATE_GATEWAY_MAPPED_PROPERTIES = {
      id: true,
      slug: true,
      primaryDomain: { id: true, __typename: true },
      name: true,
      project: { id: true, __typename: true },
      zone: { id: true, __typename: true },
      updatedAt: true,
      createdAt: true,
      __typename: true
    };
  }
};

// src/clients/projects.ts
var ProjectsClient = class _ProjectsClient {
  constructor(options) {
    this.create = async ({ name: name20 }) => {
      const response = await this.graphqlClient.mutation({
        createProject: {
          __args: {
            data: {
              name: name20
            }
          },
          ..._ProjectsClient.PROJECT_MAPPED_PROPERTIES
        }
      });
      return response.createProject;
    };
    this.update = async ({ where, data }) => {
      const response = await this.graphqlClient.mutation({
        updateProject: {
          __args: {
            where,
            data
          },
          ..._ProjectsClient.PROJECT_MAPPED_PROPERTIES
        }
      });
      return response.updateProject;
    };
    this.get = async ({ id }) => {
      const response = await this.graphqlClient.query({
        project: {
          __args: {
            where: {
              id
            }
          },
          ..._ProjectsClient.PROJECT_MAPPED_PROPERTIES
        }
      });
      return response.project;
    };
    this.list = async () => {
      const response = await this.graphqlClient.query({ projects: { data: _ProjectsClient.PROJECT_MAPPED_PROPERTIES } });
      return response.projects.data;
    };
    this.graphqlClient = options.graphqlClient;
  }
  static {
    this.PROJECT_MAPPED_PROPERTIES = {
      id: true,
      name: true,
      avatar: true,
      backupStorageOnArweave: true,
      backupStorageOnFilecoin: true,
      createdAt: true
    };
  }
};

// src/clients/sites.ts
var import_errors6 = __toESM(require_dist());
var SitesClient = class _SitesClient {
  constructor(options) {
    this.get = async ({ id }) => {
      const response = await this.graphqlClient.query({
        site: {
          __args: {
            where: {
              id
            }
          },
          ..._SitesClient.SITE_MAPPED_PROPERTIES
        }
      });
      if (!isSiteResponseQuery(response.site)) {
        throw new import_errors6.SiteNotFoundError({ site: { id } });
      }
      return this.adapt(response.site);
    };
    this.getBySlug = async ({ slug }) => {
      const response = await this.graphqlClient.query({
        siteBySlug: {
          __args: {
            where: {
              slug
            }
          },
          ..._SitesClient.SITE_MAPPED_PROPERTIES
        }
      });
      if (!isSiteResponseQuery(response.siteBySlug)) {
        throw new import_errors6.SiteNotFoundError({ site: { slug } });
      }
      return this.adapt(response.siteBySlug);
    };
    this.list = async () => {
      const response = await this.graphqlClient.query({
        sites: {
          __args: {
            where: {}
          },
          data: {
            ..._SitesClient.SITE_MAPPED_PROPERTIES
          },
          __typename: true
        }
      });
      if (!isSitesResponseQuery(response.sites.data)) {
        throw new import_errors6.SitesNotFoundError();
      }
      return response.sites.data.map(this.adapt);
    };
    this.create = async ({ name: name20 }) => {
      const response = await this.graphqlClient.mutation({
        createSite: {
          __args: {
            data: {
              name: name20
            }
          },
          ..._SitesClient.SITE_MAPPED_PROPERTIES
        }
      });
      if (!isSiteResponseQuery(response.createSite)) {
        throw new import_errors6.SiteCreationFailedError();
      }
      return this.adapt(response.createSite);
    };
    this.delete = async ({ id }) => {
      const response = await this.graphqlClient.mutation({
        deleteSite: {
          __args: {
            where: {
              id
            }
          },
          ..._SitesClient.SITE_MAPPED_PROPERTIES
        }
      });
      if (!isSiteResponseQuery(response.deleteSite)) {
        throw new import_errors6.SiteNotFoundError({ site: { id } });
      }
      return this.adapt(response.deleteSite);
    };
    this.createCustomIpfsDeployment = async ({ siteId, cid }) => {
      const response = await this.graphqlClient.mutation({
        createCustomIpfsDeployment: {
          __args: {
            data: {
              siteId,
              cid
            }
          },
          ..._SitesClient.DEPLOYMENT_MAPPED_PROPERTIES
        }
      });
      return response.createCustomIpfsDeployment;
    };
    this.getDeployment = async ({ id }) => {
      const response = await this.graphqlClient.query({
        deployment: {
          __args: {
            where: {
              id
            }
          },
          ..._SitesClient.DEPLOYMENT_MAPPED_PROPERTIES
        }
      });
      if (!isDeploymentResponseQuery(response.deployment)) {
        throw new import_errors6.SiteDeploymentNotFoundError({ deployment: { id } });
      }
      return response.deployment;
    };
    this.graphqlClient = options.graphqlClient;
  }
  static {
    this.DEPLOYMENT_MAPPED_PROPERTIES = {
      id: true,
      status: true,
      storageType: true,
      siteId: true,
      cid: true,
      updatedAt: true,
      createdAt: true,
      __typename: true
    };
  }
  static {
    this.SITE_MAPPED_PROPERTIES = {
      id: true,
      name: true,
      slug: true,
      domains: { id: true, hostname: true, __typename: true },
      zones: { id: true, status: true, __typename: true },
      primaryDomain: { id: true, hostname: true, __typename: true },
      ipnsRecords: { id: true, __typename: true },
      deployments: _SitesClient.DEPLOYMENT_MAPPED_PROPERTIES,
      __typename: true
    };
  }
  adapt(site) {
    return {
      id: site.id,
      name: site.name,
      slug: site.slug,
      ipnsRecords: site.ipnsRecords,
      domains: site.domains,
      zones: site.zones,
      deployments: site.deployments
    };
  }
};

// src/clients/storage.ts
var import_errors8 = __toESM(require_dist());
var import_file2 = require("@web-std/file");
init_src17();
var import_files_from_path2 = require("files-from-path");

// src/utils/hash.ts
var import_errors7 = __toESM(require_dist());
var import_blake3 = require("@noble/hashes/blake3");
var createFileHash = async (opts) => {
  if (!isNode) {
    throw new import_errors7.SdkRequiredNodeRuntimeError();
  }
  const { createHash } = await import("crypto");
  const { file, algorithm: algorithm2 } = opts;
  switch (algorithm2) {
    case "blake3":
      return `${algorithm2}-${Buffer.from((0, import_blake3.blake3)(file)).toString("base64")}`;
    case "sha256":
    case "sha512":
      return `${algorithm2}-${createHash(algorithm2).update(file).digest("base64")}`;
    default:
      return `sha256-${createHash("sha256").update(file).digest("base64")}`;
  }
};

// src/clients/storage.ts
var StorageClient = class _StorageClient {
  constructor(options) {
    this.uploadDirectory = async ({ path, parentFolderId, options, onUploadProgress }) => {
      requireNodeEnv();
      const { promises } = await import("fs");
      const stat = await promises.stat(path);
      if (!stat.isDirectory()) {
        throw new import_errors8.PathIsNotADirectoryError({ path });
      }
      if (options?.siteId) {
        this.checkSiteInDb(options?.siteId);
      }
      if (options?.functionName) {
        await this.checkFunctionInDb(options?.functionName);
      }
      const { basename: getBasename } = await import("path");
      const basename = getBasename(path);
      const files = await (0, import_files_from_path2.filesFromPaths)([path]);
      const getStream = () => unixfs_exports4.createDirectoryEncoderStream(files);
      return this.uploadProxyClient.uploadContent({ getStream, basename, parentFolderId, options, onUploadProgress });
    };
    this.uploadVirtualDirectory = async ({
      files,
      directoryName,
      parentFolderId,
      onUploadProgress
    }) => {
      const getStream = () => unixfs_exports4.createDirectoryEncoderStream(files, {});
      return this.uploadProxyClient.uploadContent({ getStream, basename: directoryName, parentFolderId, onUploadProgress });
    };
    this.uploadPrivateFile = async ({
      filePath,
      hashingAlhorithm,
      onUploadProgress
    }) => {
      const { promises } = await import("fs");
      const stat = await promises.stat(filePath);
      if (!stat.isFile()) {
        throw new import_errors8.PathIsNotAFileError({ path: filePath });
      }
      const buffer3 = await promises.readFile(filePath, "binary");
      const fileHash = await createFileHash({ file: buffer3, algorithm: hashingAlhorithm ?? "sha256" });
      const path = await import("path");
      const file = new import_file2.File([buffer3], path.basename(filePath));
      return this.uploadProxyClient.uploadPrivateContent({ file, fileHash, onUploadProgress });
    };
    this.uploadFile = async ({ file, parentFolderId, options, onUploadProgress }) => {
      if (options?.siteId) {
        this.checkSiteInDb(options?.siteId);
      }
      if (options?.functionName) {
        await this.checkFunctionInDb(options?.functionName);
      }
      const getStream = () => unixfs_exports4.createFileEncoderStream(file);
      return this.uploadProxyClient.uploadContent({ getStream, basename: file.name, parentFolderId, options, onUploadProgress });
    };
    this.get = async ({ cid }) => {
      const response = await this.graphqlClient.query({
        pin: {
          __args: {
            where: { cid }
          },
          ..._StorageClient.STORAGE_MAPPED_PROPERTIES
        }
      });
      if (!isPinResponseQuery(response.pin)) {
        throw new import_errors8.PinNotFoundError({ pin: { cid } });
      }
      const { filecoinDeals } = await this.graphqlClient.query({
        filecoinDeals: {
          __args: {
            where: { cid }
          },
          data: {
            dealId: true,
            __typename: true
          },
          __typename: true
        }
      });
      if (!isFilecoinDealsResponseQuery(filecoinDeals.data)) {
        throw new import_errors8.PinNotFoundError({ pin: { cid } });
      }
      return {
        ...response.pin,
        arweaveId: response.pin.arweavePin?.bundlrId,
        filecoinDealIds: filecoinDeals.data.map((deal) => deal.dealId).join(",")
      };
    };
    this.getByFilename = async ({ filename, extension }) => {
      const response = await this.graphqlClient.query({
        pinsByFilename: {
          __args: {
            where: { filename, extension }
          },
          ..._StorageClient.STORAGE_WITH_AGGREGATION_MAPPED_PROPERTIES
        }
      });
      if (!isPinsResponseQuery(response.pinsByFilename?.data)) {
        throw new import_errors8.PinsNotFoundError({ filename });
      }
      return await Promise.all(
        response.pinsByFilename.data.map(async (pin) => {
          const res = await this.graphqlClient.query({
            filecoinDeals: {
              __args: {
                where: { cid: pin.cid }
              },
              data: {
                dealId: true
              }
            }
          });
          return {
            ...pin,
            arweaveId: pin.arweavePin?.bundlrId,
            filecoinDealIds: res.filecoinDeals.data.map((deal) => deal.dealId).join(",")
          };
        })
      );
    };
    this.list = async () => {
      const response = await this.graphqlClient.query({
        pins: {
          __args: {},
          data: {
            ..._StorageClient.STORAGE_MAPPED_PROPERTIES
          },
          __typename: true
        }
      });
      if (!isPinsResponseQuery(response.pins?.data)) {
        throw new import_errors8.PinNotFoundError({ pin: { cid: response.pins.data[0].cid } });
      }
      return await Promise.all(
        response.pins.data.map(async (pin) => {
          const res = await this.graphqlClient.query({
            filecoinDeals: {
              __args: {
                where: { cid: pin.cid }
              },
              data: {
                dealId: true,
                __typename: true
              },
              __typename: true
            }
          });
          return {
            ...pin,
            arweaveId: pin.arweavePin?.bundlrId,
            filecoinDealIds: res.filecoinDeals.data.map((deal) => deal.dealId).join(",")
          };
        })
      );
    };
    this.delete = async ({ cid }) => {
      const response = await this.uploadProxyClient.delete(cid);
      return {
        status: response.status,
        body: await response.json()
      };
    };
    this.checkFunctionInDb = async (name20) => {
      try {
        await this.graphqlClient.query({
          fleekFunctionByName: {
            __args: {
              where: { name: name20 }
            },
            id: true
          }
        });
      } catch (_err) {
        throw new import_errors8.FleekFunctionNotFoundError({ function: { name: name20 } });
      }
    };
    this.checkSiteInDb = async (id) => {
      try {
        await this.graphqlClient.query({
          site: {
            __args: {
              where: { id }
            },
            data: {
              cid: true,
              filename: true,
              extension: true,
              arweavePin: {
                bundlrId: true
              }
            }
          }
        });
      } catch {
        throw new import_errors8.SiteNotFoundError({ site: { id } });
      }
    };
    this.graphqlClient = options.graphqlClient;
    this.uploadProxyClient = options.uploadProxyClient;
  }
  static {
    this.SITE_MAPPED_PROPERTIES = { id: true };
  }
  static {
    this.FUNCTION_MAPPED_PROPERTIES = { id: true };
  }
  static {
    this.STORAGE_MAPPED_PROPERTIES = {
      cid: true,
      filename: true,
      extension: true,
      arweavePin: {
        bundlrId: true,
        __typename: true
      },
      __typename: true
    };
  }
  static {
    this.STORAGE_WITH_AGGREGATION_MAPPED_PROPERTIES = {
      data: _StorageClient.STORAGE_MAPPED_PROPERTIES,
      __typename: true
    };
  }
};

// src/clients/uploadProxy.ts
var import_auth2 = __toESM(require_dist2());
var import_errors10 = __toESM(require_dist());
var import_form_data = require("@web-std/form-data");
var import_axios = __toESM(require("axios"));
init_base324();

// src/libs/retry.ts
var import_errors9 = __toESM(require_dist());
var retry2 = async ({ fn, tries, intervalMs }) => {
  let n = 1;
  while (true) {
    try {
      return await fn();
    } catch (error3) {
      if (error3 instanceof import_errors9.FleekError) {
        console.warn(error3.toString(), `Attempt ${n} of ${tries}. Retrying in ${intervalMs / 1e3}s...`);
      }
      if (n === tries) {
        throw error3;
      }
      await new Promise((resolve2) => setTimeout(resolve2, intervalMs));
      n++;
    }
  }
};

// src/clients/uploadProxy.ts
var shardSize = 10485760;
var uploadConcurrency = 3;
var fetchWithValidStatus = async ({
  request,
  parentFolderId,
  validStatuses = [200]
}) => {
  const response = await fetch(request);
  if (!validStatuses.includes(response.status)) {
    if (response.status === 429) {
      const error3 = await response.json()?.then((res) => res.errors[0]).catch((err) => {
        console.warn("Unexpected response with 429 status", err);
        throw new import_errors10.UnknownError();
      });
      if (error3.code === "DailyUploadedTotalSizeQuotaExceeded") {
        throw new import_errors10.StorageUploadTotalSizeQuotaExceededError();
      } else if (error3.code === "DailyUploadedFilesQuotaExceeded") {
        throw new import_errors10.StorageUploadFileCountQuotaExceededError();
      } else if (error3.code === "FolderNotFoundError" && parentFolderId) {
        throw new import_errors10.FolderNotFoundError({ folder: { id: parentFolderId } });
      } else {
        throw new import_errors10.UnknownError();
      }
    } else {
      throw new import_errors10.StorageIpfsUploadFailedError();
    }
  }
  return response;
};
var UploadProxyClient = class {
  constructor(options) {
    this.uploadPrivateContent = async ({ file, fileHash, onUploadProgress }) => {
      const formData = new import_form_data.FormData();
      formData.append("hash", fileHash);
      formData.append("file", file);
      const accessToken = await this.accessTokenService.getAccessToken();
      try {
        const response = await import_axios.default.post(`${this.uploadProxyApiUrl}/upload/private`, formData, {
          headers: {
            "Content-Type": "multipart/form-data",
            [import_auth2.constants.AUTHORIZATION_HEADER_NAME]: `${import_auth2.constants.AUTHORIZATION_BEARER} ${accessToken}`
          },
          onUploadProgress: (progressEvent) => {
            if (progressEvent.lengthComputable && onUploadProgress) {
              onUploadProgress({
                loadedSize: progressEvent.loaded,
                totalSize: progressEvent.total
              });
            }
          }
        });
        if (response.status !== 201 || !response.data?.cid) {
          throw new import_errors10.StorageIpfsUploadFailedError();
        }
        return { pin: { cid: response.data.cid, size: file.size }, duplicate: false };
      } catch (error3) {
        throw new import_errors10.StorageIpfsUploadFailedError();
      }
    };
    this.uploadContent = async ({
      getStream,
      basename,
      parentFolderId,
      options,
      onUploadProgress
    }) => {
      const { cid, totalSize } = await this.getStreamCidAndTotalSize({ getStream });
      const isDuplicity = parentFolderId ? await this.checkPinDuplicityByParentFolderAndBasename({ parentFolderId, basename }) : await this.checkPinDuplicityByCid({ cid });
      if (isDuplicity) {
        return { pin: { cid, size: totalSize }, duplicate: true };
      }
      if (onUploadProgress) {
        onUploadProgress({ totalSize, loadedSize: 0 });
      }
      let loadedSize = 0;
      const shardCids = [];
      const { ShardingStream: ShardingStream2 } = await Promise.resolve().then(() => (init_src17(), src_exports6));
      const { Parallel } = await import("parallel-transform-web");
      await getStream().pipeThrough(new ShardingStream2({ shardSize })).pipeThrough(
        new Parallel(uploadConcurrency, async (car) => {
          const url2 = new URL(this.uploadProxyApiUrl);
          url2.pathname = "store";
          const accessToken2 = await this.accessTokenService.getAccessToken();
          const body2 = new Uint8Array(await car.arrayBuffer());
          try {
            const response = await retry2({
              fn: async () => fetchWithValidStatus({
                request: new Request(url2, {
                  method: "POST",
                  body: body2,
                  headers: {
                    "Content-Type": "application/vnd.ipld.car",
                    [import_auth2.constants.AUTHORIZATION_HEADER_NAME]: `${import_auth2.constants.AUTHORIZATION_BEARER} ${accessToken2}`
                  }
                }),
                parentFolderId
              }),
              tries: 3,
              intervalMs: 3e3
            });
            return { cid: await response.text(), size: body2.byteLength };
          } catch {
            throw new import_errors10.UploadProxyStoreAsCarError();
          }
        })
      ).pipeTo(
        new WritableStream({
          write: async ({ cid: cid2, size: size5 }) => {
            shardCids.push(cid2);
            if (onUploadProgress) {
              loadedSize += size5;
              onUploadProgress({ totalSize, loadedSize });
            }
          }
        })
      );
      const url = new URL(this.uploadProxyApiUrl);
      url.pathname = "upload";
      if (options?.siteId) {
        url.searchParams.append("sites", "true");
      }
      if (options?.functionName) {
        url.searchParams.append("function", "true");
      }
      const accessToken = await this.accessTokenService.getAccessToken();
      const body = JSON.stringify({ basename, parentFolderId, totalSize, rootCid: cid, shardCids });
      try {
        await retry2({
          fn: async () => fetchWithValidStatus({
            request: new Request(url, {
              method: "POST",
              body,
              headers: {
                "Content-Type": "application/json",
                [import_auth2.constants.AUTHORIZATION_HEADER_NAME]: `${import_auth2.constants.AUTHORIZATION_BEARER} ${accessToken}`
              }
            }),
            parentFolderId
          }),
          tries: 3,
          intervalMs: 3e3
        });
      } catch {
        throw new import_errors10.UploadProxyUploadFileError();
      }
      return { pin: { cid, size: totalSize }, duplicate: false };
    };
    this.delete = async (cid) => {
      const accessToken = await this.accessTokenService.getAccessToken();
      const url = new URL(this.uploadProxyApiUrl);
      url.pathname = `delete/${cid}`;
      return fetch(url, {
        method: "DELETE",
        headers: {
          [import_auth2.constants.AUTHORIZATION_HEADER_NAME]: `${import_auth2.constants.AUTHORIZATION_BEARER} ${accessToken}`
        }
      });
    };
    this.getStreamCidAndTotalSize = async ({ getStream }) => {
      let totalSize = 0;
      let cid;
      const { ShardingStream: ShardingStream2 } = await Promise.resolve().then(() => (init_src17(), src_exports6));
      await getStream().pipeThrough(new ShardingStream2({ shardSize })).pipeTo(
        new WritableStream({
          write: (car) => {
            if (car.roots[0]) {
              cid = car.roots[0].toV1().toString(base324);
            }
            totalSize += car.size;
          }
        })
      );
      if (!cid) {
        throw new import_errors10.StorageIpfsUploadFailedError();
      }
      return { cid, totalSize };
    };
    this.checkPinDuplicityByCid = async ({ cid }) => {
      const url = new URL(this.uploadProxyApiUrl);
      url.pathname = `duplicity/${cid}`;
      return this.checkPinDuplicty({ url });
    };
    this.checkPinDuplicityByParentFolderAndBasename = async ({
      parentFolderId,
      basename
    }) => {
      const url = new URL(this.uploadProxyApiUrl);
      url.pathname = `/folder/${parentFolderId}/duplicity/${basename}`;
      return this.checkPinDuplicty({ url });
    };
    this.checkPinDuplicty = async ({ url }) => {
      const accessToken = await this.accessTokenService.getAccessToken();
      const response = await fetch(url, {
        method: "GET",
        headers: {
          [import_auth2.constants.AUTHORIZATION_HEADER_NAME]: `${import_auth2.constants.AUTHORIZATION_BEARER} ${accessToken}`
        }
      });
      return response.status === 409;
    };
    this.accessTokenService = options.accessTokenService;
    this.uploadProxyApiUrl = options.uploadProxyApiUrl;
  }
};

// src/clients/user.ts
var UserClient = class {
  constructor(options) {
    this.listPersonalAccessTokens = async () => {
      const response = await this.graphqlClient.query({
        personalAccessTokens: {
          data: {
            id: true,
            createdAt: true,
            name: true,
            maskedToken: true
          }
        }
      });
      return response.personalAccessTokens.data;
    };
    this.deletePersonalAccessToken = async ({ id }) => {
      const response = await this.graphqlClient.mutation({
        deletePersonalAccessToken: {
          __args: {
            where: {
              id
            }
          },
          __scalar: true
        }
      });
      return response.deletePersonalAccessToken;
    };
    this.graphqlClient = options.graphqlClient;
  }
};

// src/defined.ts
var defined = {
  SDK__AUTH_APPS_URL: "https://auth-apps.service.fleek.xyz",
  SDK__IPFS__STORAGE_API_URL: "https://storage-ipfs.service.fleek.xyz/",
  SDK__GRAPHQL_API_URL: "https://graphql.service.fleek.xyz/graphql",
  SDK__UPLOAD_PROXY_API_URL: "https://uploads.service.fleek.xyz"
};
var override_env_var_prefix = "";
var getDefined = (key) => process?.env?.[`${override_env_var_prefix}${key}`] || defined[key];

// src/libs/graphqlFetcher.ts
var import_errors11 = __toESM(require_dist());
var errors = __toESM(require_dist());
var import_form_data2 = require("@web-std/form-data");
var import_object_traversal = require("object-traversal");
var graphqlFetcher = async ({ endpoint, headers, operation }) => {
  const map3 = [];
  const files = [];
  (0, import_object_traversal.traverse)(operation, ({ parent, key, value, meta }) => {
    if (parent && key && meta.nodePath && Object.prototype.toString.call(value) === "[object File]") {
      map3.push(meta.nodePath);
      files.push(value);
      parent[key] = null;
    }
  });
  const body = new import_form_data2.FormData();
  body.append("operations", JSON.stringify(operation));
  body.append("map", JSON.stringify(Object.fromEntries(map3.map((path, index2) => [`${index2}`, [path]]))));
  files.forEach((file, index2) => body.append(`${index2}`, file));
  const fetchHandler = !isNode ? (await import("cross-fetch")).default : fetch;
  const response = await fetchHandler(endpoint, {
    method: "POST",
    headers: {
      Accept: "application/json",
      ...headers
    },
    body
  });
  if (!response.ok) {
    if (response.status === 401) {
      throw new import_errors11.UnauthorizedError({});
    }
    throw new import_errors11.UnknownError();
  }
  const data = await response.json();
  const error3 = data?.errors?.[0];
  if (!error3) {
    return data;
  }
  if ("extensions" in error3) {
    const errorClass = errors?.[error3.extensions.name];
    if (errorClass) {
      throw new errorClass(error3.extensions.data);
    }
  }
  throw new import_errors11.UnknownError();
};

// src/FleekSdk.ts
var FleekSdk = class {
  constructor({
    graphqlServiceApiUrl = getDefined("SDK__GRAPHQL_API_URL"),
    ipfsStorageApiUrl = getDefined("SDK__IPFS__STORAGE_API_URL"),
    uploadProxyApiUrl = getDefined("SDK__UPLOAD_PROXY_API_URL"),
    accessTokenService
  }) {
    this.getVersion = async () => {
      const response = await this.graphqlClient.query({ version: { __scalar: true } });
      return response;
    };
    this.user = () => {
      if (!this.userClient) {
        this.userClient = new UserClient({ graphqlClient: this.graphqlClient });
      }
      return this.userClient;
    };
    this.ipns = () => {
      if (!this.ipnsClient) {
        this.ipnsClient = new IpnsClient({ graphqlClient: this.graphqlClient });
      }
      return this.ipnsClient;
    };
    this.ipfs = () => {
      if (!isNode) {
        throw new import_errors12.SdkRequiredNodeRuntimeError();
      }
      if (!this.ipfsClient) {
        this.ipfsClient = new IpfsClient({
          uploadProxyClient: this.uploadProxyClient,
          accessTokenService: this.accessTokenService,
          ipfsStorageApiUrl: this.ipfsStorageApiUrl
        });
      }
      console.warn("Warning: The `ipfs` service in Fleek SDK will be deprecated. Please use `storage` service instead");
      return this.ipfsClient;
    };
    this.sites = () => {
      if (!this.sitesClient) {
        this.sitesClient = new SitesClient({ graphqlClient: this.graphqlClient });
      }
      return this.sitesClient;
    };
    this.projects = () => {
      if (!this.projectsClient) {
        this.projectsClient = new ProjectsClient({ graphqlClient: this.graphqlClient });
      }
      return this.projectsClient;
    };
    this.domains = () => {
      if (!this.domainsClient) {
        this.domainsClient = new DomainsClient({ graphqlClient: this.graphqlClient });
      }
      return this.domainsClient;
    };
    this.applications = () => {
      if (!this.applicationsClient) {
        this.applicationsClient = new ApplicationsClient({ graphqlClient: this.graphqlClient });
      }
      return this.applicationsClient;
    };
    this.ens = () => {
      if (!this.ensClient) {
        this.ensClient = new EnsClient({ graphqlClient: this.graphqlClient });
      }
      return this.ensClient;
    };
    this.privateGateways = () => {
      if (!this.privateGatewayClient) {
        this.privateGatewayClient = new PrivateGatewayClient({ graphqlClient: this.graphqlClient });
      }
      return this.privateGatewayClient;
    };
    this.storage = () => {
      if (!this.storageClient) {
        this.storageClient = new StorageClient({
          graphqlClient: this.graphqlClient,
          uploadProxyClient: this.uploadProxyClient
        });
      }
      return this.storageClient;
    };
    this.functions = () => {
      if (!this.functionsClient) {
        this.functionsClient = new FunctionsClient({ graphqlClient: this.graphqlClient });
      }
      return this.functionsClient;
    };
    this.getAuthenticationHeaders = async () => {
      try {
        const accessToken = await this.accessTokenService.getAccessToken();
        if (!accessToken) {
          return {};
        }
        const headers = {
          [import_auth3.constants.AUTHORIZATION_HEADER_NAME]: `Bearer ${accessToken}`
        };
        return headers;
      } catch {
        return {};
      }
    };
    this.getCustomHeaders = () => {
      const headers = {
        [import_auth3.constants.CUSTOM_HEADERS.clientType]: import_auth3.constants.SDK_CLIENT_TYPE_NAME
      };
      return headers;
    };
    if (!accessTokenService) {
      throw new import_errors12.AuthorizationError();
    }
    this.accessTokenService = accessTokenService;
    this.graphqlClient = createClient2({
      fetcher: async (operation) => graphqlFetcher({
        operation,
        headers: { ...await this.getAuthenticationHeaders(), ...this.getCustomHeaders() },
        endpoint: this.graphqlServiceApiUrl
      })
    });
    this.graphqlServiceApiUrl = graphqlServiceApiUrl ?? getDefined("SDK__GRAPHQL_API_URL");
    this.ipfsStorageApiUrl = ipfsStorageApiUrl ?? getDefined("SDK__IPFS__STORAGE_API_URL");
    this.uploadProxyApiUrl = uploadProxyApiUrl ?? getDefined("SDK__UPLOAD_PROXY_API_URL");
    this.uploadProxyClient = new UploadProxyClient({
      uploadProxyApiUrl: this.uploadProxyApiUrl,
      accessTokenService: this.accessTokenService
    });
  }
};

// src/libs/AccessTokenService/PersonalAccessTokenService.ts
var import_errors13 = __toESM(require_dist());

// src/libs/AccessTokenService/AccessTokenService.ts
var AccessTokenService = class {
};

// src/libs/AccessTokenService/PersonalAccessTokenService.ts
var PersonalAccessTokenService = class extends AccessTokenService {
  constructor({
    personalAccessToken,
    projectId,
    graphqlServiceApiUrl = getDefined("SDK__GRAPHQL_API_URL")
  }) {
    requireNodeEnv();
    if (!personalAccessToken) {
      throw new import_errors13.AuthorizationError();
    }
    super();
    this.setAccessToken = async ({ token, expiration = 60 * 8 * 1e3 }) => {
      this.accessToken = token;
      if (this.accessTokenTimeout) {
        clearTimeout(this.accessTokenTimeout);
      }
      this.accessTokenTimeout = setTimeout(() => {
        this.accessToken = void 0;
      }, expiration);
    };
    this.loginWithPersonalAccessToken = async () => {
      const { loginWithPersonalAccessToken } = await this.client.mutation({
        loginWithPersonalAccessToken: {
          __args: {
            data: {
              personalAccessToken: this.personalAccessToken,
              projectId: this.projectId
            }
          }
        }
      });
      this.setAccessToken({ token: loginWithPersonalAccessToken });
    };
    this.getAccessToken = async () => {
      if (!this.accessToken) {
        await this.loginWithPersonalAccessToken();
      }
      return this.accessToken;
    };
    this.close = () => {
      clearTimeout(this.accessTokenTimeout);
      this.accessToken = void 0;
    };
    this.personalAccessToken = personalAccessToken;
    this.projectId = projectId;
    this.client = createClient2({
      fetcher: async (operation) => graphqlFetcher({
        operation,
        headers: {},
        endpoint: graphqlServiceApiUrl
      })
    });
  }
};

// src/libs/AccessTokenService/StaticAccessTokenService.ts
var import_errors14 = __toESM(require_dist());
var StaticAccessTokenService = class extends AccessTokenService {
  constructor({ accessToken }) {
    super();
    this.getAccessToken = async () => this.accessToken;
    if (!accessToken) {
      throw new import_errors14.AuthorizationError();
    }
    this.accessToken = accessToken;
  }
};

// src/libs/AccessTokenService/ApplicationAccessTokenService.ts
var import_auth4 = __toESM(require_dist2());
var import_cross_fetch = __toESM(require("cross-fetch"));
var import_luxon = require("luxon");
var ApplicationAccessTokenService = class extends AccessTokenService {
  constructor({
    clientId,
    authAppsServiceUrl = getDefined("SDK__AUTH_APPS_URL"),
    origin = window.location.origin
  }) {
    super();
    this.refreshAccessToken = async () => {
      const params = [import_auth4.constants.CLIENT_ID_QUERY_STRING_FIELD_NAME, this.clientId].join("=");
      const url = `${this.authAppsServiceUrl}/token?${params}`;
      const headers = new Headers();
      if (this.origin) {
        headers.set("Origin", this.origin);
      }
      const response = await (0, import_cross_fetch.default)(
        url,
        {
          method: "GET",
          headers
        }
      );
      this.accessToken = await response.text();
    };
    this.getAccessToken = async () => {
      if (!this.accessToken) {
        await this.refreshAccessToken();
        return this.accessToken;
      }
      const payload = (0, import_auth4.decodeAccessToken)({ token: this.accessToken });
      if (payload.exp < import_luxon.DateTime.now().toSeconds()) {
        await this.refreshAccessToken();
      }
      return this.accessToken;
    };
    this.clientId = clientId;
    this.authAppsServiceUrl = authAppsServiceUrl;
    this.origin = origin;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ApplicationAccessTokenService,
  FleekSdk,
  PersonalAccessTokenService,
  StaticAccessTokenService,
  createClient
});
/*! Bundled license information:

@noble/ed25519/lib/esm/index.js:
  (*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)
*/
